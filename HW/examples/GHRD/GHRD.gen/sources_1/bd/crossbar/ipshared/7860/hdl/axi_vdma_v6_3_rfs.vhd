-------------------------------------------------------------------------------
-- axi_sg_pkg
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_sg_pkg.vhd
-- Description: This package contains various constants and functions for
--              AXI SG Engine.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v4_03.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Rolled axi_sg library version to version v2_00_a
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package axi_sg_pkg is

-------------------------------------------------------------------------------
-- Function declarations
-------------------------------------------------------------------------------
-- Convert boolean to a std_logic
function bo2int (value : boolean)
            return  integer;

-------------------------------------------------------------------------------
-- Constant Declarations
-------------------------------------------------------------------------------

-- AXI Response Values
constant OKAY_RESP                      : std_logic_vector(1 downto 0)  := "00";
constant EXOKAY_RESP                    : std_logic_vector(1 downto 0)  := "01";
constant SLVERR_RESP                    : std_logic_vector(1 downto 0)  := "10";
constant DECERR_RESP                    : std_logic_vector(1 downto 0)  := "11";

-- Misc Constants
constant CMD_BASE_WIDTH                 : integer := 40;
constant SG_BTT_WIDTH                   : integer := 7;
constant SG_ADDR_LSB                    : integer := 6;

-- Interrupt Coalescing
constant ZERO_THRESHOLD             : std_logic_vector(7 downto 0) := (others => '0');
constant ONE_THRESHOLD              : std_logic_vector(7 downto 0) := "00000001";
constant ZERO_DELAY                 : std_logic_vector(7 downto 0) := (others => '0');

-- Constants Used in Desc Updates
constant DESC_STS_TYPE                  : std_logic := '1';
constant DESC_DATA_TYPE                 : std_logic := '0';

-- DataMover Command / Status Constants
constant DATAMOVER_STS_CMDDONE_BIT      : integer := 7;
constant DATAMOVER_STS_SLVERR_BIT       : integer := 6;
constant DATAMOVER_STS_DECERR_BIT       : integer := 5;
constant DATAMOVER_STS_INTERR_BIT       : integer := 4;
constant DATAMOVER_STS_TAGMSB_BIT       : integer := 3;
constant DATAMOVER_STS_TAGLSB_BIT       : integer := 0;

constant DATAMOVER_CMD_BTTLSB_BIT       : integer := 0;
constant DATAMOVER_CMD_BTTMSB_BIT       : integer := 22;
constant DATAMOVER_CMD_TYPE_BIT         : integer := 23;
constant DATAMOVER_CMD_DSALSB_BIT       : integer := 24;
constant DATAMOVER_CMD_DSAMSB_BIT       : integer := 29;
constant DATAMOVER_CMD_EOF_BIT          : integer := 30;
constant DATAMOVER_CMD_DRR_BIT          : integer := 31;
constant DATAMOVER_CMD_ADDRLSB_BIT      : integer := 32;

-- Note: Bit offset require adding ADDR WIDTH to get to actual bit index
constant DATAMOVER_CMD_ADDRMSB_BOFST    : integer := 31;
constant DATAMOVER_CMD_TAGLSB_BOFST     : integer := 32;
constant DATAMOVER_CMD_TAGMSB_BOFST     : integer := 35;
constant DATAMOVER_CMD_RSVLSB_BOFST     : integer := 36;
constant DATAMOVER_CMD_RSVMSB_BOFST     : integer := 39;

-- Descriptor field bits
constant DESC_STS_INTERR_BIT            : integer := 28;
constant DESC_STS_SLVERR_BIT            : integer := 29;
constant DESC_STS_DECERR_BIT            : integer := 30;
constant DESC_STS_CMPLTD_BIT            : integer := 31;

-- IOC Bit on descriptor update
-- Stored in LSB of TAG field then catinated on status word from primary
-- datamover (i.e. DESCTYPE & IOC & STATUS & Bytes Transferred).
constant DESC_IOC_TAG_BIT               : integer := 32;


end axi_sg_pkg;

-------------------------------------------------------------------------------
-- PACKAGE BODY
-------------------------------------------------------------------------------
package body axi_sg_pkg is
-------------------------------------------------------------------------------
-- Boolean to Integer
-------------------------------------------------------------------------------
function bo2int ( value : boolean)
    return integer  is
variable value_int : integer;
begin
    if(value)then
        value_int := 1;
    else
        value_int := 0;
    end if;
    return value_int;
end function bo2int;

end package body axi_sg_pkg;


-------------------------------------------------------------------------------
-- axi_sg_ftch_sm
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_sg_ftch_sm.vhd
-- Description: This entity manages fetching of descriptors.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     6/10/10    v1_00_a
-- ^^^^^^
-- Fixed issue with fetch idle asserting too soon when simultaneous update
-- decode error and stale descriptor error detected.
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Rolled axi_sg library version to version v2_00_a
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     12/07/10    v4_03
-- ^^^^^^

--          associated generate
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;

-------------------------------------------------------------------------------
entity  axi_sg_ftch_sm is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_INCLUDE_CH1               : integer range 0 to 1      := 1;
            -- Include or Exclude channel 1 scatter gather engine
            -- 0 = Exclude Channel 1 SG Engine
            -- 1 = Include Channel 1 SG Engine

        C_INCLUDE_CH2               : integer range 0 to 1       := 1;
            -- Include or Exclude channel 2 scatter gather engine
            -- 0 = Exclude Channel 2 SG Engine
            -- 1 = Include Channel 2 SG Engine

        C_SG_CH1_WORDS_TO_FETCH     : integer range 4 to 16      := 8;
            -- Number of words to fetch

        C_SG_CH2_WORDS_TO_FETCH     : integer range 4 to 16      := 8;
            -- Number of words to fetch

        C_SG_FTCH_DESC2QUEUE     : integer range 0 to 8          := 0;
            -- Number of descriptors to fetch and queue for each channel.
            -- A value of zero excludes the fetch queues.


        C_SG_CH1_ENBL_STALE_ERROR   : integer range 0 to 1      := 1;
            -- Enable or disable stale descriptor check
            -- 0 = Disable stale descriptor error check
            -- 1 = Enable stale descriptor error check

        C_SG_CH2_ENBL_STALE_ERROR   : integer range 0 to 1      := 1
            -- Enable or disable stale descriptor check
            -- 0 = Disable stale descriptor error check
            -- 1 = Enable stale descriptor error check

    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;                   --
        m_axi_sg_aresetn            : in  std_logic                         ;                   --
                                                                                                --
        updt_error                  : in  std_logic                         ;                   --
                                                                                                --
        -- Channel 1 Control and Status                                                         --
        ch1_run_stop                : in  std_logic                         ;                   --
        ch1_desc_flush              : in  std_logic                         ;                   --
        ch1_updt_done               : in  std_logic                         ;                   --
        ch1_sg_idle                 : in  std_logic                         ;                   --
        ch1_tailpntr_enabled        : in  std_logic                         ;                   --
        ch1_ftch_queue_full         : in  std_logic                         ;                   --
        ch1_ftch_queue_empty        : in  std_logic                         ;                   --
        ch1_ftch_pause              : in  std_logic                         ;                   --
        ch1_fetch_address           : in std_logic_vector                                       --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --
        ch1_ftch_active             : out std_logic                         ;                   --
        ch1_ftch_idle               : out std_logic                         ;                   --
        ch1_ftch_interr_set         : out std_logic                         ;                   --
        ch1_ftch_slverr_set         : out std_logic                         ;                   --
        ch1_ftch_decerr_set         : out std_logic                         ;                   --
        ch1_ftch_err_early          : out std_logic                         ;                   --
        ch1_ftch_stale_desc         : out std_logic                         ;                   --
                                                                                                --
        -- Channel 2 Control and Status                                                         --
        ch2_run_stop                : in  std_logic                         ;                   --
        ch2_desc_flush              : in  std_logic                         ;                   --
        ch2_updt_done               : in  std_logic                         ;                   --
        ch2_sg_idle                 : in  std_logic                         ;                   --
        ch2_tailpntr_enabled        : in  std_logic                         ;                   --
        ch2_ftch_queue_full         : in  std_logic                         ;                   --
        ch2_ftch_queue_empty        : in  std_logic                         ;                   --
        ch2_ftch_pause              : in  std_logic                         ;                   --
        ch2_fetch_address           : in std_logic_vector                                       --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --
        ch2_ftch_active             : out std_logic                         ;                   --
        ch2_ftch_idle               : out std_logic                         ;                   --
        ch2_ftch_interr_set         : out std_logic                         ;                   --
        ch2_ftch_slverr_set         : out std_logic                         ;                   --
        ch2_ftch_decerr_set         : out std_logic                         ;                   --
        ch2_ftch_err_early          : out std_logic                         ;                   --
        ch2_ftch_stale_desc         : out std_logic                         ;                   --
                                                                                                --
        -- DataMover Command                                                                    --
        ftch_cmnd_wr                : out std_logic                         ;                   --
        ftch_cmnd_data              : out std_logic_vector                                      --
                                        ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);    --
        -- DataMover Status                                                                     --
        ftch_done                   : in  std_logic                         ;                   --
        ftch_error                  : in  std_logic                         ;                   --
        ftch_interr                 : in  std_logic                         ;                   --
        ftch_slverr                 : in  std_logic                         ;                   --
        ftch_decerr                 : in  std_logic                         ;                   --
        ftch_stale_desc             : in  std_logic                         ;                   --
        ftch_error_early            : in  std_logic                         ;                   --
        ftch_error_addr             : out std_logic_vector                                      --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)                      --


    );

end axi_sg_ftch_sm;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_ftch_sm is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- DataMover Commmand TAG
constant FETCH_CMD_TAG      : std_logic_vector(3 downto 0)  := (others => '0');
-- DataMover Command Type
constant FETCH_CMD_TYPE     : std_logic := '1';
-- DataMover Cmnd Reserved Bits
constant FETCH_MSB_IGNORED  : std_logic_vector(7 downto 0)  := (others => '0');
-- DataMover Cmnd Reserved Bits
constant FETCH_LSB_IGNORED  : std_logic_vector(15 downto 0) := (others => '0');
-- DataMover Cmnd Bytes to Xfer for Channel 1
constant FETCH_CH1_CMD_BTT  : std_logic_vector(SG_BTT_WIDTH-1 downto 0)
                                := std_logic_vector(to_unsigned(
                                (C_SG_CH1_WORDS_TO_FETCH*4),SG_BTT_WIDTH));
-- DataMover Cmnd Bytes to Xfer for Channel 2
constant FETCH_CH2_CMD_BTT  : std_logic_vector(SG_BTT_WIDTH-1 downto 0)
                                := std_logic_vector(to_unsigned(
                                (C_SG_CH2_WORDS_TO_FETCH*4),SG_BTT_WIDTH));
-- DataMover Cmnd Reserved Bits
constant FETCH_CMD_RSVD     : std_logic_vector(
                                DATAMOVER_CMD_RSVMSB_BOFST + C_M_AXI_SG_ADDR_WIDTH downto
                                DATAMOVER_CMD_RSVLSB_BOFST + C_M_AXI_SG_ADDR_WIDTH)
                                := (others => '0');


-- Required width in bits for C_SG_FTCH_DESC2QUEUE
--constant SG_FTCH_DESC2QUEUE_WIDTH : integer := clog2(C_SG_FTCH_DESC2QUEUE+1);
--
---- Vector version of C_SG_FTCH_DESC2QUEUE
--constant SG_FTCH_DESC2QUEUE_VEC   : std_logic_vector(SG_FTCH_DESC2QUEUE_WIDTH-1 downto 0)
--                                    := std_logic_vector(to_unsigned
--                                    (C_SG_FTCH_DESC2QUEUE,SG_FTCH_DESC2QUEUE_WIDTH));


-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
type SG_FTCH_STATE_TYPE      is (
                                IDLE,
                                FETCH_DESCRIPTOR,
                                FETCH_STATUS,
                                FETCH_ERROR
                                );

signal ftch_cs                  : SG_FTCH_STATE_TYPE;
signal ftch_ns                  : SG_FTCH_STATE_TYPE;


-- State Machine Signals
signal ch1_active_set           : std_logic := '0';
signal ch2_active_set           : std_logic := '0';
signal write_cmnd_cmb           : std_logic := '0';
signal ch1_ftch_sm_idle         : std_logic := '0';
signal ch2_ftch_sm_idle         : std_logic := '0';
signal ch1_pause_fetch          : std_logic := '0';
signal ch2_pause_fetch          : std_logic := '0';


-- Misc Signals
signal fetch_cmd_addr           : std_logic_vector
                                    (C_M_AXI_SG_ADDR_WIDTH-1 downto 0) := (others => '0');
signal ch1_active_i             : std_logic := '0';
signal service_ch1              : std_logic := '0';

signal ch2_active_i             : std_logic := '0';
signal service_ch2              : std_logic := '0';

signal fetch_cmd_btt            : std_logic_vector
                                    (SG_BTT_WIDTH-1 downto 0) := (others => '0');
signal ch1_stale_descriptor     : std_logic := '0';
signal ch2_stale_descriptor     : std_logic := '0';

signal ch1_ftch_interr_set_i    : std_logic := '0';
signal ch2_ftch_interr_set_i    : std_logic := '0';


-- counts for keeping track of queue descriptors to prevent
-- fifo fill
--signal ch1_desc_ftched_count    : std_logic_vector
--                                    (SG_FTCH_DESC2QUEUE_WIDTH-1 downto 0) := (others => '0');
--signal ch2_desc_ftched_count    : std_logic_vector
--                                    (SG_FTCH_DESC2QUEUE_WIDTH-1 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
ch1_ftch_active  <= ch1_active_i;
ch2_ftch_active  <= ch2_active_i;


-------------------------------------------------------------------------------
-- Scatter Gather Fetch State Machine
-------------------------------------------------------------------------------
SG_FTCH_MACHINE : process(ftch_cs,
                            ch1_active_i,
                            ch2_active_i,
                            service_ch1,
                            service_ch2,
                            ftch_error,
                            ftch_done)

    begin
        -- Default signal assignment
        ch1_active_set          <= '0';
        ch2_active_set          <= '0';
        write_cmnd_cmb          <= '0';
        ch1_ftch_sm_idle        <= '0';
        ch2_ftch_sm_idle        <= '0';
        ftch_ns                 <= ftch_cs;

        case ftch_cs is

            -------------------------------------------------------------------
            when IDLE =>
                ch1_ftch_sm_idle       <=  not service_ch1;
                ch2_ftch_sm_idle       <=  not service_ch2;
                -- sg error during fetch - shut down
                if(ftch_error = '1')then
                    ftch_ns     <= FETCH_ERROR;
                -- If channel 1 is running and not idle and queue is not full
                -- then fetch descriptor for channel 1
                elsif(service_ch1 = '1')then
                    ch1_active_set  <= '1';
                    ftch_ns <= FETCH_DESCRIPTOR;
                -- If channel 2 is running and not idle and queue is not full
                -- then fetch descriptor for channel 2
                elsif(service_ch2 = '1')then
                    ch2_active_set  <= '1';
                    ftch_ns <= FETCH_DESCRIPTOR;

                else
                    ftch_ns                <= IDLE;
                end if;

            -------------------------------------------------------------------
            when FETCH_DESCRIPTOR =>
                -- sg error during fetch - shut down
                if(ftch_error = '1')then
                    ftch_ns     <= FETCH_ERROR;
                else
                    ch1_ftch_sm_idle    <= not ch1_active_i and not service_ch1;
                    ch2_ftch_sm_idle    <= not ch2_active_i and not service_ch2;
                    write_cmnd_cmb      <= '1';
                    ftch_ns             <= FETCH_STATUS;
                end if;

            -------------------------------------------------------------------
            when FETCH_STATUS =>

                ch1_ftch_sm_idle    <= not ch1_active_i and not service_ch1;
                ch2_ftch_sm_idle    <= not ch2_active_i and not service_ch2;

                -- sg error during fetch - shut down
                if(ftch_error = '1')then
                    ftch_ns     <= FETCH_ERROR;

                elsif(ftch_done = '1')then
                    -- If just finished fethcing for channel 2 then...
                    if(ch2_active_i = '1')then
                        -- If ready, fetch descriptor for channel 1
                        if(service_ch1 = '1')then
                            ch1_active_set <= '1';
                            ftch_ns <= FETCH_DESCRIPTOR;
                        -- Else if channel 2 still ready then fetch
                        -- another descriptor for channel 2
                        elsif(service_ch2 = '1')then
                            ch1_ftch_sm_idle    <= '1';
                            ftch_ns             <= FETCH_DESCRIPTOR;
                        -- Otherwise return to IDLE
                        else
                            ftch_ns <= IDLE;
                        end if;

                    -- If just finished fethcing for channel 1 then...
                    elsif(ch1_active_i = '1')then
                        -- If ready, fetch descriptor for channel 2
                        if(service_ch2 = '1')then
                            ch2_active_set <= '1';
                            ftch_ns <= FETCH_DESCRIPTOR;
                        -- Else if channel 1 still ready then fetch
                        -- another descriptor for channel 1
                        elsif(service_ch1 = '1')then
                            ch2_ftch_sm_idle    <= '1';
                            ftch_ns             <= FETCH_DESCRIPTOR;
                        -- Otherwise return to IDLE
                        else
                            ftch_ns <= IDLE;
                        end if;
                    else
                        ftch_ns <= IDLE;
                    end if;
                else
                    ftch_ns <= FETCH_STATUS;

                end if;

            -------------------------------------------------------------------
            when FETCH_ERROR =>
                ch1_ftch_sm_idle    <= '1';
                ch2_ftch_sm_idle    <= '1';
                ftch_ns             <= FETCH_ERROR;

            -------------------------------------------------------------------
            when others =>
                ftch_ns <= IDLE;

        end case;
    end process SG_FTCH_MACHINE;

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
REGISTER_STATE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                ftch_cs     <= IDLE;
            else
                ftch_cs     <= ftch_ns;
            end if;
        end if;
    end process REGISTER_STATE;


-------------------------------------------------------------------------------
-- Channel included therefore generate fetch logic
-------------------------------------------------------------------------------
GEN_CH1_FETCH : if C_INCLUDE_CH1 = 1 generate
begin

    -------------------------------------------------------------------------------
    -- Active channel flag.  Indicates which channel is active.
    -- 0 = channel active
    -- 1 = channel active
    -------------------------------------------------------------------------------
    CH1_ACTIVE_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or ch2_active_set = '1')then
                    ch1_active_i <= '0';
                elsif(ch1_active_set = '1')then
                    ch1_active_i <= '1';
                end if;
            end if;
        end process CH1_ACTIVE_PROCESS;

    -------------------------------------------------------------------------------
    -- Channel 1 IDLE process. Indicates channel 1 fetch process is IDLE
    -- This is 1 part of determining IDLE for a channel
    -------------------------------------------------------------------------------
    CH1_IDLE_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                -- If reset or stopped then clear idle bit
                if(m_axi_sg_aresetn = '0')then
                    ch1_ftch_idle   <= '1';

                -- SG Error therefore force IDLE
                -- fetch idle asserted too soon when update error occured.
                -- fetch idle does not need to be concerned with updt_error.  This is
                -- because on going fetch is guarentteed to complete regardless of dma
                -- controller or sg update engine.
                --elsif(updt_error = '1' or ftch_error = '1'
                elsif(ftch_error = '1'
                or ch1_ftch_interr_set_i = '1')then
                    ch1_ftch_idle   <= '1';

                -- When SG Fetch no longer idle then clear fetch idle
                elsif(ch1_sg_idle = '0')then
                    ch1_ftch_idle   <= '0';

                -- If tail = cur and fetch queue is empty then
                elsif(ch1_sg_idle = '1' and ch1_ftch_queue_empty = '1' and ch1_ftch_sm_idle = '1')then
                    ch1_ftch_idle   <= '1';

                end if;
            end if;
        end process CH1_IDLE_PROCESS;

    -------------------------------------------------------------------------------
    -- For No Fetch Queue, generate pause logic to prevent partial descriptor from
    -- being fetched and then endless throttle on AXI read bus
    -------------------------------------------------------------------------------
    GEN_CH1_FETCH_PAUSE : if C_SG_FTCH_DESC2QUEUE = 0 generate
    begin
        REG_PAUSE_FETCH : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    -- On descriptor update done clear pause
                    if(m_axi_sg_aresetn = '0' or ch1_updt_done = '1')then
                        ch1_pause_fetch <= '0';
                    -- If channel active and command written then pause
                    elsif(ch1_active_i='1' and write_cmnd_cmb = '1')then
                        ch1_pause_fetch <= '1';
                    end if;
                 end if;
             end process REG_PAUSE_FETCH;
    end generate GEN_CH1_FETCH_PAUSE;

    -- Fetch queues so do not need to pause
    GEN_CH1_NO_FETCH_PAUSE : if C_SG_FTCH_DESC2QUEUE /= 0 generate

--    -- Required width in bits for C_SG_FTCH_DESC2QUEUE
--    constant SG_FTCH_DESC2QUEUE_WIDTH : integer := clog2(C_SG_FTCH_DESC2QUEUE+1);
--    -- Vector version of C_SG_FTCH_DESC2QUEUE
--    constant SG_FTCH_DESC2QUEUE_VEC   : std_logic_vector(SG_FTCH_DESC2QUEUE_WIDTH-1 downto 0)
--                                        := std_logic_vector(to_unsigned
--                                        (C_SG_FTCH_DESC2QUEUE,SG_FTCH_DESC2QUEUE_WIDTH));
--    signal desc_queued_incr     : std_logic := '0';
--    signal desc_queued_decr     : std_logic := '0';
--

--    signal ch1_desc_ftched_count: std_logic_vector
--                                    (SG_FTCH_DESC2QUEUE_WIDTH-1 downto 0) := (others => '0');
--    begin
--
--        desc_queued_incr <= '1' when ch1_active_i = '1'
--                                 and write_cmnd_cmb = '1'
--                                 and ch1_ftch_descpulled = '0'
--                       else '0';
--
--        desc_queued_decr <= '1' when ch1_ftch_descpulled = '1'
--                                and not (ch1_active_i = '1' and write_cmnd_cmb = '1')
--                       else '0';
--
--        -- Keep track of descriptors queued version descriptors updated
--        DESC_FETCHED_CNTR : process(m_axi_sg_aclk)
--            begin
--                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                    if(m_axi_sg_aresetn = '0')then
--                        ch1_desc_ftched_count <= (others => '0');
--                    elsif(desc_queued_incr = '1')then
--                        ch1_desc_ftched_count <= std_logic_vector(unsigned(ch1_desc_ftched_count) + 1);
--                    elsif(desc_queued_decr = '1')then
--                        ch1_desc_ftched_count <= std_logic_vector(unsigned(ch1_desc_ftched_count) - 1);
--                    end if;
--                end if;
--            end process DESC_FETCHED_CNTR;
--
--        REG_PAUSE_FETCH : process(m_axi_sg_aclk)
--            begin
--                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                    if(m_axi_sg_aresetn = '0')then
--                        ch1_pause_fetch <= '0';
--                    elsif(ch1_desc_ftched_count >= SG_FTCH_DESC2QUEUE_VEC)then
--                        ch1_pause_fetch <= '1';
--                    else
--                        ch1_pause_fetch <= '0';
--                    end if;
--                end if;
--            end process REG_PAUSE_FETCH;
--
--
--
            ch1_pause_fetch <= ch1_ftch_pause;

    end generate GEN_CH1_NO_FETCH_PAUSE;


    -------------------------------------------------------------------------------
    -- Channel 1 ready to be serviced?
    -------------------------------------------------------------------------------
    service_ch1 <= '1' when ch1_run_stop = '1'          -- Channel running
                        and ch1_sg_idle = '0'           -- SG Engine running
                        and ch1_ftch_queue_full = '0'   -- Queue not full
                        and updt_error = '0'            -- No SG Update error
                        and ch1_stale_descriptor = '0'  -- No Stale Descriptors
                        and ch1_desc_flush = '0'        -- Not flushing desc
                        and ch1_pause_fetch = '0'       -- Not pausing


              else '0';

    -------------------------------------------------------------------------------
    -- Log Fetch Errors
    -------------------------------------------------------------------------------
    INT_ERROR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                -- If reset or stopped then clear idle bit
                if(m_axi_sg_aresetn = '0')then
                    ch1_ftch_interr_set_i  <= '0';
                -- Channel active and datamover int error or fetch done and descriptor stale
                elsif((ch1_active_i = '1' and ftch_interr = '1')
                   or ((ftch_done = '1' or ftch_error = '1') and ch1_stale_descriptor = '1'))then
                    ch1_ftch_interr_set_i  <= '1';
                end if;
            end if;
        end process INT_ERROR_PROCESS;

    ch1_ftch_interr_set <= ch1_ftch_interr_set_i;


    SLV_ERROR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                -- If reset or stopped then clear idle bit
                if(m_axi_sg_aresetn = '0')then
                    ch1_ftch_slverr_set  <= '0';
                elsif(ch1_active_i = '1' and ftch_slverr = '1')then
                    ch1_ftch_slverr_set  <= '1';
                end if;
            end if;
        end process SLV_ERROR_PROCESS;

    DEC_ERROR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                -- If reset or stopped then clear idle bit
                if(m_axi_sg_aresetn = '0')then
                    ch1_ftch_decerr_set  <= '0';
                elsif(ch1_active_i = '1' and ftch_decerr = '1')then
                    ch1_ftch_decerr_set  <= '1';
                end if;
            end if;
        end process DEC_ERROR_PROCESS;


    -- Early detection of SlvErr or DecErr, used to prevent error'ed descriptor
    -- from being used by dma controller
    ch1_ftch_err_early  <= '1' when ftch_error_early = '1' and ch1_active_i = '1'
                      else '0';

    -- Enable stale descriptor check
    GEN_CH1_STALE_CHECK : if C_SG_CH1_ENBL_STALE_ERROR = 1 generate
    begin
        -----------------------------------------------------------------------
        -- Stale Descriptor Error
        -----------------------------------------------------------------------
        CH1_STALE_DESC : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    -- If reset then clear flag
                    if(m_axi_sg_aresetn = '0')then
                        ch1_stale_descriptor <= '0';
                    elsif(ftch_stale_desc = '1' and ch1_active_i = '1' )then
                        ch1_stale_descriptor <= '1';
                    end if;
                end if;
            end process CH1_STALE_DESC;

    end generate GEN_CH1_STALE_CHECK;

    -- Disable stale descriptor check
    GEN_CH1_NO_STALE_CHECK : if C_SG_CH1_ENBL_STALE_ERROR = 0 generate
    begin
        ch1_stale_descriptor <= '0';
    end generate GEN_CH1_NO_STALE_CHECK;


    -- Early detection of Stale Descriptor (valid only in tailpntr mode) used
    -- to prevent error'ed descriptor from being used.
    ch1_ftch_stale_desc <= ch1_stale_descriptor;

end generate GEN_CH1_FETCH;

-------------------------------------------------------------------------------
-- Channel excluded therefore do not generate fetch logic
-------------------------------------------------------------------------------
GEN_NO_CH1_FETCH : if C_INCLUDE_CH1 = 0 generate
begin
    service_ch1         <= '0';
    ch1_active_i        <= '0';
    ch1_ftch_idle       <= '0';
    ch1_ftch_interr_set <= '0';
    ch1_ftch_slverr_set <= '0';
    ch1_ftch_decerr_set <= '0';
    ch1_ftch_err_early  <= '0';
    ch1_ftch_stale_desc <= '0';
end generate GEN_NO_CH1_FETCH;


-------------------------------------------------------------------------------
-- Channel included therefore generate fetch logic
-------------------------------------------------------------------------------
GEN_CH2_FETCH : if C_INCLUDE_CH2 = 1 generate
begin
    -------------------------------------------------------------------------------
    -- Active channel flag.  Indicates which channel is active.
    -- 0 = channel active
    -- 1 = channel active
    -------------------------------------------------------------------------------
    CH2_ACTIVE_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or ch1_active_set = '1')then
                    ch2_active_i <= '0';
                elsif(ch2_active_set = '1')then
                    ch2_active_i <= '1';
                end if;
            end if;
        end process CH2_ACTIVE_PROCESS;

    -------------------------------------------------------------------------------
    -- Channel 2 IDLE process. Indicates channel 2 fetch process is IDLE
    -- This is 1 part of determining IDLE for a channel
    -------------------------------------------------------------------------------
    CH2_IDLE_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                -- If reset or stopped then clear idle bit
                if(m_axi_sg_aresetn = '0')then
                    ch2_ftch_idle   <= '1';

                -- SG Error therefore force IDLE
                -- fetch idle asserted too soon when update error occured.
                -- fetch idle does not need to be concerned with updt_error.  This is
                -- because on going fetch is guarentteed to complete regardless of dma
                -- controller or sg update engine.
--                elsif(updt_error = '1' or ftch_error = '1'
                elsif(ftch_error = '1'
                or ch2_ftch_interr_set_i = '1')then

                    ch2_ftch_idle   <= '1';

                -- When SG Fetch no longer idle then clear fetch idle
                elsif(ch2_sg_idle = '0')then
                    ch2_ftch_idle   <= '0';

                -- If tail = cur and fetch queue is empty then
                elsif(ch2_sg_idle = '1' and ch2_ftch_queue_empty = '1' and ch2_ftch_sm_idle = '1')then
                    ch2_ftch_idle   <= '1';
                end if;
            end if;
        end process CH2_IDLE_PROCESS;

    -------------------------------------------------------------------------------
    -- For No Fetch Queue, generate pause logic to prevent partial descriptor from
    -- being fetched and then endless throttle on AXI read bus
    -------------------------------------------------------------------------------
    GEN_CH2_FETCH_PAUSE : if C_SG_FTCH_DESC2QUEUE = 0 generate
    begin
        REG_PAUSE_FETCH : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    -- On descriptor update done clear pause
                    if(m_axi_sg_aresetn = '0' or ch2_updt_done = '1')then
                        ch2_pause_fetch <= '0';
                    -- If channel active and command written then pause
                    elsif(ch2_active_i='1' and write_cmnd_cmb = '1')then
                        ch2_pause_fetch <= '1';
                    end if;
                 end if;
             end process REG_PAUSE_FETCH;
    end generate GEN_CH2_FETCH_PAUSE;

    -- Fetch queues so do not need to pause
    GEN_CH2_NO_FETCH_PAUSE : if C_SG_FTCH_DESC2QUEUE /= 0 generate

--    -- Required width in bits for C_SG_FTCH_DESC2QUEUE
--    constant SG_FTCH_DESC2QUEUE_WIDTH : integer := clog2(C_SG_FTCH_DESC2QUEUE+1);
--    -- Vector version of C_SG_FTCH_DESC2QUEUE
--    constant SG_FTCH_DESC2QUEUE_VEC   : std_logic_vector(SG_FTCH_DESC2QUEUE_WIDTH-1 downto 0)
--                                        := std_logic_vector(to_unsigned
--                                        (C_SG_FTCH_DESC2QUEUE,SG_FTCH_DESC2QUEUE_WIDTH));
--    signal desc_queued_incr     : std_logic := '0';
--    signal desc_queued_decr     : std_logic := '0';
--

--    signal ch2_desc_ftched_count: std_logic_vector
--                                    (SG_FTCH_DESC2QUEUE_WIDTH-1 downto 0) := (others => '0');
--
--    begin
--
--        desc_queued_incr <= '1' when ch2_active_i = '1'
--                                 and write_cmnd_cmb = '1'
--                                 and ch2_ftch_descpulled = '0'
--                       else '0';
--
--        desc_queued_decr <= '1' when ch2_ftch_descpulled = '1'
--                                and not (ch2_active_i = '1' and write_cmnd_cmb = '1')
--                       else '0';
--
--        -- Keep track of descriptors queued version descriptors updated
--        DESC_FETCHED_CNTR : process(m_axi_sg_aclk)
--            begin
--                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                    if(m_axi_sg_aresetn = '0')then
--                        ch2_desc_ftched_count <= (others => '0');
--                    elsif(desc_queued_incr = '1')then
--                        ch2_desc_ftched_count <= std_logic_vector(unsigned(ch2_desc_ftched_count) + 1);
--                    elsif(desc_queued_decr = '1')then
--                        ch2_desc_ftched_count <= std_logic_vector(unsigned(ch2_desc_ftched_count) - 1);
--                    end if;
--                end if;
--            end process DESC_FETCHED_CNTR;
--
--        REG_PAUSE_FETCH : process(m_axi_sg_aclk)
--            begin
--                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                    if(m_axi_sg_aresetn = '0')then
--                        ch2_pause_fetch <= '0';
--                    elsif(ch2_desc_ftched_count >= SG_FTCH_DESC2QUEUE_VEC)then
--                        ch2_pause_fetch <= '1';
--                    else
--                        ch2_pause_fetch <= '0';
--                    end if;
--                end if;
--            end process REG_PAUSE_FETCH;
--
            ch2_pause_fetch <= ch2_ftch_pause;
    end generate GEN_CH2_NO_FETCH_PAUSE;

    -------------------------------------------------------------------------------
    -- Channel 2 ready to be serviced?
    -------------------------------------------------------------------------------
    service_ch2 <= '1' when ch2_run_stop = '1'          -- Channel running
                        and ch2_sg_idle = '0'           -- SG Engine running
                        and ch2_ftch_queue_full = '0'   -- Queue not full
                        and updt_error = '0'            -- No SG Update error
                        and ch2_stale_descriptor = '0'  -- No Stale Descriptors
                        and ch2_desc_flush = '0'        -- Not flushing desc
                        and ch2_pause_fetch = '0'       -- No fetch pause
              else '0';

    -------------------------------------------------------------------------------
    -- Log Fetch Errors
    -------------------------------------------------------------------------------
    INT_ERROR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                -- If reset or stopped then clear idle bit
                if(m_axi_sg_aresetn = '0')then
                    ch2_ftch_interr_set_i  <= '0';
                -- Channel active and datamover int error or fetch done and descriptor stale
                elsif((ch2_active_i = '1' and ftch_interr = '1')
                   or ((ftch_done = '1' or ftch_error = '1') and ch2_stale_descriptor = '1'))then
                    ch2_ftch_interr_set_i  <= '1';
                end if;
            end if;
        end process INT_ERROR_PROCESS;

    ch2_ftch_interr_set <= ch2_ftch_interr_set_i;

    SLV_ERROR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                -- If reset or stopped then clear idle bit
                if(m_axi_sg_aresetn = '0')then
                    ch2_ftch_slverr_set  <= '0';
                elsif(ch2_active_i = '1' and ftch_slverr = '1')then
                    ch2_ftch_slverr_set  <= '1';
                end if;
            end if;
        end process SLV_ERROR_PROCESS;

    DEC_ERROR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                -- If reset or stopped then clear idle bit
                if(m_axi_sg_aresetn = '0')then
                    ch2_ftch_decerr_set  <= '0';
                elsif(ch2_active_i = '1' and ftch_decerr = '1')then
                    ch2_ftch_decerr_set  <= '1';
                end if;
            end if;
        end process DEC_ERROR_PROCESS;

    -- Early detection of SlvErr or DecErr, used to prevent error'ed descriptor
    -- from being used by dma controller
    ch2_ftch_err_early  <= '1' when ftch_error_early = '1' and ch2_active_i = '1'
                      else '0';


    -- Enable stale descriptor check
    GEN_CH2_STALE_CHECK : if C_SG_CH2_ENBL_STALE_ERROR = 1 generate
    begin
        -----------------------------------------------------------------------
        -- Stale Descriptor Error
        -----------------------------------------------------------------------
        CH2_STALE_DESC : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    -- If reset then clear flag
                    if(m_axi_sg_aresetn = '0')then
                        ch2_stale_descriptor <= '0';
                    elsif(ftch_stale_desc = '1' and ch2_active_i = '1' )then
                        ch2_stale_descriptor <= '1';
                    end if;
                end if;
            end process CH2_STALE_DESC;

    end generate GEN_CH2_STALE_CHECK;

    -- Disable stale descriptor check
    GEN_CH2_NO_STALE_CHECK : if C_SG_CH2_ENBL_STALE_ERROR = 0 generate
    begin
        ch2_stale_descriptor <= '0';
    end generate GEN_CH2_NO_STALE_CHECK;

    -- Early detection of Stale Descriptor (valid only in tailpntr mode) used
    -- to prevent error'ed descriptor from being used.
    ch2_ftch_stale_desc <= ch2_stale_descriptor;

end generate GEN_CH2_FETCH;

-------------------------------------------------------------------------------
-- Channel excluded therefore do not generate fetch logic
-------------------------------------------------------------------------------
GEN_NO_CH2_FETCH : if C_INCLUDE_CH2 = 0 generate
begin
    service_ch2         <= '0';
    ch2_active_i        <= '0';
    ch2_ftch_idle       <= '0';
    ch2_ftch_interr_set <= '0';
    ch2_ftch_slverr_set <= '0';
    ch2_ftch_decerr_set <= '0';
    ch2_ftch_err_early  <= '0';
    ch2_ftch_stale_desc <= '0';
end generate GEN_NO_CH2_FETCH;

-------------------------------------------------------------------------------
-- Build DataMover command
-------------------------------------------------------------------------------
-- Assign fetch address
fetch_cmd_addr  <= ch1_fetch_address when ch1_active_i = '1'
             else  ch2_fetch_address;

-- Assign bytes to transfer (BTT)
fetch_cmd_btt   <= FETCH_CH1_CMD_BTT when ch1_active_i = '1'
             else  FETCH_CH2_CMD_BTT;


-- When command by sm, drive command to ftch_cmdsts_if
GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                ftch_cmnd_wr    <= '0';
                ftch_cmnd_data  <= (others => '0');

            -- Fetch SM issued a command write
            elsif(write_cmnd_cmb = '1')then
                ftch_cmnd_wr    <= '1';
                ftch_cmnd_data  <=  FETCH_CMD_RSVD
                                    & FETCH_CMD_TAG
                                    & fetch_cmd_addr
                                    & FETCH_MSB_IGNORED
                                    & FETCH_CMD_TYPE
                                    & FETCH_LSB_IGNORED
                                    & fetch_cmd_btt;
            else
                ftch_cmnd_wr    <= '0';

            end if;
        end if;
    end process GEN_DATAMOVER_CMND;

-------------------------------------------------------------------------------
-- Capture and hold fetch address in case an error occurs
-------------------------------------------------------------------------------
LOG_ERROR_ADDR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                ftch_error_addr    <= (others => '0');
            elsif(write_cmnd_cmb = '1')then
                ftch_error_addr    <= fetch_cmd_addr;
            end if;
        end if;
    end process LOG_ERROR_ADDR;



end implementation;


-------------------------------------------------------------------------------
-- axi_sg_ftch_pntr
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_sg_ftch_pntr.vhd
-- Description: This entity manages descriptor pointers and determine scatter
--              gather idle mode.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     7/20/10    v1_00_a
-- ^^^^^^
-- CR568950
-- Qualified reseting of sg_idle from axi_sg_ftch_pntr with associated channel's
-- flush control.
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Rolled axi_sg library version to version v2_00_a
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;

-------------------------------------------------------------------------------
entity  axi_sg_ftch_pntr is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64        := 32   ;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_INCLUDE_CH1               : integer range 0 to 1          := 1    ;
            -- Include or Exclude channel 1 scatter gather engine
            -- 0 = Exclude Channel 1 SG Engine
            -- 1 = Include Channel 1 SG Engine

        C_INCLUDE_CH2               : integer range 0 to 1          := 1
            -- Include or Exclude channel 2 scatter gather engine
            -- 0 = Exclude Channel 2 SG Engine
            -- 1 = Include Channel 2 SG Engine
    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;                  --
        m_axi_sg_aresetn            : in  std_logic                         ;                  --
                                                                                               --
        nxtdesc                     : in  std_logic_vector                                     --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                  --
                                                                                               --
        -------------------------------                                                        --
        -- CHANNEL 1                                                                           --
        -------------------------------                                                        --
        ch1_run_stop                : in  std_logic                         ;                  --
        ch1_desc_flush              : in  std_logic                         ; 
                                                                                               --
        -- CURDESC update to fetch pointer on run/stop assertion                               --
        ch1_curdesc                 : in  std_logic_vector                                     --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                  --
                                                                                               --
        -- TAILDESC update on CPU write (from axi_dma_reg_module)                              --
        ch1_tailpntr_enabled        : in  std_logic                         ;                  --
        ch1_taildesc_wren           : in  std_logic                         ;                  --
        ch1_taildesc                : in  std_logic_vector                                     --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                  --
                                                                                               --
        -- NXTDESC update on descriptor fetch (from axi_sg_ftchq_if)                           --
        ch1_nxtdesc_wren            : in  std_logic                         ;                  --
                                                                                               --
        -- Current address of descriptor to fetch                                              --
        ch1_fetch_address           : out std_logic_vector                                     --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                  --
        ch1_sg_idle                 : out std_logic                         ;                  --
                                                                                               --
        -------------------------------                                                        --
        -- CHANNEL 2                                                                           --
        -------------------------------                                                        --
        ch2_run_stop                : in  std_logic                         ;                  --
        ch2_desc_flush              : in  std_logic                         ;
                                                                                               --
        -- CURDESC update to fetch pointer on run/stop assertion                               --
        ch2_curdesc                 : in  std_logic_vector                                     --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                  --
                                                                                               --
        -- TAILDESC update on CPU write (from axi_dma_reg_module)                              --
        ch2_tailpntr_enabled        : in  std_logic                         ;                  --
        ch2_taildesc_wren           : in  std_logic                         ;                  --
        ch2_taildesc                : in  std_logic_vector                                     --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                  --
                                                                                               --
        -- NXTDESC update on descriptor fetch (from axi_sg_ftchq_if)                           --
        ch2_nxtdesc_wren            : in  std_logic                         ;                  --
                                                                                               --
        -- Current address of descriptor to fetch                                              --
        ch2_fetch_address           : out std_logic_vector                                     --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                  --
        ch2_sg_idle                 : out std_logic                                            --
    );

end axi_sg_ftch_pntr;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_ftch_pntr is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal ch1_run_stop_d1              : std_logic := '0';
signal ch1_run_stop_re              : std_logic := '0';
signal ch1_use_crntdesc             : std_logic := '0';
signal ch1_fetch_address_i          : std_logic_vector
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)
                                        := (others => '0');

signal ch2_run_stop_d1              : std_logic := '0';
signal ch2_run_stop_re              : std_logic := '0';
signal ch2_use_crntdesc             : std_logic := '0';
signal ch2_fetch_address_i          : std_logic_vector
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)
                                        := (others => '0');

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

-- Channel 1 is included therefore generate pointer logic
GEN_PNTR_FOR_CH1 : if C_INCLUDE_CH1 = 1 generate
begin


    GEN_RUNSTOP_RE : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch1_run_stop_d1 <= '0';
                else
                    ch1_run_stop_d1 <= ch1_run_stop;
                end if;
            end if;
        end process GEN_RUNSTOP_RE;

    ch1_run_stop_re <= ch1_run_stop and not ch1_run_stop_d1;


    ---------------------------------------------------------------------------
    -- At setting of run/stop need to use current descriptor pointer therefor
    -- flag for use
    ---------------------------------------------------------------------------
    GEN_INIT_PNTR : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or ch1_nxtdesc_wren = '1')then
                    ch1_use_crntdesc <= '0';
                elsif(ch1_run_stop_re = '1')then
                    ch1_use_crntdesc <= '1';
                end if;
            end if;
        end process GEN_INIT_PNTR;

    ---------------------------------------------------------------------------
    -- Register Current Fetch Address.  During start (run/stop asserts) reg
    -- curdesc pointer from register module.  Once running use nxtdesc pointer.
    ---------------------------------------------------------------------------
    REG_FETCH_ADDRESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch1_fetch_address_i <= (others => '0');
                -- On initial tail pointer write use current desc pointer
                elsif(ch1_use_crntdesc = '1' and ch1_nxtdesc_wren = '0')then
                    ch1_fetch_address_i <= ch1_curdesc;
                -- On desriptor fetch capture next pointer
                elsif(ch1_nxtdesc_wren = '1')then
                    ch1_fetch_address_i <= nxtdesc;
                end if;
            end if;
        end process REG_FETCH_ADDRESS;

    -- Pass address out of module
    ch1_fetch_address <= ch1_fetch_address_i;

    ---------------------------------------------------------------------------
    -- Compair tail descriptor pointer to scatter gather engine current
    -- descriptor pointer.  Set idle if matched.  Only check if DMA engine
    -- is running and current descriptor is in process of being fetched.  This
    -- forces at least 1 descriptor fetch before checking for IDLE condition.
    ---------------------------------------------------------------------------
    COMPARE_ADDRESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                -- SG is IDLE on reset and on stop.
                
                --if(m_axi_sg_aresetn = '0' or ch1_run_stop = '0')then
                if(m_axi_sg_aresetn = '0' or ch1_run_stop = '0' or ch1_desc_flush = '1')then
                    ch1_sg_idle <= '1';

                -- taildesc_wren must be in this 'if' to force a minimum
                -- of 1 clock of sg_idle = '0'.
                elsif(ch1_taildesc_wren = '1' or ch1_tailpntr_enabled = '0')then
                    ch1_sg_idle <= '0';

                -- Descriptor at fetch_address is being fetched (wren=1)
                -- therefore safe to check if tail matches the fetch address
                elsif(ch1_nxtdesc_wren = '1'
                and ch1_taildesc = ch1_fetch_address_i)then
                    ch1_sg_idle <= '1';
                end if;
            end if;
        end process COMPARE_ADDRESS;

end generate GEN_PNTR_FOR_CH1;


-- Channel 1 is NOT included therefore tie off pointer logic
GEN_NO_PNTR_FOR_CH1 : if C_INCLUDE_CH1 = 0 generate
begin
    ch1_fetch_address   <= (others =>'0');
    ch1_sg_idle         <= '0';
end generate GEN_NO_PNTR_FOR_CH1;

-- Channel 2 is included therefore generate pointer logic
GEN_PNTR_FOR_CH2 : if C_INCLUDE_CH2 = 1 generate
begin

    ---------------------------------------------------------------------------
    -- Create clock delay of run_stop in order to generate a rising edge pulse
    ---------------------------------------------------------------------------
    GEN_RUNSTOP_RE : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch2_run_stop_d1 <= '0';
                else
                    ch2_run_stop_d1 <= ch2_run_stop;
                end if;
            end if;
        end process GEN_RUNSTOP_RE;

    ch2_run_stop_re <= ch2_run_stop and not ch2_run_stop_d1;

    ---------------------------------------------------------------------------
    -- At setting of run/stop need to use current descriptor pointer therefor
    -- flag for use
    ---------------------------------------------------------------------------
    GEN_INIT_PNTR : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or ch2_nxtdesc_wren = '1')then
                    ch2_use_crntdesc <= '0';
                elsif(ch2_run_stop_re = '1')then
                    ch2_use_crntdesc <= '1';
                end if;
            end if;
        end process GEN_INIT_PNTR;

    ---------------------------------------------------------------------------
    -- Register Current Fetch Address.  During start (run/stop asserts) reg
    -- curdesc pointer from register module.  Once running use nxtdesc pointer.
    ---------------------------------------------------------------------------
    REG_FETCH_ADDRESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch2_fetch_address_i <= (others => '0');
                -- On initial tail pointer write use current desc pointer
                elsif(ch2_use_crntdesc = '1' and ch2_nxtdesc_wren = '0')then
                    ch2_fetch_address_i <= ch2_curdesc;
                -- On descirptor fetch capture next pointer
                elsif(ch2_nxtdesc_wren = '1')then
                    ch2_fetch_address_i <= nxtdesc;
                end if;
            end if;
        end process REG_FETCH_ADDRESS;

    -- Pass address out of module
    ch2_fetch_address <= ch2_fetch_address_i;

    ---------------------------------------------------------------------------
    -- Compair tail descriptor pointer to scatter gather engine current
    -- descriptor pointer.  Set idle if matched.  Only check if DMA engine
    -- is running and current descriptor is in process of being fetched.  This
    -- forces at least 1 descriptor fetch before checking for IDLE condition.
    ---------------------------------------------------------------------------
    COMPARE_ADDRESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                -- SG is IDLE on reset and on stop.
                
                --if(m_axi_sg_aresetn = '0' or ch2_run_stop = '0')then
                if(m_axi_sg_aresetn = '0' or ch2_run_stop = '0' or ch2_desc_flush = '1')then
                    ch2_sg_idle <= '1';

                -- taildesc_wren must be in this 'if' to force a minimum
                -- of 1 clock of sg_idle = '0'.
                elsif(ch2_taildesc_wren = '1' or ch2_tailpntr_enabled = '0')then
                    ch2_sg_idle <= '0';

                -- Descriptor at fetch_address is being fetched (wren=1)
                -- therefore safe to check if tail matches the fetch address
                elsif(ch2_nxtdesc_wren = '1'
                and ch2_taildesc = ch2_fetch_address_i)then
                    ch2_sg_idle <= '1';
                end if;
            end if;
        end process COMPARE_ADDRESS;

end generate GEN_PNTR_FOR_CH2;


-- Channel 2 is NOT included therefore tie off pointer logic
GEN_NO_PNTR_FOR_CH2 : if C_INCLUDE_CH2 = 0 generate
begin
    ch2_fetch_address   <= (others =>'0');
    ch2_sg_idle         <= '0';
end generate GEN_NO_PNTR_FOR_CH2;

end implementation;


-------------------------------------------------------------------------------
-- axi_sg_ftch_cmdsts_if
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_sg_ftch_cmdsts_if.vhd
-- Description: This entity is the descriptor fetch command and status inteface
--              for the Scatter Gather Engine AXI DataMover.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Rolled axi_sg library version to version v2_00_a
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;

-------------------------------------------------------------------------------
entity  axi_sg_ftch_cmdsts_if is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64        := 32
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;                   --
        m_axi_sg_aresetn            : in  std_logic                         ;                   --
                                                                                                --
        -- Fetch command write interface from fetch sm                                          --
        ftch_cmnd_wr                : in  std_logic                         ;                   --
        ftch_cmnd_data              : in  std_logic_vector                                      --
                                        ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);    --
                                                                                                --
        -- User Command Interface Ports (AXI Stream)                                            --
        s_axis_ftch_cmd_tvalid      : out std_logic                         ;                   --
        s_axis_ftch_cmd_tready      : in  std_logic                         ;                   --
        s_axis_ftch_cmd_tdata       : out std_logic_vector                                      --
                                        ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);    --
                                                                                                --
        -- Read response for detecting slverr, decerr early                                     --
        m_axi_sg_rresp              : in  std_logic_vector(1 downto 0)      ;                   --
        m_axi_sg_rvalid             : in  std_logic                         ;                   --
                                                                                                --
        -- User Status Interface Ports (AXI Stream)                                             --
        m_axis_ftch_sts_tvalid      : in  std_logic                         ;                   --
        m_axis_ftch_sts_tready      : out std_logic                         ;                   --
        m_axis_ftch_sts_tdata       : in  std_logic_vector(7 downto 0)      ;                   --
        m_axis_ftch_sts_tkeep       : in  std_logic_vector(0 downto 0)      ;                   --
                                                                                                --
        -- Scatter Gather Fetch Status                                                          --
        mm2s_err                    : in  std_logic                         ;                   --
        ftch_done                   : out std_logic                         ;                   --
        ftch_error                  : out std_logic                         ;                   --
        ftch_interr                 : out std_logic                         ;                   --
        ftch_slverr                 : out std_logic                         ;                   --
        ftch_decerr                 : out std_logic                         ;                   --
        ftch_error_early            : out std_logic                                             --

    );

end axi_sg_ftch_cmdsts_if;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_ftch_cmdsts_if is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal ftch_slverr_i    : std_logic := '0';
signal ftch_decerr_i    : std_logic := '0';
signal ftch_interr_i    : std_logic := '0';
signal mm2s_error       : std_logic := '0';

signal sg_rresp         : std_logic_vector(1 downto 0) := (others => '0');
signal sg_rvalid        : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

ftch_slverr <= ftch_slverr_i;
ftch_decerr <= ftch_decerr_i;
ftch_interr <= ftch_interr_i;

-------------------------------------------------------------------------------
-- DataMover Command Interface
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-- When command by fetch sm, drive descriptor fetch command to data mover.
-- Hold until data mover indicates ready.
-------------------------------------------------------------------------------
GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s_axis_ftch_cmd_tvalid  <= '0';
                s_axis_ftch_cmd_tdata   <= (others => '0');

            elsif(ftch_cmnd_wr = '1')then
                s_axis_ftch_cmd_tvalid  <= '1';
                s_axis_ftch_cmd_tdata   <= ftch_cmnd_data;

            elsif(s_axis_ftch_cmd_tready = '1')then
                s_axis_ftch_cmd_tvalid  <= '0';
                s_axis_ftch_cmd_tdata   <= (others => '0');

            end if;
        end if;
    end process GEN_DATAMOVER_CMND;

-------------------------------------------------------------------------------
-- DataMover Status Interface
-------------------------------------------------------------------------------
-- Drive ready low during reset to indicate not ready
REG_STS_READY : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                m_axis_ftch_sts_tready <= '0';
            else
                m_axis_ftch_sts_tready <= '1';
            end if;
        end if;
    end process REG_STS_READY;

-------------------------------------------------------------------------------
-- Log status bits out of data mover.
-------------------------------------------------------------------------------
DATAMOVER_STS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                ftch_done      <= '0';
                ftch_slverr_i  <= '0';
                ftch_decerr_i  <= '0';
                ftch_interr_i  <= '0';
            -- Status valid, therefore capture status
            elsif(m_axis_ftch_sts_tvalid = '1')then
                ftch_done      <= m_axis_ftch_sts_tdata(DATAMOVER_STS_CMDDONE_BIT);
                ftch_slverr_i  <= m_axis_ftch_sts_tdata(DATAMOVER_STS_SLVERR_BIT);
                ftch_decerr_i  <= m_axis_ftch_sts_tdata(DATAMOVER_STS_DECERR_BIT);
                ftch_interr_i  <= m_axis_ftch_sts_tdata(DATAMOVER_STS_INTERR_BIT);
            -- Only assert when valid
            else
                ftch_done      <= '0';
                ftch_slverr_i  <= '0';
                ftch_decerr_i  <= '0';
                ftch_interr_i  <= '0';
            end if;
        end if;
    end process DATAMOVER_STS;


-------------------------------------------------------------------------------
-- Early SlvErr and DecErr detections
-- Early detection primarily required for non-queue mode because fetched desc
-- is immediatle fed to DMA controller.  Status from SG Datamover arrives
-- too late to stop the insuing transfer on fetch error
-------------------------------------------------------------------------------
REG_MM_RD_SIGNALS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                sg_rresp  <= (others => '0');
                sg_rvalid <= '0';
            else
                sg_rresp  <= m_axi_sg_rresp;
                sg_rvalid <= m_axi_sg_rvalid;
            end if;
        end if;
    end process REG_MM_RD_SIGNALS;


REG_ERLY_FTCH_ERROR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                ftch_error_early     <= '0';
            elsif(sg_rvalid = '1' and (sg_rresp = SLVERR_RESP
                                    or sg_rresp = DECERR_RESP))then
                ftch_error_early     <= '1';
            end if;
        end if;
    end process REG_ERLY_FTCH_ERROR;


-------------------------------------------------------------------------------
-- Register global error from data mover.
-------------------------------------------------------------------------------
mm2s_error <= ftch_slverr_i or ftch_decerr_i or ftch_interr_i;

-- Log errors into a global error output
FETCH_ERROR_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                ftch_error <= '0';
            elsif(mm2s_error = '1')then
                ftch_error <= '1';
            end if;
        end if;
    end process FETCH_ERROR_PROCESS;

end implementation;


-------------------------------------------------------------------------------
-- axi_sg_ftch_mngr
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_sg_ftch_mngr.vhd
-- Description: This entity manages fetching of descriptors.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     7/20/10    v1_00_a
-- ^^^^^^
-- Qualified reseting of sg_idle from axi_sg_ftch_pntr with associated channel's
-- flush control.
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Rolled axi_sg library version to version v2_00_a
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;


-------------------------------------------------------------------------------
entity  axi_sg_ftch_mngr is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_INCLUDE_CH1           : integer range 0 to 1          := 1;
            -- Include or Exclude channel 1 scatter gather engine
            -- 0 = Exclude Channel 1 SG Engine
            -- 1 = Include Channel 1 SG Engine

        C_INCLUDE_CH2           : integer range 0 to 1          := 1;
            -- Include or Exclude channel 2 scatter gather engine
            -- 0 = Exclude Channel 2 SG Engine
            -- 1 = Include Channel 2 SG Engine

        C_SG_CH1_WORDS_TO_FETCH : integer range 4 to 16         := 8;
            -- Number of words to fetch for channel 1

        C_SG_CH2_WORDS_TO_FETCH : integer range 4 to 16         := 8;
            -- Number of words to fetch for channel 1

        C_SG_FTCH_DESC2QUEUE     : integer range 0 to 8         := 0;
            -- Number of descriptors to fetch and queue for each channel.
            -- A value of zero excludes the fetch queues.

        C_SG_CH1_ENBL_STALE_ERROR   : integer range 0 to 1      := 1;
            -- Enable or disable stale descriptor check
            -- 0 = Disable stale descriptor error check
            -- 1 = Enable stale descriptor error check

        C_SG_CH2_ENBL_STALE_ERROR   : integer range 0 to 1      := 1
            -- Enable or disable stale descriptor check
            -- 0 = Disable stale descriptor error check
            -- 1 = Enable stale descriptor error check



    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;                    --
        m_axi_sg_aresetn            : in  std_logic                         ;                    --
                                                                                                 --
        -- Channel 1 Control and Status                                                          --
        ch1_run_stop                : in  std_logic                         ;                    --
        ch1_desc_flush              : in  std_logic                         ;                    --
        ch1_updt_done               : in  std_logic                         ;                    --
        ch1_ftch_idle               : out std_logic                         ;                    --
        ch1_ftch_active             : out std_logic                         ;                    --
        ch1_ftch_interr_set         : out std_logic                         ;                    --
        ch1_ftch_slverr_set         : out std_logic                         ;                    --
        ch1_ftch_decerr_set         : out std_logic                         ;                    --
        ch1_ftch_err_early          : out std_logic                         ;                    --
        ch1_ftch_stale_desc         : out std_logic                         ;                    --
        ch1_tailpntr_enabled        : in  std_logic                         ;                    --
        ch1_taildesc_wren           : in  std_logic                         ;                    --
        ch1_taildesc                : in  std_logic_vector                                       --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                    --
        ch1_nxtdesc_wren            : in  std_logic                         ;                    --
        ch1_curdesc                 : in  std_logic_vector                                       --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                    --
        ch1_ftch_queue_empty        : in  std_logic                         ;                    --
        ch1_ftch_queue_full         : in  std_logic                         ;                    --
        ch1_ftch_pause              : in  std_logic                         ;                    --
                                                                                                 --
        -- Channel 2 Control and Status                                                          --
        ch2_run_stop                : in  std_logic                         ;                    --
        ch2_updt_done               : in  std_logic                         ;                    --
        ch2_desc_flush              : in  std_logic                         ;                    --
        ch2_ftch_idle               : out std_logic                         ;                    --
        ch2_ftch_active             : out std_logic                         ;                    --
        ch2_ftch_interr_set         : out std_logic                         ;                    --
        ch2_ftch_slverr_set         : out std_logic                         ;                    --
        ch2_ftch_decerr_set         : out std_logic                         ;                    --
        ch2_ftch_err_early          : out std_logic                         ;                    --
        ch2_ftch_stale_desc         : out std_logic                         ;                    --
        ch2_tailpntr_enabled        : in  std_logic                         ;                    --
        ch2_taildesc_wren           : in  std_logic                         ;                    --
        ch2_taildesc                : in  std_logic_vector                                       --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                    --
        ch2_nxtdesc_wren            : in  std_logic                         ;                    --
        ch2_curdesc                 : in  std_logic_vector                                       --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                    --
        ch2_ftch_queue_empty        : in  std_logic                         ;                    --
        ch2_ftch_queue_full         : in  std_logic                         ;                    --
        ch2_ftch_pause              : in  std_logic                         ;                    --
                                                                                                 --
        nxtdesc                     : in  std_logic_vector                                       --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                    --
                                                                                                 --
        -- Read response for detecting slverr, decerr early                                      --
        m_axi_sg_rresp              : in  std_logic_vector(1 downto 0)      ;                    --
        m_axi_sg_rvalid             : in  std_logic                         ;                    --
                                                                                                 --
        -- User Command Interface Ports (AXI Stream)                                             --
        s_axis_ftch_cmd_tvalid      : out std_logic                         ;                    --
        s_axis_ftch_cmd_tready      : in  std_logic                         ;                    --
        s_axis_ftch_cmd_tdata       : out std_logic_vector                                       --
                                        ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);     --
                                                                                                 --
        -- User Status Interface Ports (AXI Stream)                                              --
        m_axis_ftch_sts_tvalid      : in  std_logic                         ;                    --
        m_axis_ftch_sts_tready      : out std_logic                         ;                    --
        m_axis_ftch_sts_tdata       : in  std_logic_vector(7 downto 0)      ;                    --
        m_axis_ftch_sts_tkeep       : in  std_logic_vector(0 downto 0)      ;                    --
        mm2s_err                    : in  std_logic                         ;                    --
                                                                                                 --
                                                                                                 --
        ftch_cmnd_wr                : out std_logic                         ;                    --
        ftch_cmnd_data              : out std_logic_vector                                       --
                                        ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);     --
        ftch_stale_desc             : in  std_logic                         ;                    --
        updt_error                  : in  std_logic                         ;                    --
        ftch_error                  : out std_logic                         ;                    --
        ftch_error_addr             : out std_logic_vector                                       --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)                       --

    );

end axi_sg_ftch_mngr;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_ftch_mngr is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal ftch_cmnd_wr_i               : std_logic := '0';
signal ftch_cmnd_data_i             : std_logic_vector
                                        ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0)
                                        := (others => '0');

signal ch1_sg_idle                  : std_logic := '0';
signal ch1_fetch_address            : std_logic_vector
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)
                                        := (others => '0');

signal ch2_sg_idle                  : std_logic := '0';
signal ch2_fetch_address            : std_logic_vector
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)
                                        := (others => '0');

signal ftch_done                    : std_logic := '0';
signal ftch_error_i                 : std_logic := '0';
signal ftch_interr                  : std_logic := '0';
signal ftch_slverr                  : std_logic := '0';
signal ftch_decerr                  : std_logic := '0';
signal ftch_error_early             : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
ftch_cmnd_wr        <= ftch_cmnd_wr_i;
ftch_cmnd_data      <= ftch_cmnd_data_i;
ftch_error          <= ftch_error_i;

-------------------------------------------------------------------------------
--  Scatter Gather Fetch State Machine
-------------------------------------------------------------------------------
I_FTCH_SG : entity  axi_vdma_v6_3_10.axi_sg_ftch_sm
    generic map(
        C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH                ,
        C_INCLUDE_CH1               => C_INCLUDE_CH1                        ,
        C_INCLUDE_CH2               => C_INCLUDE_CH2                        ,
        C_SG_CH1_WORDS_TO_FETCH     => C_SG_CH1_WORDS_TO_FETCH              ,
        C_SG_CH2_WORDS_TO_FETCH     => C_SG_CH2_WORDS_TO_FETCH              ,
        C_SG_FTCH_DESC2QUEUE        => C_SG_FTCH_DESC2QUEUE                 ,
        C_SG_CH1_ENBL_STALE_ERROR   => C_SG_CH1_ENBL_STALE_ERROR            ,
        C_SG_CH2_ENBL_STALE_ERROR   => C_SG_CH2_ENBL_STALE_ERROR
    )
    port map(
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               => m_axi_sg_aclk                        ,
        m_axi_sg_aresetn            => m_axi_sg_aresetn                     ,
        updt_error                  => updt_error                           ,

        -- Channel 1 Control and Status
        ch1_run_stop                => ch1_run_stop                         ,
        ch1_updt_done               => ch1_updt_done                        ,
        ch1_desc_flush              => ch1_desc_flush                       ,
        ch1_sg_idle                 => ch1_sg_idle                          ,
        ch1_tailpntr_enabled        => ch1_tailpntr_enabled                 ,
        ch1_ftch_queue_empty        => ch1_ftch_queue_empty                 ,
        ch1_ftch_queue_full         => ch1_ftch_queue_full                  ,
        ch1_fetch_address           => ch1_fetch_address                    ,
        ch1_ftch_active             => ch1_ftch_active                      ,
        ch1_ftch_idle               => ch1_ftch_idle                        ,
        ch1_ftch_interr_set         => ch1_ftch_interr_set                  ,
        ch1_ftch_slverr_set         => ch1_ftch_slverr_set                  ,
        ch1_ftch_decerr_set         => ch1_ftch_decerr_set                  ,
        ch1_ftch_err_early          => ch1_ftch_err_early                   ,
        ch1_ftch_stale_desc         => ch1_ftch_stale_desc                  ,
        ch1_ftch_pause              => ch1_ftch_pause                       ,

        -- Channel 2 Control and Status
        ch2_run_stop                => ch2_run_stop                         ,
        ch2_updt_done               => ch2_updt_done                        ,
        ch2_desc_flush              => ch2_desc_flush                       ,
        ch2_sg_idle                 => ch2_sg_idle                          ,
        ch2_tailpntr_enabled        => ch2_tailpntr_enabled                 ,
        ch2_ftch_queue_empty        => ch2_ftch_queue_empty                 ,
        ch2_ftch_queue_full         => ch2_ftch_queue_full                  ,
        ch2_fetch_address           => ch2_fetch_address                    ,
        ch2_ftch_active             => ch2_ftch_active                      ,
        ch2_ftch_idle               => ch2_ftch_idle                        ,
        ch2_ftch_interr_set         => ch2_ftch_interr_set                  ,
        ch2_ftch_slverr_set         => ch2_ftch_slverr_set                  ,
        ch2_ftch_decerr_set         => ch2_ftch_decerr_set                  ,
        ch2_ftch_err_early          => ch2_ftch_err_early                   ,
        ch2_ftch_stale_desc         => ch2_ftch_stale_desc                  ,
        ch2_ftch_pause              => ch2_ftch_pause                       ,

        -- Transfer Request
        ftch_cmnd_wr                => ftch_cmnd_wr_i                       ,
        ftch_cmnd_data              => ftch_cmnd_data_i                     ,

        -- Transfer Status
        ftch_done                   => ftch_done                            ,
        ftch_error                  => ftch_error_i                         ,
        ftch_interr                 => ftch_interr                          ,
        ftch_slverr                 => ftch_slverr                          ,
        ftch_decerr                 => ftch_decerr                          ,
        ftch_stale_desc             => ftch_stale_desc                      ,
        ftch_error_addr             => ftch_error_addr                      ,
        ftch_error_early            => ftch_error_early
    );

-------------------------------------------------------------------------------
--  Scatter Gather Fetch Pointer Manager
-------------------------------------------------------------------------------
I_FTCH_PNTR_MNGR : entity  axi_vdma_v6_3_10.axi_sg_ftch_pntr
    generic map(
        C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH                ,
        C_INCLUDE_CH1               => C_INCLUDE_CH1                        ,
        C_INCLUDE_CH2               => C_INCLUDE_CH2
    )
    port map(
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               => m_axi_sg_aclk                        ,
        m_axi_sg_aresetn            => m_axi_sg_aresetn                     ,


        nxtdesc                     => nxtdesc                              ,

        -------------------------------
        -- CHANNEL 1
        -------------------------------
        ch1_run_stop                => ch1_run_stop                         ,
        ch1_desc_flush              => ch1_desc_flush                       ,

        -- CURDESC update on run/stop assertion (from ftch_sm)
        ch1_curdesc                 => ch1_curdesc                          ,

        -- TAILDESC update on CPU write (from axi_dma_reg_module)
        ch1_tailpntr_enabled        => ch1_tailpntr_enabled                 ,
        ch1_taildesc_wren           => ch1_taildesc_wren                    ,
        ch1_taildesc                => ch1_taildesc                         ,

        -- NXTDESC update on descriptor fetch (from axi_sg_ftchq_if)
        ch1_nxtdesc_wren            => ch1_nxtdesc_wren                     ,

        -- Current address of descriptor to fetch
        ch1_fetch_address           => ch1_fetch_address                    ,
        ch1_sg_idle                 => ch1_sg_idle                          ,

        -------------------------------
        -- CHANNEL 2
        -------------------------------
        ch2_run_stop                => ch2_run_stop                         ,
        ch2_desc_flush              => ch2_desc_flush                       ,

        -- CURDESC update on run/stop assertion (from ftch_sm)
        ch2_curdesc                 => ch2_curdesc                          ,

        -- TAILDESC update on CPU write (from axi_dma_reg_module)
        ch2_tailpntr_enabled        => ch2_tailpntr_enabled                 ,
        ch2_taildesc_wren           => ch2_taildesc_wren                    ,
        ch2_taildesc                => ch2_taildesc                         ,

        -- NXTDESC update on descriptor fetch (from axi_sg_ftchq_if)
        ch2_nxtdesc_wren            => ch2_nxtdesc_wren                     ,

        -- Current address of descriptor to fetch
        ch2_fetch_address           => ch2_fetch_address                    ,
        ch2_sg_idle                 => ch2_sg_idle
    );

-------------------------------------------------------------------------------
--  Scatter Gather Fetch Command / Status Interface
-------------------------------------------------------------------------------
I_FTCH_CMDSTS_IF : entity  axi_vdma_v6_3_10.axi_sg_ftch_cmdsts_if
    generic map(
        C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH
    )
    port map(
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               => m_axi_sg_aclk                        ,
        m_axi_sg_aresetn            => m_axi_sg_aresetn                     ,

        -- Fetch command write interface from fetch sm
        ftch_cmnd_wr                => ftch_cmnd_wr_i                       ,
        ftch_cmnd_data              => ftch_cmnd_data_i                     ,


        -- Read response for detecting slverr, decerr early
        m_axi_sg_rresp              => m_axi_sg_rresp                       ,
        m_axi_sg_rvalid             => m_axi_sg_rvalid                      ,

        -- User Command Interface Ports (AXI Stream)
        s_axis_ftch_cmd_tvalid      => s_axis_ftch_cmd_tvalid               ,
        s_axis_ftch_cmd_tready      => s_axis_ftch_cmd_tready               ,
        s_axis_ftch_cmd_tdata       => s_axis_ftch_cmd_tdata                ,

        -- User Status Interface Ports (AXI Stream)
        m_axis_ftch_sts_tvalid      => m_axis_ftch_sts_tvalid               ,
        m_axis_ftch_sts_tready      => m_axis_ftch_sts_tready               ,
        m_axis_ftch_sts_tdata       => m_axis_ftch_sts_tdata                ,
        m_axis_ftch_sts_tkeep       => m_axis_ftch_sts_tkeep                ,

        -- Scatter Gather Fetch Status
        mm2s_err                    => mm2s_err                             ,

        ftch_done                   => ftch_done                            ,
        ftch_error                  => ftch_error_i                         ,
        ftch_interr                 => ftch_interr                          ,
        ftch_slverr                 => ftch_slverr                          ,
        ftch_decerr                 => ftch_decerr                          ,
        ftch_error_early            => ftch_error_early
    );




end implementation;


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- axi_sg_afifo_autord.vhd - entity/architecture pair
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_sg_afifo_autord.vhd
-- Version:         initial
-- Description:
--    This file contains the logic to generate a CoreGen call to create a
-- asynchronous FIFO as part of the synthesis process of XST. This eliminates
-- the need for multiple fixed netlists for various sizes and widths of FIFOs.
--
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:          DET
-- History:
--   DET           12/21/2009    First Version
--   GAB            3/23/2010    renamed for axi_dma
--
--  GAB     10/15/10    v4_03
-- ^^^^^^
--  - Updated libraries to v4_03
-- ~~~~~~
--  GAB     2/15/11     v4_030_a
-- ^^^^^^
--  Updated libraries to v4_030_a
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
--  GAB     7/19/11    v4_03
-- ^^^^^^
-- Update for use with axi_sg_v4_03
-- ~~~~~~
-------------------------------------------------------------------------------
-- Naming Conventions:
--      active low signals:                     "*_n"
--      clock signals:                          "clk", "clk_div#", "clk_#x"
--      reset signals:                          "rst", "rst_n"
--      generics:                               "C_*"
--      user defined types:                     "*_TYPE"
--      state machine next state:               "*_ns"
--      state machine current state:            "*_cs"
--      combinatorial signals:                  "*_com"
--      pipelined or register delay signals:    "*_d#"
--      counter signals:                        "*cnt*"
--      clock enable signals:                   "*_ce"
--      internal version of output port         "*_i"
--      device pins:                            "*_pin"
--      ports:                                  - Names begin with Uppercase
--      processes:                              "*_PROCESS"
--      component instantiations:               "<ENTITY_>I_<#|FUNC>
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;

library lib_fifo_v1_0_14;
use lib_fifo_v1_0_14.async_fifo_fg;

-----------------------------------------------------------------------------
-- Entity section
-----------------------------------------------------------------------------

entity axi_sg_afifo_autord is
  generic (
     C_DWIDTH        : integer := 32;
       -- Sets the width of the FIFO Data

     C_DEPTH         : integer := 16;
       -- Sets the depth of the FIFO

     C_CNT_WIDTH     : Integer := 5;
       -- Sets the width of the FIFO Data Count output

     C_USE_BLKMEM    : Integer := 1 ;
       -- Sets the type of memory to use for the FIFO
       -- 0 = Distributed Logic
       -- 1 = Block Ram

     C_FAMILY        : String  := "virtex6"
       -- Specifies the target FPGA Family

    );
  port (
    -- FIFO Inputs --------------------------------------------------------------
     AFIFO_Ainit                : In  std_logic;                               --
     AFIFO_Wr_clk               : In  std_logic;                               --
     AFIFO_Wr_en                : In  std_logic;                               --
     AFIFO_Din                  : In  std_logic_vector(C_DWIDTH-1 downto 0);   --
     AFIFO_Rd_clk               : In  std_logic;                               --
     AFIFO_Rd_en                : In  std_logic;                               --
     AFIFO_Clr_Rd_Data_Valid    : In  std_logic;                               --
     ----------------------------------------------------------------------------

    -- FIFO Outputs --------------------------------------------------------------
     AFIFO_DValid               : Out std_logic;                                --
     AFIFO_Dout                 : Out std_logic_vector(C_DWIDTH-1 downto 0);    --
     AFIFO_Full                 : Out std_logic;                                --
     AFIFO_Empty                : Out std_logic;                                --
     AFIFO_Almost_full          : Out std_logic;                                --
     AFIFO_Almost_empty         : Out std_logic;                                --
     AFIFO_Wr_count             : Out std_logic_vector(C_CNT_WIDTH-1 downto 0); --
     AFIFO_Rd_count             : Out std_logic_vector(C_CNT_WIDTH-1 downto 0); --
     AFIFO_Corr_Rd_count        : Out std_logic_vector(C_CNT_WIDTH downto 0);   --
     AFIFO_Corr_Rd_count_minus1 : Out std_logic_vector(C_CNT_WIDTH downto 0);   --
     AFIFO_Rd_ack               : Out std_logic                                 --
     -----------------------------------------------------------------------------

    );
end entity axi_sg_afifo_autord;


-----------------------------------------------------------------------------
-- Architecture section
-----------------------------------------------------------------------------

architecture imp of axi_sg_afifo_autord is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";


-- Constant declarations
  -- none

-- Signal declarations
   signal write_data_lil_end       : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
   signal read_data_lil_end        : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');

--   signal wr_count_lil_end         : std_logic_vector(C_CNT_WIDTH-1 downto 0) := (others => '0');
--   signal rd_count_lil_end         : std_logic_vector(C_CNT_WIDTH-1 downto 0) := (others => '0');
   signal wr_count_lil_end         : std_logic_vector(C_CNT_WIDTH-2 downto 0) := (others => '0');
   signal rd_count_lil_end         : std_logic_vector(C_CNT_WIDTH-2 downto 0) := (others => '0');

   signal rd_count_int             : natural   :=  0;
   signal rd_count_int_corr        : natural   :=  0;
   signal rd_count_int_corr_minus1 : natural   :=  0;
   Signal corrected_empty          : std_logic := '0';
   Signal corrected_almost_empty   : std_logic := '0';
   Signal sig_afifo_empty          : std_logic := '0';
   Signal sig_afifo_almost_empty   : std_logic := '0';

 -- backend fifo read ack sample and hold
   Signal sig_rddata_valid         : std_logic := '0';
   Signal hold_ff_q                : std_logic := '0';
   Signal ored_ack_ff_reset        : std_logic := '0';
   Signal autoread                 : std_logic := '0';
   Signal sig_wrfifo_rdack         : std_logic := '0';
   Signal fifo_read_enable         : std_logic := '0';

   signal afifo_full_i             : std_logic := '0';

-----------------------------------------------------------------------------
-- Begin architecture
-----------------------------------------------------------------------------
begin

 -- Bit ordering translations

    write_data_lil_end   <=  AFIFO_Din;  -- translate from Big Endian to little
                                         -- endian.
    AFIFO_Rd_ack         <= sig_wrfifo_rdack;

    AFIFO_Dout           <= read_data_lil_end;  -- translate from Little Endian to
                                                -- Big endian.

    AFIFO_Almost_empty   <= corrected_almost_empty;

    AFIFO_Empty          <= corrected_empty;

    AFIFO_Full          <= afifo_full_i;

--    AFIFO_Wr_count       <= wr_count_lil_end;
    AFIFO_Wr_count       <= afifo_full_i & wr_count_lil_end;

--    AFIFO_Rd_count       <= 'rd_count_lil_end;
    AFIFO_Rd_count       <= '0' & rd_count_lil_end;


    AFIFO_Corr_Rd_count  <= CONV_STD_LOGIC_VECTOR(rd_count_int_corr,
                                                  C_CNT_WIDTH+1);

    AFIFO_Corr_Rd_count_minus1 <= CONV_STD_LOGIC_VECTOR(rd_count_int_corr_minus1,
                                                        C_CNT_WIDTH+1);

    AFIFO_DValid         <= sig_rddata_valid; -- Output data valid indicator


    fifo_read_enable     <= AFIFO_Rd_en or autoread;



   -------------------------------------------------------------------------------
   -- Instantiate the CoreGen FIFO
   --
   -- NOTE:
   -- This instance refers to a wrapper file that interm will use the
   -- CoreGen FIFO Generator Async FIFO utility.
   --
   -------------------------------------------------------------------------------
    I_ASYNC_FIFOGEN_FIFO : entity lib_fifo_v1_0_14.async_fifo_fg
       generic map (
	  C_XPM_FIFO		=>  1,
          C_ALLOW_2N_DEPTH      =>  1,
          C_FAMILY              =>  C_FAMILY,
          C_DATA_WIDTH          =>  C_DWIDTH,
          C_SYNCHRONIZER_STAGE          =>  4,
          C_ENABLE_RLOCS        =>  0,
          C_FIFO_DEPTH          =>  C_DEPTH,
          C_HAS_ALMOST_EMPTY    =>  1,
          C_HAS_ALMOST_FULL     =>  1,
          C_HAS_RD_ACK          =>  1,
          C_HAS_RD_COUNT        =>  1,
          C_HAS_RD_ERR          =>  0,
          C_HAS_WR_ACK          =>  0,
          C_HAS_WR_COUNT        =>  1,
          C_HAS_WR_ERR          =>  0,
          C_RD_ACK_LOW          =>  0,
--          C_RD_COUNT_WIDTH      =>  C_CNT_WIDTH,
          C_RD_COUNT_WIDTH      =>  C_CNT_WIDTH-1,
          C_RD_ERR_LOW          =>  0,
          C_USE_BLOCKMEM        =>  C_USE_BLKMEM,
          C_WR_ACK_LOW          =>  0,
--          C_WR_COUNT_WIDTH      =>  C_CNT_WIDTH,
          C_EN_SAFETY_CKT       =>  1,  
          C_WR_COUNT_WIDTH      =>  C_CNT_WIDTH-1,
          C_WR_ERR_LOW          =>  0
          --C_WR_ERR_LOW          =>  0,
          --C_USE_EMBEDDED_REG    =>  1, -- 0 ;
          --C_PRELOAD_REGS        =>  0, -- 0 ;
          --C_PRELOAD_LATENCY     =>  1  -- 1 ;
         )
      port Map (
         Din                 =>  write_data_lil_end,
         Wr_en               =>  AFIFO_Wr_en,
         Wr_clk              =>  AFIFO_Wr_clk,
         Rd_en               =>  fifo_read_enable,
         Rd_clk              =>  AFIFO_Rd_clk,
         Ainit               =>  AFIFO_Ainit,
         Dout                =>  read_data_lil_end,
--         Full                =>  AFIFO_Full,
         Full                =>  afifo_full_i,
         Empty               =>  sig_afifo_empty,
         Almost_full         =>  AFIFO_Almost_full,
         Almost_empty        =>  sig_afifo_almost_empty,
         Wr_count            =>  wr_count_lil_end,
         Rd_count            =>  rd_count_lil_end,
         Rd_ack              =>  sig_wrfifo_rdack,
         Rd_err              =>  open,
         Wr_ack              =>  open,
         Wr_err              =>  open
        );


   ----------------------------------------------------------------------------
   -- Read Ack assert & hold logic (needed because:
   --     1) The Async FIFO has to be read once to get valid
   --        data to the read data port (data is discarded).
   --     2) The Read ack from the fifo is only asserted for 1 clock.
   --     3) A signal is needed that indicates valid data is at the read
   --        port of the FIFO and has not yet been read. This signal needs
   --        to be held until the next read operation occurs or a clear
   --        signal is received.


    ored_ack_ff_reset  <=  fifo_read_enable or
                           AFIFO_Ainit or
                           AFIFO_Clr_Rd_Data_Valid;

    sig_rddata_valid   <=  hold_ff_q or
                           sig_wrfifo_rdack;




    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_ACK_HOLD_FLOP
    --
    -- Process Description:
    --  Flop for registering the hold flag
    --
    -------------------------------------------------------------
    IMP_ACK_HOLD_FLOP : process (AFIFO_Rd_clk)
       begin
         if (AFIFO_Rd_clk'event and AFIFO_Rd_clk = '1') then
           if (ored_ack_ff_reset = '1') then
             hold_ff_q  <= '0';
           else
             hold_ff_q  <= sig_rddata_valid;
           end if;
         end if;
       end process IMP_ACK_HOLD_FLOP;



  -- generate auto-read enable. This keeps fresh data at the output
  -- of the FIFO whenever it is available.
    autoread <= '1'                     -- create a read strobe when the
      when (sig_rddata_valid = '0' and  -- output data is NOT valid
            sig_afifo_empty = '0')      -- and the FIFO is not empty
      Else '0';


    rd_count_int <=  CONV_INTEGER(rd_count_lil_end);


    -------------------------------------------------------------
    -- Combinational Process
    --
    -- Label: CORRECT_RD_CNT
    --
    -- Process Description:
    --  This process corrects the FIFO Read Count output for the
    -- auto read function.
    --
    -------------------------------------------------------------
    CORRECT_RD_CNT : process (sig_rddata_valid,
                              sig_afifo_empty ,
                              sig_afifo_almost_empty,
                              rd_count_int)
       begin

          if (sig_rddata_valid = '0') then

             rd_count_int_corr        <= 0;
             rd_count_int_corr_minus1 <= 0;
             corrected_empty          <= '1';
             corrected_almost_empty   <= '0';

          elsif (sig_afifo_empty = '1') then         -- rddata valid and fifo empty

             rd_count_int_corr        <= 1;
             rd_count_int_corr_minus1 <= 0;
             corrected_empty          <= '0';
             corrected_almost_empty   <= '1';

          Elsif (sig_afifo_almost_empty = '1') Then  -- rddata valid and fifo almost empty

             rd_count_int_corr        <= 2;
             rd_count_int_corr_minus1 <= 1;
             corrected_empty          <= '0';
             corrected_almost_empty   <= '0';

          else                                       -- rddata valid and modify rd count from FIFO

             rd_count_int_corr        <= rd_count_int+1;
             rd_count_int_corr_minus1 <= rd_count_int;
             corrected_empty          <= '0';
             corrected_almost_empty   <= '0';

          end if;

       end process CORRECT_RD_CNT;



end imp;


-------------------------------------------------------------------------------
-- axi_sg_ftch_queue
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_sg_ftch_queue.vhd
-- Description: This entity is the descriptor fetch queue interface
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     7/27/10    v1_00_a
-- ^^^^^^

-- Remove double driven signal for exclude update engine mode
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Rolled axi_sg library version to version v2_00_a
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     11/15/10    v2_01_a
-- ^^^^^^

--  Converted all stream paraters ***_DATA_WIDTH to ***_TDATA_WIDTH
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
--  GAB     7/8/11    v4_03
-- ^^^^^^

-- ~~~~~~
--  GAB     8/16/11    v4_03
-- ^^^^^^

--            utilized wrcount from queue to create empty flag for fetch sm.
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;

library lib_pkg_v1_0_2;
library lib_fifo_v1_0_14;
use lib_fifo_v1_0_14.sync_fifo_fg;
use lib_pkg_v1_0_2.lib_pkg.all;

-------------------------------------------------------------------------------
entity  axi_sg_ftch_queue is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width

        C_M_AXIS_SG_TDATA_WIDTH     : integer range 32 to 32    := 32;
            -- Master AXI Stream Data width

        C_SG_FTCH_DESC2QUEUE        : integer range 0 to 8      := 0;
            -- Number of descriptors to fetch and queue for each channel.
            -- A value of zero excludes the fetch queues.

        C_SG_WORDS_TO_FETCH         : integer range 4 to 16     := 8;
            -- Number of words to fetch for channel 1

        C_AXIS_IS_ASYNC             : integer range 0 to 1      := 0;
            -- Channel 1 is async to sg_aclk
            -- 0 = Synchronous to SG ACLK
            -- 1 = Asynchronous to SG ACLK

        C_FAMILY                    : string            := "virtex6"
            -- Device family used for proper BRAM selection
    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;                   --
        m_axi_sg_aresetn            : in  std_logic                         ;                   --
                                                                                                --
        -- Channel Control                                                                    --
        desc_flush                  : in  std_logic                         ;                   --
        ftch_active                 : in  std_logic                         ;                   --
        ftch_queue_empty            : out std_logic                         ;                   --
        ftch_queue_full             : out std_logic                         ;                   --
        ftch_pause                  : out std_logic                         ;                   --
                                                                                                --
        writing_nxtdesc_in          : in  std_logic                         ;                   --
        writing_curdesc_out         : out std_logic                         ;                   --
                                                                                                --
        -- DataMover Command                                                                    --
        ftch_cmnd_wr                : in  std_logic                         ;                   --
        ftch_cmnd_data              : in  std_logic_vector                                      --
                                        ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);    --
                                                                                                --
        -- MM2S Stream In from DataMover                                                        --
        m_axis_mm2s_tdata           : in  std_logic_vector                                      --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) ;                  --
        m_axis_mm2s_tlast           : in  std_logic                         ;                   --
        m_axis_mm2s_tvalid          : in  std_logic                         ;                   --
        m_axis_mm2s_tready          : out std_logic                         ;                   --
                                                                                                --
                                                                                                --
        -- Channel 1 AXI Fetch Stream Out                                                       --
        m_axis_ftch_aclk            : in  std_logic                         ;                   --
        m_axis_ftch_tdata           : out std_logic_vector                                      --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0);                   --
        m_axis_ftch_tvalid          : out std_logic                         ;                   --
        m_axis_ftch_tready          : in  std_logic                         ;                   --
        m_axis_ftch_tlast           : out std_logic                                             --
    );

end axi_sg_ftch_queue;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_ftch_queue is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- Not currently used
--constant USE_LOGIC_FIFOS        : integer   := 0; -- Use Logic FIFOs
--constant USE_BRAM_FIFOS         : integer   := 1; -- Use BRAM FIFOs

-- Number of words deep fifo needs to be
constant    FETCH_QUEUE_DEPTH       : integer := max2(16,pad_power2(C_SG_FTCH_DESC2QUEUE
                                                                  * C_SG_WORDS_TO_FETCH));

-- Width of fifo rd and wr counts - only used for proper fifo operation
constant    FETCH_QUEUE_CNT_WIDTH   : integer   := clog2(FETCH_QUEUE_DEPTH+1);

-- Select between BRAM or Logic Memory Type
constant    MEMORY_TYPE : integer := bo2int(C_SG_FTCH_DESC2QUEUE
                                    * C_SG_WORDS_TO_FETCH > 16);


constant DESC2QUEUE_VECT_WIDTH      : integer := 4;
--constant SG_FTCH_DESC2QUEUE_VECT    : std_logic_vector(DESC2QUEUE_VECT_WIDTH-1 downto 0)
--                                        := std_logic_vector(to_unsigned(C_SG_FTCH_DESC2QUEUE,DESC2QUEUE_VECT_WIDTH));
constant SG_FTCH_DESC2QUEUE_VECT    : std_logic_vector(DESC2QUEUE_VECT_WIDTH-1 downto 0)
                                        := std_logic_vector(to_unsigned(C_SG_FTCH_DESC2QUEUE,DESC2QUEUE_VECT_WIDTH)); 

constant DCNT_LO_INDEX              : integer :=  max2(1,clog2(C_SG_WORDS_TO_FETCH)) - 1;
--constant DCNT_HI_INDEX              : integer :=  (DCNT_LO_INDEX + DESC2QUEUE_VECT_WIDTH) - 1;  
constant DCNT_HI_INDEX              : integer :=  FETCH_QUEUE_CNT_WIDTH-1;                       


constant ZERO_COUNT                 : std_logic_vector(FETCH_QUEUE_CNT_WIDTH-1 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Internal signals
signal curdesc_tdata            : std_logic_vector
                                    (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) := (others => '0');
signal curdesc_tvalid           : std_logic := '0';
signal ftch_tvalid              : std_logic := '0';
signal ftch_tdata               : std_logic_vector
                                    (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) := (others => '0');
signal ftch_tlast               : std_logic := '0';
signal ftch_tready              : std_logic := '0';

-- Misc Signals
signal writing_curdesc          : std_logic := '0';
signal writing_nxtdesc          : std_logic := '0';

signal msb_curdesc              : std_logic_vector(31 downto 0) := (others => '0');
signal writing_lsb              : std_logic := '0';
signal writing_msb              : std_logic := '0';

-- FIFO signals
signal queue_rden               : std_logic := '0';
signal queue_wren               : std_logic := '0';
signal queue_empty              : std_logic := '0';
signal queue_full               : std_logic := '0';
signal queue_din                : std_logic_vector
                                    (C_M_AXIS_SG_TDATA_WIDTH downto 0) := (others => '0');
signal queue_dout               : std_logic_vector
                                    (C_M_AXIS_SG_TDATA_WIDTH downto 0) := (others => '0');
signal queue_sinit              : std_logic := '0';
signal q_vacancy                : std_logic_vector(FETCH_QUEUE_CNT_WIDTH-1 downto 0) := (others => '0');
signal queue_dcount             : std_logic_vector(FETCH_QUEUE_CNT_WIDTH-1 downto 0) := (others => '0');
signal ftch_no_room             : std_logic;

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin


---------------------------------------------------------------------------
-- Write current descriptor to FIFO or out channel port
---------------------------------------------------------------------------
WRITE_CURDESC_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' )then
                curdesc_tdata       <= (others => '0');
                curdesc_tvalid      <= '0';
                writing_lsb         <= '0';
                writing_msb         <= '0';

            -- Write LSB Address on command write
            elsif(ftch_cmnd_wr = '1' and ftch_active = '1')then
                curdesc_tdata       <= ftch_cmnd_data(DATAMOVER_CMD_ADDRMSB_BOFST
                                                        + DATAMOVER_CMD_ADDRLSB_BIT
                                                        downto DATAMOVER_CMD_ADDRLSB_BIT);
                curdesc_tvalid      <= '1';
                writing_lsb         <= '1';
                writing_msb         <= '0';

            -- On ready write MSB address
            elsif(writing_lsb = '1' and ftch_tready = '1')then
                curdesc_tdata       <= msb_curdesc;
                curdesc_tvalid      <= '1';
                writing_lsb         <= '0';
                writing_msb         <= '1';

            -- On MSB write and ready then clear all
            elsif(writing_msb = '1' and ftch_tready = '1')then
                curdesc_tdata       <= (others => '0');
                curdesc_tvalid      <= '0';
                writing_lsb         <= '0';
                writing_msb         <= '0';

            end if;
        end if;
    end process WRITE_CURDESC_PROCESS;

---------------------------------------------------------------------------
-- TVALID MUX
-- MUX tvalid out channel port
---------------------------------------------------------------------------
TVALID_TDATA_MUX : process(writing_curdesc,
                                writing_nxtdesc,
                                ftch_active,
                                curdesc_tvalid,
                                curdesc_tdata,
                                m_axis_mm2s_tvalid,
                                m_axis_mm2s_tdata,
                                m_axis_mm2s_tlast)
    begin
        -- Select current descriptor to drive out (Queue or Channel Port)
        if(writing_curdesc = '1')then
            ftch_tvalid  <= curdesc_tvalid;
            ftch_tdata   <= curdesc_tdata;
            ftch_tlast   <= '0';
        -- Deassert tvalid when capturing next descriptor pointer
        elsif(writing_nxtdesc = '1')then
            ftch_tvalid  <= '0';
            ftch_tdata   <= (others => '0');
            ftch_tlast   <= '0';
        -- Otherwise drive data from Datamover out (Queue or Channel Port)
        elsif(ftch_active = '1')then
            ftch_tvalid  <= m_axis_mm2s_tvalid;
            ftch_tdata   <= m_axis_mm2s_tdata;
            ftch_tlast   <= m_axis_mm2s_tlast;
        else
            ftch_tvalid  <= '0';
            ftch_tdata   <= (others => '0');
            ftch_tlast   <= '0';
        end if;
    end process TVALID_TDATA_MUX;



GEN_FIFO_FOR_SYNC : if C_AXIS_IS_ASYNC = 0 generate
begin
    -- Generate Synchronous FIFO
    I_CH1_FTCH_FIFO : entity lib_fifo_v1_0_14.sync_fifo_fg
    generic map (
        C_FAMILY                =>  C_FAMILY                ,
        C_MEMORY_TYPE           =>  MEMORY_TYPE             ,
        C_WRITE_DATA_WIDTH      =>  C_M_AXIS_SG_TDATA_WIDTH + 1,
        C_WRITE_DEPTH           =>  FETCH_QUEUE_DEPTH       ,
        C_READ_DATA_WIDTH       =>  C_M_AXIS_SG_TDATA_WIDTH + 1,
        C_READ_DEPTH            =>  FETCH_QUEUE_DEPTH       ,
        C_PORTS_DIFFER          =>  0,
        C_HAS_DCOUNT            =>  1,
        C_DCOUNT_WIDTH          =>  FETCH_QUEUE_CNT_WIDTH,
        C_HAS_ALMOST_FULL       =>  0,
        C_HAS_RD_ACK            =>  0,
        C_HAS_RD_ERR            =>  0,
        C_HAS_WR_ACK            =>  0,
        C_HAS_WR_ERR            =>  0,
        C_RD_ACK_LOW            =>  0,
        C_RD_ERR_LOW            =>  0,
        C_WR_ACK_LOW            =>  0,
        C_WR_ERR_LOW            =>  0,
        C_PRELOAD_REGS          =>  1,-- 1 = first word fall through
        C_PRELOAD_LATENCY       =>  0 -- 0 = first word fall through

    )
    port map (

        Clk             =>  m_axi_sg_aclk       ,
        Sinit           =>  queue_sinit         ,
        Din             =>  queue_din           ,
        Wr_en           =>  queue_wren          ,
        Rd_en           =>  queue_rden          ,
        Dout            =>  queue_dout          ,
        Full            =>  queue_full          ,
        Empty           =>  queue_empty         ,
        Almost_full     =>  open                ,
        Data_count      =>  queue_dcount        ,
        Rd_ack          =>  open                ,
        Rd_err          =>  open                ,
        Wr_ack          =>  open                ,
        Wr_err          =>  open

    );

--    REG_DESC_PULLED : process(m_axi_sg_aclk)
--        begin
--            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk='1')then
--                if(m_axi_sg_aresetn = '0')then
--                    ftch_descpulled <= '0';
--                -- tlast read from fifo then complete descriptor read out
--                elsif(queue_rden = '1' and queue_dout(C_M_AXIS_SG_TDATA_WIDTH) = '1')then
--                    ftch_descpulled <= '1';
--                else
--                    ftch_descpulled <= '0';
--                end if;
--            end if;
--        end process REG_DESC_PULLED;


end generate GEN_FIFO_FOR_SYNC;

GEN_FIFO_FOR_ASYNC : if C_AXIS_IS_ASYNC = 1 generate
begin
    -- Generate Asynchronous FIFO
    I_CH1_FTCH_FIFO : entity axi_vdma_v6_3_10.axi_sg_afifo_autord
      generic map(
         C_DWIDTH        => C_M_AXIS_SG_TDATA_WIDTH + 1         ,
         C_DEPTH         => FETCH_QUEUE_DEPTH                   ,
         C_CNT_WIDTH     => FETCH_QUEUE_CNT_WIDTH               ,
         C_USE_BLKMEM    => MEMORY_TYPE                         ,
         C_FAMILY        => C_FAMILY
        )
      port map(
        -- Inputs
         AFIFO_Ainit                => queue_sinit              ,
         AFIFO_Wr_clk               => m_axi_sg_aclk            ,
         AFIFO_Wr_en                => queue_wren               ,
         AFIFO_Din                  => queue_din                ,
         AFIFO_Rd_clk               => m_axis_ftch_aclk         ,
         AFIFO_Rd_en                => queue_rden               ,
         AFIFO_Clr_Rd_Data_Valid    => '0'                      ,

        -- Outputs
         AFIFO_DValid               => open                     ,
         AFIFO_Dout                 => queue_dout               ,
         AFIFO_Full                 => queue_full               ,
         AFIFO_Empty                => queue_empty              ,
         AFIFO_Almost_full          => open                     ,
         AFIFO_Almost_empty         => open                     ,
         AFIFO_Wr_count             => queue_dcount             ,
         AFIFO_Rd_count             => open                     ,
         AFIFO_Corr_Rd_count        => open                     ,
         AFIFO_Corr_Rd_count_minus1 => open                     ,
         AFIFO_Rd_ack               => open
        );


end generate GEN_FIFO_FOR_ASYNC;





-----------------------------------------------------------------------
-- Internal Side
-----------------------------------------------------------------------
queue_sinit <= desc_flush or not m_axi_sg_aresetn;

-- Drive tready with fifo not full
ftch_tready <= not queue_full;

-- Drive out to datamover
m_axis_mm2s_tready <= ftch_tready;

-- Build FIFO data in, appending tlast bit
queue_din(C_M_AXIS_SG_TDATA_WIDTH)               <= ftch_tlast;
queue_din(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)    <= ftch_tdata;

-- Write to fifo if it is not full and data is valid
queue_wren  <= not queue_full
               and ftch_tvalid;

-- Pass fifo status back to fetch sm for channel IDLE determination

ftch_queue_empty <= '1' when queue_dcount = ZERO_COUNT and queue_wren = '0'
               else '0';


ftch_queue_full     <= queue_full;

ftch_pause <= '1' when queue_dcount(DCNT_HI_INDEX
                             downto DCNT_LO_INDEX) >= SG_FTCH_DESC2QUEUE_VECT
         else '0';

-----------------------------------------------------------------------
-- Channel Port Side
-----------------------------------------------------------------------
-- Read if fifo is not empty and target is ready
queue_rden  <= not queue_empty
               and m_axis_ftch_tready;

-- drive valid if fifo is not empty
m_axis_ftch_tvalid  <= not queue_empty;

-- Pass data out to port channel with MSB driving tlast
m_axis_ftch_tlast   <= not queue_empty and queue_dout(C_M_AXIS_SG_TDATA_WIDTH);
m_axis_ftch_tdata   <= queue_dout(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0);


-- If writing curdesc out then flag for proper mux selection
writing_curdesc     <= curdesc_tvalid;
-- Map intnal signal to port
writing_curdesc_out <= writing_curdesc;
-- Map port to internal signal
writing_nxtdesc     <= writing_nxtdesc_in;


end implementation;


-------------------------------------------------------------------------------
-- axi_sg_ftch_noqueue
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_sg_ftch_noqueue.vhd
-- Description: This entity is the no queue version
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     6/16/10    v4_03
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;

library lib_pkg_v1_0_2;
library lib_fifo_v1_0_14;
use lib_fifo_v1_0_14.sync_fifo_fg;
use lib_pkg_v1_0_2.lib_pkg.all;

-------------------------------------------------------------------------------
entity  axi_sg_ftch_noqueue is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64        := 32;
            -- Master AXI Memory Map Address Width

        C_M_AXIS_SG_TDATA_WIDTH     : integer range 32 to 32        := 32
            -- Master AXI Stream Data Width

    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;                   --
        m_axi_sg_aresetn            : in  std_logic                         ;                   --
                                                                                                --
        -- Channel Control                                                                    --
        desc_flush                  : in  std_logic                         ;                   --
        ftch_active                 : in  std_logic                         ;                   --
        ftch_queue_empty            : out std_logic                         ;                   --
        ftch_queue_full             : out std_logic                         ;                   --
                                                                                                --
        writing_nxtdesc_in          : in  std_logic                         ;                   --
        writing_curdesc_out         : out std_logic                         ;                   --

        -- DataMover Command                                                                    --
        ftch_cmnd_wr                : in  std_logic                         ;                   --
        ftch_cmnd_data              : in  std_logic_vector                                      --
                                        ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);    --
                                                                                                --
        -- MM2S Stream In from DataMover                                                        --
        m_axis_mm2s_tdata           : in  std_logic_vector                                      --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) ;                  --
        m_axis_mm2s_tlast           : in  std_logic                         ;                   --
        m_axis_mm2s_tvalid          : in  std_logic                         ;                   --
        m_axis_mm2s_tready          : out std_logic                         ;                   --
                                                                                                --
        -- Channel 1 AXI Fetch Stream Out                                                       --
        m_axis_ftch_tdata           : out std_logic_vector                                      --
                                            (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) ;              --
        m_axis_ftch_tvalid          : out std_logic                         ;                   --
        m_axis_ftch_tready          : in  std_logic                         ;                   --
        m_axis_ftch_tlast           : out std_logic                                             --
    );

end axi_sg_ftch_noqueue;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_ftch_noqueue is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Channel 1 internal signals
signal curdesc_tdata            : std_logic_vector
                                    (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) := (others => '0');
signal curdesc_tvalid           : std_logic := '0';
signal ftch_tvalid              : std_logic := '0';
signal ftch_tdata               : std_logic_vector
                                    (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) := (others => '0');
signal ftch_tlast               : std_logic := '0';
signal ftch_tready              : std_logic := '0';

-- Misc Signals
signal writing_curdesc          : std_logic := '0';
signal writing_nxtdesc          : std_logic := '0';
signal msb_curdesc              : std_logic_vector(31 downto 0) := (others => '0');


signal writing_lsb              : std_logic := '0';
signal writing_msb              : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

---------------------------------------------------------------------------
-- Write current descriptor to FIFO or out channel port
---------------------------------------------------------------------------
WRITE_CURDESC_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' )then
                curdesc_tdata       <= (others => '0');
                curdesc_tvalid      <= '0';
                writing_lsb         <= '0';
                writing_msb         <= '0';

            -- Write LSB Address on command write
            elsif(ftch_cmnd_wr = '1' and ftch_active = '1')then
                curdesc_tdata       <= ftch_cmnd_data(DATAMOVER_CMD_ADDRMSB_BOFST
                                                        + DATAMOVER_CMD_ADDRLSB_BIT
                                                        downto DATAMOVER_CMD_ADDRLSB_BIT);
                curdesc_tvalid      <= '1';
                writing_lsb         <= '1';
                writing_msb         <= '0';

            -- On ready write MSB address
            elsif(writing_lsb = '1' and ftch_tready = '1')then
                curdesc_tdata       <= msb_curdesc;
                curdesc_tvalid      <= '1';
                writing_lsb         <= '0';
                writing_msb         <= '1';

            -- On MSB write and ready then clear all
            elsif(writing_msb = '1' and ftch_tready = '1')then
                curdesc_tdata       <= (others => '0');
                curdesc_tvalid      <= '0';
                writing_lsb         <= '0';
                writing_msb         <= '0';

            end if;
        end if;
    end process WRITE_CURDESC_PROCESS;

---------------------------------------------------------------------------
-- TVALID MUX
-- MUX tvalid out channel port
---------------------------------------------------------------------------
TVALID_TDATA_MUX : process(writing_curdesc,
                                writing_nxtdesc,
                                ftch_active,
                                curdesc_tvalid,
                                curdesc_tdata,
                                m_axis_mm2s_tvalid,
                                m_axis_mm2s_tdata,
                                m_axis_mm2s_tlast)
    begin
        -- Select current descriptor to drive out (Queue or Channel Port)
        if(writing_curdesc = '1')then
            ftch_tvalid  <= curdesc_tvalid;
            ftch_tdata   <= curdesc_tdata;
            ftch_tlast   <= '0';
        -- Deassert tvalid when capturing next descriptor pointer
        elsif(writing_nxtdesc = '1')then
            ftch_tvalid  <= '0';
            ftch_tdata   <= (others => '0');
            ftch_tlast   <= '0';
        -- Otherwise drive data from Datamover out (Queue or Channel Port)
        elsif(ftch_active = '1')then
            ftch_tvalid  <= m_axis_mm2s_tvalid;
            ftch_tdata   <= m_axis_mm2s_tdata;
            ftch_tlast   <= m_axis_mm2s_tlast;
        else
            ftch_tvalid  <= '0';
            ftch_tdata   <= (others => '0');
            ftch_tlast   <= '0';
        end if;
    end process TVALID_TDATA_MUX;

---------------------------------------------------------------------------
-- Map internal stream to external
---------------------------------------------------------------------------
m_axis_ftch_tdata       <= ftch_tdata;
m_axis_ftch_tlast       <= ftch_tlast;
m_axis_ftch_tvalid      <= ftch_tvalid;
ftch_tready             <= m_axis_ftch_tready;


m_axis_mm2s_tready      <= ftch_tready;

---------------------------------------------------------------------------
-- generate psuedo empty flag for Idle generation
---------------------------------------------------------------------------
Q_EMPTY_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk='1')then
            if(m_axi_sg_aresetn = '0' or desc_flush = '1')then
                ftch_queue_empty <= '1';

            -- Else on valid and ready modify empty flag
            elsif(ftch_tvalid = '1' and m_axis_ftch_tready = '1')then
                -- On last mark as empty
                if(ftch_tlast = '1' )then
                    ftch_queue_empty <= '1';
                -- Otherwise mark as not empty
                else
                    ftch_queue_empty <= '0';
                end if;
            end if;
        end if;
    end process Q_EMPTY_PROCESS;

-- do not need to indicate full to axi_sg_ftch_sm.  Only
-- needed for queue case to allow other channel to be serviced
-- if it had queue room
ftch_queue_full <= '0';

-- If writing curdesc out then flag for proper mux selection
writing_curdesc     <= curdesc_tvalid;
-- Map intnal signal to port
writing_curdesc_out <= writing_curdesc;
-- Map port to internal signal
writing_nxtdesc     <= writing_nxtdesc_in;


end implementation;


-------------------------------------------------------------------------------
-- axi_sg_ftch_queue
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_sg_ftch_queue.vhd
-- Description: This entity is the descriptor fetch queue interface
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     7/27/10    v1_00_a
-- ^^^^^^

-- Remove double driven signal for exclude update engine mode
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Rolled axi_sg library version to version v2_00_a
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     11/15/10    v2_01_a
-- ^^^^^^

--  Converted all stream paraters ***_DATA_WIDTH to ***_TDATA_WIDTH
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;

library lib_pkg_v1_0_2;
library lib_fifo_v1_0_14;
use lib_fifo_v1_0_14.sync_fifo_fg;
use lib_pkg_v1_0_2.lib_pkg.all;

-------------------------------------------------------------------------------
entity  axi_sg_ftch_q_mngr is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width

        C_M_AXIS_SG_TDATA_WIDTH     : integer range 32 to 32    := 32;
            -- Master AXI Stream Data width

        C_AXIS_IS_ASYNC             : integer range 0 to 1      := 0;
            -- Channel 1 is async to sg_aclk
            -- 0 = Synchronous to SG ACLK
            -- 1 = Asynchronous to SG ACLK

        C_SG_FTCH_DESC2QUEUE        : integer range 0 to 8         := 0;
            -- Number of descriptors to fetch and queue for each channel.
            -- A value of zero excludes the fetch queues.

        C_SG_CH1_WORDS_TO_FETCH         : integer range 4 to 16     := 8;
            -- Number of words to fetch for channel 1

        C_SG_CH2_WORDS_TO_FETCH         : integer range 4 to 16     := 8;
            -- Number of words to fetch for channel 1

        C_SG_CH1_ENBL_STALE_ERROR   : integer range 0 to 1          := 1;
            -- Enable or disable stale descriptor check
            -- 0 = Disable stale descriptor error check
            -- 1 = Enable stale descriptor error check

        C_SG_CH2_ENBL_STALE_ERROR   : integer range 0 to 1          := 1;
            -- Enable or disable stale descriptor check
            -- 0 = Disable stale descriptor error check
            -- 1 = Enable stale descriptor error check

        C_INCLUDE_CH1               : integer range 0 to 1          := 1;
            -- Include or Exclude channel 1 scatter gather engine
            -- 0 = Exclude Channel 1 SG Engine
            -- 1 = Include Channel 1 SG Engine


        C_INCLUDE_CH2               : integer range 0 to 1          := 1;
            -- Include or Exclude channel 2 scatter gather engine
            -- 0 = Exclude Channel 2 SG Engine
            -- 1 = Include Channel 2 SG Engine

        C_FAMILY                    : string            := "virtex6"
            -- Device family used for proper BRAM selection
    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;                   --
        m_axi_sg_aresetn            : in  std_logic                         ;                   --
                                                                                                --
        -- Channel 1 Control                                                                    --
        ch1_desc_flush              : in  std_logic                         ;                   --
        ch1_ftch_active             : in  std_logic                         ;                   --
        ch1_nxtdesc_wren            : out std_logic                         ;                   --
        ch1_ftch_queue_empty        : out std_logic                         ;                   --
        ch1_ftch_queue_full         : out std_logic                         ;                   --
        ch1_ftch_pause              : out std_logic                         ;                   --
                                                                                                --
        -- Channel 2 Control                                                                    --
        ch2_desc_flush              : in  std_logic                         ;                   --
        ch2_ftch_active             : in  std_logic                         ;                   --
        ch2_nxtdesc_wren            : out std_logic                         ;                   --
        ch2_ftch_queue_empty        : out std_logic                         ;                   --
        ch2_ftch_queue_full         : out std_logic                         ;                   --
        ch2_ftch_pause              : out std_logic                         ;                   --
        nxtdesc                     : out std_logic_vector                                      --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --
        -- DataMover Command                                                                    --
        ftch_cmnd_wr                : in  std_logic                         ;                   --
        ftch_cmnd_data              : in  std_logic_vector                                      --
                                        ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);    --
        ftch_stale_desc             : out std_logic                         ;                   --
                                                                                                --
        -- MM2S Stream In from DataMover                                                        --
        m_axis_mm2s_tdata           : in  std_logic_vector                                      --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) ;                  --
        m_axis_mm2s_tkeep           : in  std_logic_vector                                      --
                                        ((C_M_AXIS_SG_TDATA_WIDTH/8)-1 downto 0);               --
        m_axis_mm2s_tlast           : in  std_logic                         ;                   --
        m_axis_mm2s_tvalid          : in  std_logic                         ;                   --
        m_axis_mm2s_tready          : out std_logic                         ;                   --
                                                                                                --
                                                                                                --
        -- Channel 1 AXI Fetch Stream Out                                                       --
        m_axis_ch1_ftch_aclk        : in  std_logic                         ;
        m_axis_ch1_ftch_tdata       : out std_logic_vector                                      --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0);                   --
        m_axis_ch1_ftch_tvalid      : out std_logic                         ;                   --
        m_axis_ch1_ftch_tready      : in  std_logic                         ;                   --
        m_axis_ch1_ftch_tlast       : out std_logic                         ;                   --
                                                                                                --
                                                                                                --
        -- Channel 2 AXI Fetch Stream Out                                                       --
        m_axis_ch2_ftch_aclk        : in  std_logic                         ;                   --
        m_axis_ch2_ftch_tdata       : out std_logic_vector                                      --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) ;                  --
        m_axis_ch2_ftch_tvalid      : out std_logic                         ;                   --
        m_axis_ch2_ftch_tready      : in  std_logic                         ;                   --
        m_axis_ch2_ftch_tlast       : out std_logic                                             --

    );

end axi_sg_ftch_q_mngr;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_ftch_q_mngr is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- Determine the maximum word count for use in setting the word counter width
-- Set bit width on max num words to fetch
constant FETCH_COUNT            : integer := max2(C_SG_CH1_WORDS_TO_FETCH
                                                 ,C_SG_CH2_WORDS_TO_FETCH);
-- LOG2 to get width of counter
constant WORDS2FETCH_BITWIDTH   : integer := clog2(FETCH_COUNT);
-- Zero value for counter
constant WORD_ZERO              : std_logic_vector(WORDS2FETCH_BITWIDTH-1 downto 0)
                                    := (others => '0');
-- One value for counter
constant WORD_ONE               : std_logic_vector(WORDS2FETCH_BITWIDTH-1 downto 0)
                                    := std_logic_vector(to_unsigned(1,WORDS2FETCH_BITWIDTH));
-- Seven value for counter
constant WORD_SEVEN             : std_logic_vector(WORDS2FETCH_BITWIDTH-1 downto 0)
                                    := std_logic_vector(to_unsigned(7,WORDS2FETCH_BITWIDTH));

constant USE_LOGIC_FIFOS        : integer   := 0; -- Use Logic FIFOs
constant USE_BRAM_FIFOS         : integer   := 1; -- Use BRAM FIFOs


-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal m_axis_mm2s_tready_i     : std_logic := '0';
signal ch1_ftch_tready          : std_logic := '0';
signal ch2_ftch_tready          : std_logic := '0';

-- Misc Signals
signal writing_curdesc          : std_logic := '0';
signal fetch_word_count         : std_logic_vector
                                    (WORDS2FETCH_BITWIDTH-1 downto 0) := (others => '0');
signal msb_curdesc              : std_logic_vector(31 downto 0) := (others => '0');

signal lsbnxtdesc_tready        : std_logic := '0';
signal msbnxtdesc_tready        : std_logic := '0';
signal nxtdesc_tready           : std_logic := '0';

signal ch1_writing_curdesc      : std_logic := '0';
signal ch2_writing_curdesc      : std_logic := '0';


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

---------------------------------------------------------------------------
-- For 32-bit SG addresses then drive zero on msb
---------------------------------------------------------------------------
GEN_CURDESC_32 : if C_M_AXI_SG_ADDR_WIDTH = 32 generate
begin
    msb_curdesc <= (others => '0');
end generate  GEN_CURDESC_32;

---------------------------------------------------------------------------
-- For 64-bit SG addresses then capture upper order adder to msb
---------------------------------------------------------------------------
GEN_CURDESC_64 : if C_M_AXI_SG_ADDR_WIDTH = 64 generate
begin
    CAPTURE_CURADDR : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    msb_curdesc <= (others => '0');
                elsif(ftch_cmnd_wr = '1')then
                    msb_curdesc <= ftch_cmnd_data(DATAMOVER_CMD_ADDRMSB_BOFST
                                                    + C_M_AXI_SG_ADDR_WIDTH
                                                    downto DATAMOVER_CMD_ADDRMSB_BOFST
                                                    + DATAMOVER_CMD_ADDRLSB_BIT + 1);
                end if;
            end if;
        end process CAPTURE_CURADDR;
end generate  GEN_CURDESC_64;

-------------------------------------------------------------------------------
-- Fetch Stream Word Counter
-- The process is used to determine when to strip off NextDesc pointer from
-- stream and when to look at control word for complete bit set.
-------------------------------------------------------------------------------
REG_WORD_COUNTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            -- Clear on reset and on datamover command write
            if(m_axi_sg_aresetn = '0' or ftch_cmnd_wr = '1'
            or (m_axis_mm2s_tlast = '1' and m_axis_mm2s_tvalid = '1' and m_axis_mm2s_tready_i = '1'))then
                fetch_word_count <= (others => '0');
            -- If both tvalid=1 and tready = 1 then count
            elsif(m_axis_mm2s_tvalid = '1' and m_axis_mm2s_tready_i = '1')then
                fetch_word_count <= std_logic_vector(unsigned(fetch_word_count
                                        (WORDS2FETCH_BITWIDTH-1 downto 0)) + 1);
            end if;
        end if;
    end process REG_WORD_COUNTER;

---------------------------------------------------------------------------
-- Write lower order Next Descriptor Pointer out to pntr_mngr
---------------------------------------------------------------------------
REG_LSB_NXTPNTR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' )then
                nxtdesc(31 downto 0)    <= (others => '0');

            -- On valid and word count at 0 and channel active capture LSB next pointer
            elsif(m_axis_mm2s_tvalid = '1' and fetch_word_count = WORD_ZERO)then
                nxtdesc(31 downto 0)    <= m_axis_mm2s_tdata;

            end if;
        end if;
    end process REG_LSB_NXTPNTR;

lsbnxtdesc_tready <= '1' when m_axis_mm2s_tvalid = '1'
                          and fetch_word_count = WORD_ZERO
                    else '0';

---------------------------------------------------------------------------
-- 64 Bit Scatter Gather addresses enabled
---------------------------------------------------------------------------
GEN_UPPER_MSB_NXTDESC : if C_M_AXI_SG_ADDR_WIDTH = 64 generate
begin
    ---------------------------------------------------------------------------
    -- Write upper order Next Descriptor Pointer out to pntr_mngr
    ---------------------------------------------------------------------------
    REG_MSB_NXTPNTR : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' )then
                    nxtdesc(63 downto 32)   <= (others => '0');
                    ch1_nxtdesc_wren            <= '0';
                    ch2_nxtdesc_wren            <= '0';
                -- Capture upper pointer, drive ready to progress DataMover
                -- and also write nxtdesc out
                elsif(m_axis_mm2s_tvalid = '1' and fetch_word_count = WORD_ONE)then
                    nxtdesc(63 downto 32)   <= m_axis_mm2s_tdata;
                    ch1_nxtdesc_wren            <= ch1_ftch_active;
                    ch2_nxtdesc_wren            <= ch2_ftch_active;
                -- Assert tready/wren for only 1 clock
                else
                    ch1_nxtdesc_wren            <= '0';
                    ch2_nxtdesc_wren            <= '0';
                end if;
            end if;
        end process REG_MSB_NXTPNTR;

    msbnxtdesc_tready <= '1' when m_axis_mm2s_tvalid = '1'
                              and fetch_word_count = WORD_ONE
                        else '0';


end generate GEN_UPPER_MSB_NXTDESC;

---------------------------------------------------------------------------
-- 32 Bit Scatter Gather addresses enabled
---------------------------------------------------------------------------
GEN_NO_UPR_MSB_NXTDESC : if C_M_AXI_SG_ADDR_WIDTH = 32 generate
begin

    -----------------------------------------------------------------------
    -- No upper order therefore dump fetched word and write pntr lower next
    -- pointer to pntr mngr
    -----------------------------------------------------------------------
    REG_MSB_NXTPNTR : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' )then
                    ch1_nxtdesc_wren            <= '0';
                    ch2_nxtdesc_wren            <= '0';
                -- Throw away second word but drive ready to progress DataMover
                -- and also write nxtdesc out
                elsif(m_axis_mm2s_tvalid = '1' and fetch_word_count = WORD_ONE)then
                    ch1_nxtdesc_wren            <= ch1_ftch_active;
                    ch2_nxtdesc_wren            <= ch2_ftch_active;
                -- Assert for only 1 clock
                else
                    ch1_nxtdesc_wren            <= '0';
                    ch2_nxtdesc_wren            <= '0';
                end if;
            end if;
        end process REG_MSB_NXTPNTR;

    msbnxtdesc_tready <= '1' when m_axis_mm2s_tvalid = '1'
                              and fetch_word_count = WORD_ONE
                    else '0';


end generate GEN_NO_UPR_MSB_NXTDESC;

-- Drive ready to DataMover for ether lsb or msb capture
nxtdesc_tready  <= msbnxtdesc_tready or lsbnxtdesc_tready;

-- Generate logic for checking stale descriptor
GEN_STALE_DESC_CHECK : if C_SG_CH1_ENBL_STALE_ERROR = 1 or C_SG_CH2_ENBL_STALE_ERROR = 1 generate
begin

    ---------------------------------------------------------------------------
    -- Examine Completed BIT to determine if stale descriptor fetched
    ---------------------------------------------------------------------------
    CMPLTD_CHECK : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' )then
                    ftch_stale_desc <= '0';
                -- On valid and word count at 0 and channel active capture LSB next pointer
                elsif(m_axis_mm2s_tvalid = '1' and fetch_word_count = WORD_SEVEN
                and m_axis_mm2s_tready_i = '1'
                and m_axis_mm2s_tdata(DESC_STS_CMPLTD_BIT) = '1' )then
                    ftch_stale_desc <= '1';
                else
                    ftch_stale_desc <= '0';
                end if;
            end if;
        end process CMPLTD_CHECK;

end generate GEN_STALE_DESC_CHECK;

-- No needed logic for checking stale descriptor
GEN_NO_STALE_CHECK : if C_SG_CH1_ENBL_STALE_ERROR = 0 and C_SG_CH2_ENBL_STALE_ERROR = 0 generate
begin
    ftch_stale_desc <= '0';
end generate GEN_NO_STALE_CHECK;



-------------------------------------------------------------------------------
-- If channel 1 is included then generate ch1 logic
-------------------------------------------------------------------------------
GEN_CH1_FTCH_Q_IF : if C_INCLUDE_CH1 = 1 generate
begin
    ---------------------------------------------------------------------------
    -- SG Queueing therefore pass stream signals to
    -- FIFO
    ---------------------------------------------------------------------------
    GEN_CH1_QUEUE : if C_SG_FTCH_DESC2QUEUE /= 0 generate
    begin
        -- Instantiate the queue version
        FTCH_QUEUE_I : entity  axi_vdma_v6_3_10.axi_sg_ftch_queue
            generic map(
                C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH        ,
                C_M_AXIS_SG_TDATA_WIDTH     => C_M_AXIS_SG_TDATA_WIDTH      ,
                C_SG_FTCH_DESC2QUEUE        => C_SG_FTCH_DESC2QUEUE         ,
                C_SG_WORDS_TO_FETCH         => C_SG_CH1_WORDS_TO_FETCH      ,
                C_AXIS_IS_ASYNC             => C_AXIS_IS_ASYNC              ,
                C_FAMILY                    => C_FAMILY
            )
            port map(
                -----------------------------------------------------------------------
                -- AXI Scatter Gather Interface
                -----------------------------------------------------------------------
                m_axi_sg_aclk               => m_axi_sg_aclk                ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn             ,

                -- Channel Control
                desc_flush                  => ch1_desc_flush               ,
                ftch_active                 => ch1_ftch_active              ,
                ftch_queue_empty            => ch1_ftch_queue_empty         ,
                ftch_queue_full             => ch1_ftch_queue_full          ,
                ftch_pause                  => ch1_ftch_pause               ,

                writing_nxtdesc_in          => nxtdesc_tready               ,
                writing_curdesc_out         => ch1_writing_curdesc          ,

                -- DataMover Command
                ftch_cmnd_wr                => ftch_cmnd_wr                 ,
                ftch_cmnd_data              => ftch_cmnd_data               ,

                -- MM2S Stream In from DataMover
                m_axis_mm2s_tdata           => m_axis_mm2s_tdata            ,
                m_axis_mm2s_tlast           => m_axis_mm2s_tlast            ,
                m_axis_mm2s_tvalid          => m_axis_mm2s_tvalid           ,
                m_axis_mm2s_tready          => ch1_ftch_tready              ,

                -- Channel 1 AXI Fetch Stream Out
                m_axis_ftch_aclk            => m_axis_ch1_ftch_aclk         ,
                m_axis_ftch_tdata           => m_axis_ch1_ftch_tdata        ,
                m_axis_ftch_tvalid          => m_axis_ch1_ftch_tvalid       ,
                m_axis_ftch_tready          => m_axis_ch1_ftch_tready       ,
                m_axis_ftch_tlast           => m_axis_ch1_ftch_tlast
            );

    end generate GEN_CH1_QUEUE;

    -- No SG Queueing therefore pass stream signals straight
    -- out channel port
    GEN_NO_CH1_QUEUE : if C_SG_FTCH_DESC2QUEUE = 0 generate
    begin
        -- Instantiate the No queue version
        NO_FTCH_QUEUE_I : entity  axi_vdma_v6_3_10.axi_sg_ftch_noqueue
            generic map (
                C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH,
                C_M_AXIS_SG_TDATA_WIDTH     => C_M_AXIS_SG_TDATA_WIDTH
            )
            port map(
                -----------------------------------------------------------------------
                -- AXI Scatter Gather Interface
                -----------------------------------------------------------------------
                m_axi_sg_aclk               => m_axi_sg_aclk                ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn             ,

                -- Channel Control
                desc_flush                  => ch1_desc_flush               ,
                ftch_active                 => ch1_ftch_active              ,
                ftch_queue_empty            => ch1_ftch_queue_empty         ,
                ftch_queue_full             => ch1_ftch_queue_full          ,

                writing_nxtdesc_in          => nxtdesc_tready               ,
                writing_curdesc_out         => ch1_writing_curdesc          ,

                -- DataMover Command
                ftch_cmnd_wr                => ftch_cmnd_wr                 ,
                ftch_cmnd_data              => ftch_cmnd_data               ,

                -- MM2S Stream In from DataMover
                m_axis_mm2s_tdata           => m_axis_mm2s_tdata            ,
                m_axis_mm2s_tlast           => m_axis_mm2s_tlast            ,
                m_axis_mm2s_tvalid          => m_axis_mm2s_tvalid           ,
                m_axis_mm2s_tready          => ch1_ftch_tready              ,

                -- Channel 1 AXI Fetch Stream Out
                m_axis_ftch_tdata           => m_axis_ch1_ftch_tdata        ,
                m_axis_ftch_tvalid          => m_axis_ch1_ftch_tvalid       ,
                m_axis_ftch_tready          => m_axis_ch1_ftch_tready       ,
                m_axis_ftch_tlast           => m_axis_ch1_ftch_tlast
            );

        ch1_ftch_pause          <= '0';

    end generate GEN_NO_CH1_QUEUE;

end generate GEN_CH1_FTCH_Q_IF;


-------------------------------------------------------------------------------
-- Channel 1 excluded so tie outputs low
-------------------------------------------------------------------------------
GEN_NO_CH1_FTCH_Q_IF : if C_INCLUDE_CH1 = 0 generate
begin
    ch1_ftch_queue_empty    <= '0';
    ch1_ftch_queue_full     <= '0';
    ch1_ftch_pause          <= '0';
    ch1_writing_curdesc     <= '0';
    ch1_ftch_tready         <= '0';

    m_axis_ch1_ftch_tdata   <= (others => '0');
    m_axis_ch1_ftch_tlast   <= '0';
    m_axis_ch1_ftch_tvalid  <= '0';

end generate GEN_NO_CH1_FTCH_Q_IF;



-------------------------------------------------------------------------------
-- If channel 2 is included then generate ch1 logic
-------------------------------------------------------------------------------
GEN_CH2_FTCH_Q_IF : if C_INCLUDE_CH2 = 1 generate
begin
    ---------------------------------------------------------------------------
    -- SG Queueing therefore pass stream signals to
    -- FIFO
    ---------------------------------------------------------------------------
    GEN_CH2_QUEUE : if C_SG_FTCH_DESC2QUEUE /= 0 generate
    begin
        -- Instantiate the queue version
        FTCH_QUEUE_I : entity  axi_vdma_v6_3_10.axi_sg_ftch_queue
            generic map(
                C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH        ,
                C_M_AXIS_SG_TDATA_WIDTH     => C_M_AXIS_SG_TDATA_WIDTH      ,
                C_SG_FTCH_DESC2QUEUE        => C_SG_FTCH_DESC2QUEUE         ,
                C_SG_WORDS_TO_FETCH         => C_SG_CH2_WORDS_TO_FETCH      ,
                C_AXIS_IS_ASYNC             => C_AXIS_IS_ASYNC              ,
                C_FAMILY                    => C_FAMILY
            )
            port map(
                -----------------------------------------------------------------------
                -- AXI Scatter Gather Interface
                -----------------------------------------------------------------------
                m_axi_sg_aclk               => m_axi_sg_aclk                ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn             ,

                -- Channel Control
                desc_flush                  => ch2_desc_flush               ,
                ftch_active                 => ch2_ftch_active              ,
                ftch_queue_empty            => ch2_ftch_queue_empty         ,
                ftch_queue_full             => ch2_ftch_queue_full          ,
                ftch_pause                  => ch2_ftch_pause               ,

                writing_nxtdesc_in          => nxtdesc_tready               ,
                writing_curdesc_out         => ch2_writing_curdesc          ,

                -- DataMover Command
                ftch_cmnd_wr                => ftch_cmnd_wr                 ,
                ftch_cmnd_data              => ftch_cmnd_data               ,

                -- MM2S Stream In from DataMover
                m_axis_mm2s_tdata           => m_axis_mm2s_tdata            ,
                m_axis_mm2s_tlast           => m_axis_mm2s_tlast            ,
                m_axis_mm2s_tvalid          => m_axis_mm2s_tvalid           ,
                m_axis_mm2s_tready          => ch2_ftch_tready              ,

                -- Channel 1 AXI Fetch Stream Out
                m_axis_ftch_aclk            => m_axis_ch2_ftch_aclk         ,
                m_axis_ftch_tdata           => m_axis_ch2_ftch_tdata        ,
                m_axis_ftch_tvalid          => m_axis_ch2_ftch_tvalid       ,
                m_axis_ftch_tready          => m_axis_ch2_ftch_tready       ,
                m_axis_ftch_tlast           => m_axis_ch2_ftch_tlast
            );

    end generate GEN_CH2_QUEUE;

    -- No SG Queueing therefore pass stream signals straight
    -- out channel port
    GEN_NO_CH2_QUEUE : if C_SG_FTCH_DESC2QUEUE = 0 generate
    begin
        -- Instantiate the No queue version
        NO_FTCH_QUEUE_I : entity  axi_vdma_v6_3_10.axi_sg_ftch_noqueue
            generic map (
                C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH,
                C_M_AXIS_SG_TDATA_WIDTH     => C_M_AXIS_SG_TDATA_WIDTH
            )
            port map(
                -----------------------------------------------------------------------
                -- AXI Scatter Gather Interface
                -----------------------------------------------------------------------
                m_axi_sg_aclk               => m_axi_sg_aclk                ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn             ,

                -- Channel Control
                desc_flush                  => ch2_desc_flush               ,
                ftch_active                 => ch2_ftch_active              ,
                ftch_queue_empty            => ch2_ftch_queue_empty         ,
                ftch_queue_full             => ch2_ftch_queue_full          ,

                writing_nxtdesc_in          => nxtdesc_tready               ,
                writing_curdesc_out         => ch2_writing_curdesc          ,

                -- DataMover Command
                ftch_cmnd_wr                => ftch_cmnd_wr                 ,
                ftch_cmnd_data              => ftch_cmnd_data               ,

                -- MM2S Stream In from DataMover
                m_axis_mm2s_tdata           => m_axis_mm2s_tdata            ,
                m_axis_mm2s_tlast           => m_axis_mm2s_tlast            ,
                m_axis_mm2s_tvalid          => m_axis_mm2s_tvalid           ,
                m_axis_mm2s_tready          => ch2_ftch_tready              ,

                -- Channel 2 AXI Fetch Stream Out
                m_axis_ftch_tdata           => m_axis_ch2_ftch_tdata        ,
                m_axis_ftch_tvalid          => m_axis_ch2_ftch_tvalid       ,
                m_axis_ftch_tready          => m_axis_ch2_ftch_tready       ,
                m_axis_ftch_tlast           => m_axis_ch2_ftch_tlast
            );

            ch2_ftch_pause          <= '0';

    end generate GEN_NO_CH2_QUEUE;

end generate GEN_CH2_FTCH_Q_IF;


-------------------------------------------------------------------------------
-- Channel 2 excluded so tie outputs low
-------------------------------------------------------------------------------
GEN_NO_CH2_FTCH_Q_IF : if C_INCLUDE_CH2 = 0 generate
begin
    ch2_ftch_queue_empty    <= '0';
    ch2_ftch_queue_full     <= '0';
    ch2_ftch_pause          <= '0';
    ch2_writing_curdesc     <= '0';
    ch2_ftch_tready         <= '0';

    m_axis_ch2_ftch_tdata   <= (others => '0');
    m_axis_ch2_ftch_tlast   <= '0';
    m_axis_ch2_ftch_tvalid  <= '0';

end generate GEN_NO_CH2_FTCH_Q_IF;


-------------------------------------------------------------------------------
-- DataMover TREADY MUX
-------------------------------------------------------------------------------
writing_curdesc <= ch1_writing_curdesc or ch2_writing_curdesc or ftch_cmnd_wr;


TREADY_MUX : process(writing_curdesc,
                     fetch_word_count,
                     nxtdesc_tready,

                     -- channel 1 signals
                     ch1_ftch_active,
                     ch1_desc_flush,
                     ch1_ftch_tready,

                     -- channel 2 signals
                     ch2_ftch_active,
                     ch2_desc_flush,
                     ch2_ftch_tready)
    begin
        -- If commmanded to flush descriptor then assert ready
        -- to datamover until active de-asserts.  this allows
        -- any commanded fetches to complete.
        if( (ch1_desc_flush = '1' and ch1_ftch_active = '1')
          or(ch2_desc_flush = '1' and ch2_ftch_active = '1'))then
            m_axis_mm2s_tready_i <= '1';

        -- NOT ready if cmnd being written because
        -- curdesc gets written to queue
        elsif(writing_curdesc = '1')then
            m_axis_mm2s_tready_i <= '0';

        -- First two words drive ready from internal logic
        elsif(fetch_word_count = WORD_ZERO or fetch_word_count = WORD_ONE)then
            m_axis_mm2s_tready_i <= nxtdesc_tready;

        -- Remainder stream words drive ready from channel input
        else
            m_axis_mm2s_tready_i <= (ch1_ftch_active and ch1_ftch_tready)
                                 or (ch2_ftch_active and ch2_ftch_tready);
        end if;
    end process TREADY_MUX;

m_axis_mm2s_tready    <= m_axis_mm2s_tready_i;





end implementation;


-------------------------------------------------------------------------------
-- axi_sg_updt_cmdsts_if
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_sg_updt_cmdsts_if.vhd
-- Description: This entity is the descriptor update command and status inteface
--              for the Scatter Gather Engine AXI DataMover.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Rolled axi_sg library version to version v2_00_a
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;

-------------------------------------------------------------------------------
entity  axi_sg_updt_cmdsts_if is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64        := 32
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;                   --
        m_axi_sg_aresetn            : in  std_logic                         ;                   --
                                                                                                --
        -- Update command write interface from fetch sm                                         --
        updt_cmnd_wr                : in  std_logic                         ;                   --
        updt_cmnd_data              : in  std_logic_vector                                      --
                                        ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);    --
                                                                                                --
        -- User Command Interface Ports (AXI Stream)                                            --
        s_axis_updt_cmd_tvalid      : out std_logic                         ;                   --
        s_axis_updt_cmd_tready      : in  std_logic                         ;                   --
        s_axis_updt_cmd_tdata       : out std_logic_vector                                      --
                                        ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);    --
                                                                                                --
        -- User Status Interface Ports (AXI Stream)                                             --
        m_axis_updt_sts_tvalid      : in  std_logic                         ;                   --
        m_axis_updt_sts_tready      : out std_logic                         ;                   --
        m_axis_updt_sts_tdata       : in  std_logic_vector(7 downto 0)      ;                   --
        m_axis_updt_sts_tkeep       : in  std_logic_vector(0 downto 0)      ;                   --
                                                                                                --
        -- Scatter Gather Fetch Status                                                          --
        s2mm_err                    : in  std_logic                         ;                   --
        updt_done                   : out std_logic                         ;                   --
        updt_error                  : out std_logic                         ;                   --
        updt_interr                 : out std_logic                         ;                   --
        updt_slverr                 : out std_logic                         ;                   --
        updt_decerr                 : out std_logic                                             --
    );

end axi_sg_updt_cmdsts_if;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_updt_cmdsts_if is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal updt_slverr_i    : std_logic := '0';
signal updt_decerr_i    : std_logic := '0';
signal updt_interr_i    : std_logic := '0';
signal s2mm_error       : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

updt_slverr <= updt_slverr_i;
updt_decerr <= updt_decerr_i;
updt_interr <= updt_interr_i;


-------------------------------------------------------------------------------
-- DataMover Command Interface
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-- When command by fetch sm, drive descriptor update command to data mover.
-- Hold until data mover indicates ready.
-------------------------------------------------------------------------------
GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s_axis_updt_cmd_tvalid  <= '0';
                s_axis_updt_cmd_tdata   <= (others => '0');

            elsif(updt_cmnd_wr = '1')then
                s_axis_updt_cmd_tvalid  <= '1';
                s_axis_updt_cmd_tdata   <= updt_cmnd_data;

            elsif(s_axis_updt_cmd_tready = '1')then
                s_axis_updt_cmd_tvalid  <= '0';
                s_axis_updt_cmd_tdata   <= (others => '0');

            end if;
        end if;
    end process GEN_DATAMOVER_CMND;

-------------------------------------------------------------------------------
-- DataMover Status Interface
-------------------------------------------------------------------------------
-- Drive ready low during reset to indicate not ready
REG_STS_READY : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                m_axis_updt_sts_tready <= '0';
            else
                m_axis_updt_sts_tready <= '1';
            end if;
        end if;
    end process REG_STS_READY;

-------------------------------------------------------------------------------
-- Log status bits out of data mover.
-------------------------------------------------------------------------------
DATAMOVER_STS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                updt_slverr_i  <= '0';
                updt_decerr_i  <= '0';
                updt_interr_i  <= '0';
            -- Status valid, therefore capture status
            elsif(m_axis_updt_sts_tvalid = '1')then
                updt_slverr_i  <= m_axis_updt_sts_tdata(DATAMOVER_STS_SLVERR_BIT);
                updt_decerr_i  <= m_axis_updt_sts_tdata(DATAMOVER_STS_DECERR_BIT);
                updt_interr_i  <= m_axis_updt_sts_tdata(DATAMOVER_STS_INTERR_BIT);
            -- Only assert when valid
            else
                updt_slverr_i  <= '0';
                updt_decerr_i  <= '0';
                updt_interr_i  <= '0';
            end if;
        end if;
    end process DATAMOVER_STS;


-------------------------------------------------------------------------------
-- Transfer Done
-------------------------------------------------------------------------------
XFER_DONE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                updt_done      <= '0';
            -- Status valid, therefore capture status
            elsif(m_axis_updt_sts_tvalid = '1')then
                updt_done      <= m_axis_updt_sts_tdata(DATAMOVER_STS_CMDDONE_BIT)
                                  or  m_axis_updt_sts_tdata(DATAMOVER_STS_SLVERR_BIT)
                                  or  m_axis_updt_sts_tdata(DATAMOVER_STS_DECERR_BIT)
                                  or  m_axis_updt_sts_tdata(DATAMOVER_STS_INTERR_BIT);
            -- Only assert when valid
            else
                updt_done      <= '0';
            end if;
        end if;
    end process XFER_DONE;

-------------------------------------------------------------------------------
-- Register global error from data mover.
-------------------------------------------------------------------------------
s2mm_error <= updt_slverr_i or updt_decerr_i or updt_interr_i;

-- Log errors into a global error output
UPDATE_ERROR_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                updt_error <= '0';
            elsif(s2mm_error = '1')then
                updt_error <= '1';
            end if;
        end if;
    end process UPDATE_ERROR_PROCESS;

end implementation;


-------------------------------------------------------------------------------
-- axi_sg_updt_sm
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_sg_updt_sm.vhd
-- Description: This entity manages updating of descriptors.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Rolled axi_sg library version to version v2_00_a
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;


-------------------------------------------------------------------------------
entity  axi_sg_updt_sm is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_INCLUDE_CH1               : integer range 0 to 1      := 1;
            -- Include or Exclude channel 1 scatter gather engine
            -- 0 = Exclude Channel 1 SG Engine
            -- 1 = Include Channel 1 SG Engine

        C_INCLUDE_CH2               : integer range 0 to 1       := 1;
            -- Include or Exclude channel 2 scatter gather engine
            -- 0 = Exclude Channel 2 SG Engine
            -- 1 = Include Channel 2 SG Engine

        C_SG_CH1_WORDS_TO_UPDATE    : integer range 1 to 16     := 8;
            -- Number of words to fetch

        C_SG_CH1_FIRST_UPDATE_WORD  : integer range 0 to 15     := 0;
            -- Starting update word offset

        C_SG_CH2_WORDS_TO_UPDATE    : integer range 1 to 16     := 8;
            -- Number of words to fetch

        C_SG_CH2_FIRST_UPDATE_WORD  : integer range 0 to 15     := 0
            -- Starting update word offset

    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;                  --
        m_axi_sg_aresetn            : in  std_logic                         ;                  --
                                                                                               --
        ftch_error                  : in  std_logic                         ;                  --
                                                                                               --
        -- Channel 1 Control and Status                                                        --
        ch1_updt_queue_empty        : in  std_logic                         ;                  --
        ch1_updt_curdesc_wren       : in  std_logic                         ;                  --
        ch1_updt_curdesc            : in  std_logic_vector                                     --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                  --
        ch1_updt_ioc                : in  std_logic                         ;                  --
        ch1_dma_interr              : in  std_logic                         ;                  --
        ch1_dma_slverr              : in  std_logic                         ;                  --
        ch1_dma_decerr              : in  std_logic                         ;                  --
        ch1_updt_active             : out std_logic                         ;                  --
        ch1_updt_idle               : out std_logic                         ;                  --
        ch1_updt_interr_set         : out std_logic                         ;                  --
        ch1_updt_slverr_set         : out std_logic                         ;                  --
        ch1_updt_decerr_set         : out std_logic                         ;                  --
        ch1_dma_interr_set          : out std_logic                         ;                  --
        ch1_dma_slverr_set          : out std_logic                         ;                  --
        ch1_dma_decerr_set          : out std_logic                         ;                  --
        ch1_updt_ioc_irq_set        : out std_logic                         ;                  --
        ch1_updt_done               : out std_logic                         ;                  --
                                                                                               --
        -- Channel 2 Control and Status                                                        --
        ch2_updt_queue_empty        : in  std_logic                         ;                  --
        ch2_updt_curdesc_wren       : in  std_logic                         ;                  --
        ch2_updt_curdesc            : in  std_logic_vector                                     --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                  --
        ch2_updt_ioc                : in  std_logic                         ;                  --
        ch2_dma_interr              : in  std_logic                         ;                  --
        ch2_dma_slverr              : in  std_logic                         ;                  --
        ch2_dma_decerr              : in  std_logic                         ;                  --
        ch2_updt_active             : out std_logic                         ;                  --
        ch2_updt_idle               : out std_logic                         ;                  --
        ch2_updt_interr_set         : out std_logic                         ;                  --
        ch2_updt_slverr_set         : out std_logic                         ;                  --
        ch2_updt_decerr_set         : out std_logic                         ;                  --
        ch2_dma_interr_set          : out std_logic                         ;                  --
        ch2_dma_slverr_set          : out std_logic                         ;                  --
        ch2_dma_decerr_set          : out std_logic                         ;                  --
        ch2_updt_ioc_irq_set        : out std_logic                         ;                  --
        ch2_updt_done               : out std_logic                         ;                  --
                                                                                               --
        -- DataMover Command                                                                   --
        updt_cmnd_wr                : out std_logic                         ;                  --
        updt_cmnd_data              : out std_logic_vector                                     --
                                        ((C_M_AXI_SG_ADDR_WIDTH                                --
                                        +CMD_BASE_WIDTH)-1 downto 0)        ;                  --
        -- DataMover Status                                                                    --
        updt_done                   : in  std_logic                         ;                  --
        updt_error                  : in  std_logic                         ;                  --
        updt_interr                 : in  std_logic                         ;                  --
        updt_slverr                 : in  std_logic                         ;                  --
        updt_decerr                 : in  std_logic                         ;                  --
        updt_error_addr             : out std_logic_vector                                     --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)                     --
    );

end axi_sg_updt_sm;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_updt_sm is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- DataMover Commmand TAG
constant UPDATE_CMD_TAG      : std_logic_vector(3 downto 0)  := (others => '0');
-- DataMover Command Type
constant UPDATE_CMD_TYPE     : std_logic := '0';
-- DataMover Cmnd Reserved Bits
constant UPDATE_MSB_IGNORED  : std_logic_vector(7 downto 0)  := (others => '0');
-- DataMover Cmnd Reserved Bits
constant UPDATE_LSB_IGNORED  : std_logic_vector(15 downto 0) := (others => '0');
-- DataMover Cmnd Bytes to Xfer for Channel 1
constant UPDATE_CH1_CMD_BTT  : std_logic_vector(SG_BTT_WIDTH-1 downto 0)
                                := std_logic_vector(to_unsigned(
                                (C_SG_CH1_WORDS_TO_UPDATE*4),SG_BTT_WIDTH));
-- DataMover Cmnd Bytes to Xfer for Channel 2
constant UPDATE_CH2_CMD_BTT  : std_logic_vector(SG_BTT_WIDTH-1 downto 0)
                                := std_logic_vector(to_unsigned(
                                (C_SG_CH2_WORDS_TO_UPDATE*4),SG_BTT_WIDTH));
-- DataMover Cmnd Reserved Bits
constant UPDATE_CMD_RSVD     : std_logic_vector(
                                DATAMOVER_CMD_RSVMSB_BOFST + C_M_AXI_SG_ADDR_WIDTH downto
                                DATAMOVER_CMD_RSVLSB_BOFST + C_M_AXI_SG_ADDR_WIDTH)
                                := (others => '0');
-- DataMover Cmnd Address Offset for channel 1
constant UPDATE_CH1_ADDR_OFFSET  : integer := C_SG_CH1_FIRST_UPDATE_WORD*4;
-- DataMover Cmnd Address Offset for channel 2
constant UPDATE_CH2_ADDR_OFFSET  : integer := C_SG_CH2_FIRST_UPDATE_WORD*4;


-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
type SG_UPDATE_STATE_TYPE      is (
                                IDLE,
                                GET_UPDATE_PNTR,
                                UPDATE_DESCRIPTOR,
                                UPDATE_STATUS,
                                UPDATE_ERROR
                                );

signal updt_cs                  : SG_UPDATE_STATE_TYPE;
signal updt_ns                  : SG_UPDATE_STATE_TYPE;


-- State Machine Signals
signal ch1_active_set           : std_logic := '0';
signal ch2_active_set           : std_logic := '0';
signal write_cmnd_cmb           : std_logic := '0';
signal ch1_updt_sm_idle         : std_logic := '0';
signal ch2_updt_sm_idle         : std_logic := '0';

-- Misc Signals
signal ch1_active_i             : std_logic := '0';
signal service_ch1              : std_logic := '0';

signal ch2_active_i             : std_logic := '0';
signal service_ch2              : std_logic := '0';

signal update_address           : std_logic_vector
                                    (C_M_AXI_SG_ADDR_WIDTH-1 downto 0) := (others => '0');
signal update_cmd_btt           : std_logic_vector
                                    (SG_BTT_WIDTH-1 downto 0) := (others => '0');


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
ch1_updt_active  <= ch1_active_i;
ch2_updt_active  <= ch2_active_i;

-------------------------------------------------------------------------------
-- Scatter Gather Fetch State Machine
-------------------------------------------------------------------------------
SG_UPDT_MACHINE : process(updt_cs,
                            ch1_active_i,
                            ch2_active_i,
                            service_ch1,
                            service_ch2,
                            ch1_updt_curdesc_wren,
                            ch2_updt_curdesc_wren,
                            updt_error,
                            updt_done)

    begin
        -- Default signal assignment
        ch1_active_set          <= '0';
        ch2_active_set          <= '0';
        write_cmnd_cmb          <= '0';
        ch1_updt_sm_idle        <= '0';
        ch2_updt_sm_idle        <= '0';
        updt_ns                 <= updt_cs;

        case updt_cs is

            -------------------------------------------------------------------
            when IDLE =>
                ch1_updt_sm_idle       <= not service_ch1;
                ch2_updt_sm_idle       <= not service_ch2;
                -- error during update - therefore shut down
                if(updt_error = '1')then
                    updt_ns     <= UPDATE_ERROR;
                -- If channel 1 is running and not idle and queue is not full
                -- then fetch descriptor for channel 1
                elsif(service_ch1 = '1')then
                    ch1_active_set  <= '1';
                    updt_ns <= GET_UPDATE_PNTR;
                -- If channel 2 is running and not idle and queue is not full
                -- then fetch descriptor for channel 2
                elsif(service_ch2 = '1')then
                    ch2_active_set  <= '1';
                    updt_ns <= GET_UPDATE_PNTR;
                else
                    updt_ns <= IDLE;
                end if;

            when GET_UPDATE_PNTR =>
                if(ch1_updt_curdesc_wren = '1' or ch2_updt_curdesc_wren = '1')then
                    updt_ns <= UPDATE_DESCRIPTOR;
                else
                    updt_ns <= GET_UPDATE_PNTR;
                end if;

            -------------------------------------------------------------------
            when UPDATE_DESCRIPTOR =>
                -- error during update - therefore shut down
                if(updt_error = '1')then
                    updt_ns     <= UPDATE_ERROR;
                -- write command
                else
                    ch1_updt_sm_idle        <= not ch1_active_i and not service_ch1;
                    ch2_updt_sm_idle        <= not ch2_active_i and not service_ch2;
                    write_cmnd_cmb          <= '1';
                    updt_ns                 <= UPDATE_STATUS;
                end if;

            -------------------------------------------------------------------
            when UPDATE_STATUS =>
                ch1_updt_sm_idle        <= not ch1_active_i and not service_ch1;
                ch2_updt_sm_idle        <= not ch2_active_i and not service_ch2;
                -- error during update - therefore shut down
                if(updt_error = '1')then
                    updt_ns     <= UPDATE_ERROR;
                -- wait until done with update
                elsif(updt_done = '1')then

                    -- If just finished fethcing for channel 2 then...
                    if(ch2_active_i = '1')then
                        -- If ready, update descriptor for channel 1
                        if(service_ch1 = '1')then
                            ch1_active_set <= '1';
                            updt_ns <= GET_UPDATE_PNTR;
                        -- Otherwise return to IDLE
                        else
                            updt_ns <= IDLE;
                        end if;

                    -- If just finished fethcing for channel 1 then...
                    elsif(ch1_active_i = '1')then
                        -- If ready, update descriptor for channel 2
                        if(service_ch2 = '1')then
                            ch2_active_set <= '1';
                            updt_ns <= GET_UPDATE_PNTR;
                        -- Otherwise return to IDLE
                        else
                            updt_ns <= IDLE;
                        end if;
                    else
                        updt_ns <= IDLE;
                    end if;
                else
                    updt_ns <= UPDATE_STATUS;
                end if;

            -------------------------------------------------------------------
            when UPDATE_ERROR =>
                ch1_updt_sm_idle       <= '1';
                ch2_updt_sm_idle       <= '1';
                updt_ns <= UPDATE_ERROR;

            -------------------------------------------------------------------
            when others =>
                updt_ns <= IDLE;

        end case;
    end process SG_UPDT_MACHINE;

-------------------------------------------------------------------------------
-- Register states of state machine
-------------------------------------------------------------------------------
REGISTER_STATE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                updt_cs     <= IDLE;
            else
                updt_cs     <= updt_ns;
            end if;
        end if;
    end process REGISTER_STATE;


-------------------------------------------------------------------------------
-- Channel included therefore generate fetch logic
-------------------------------------------------------------------------------
GEN_CH1_UPDATE : if C_INCLUDE_CH1 = 1 generate
begin
    -------------------------------------------------------------------------------
    -- Active channel flag.  Indicates which channel is active.
    -- 0 = channel active
    -- 1 = channel active
    -------------------------------------------------------------------------------
    CH1_ACTIVE_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch1_active_i <= '0';

                elsif(ch1_active_i = '1' and updt_done = '1')then
                    ch1_active_i <= '0';

                elsif(ch1_active_set = '1')then
                    ch1_active_i <= '1';
                end if;
            end if;
        end process CH1_ACTIVE_PROCESS;

    -------------------------------------------------------------------------------
    -- Channel 1 ready to be serviced?
    -------------------------------------------------------------------------------
    service_ch1 <= '1' when ch1_updt_queue_empty = '0'  -- Queue not empty
                        and ftch_error = '0'            -- No SG Fetch Error
              else '0';


    -------------------------------------------------------------------------------
    -- Channel 1 Interrupt On Complete
    -------------------------------------------------------------------------------
    CH1_INTR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch1_updt_ioc_irq_set <= '0';
                -- Set interrupt on Done and Descriptor IOC set
                elsif(updt_done = '1' and ch1_updt_ioc = '1')then
                    ch1_updt_ioc_irq_set <= '1';
                else
                    ch1_updt_ioc_irq_set <= '0';
                end if;
            end if;
        end process CH1_INTR_PROCESS;

    -------------------------------------------------------------------------------
    -- Channel 1 DMA Internal Error
    -------------------------------------------------------------------------------
    CH1_INTERR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch1_dma_interr_set <= '0';
                -- Set internal error on desc updt Done and Internal Error
                elsif(updt_done = '1' and ch1_dma_interr = '1')then
                    ch1_dma_interr_set <= '1';
                end if;
            end if;
        end process CH1_INTERR_PROCESS;

    -------------------------------------------------------------------------------
    -- Channel 1 DMA Slave Error
    -------------------------------------------------------------------------------
    CH1_SLVERR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch1_dma_slverr_set <= '0';
                -- Set slave error on desc updt Done and Slave Error
                elsif(updt_done = '1' and ch1_dma_slverr = '1')then
                    ch1_dma_slverr_set <= '1';
                end if;
            end if;
        end process CH1_SLVERR_PROCESS;

    -------------------------------------------------------------------------------
    -- Channel 1 DMA Decode Error
    -------------------------------------------------------------------------------
    CH1_DECERR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch1_dma_decerr_set <= '0';
                -- Set decode error on desc updt Done and Decode Error
                elsif(updt_done = '1' and ch1_dma_decerr = '1')then
                    ch1_dma_decerr_set <= '1';
                end if;
            end if;
        end process CH1_DECERR_PROCESS;

    -------------------------------------------------------------------------------
    -- Log Fetch Errors
    -------------------------------------------------------------------------------
    -- Log Slave Errors reported during descriptor update
    SLV_SET_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch1_updt_slverr_set  <= '0';
                elsif(ch1_active_i = '1' and updt_slverr = '1')then
                    ch1_updt_slverr_set  <= '1';
                end if;
            end if;
        end process SLV_SET_PROCESS;

    -- Log Internal Errors reported during descriptor update
    INT_SET_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch1_updt_interr_set  <= '0';
                elsif(ch1_active_i = '1' and updt_interr = '1')then
                    ch1_updt_interr_set  <= '1';
                end if;
            end if;
        end process INT_SET_PROCESS;

    -- Log Decode Errors reported during descriptor update
    DEC_SET_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch1_updt_decerr_set  <= '0';
                elsif(ch1_active_i = '1' and updt_decerr = '1')then
                    ch1_updt_decerr_set  <= '1';
                end if;
            end if;
        end process DEC_SET_PROCESS;


    -- Indicate update is idle if state machine is idle and update queue is empty
    IDLE_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or updt_error = '1' or ftch_error = '1')then
                    ch1_updt_idle <= '1';


                elsif(service_ch1 = '1')then
                    ch1_updt_idle <= '0';

                elsif(service_ch1 = '0' and ch1_updt_sm_idle = '1')then

                    ch1_updt_idle <= '1';
                end if;
            end if;
        end process IDLE_PROCESS;

    ---------------------------------------------------------------------------
    -- Indicate update is done to allow fetch of next descriptor
    -- This is needed to prevent a partial descriptor being fetched
    -- and then axi read is throttled for extended periods until the
    -- remainder of the descriptor is fetched.
    --
    -- Note: Only used when fetch queue not inluded otherwise
    -- tools optimize out this process
    ---------------------------------------------------------------------------
    REG_CH1_DONE : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch1_updt_done <= '0';
                elsif(updt_done = '1' and ch1_active_i = '1')then
                    ch1_updt_done <= '1';
                else
                    ch1_updt_done <= '0';
                end if;
            end if;
        end process REG_CH1_DONE;

end generate GEN_CH1_UPDATE;

-------------------------------------------------------------------------------
-- Channel excluded therefore do not generate fetch logic
-------------------------------------------------------------------------------
GEN_NO_CH1_UPDATE : if C_INCLUDE_CH1 = 0 generate
begin
    service_ch1             <= '0';
    ch1_active_i            <= '0';
    ch1_updt_idle           <= '0';
    ch1_updt_interr_set     <= '0';
    ch1_updt_slverr_set     <= '0';
    ch1_updt_decerr_set     <= '0';
    ch1_dma_interr_set      <= '0';
    ch1_dma_slverr_set      <= '0';
    ch1_dma_decerr_set      <= '0';
    ch1_updt_ioc_irq_set    <= '0';
    ch1_updt_done           <= '0';
end generate GEN_NO_CH1_UPDATE;


-------------------------------------------------------------------------------
-- Channel included therefore generate fetch logic
-------------------------------------------------------------------------------
GEN_CH2_UPDATE : if C_INCLUDE_CH2 = 1 generate
begin

    -------------------------------------------------------------------------------
    -- Active channel flag.  Indicates which channel is active.
    -- 0 = channel active
    -- 1 = channel active
    -------------------------------------------------------------------------------
    CH2_ACTIVE_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch2_active_i <= '0';
                elsif(ch2_active_i = '1' and updt_done = '1')then
                    ch2_active_i <= '0';
                elsif(ch2_active_set = '1')then
                    ch2_active_i <= '1';
                end if;
            end if;
        end process CH2_ACTIVE_PROCESS;

    -------------------------------------------------------------------------------
    -- Channel 2 ready to be serviced?
    -------------------------------------------------------------------------------
    service_ch2 <= '1' when ch2_updt_queue_empty = '0'  -- Queue not empty
                        and ftch_error = '0'            -- No SG Fetch Error
              else '0';


    -------------------------------------------------------------------------------
    -- Channel 2 Interrupt On Complete
    -------------------------------------------------------------------------------
    CH2_INTR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch2_updt_ioc_irq_set <= '0';
                -- Set interrupt on Done and Descriptor IOC set
                elsif(updt_done = '1' and ch2_updt_ioc = '1')then
                    ch2_updt_ioc_irq_set <= '1';
                else
                    ch2_updt_ioc_irq_set <= '0';
                end if;
            end if;
        end process CH2_INTR_PROCESS;

    -------------------------------------------------------------------------------
    -- Channel 1 DMA Internal Error
    -------------------------------------------------------------------------------
    CH2_INTERR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch2_dma_interr_set <= '0';
                -- Set internal error on desc updt Done and Internal Error
                elsif(updt_done = '1' and ch2_dma_interr = '1')then
                    ch2_dma_interr_set <= '1';
                end if;
            end if;
        end process CH2_INTERR_PROCESS;

    -------------------------------------------------------------------------------
    -- Channel 1 DMA Slave Error
    -------------------------------------------------------------------------------
    CH2_SLVERR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch2_dma_slverr_set <= '0';
                -- Set slave error on desc updt Done and Slave Error
                elsif(updt_done = '1' and ch2_dma_slverr = '1')then
                    ch2_dma_slverr_set <= '1';
                end if;
            end if;
        end process CH2_SLVERR_PROCESS;

    -------------------------------------------------------------------------------
    -- Channel 1 DMA Decode Error
    -------------------------------------------------------------------------------
    CH2_DECERR_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch2_dma_decerr_set <= '0';
                -- Set decode error on desc updt Done and Decode Error
                elsif(updt_done = '1' and ch2_dma_decerr = '1')then
                    ch2_dma_decerr_set <= '1';
                end if;
            end if;
        end process CH2_DECERR_PROCESS;

    -------------------------------------------------------------------------------
    -- Log Fetch Errors
    -------------------------------------------------------------------------------
    -- Log Slave Errors reported during descriptor update
    SLV_SET_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch2_updt_slverr_set  <= '0';
                elsif(ch2_active_i = '1' and updt_slverr = '1')then
                    ch2_updt_slverr_set  <= '1';
                end if;
            end if;
        end process SLV_SET_PROCESS;

    -- Log Internal Errors reported during descriptor update
    INT_SET_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch2_updt_interr_set  <= '0';
                elsif(ch2_active_i = '1' and updt_interr = '1')then
                    ch2_updt_interr_set  <= '1';
                end if;
            end if;
        end process INT_SET_PROCESS;

    -- Log Decode Errors reported during descriptor update
    DEC_SET_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch2_updt_decerr_set  <= '0';
                elsif(ch2_active_i = '1' and updt_decerr = '1')then
                    ch2_updt_decerr_set  <= '1';
                end if;
            end if;
        end process DEC_SET_PROCESS;

    -- Indicate update is idle if state machine is idle and update queue is empty
    IDLE_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or updt_error = '1' or ftch_error = '1')then
                    ch2_updt_idle <= '1';

                elsif(service_ch2 = '1')then
                    ch2_updt_idle <= '0';

                elsif(service_ch2 = '0' and ch2_updt_sm_idle = '1')then

                    ch2_updt_idle <= '1';
                end if;
            end if;
        end process IDLE_PROCESS;

    ---------------------------------------------------------------------------
    -- Indicate update is done to allow fetch of next descriptor
    -- This is needed to prevent a partial descriptor being fetched
    -- and then axi read is throttled for extended periods until the
    -- remainder of the descriptor is fetched.
    --
    -- Note: Only used when fetch queue not inluded otherwise
    -- tools optimize out this process
    ---------------------------------------------------------------------------
    REG_CH2_DONE : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch2_updt_done <= '0';
                elsif(updt_done = '1' and ch2_active_i = '1')then
                    ch2_updt_done <= '1';
                else
                    ch2_updt_done <= '0';
                end if;
            end if;
        end process REG_CH2_DONE;


end generate GEN_CH2_UPDATE;

-------------------------------------------------------------------------------
-- Channel excluded therefore do not generate fetch logic
-------------------------------------------------------------------------------
GEN_NO_CH2_UPDATE : if C_INCLUDE_CH2 = 0 generate
begin
    service_ch2             <= '0';
    ch2_active_i            <= '0';
    ch2_updt_idle           <= '0';
    ch2_updt_interr_set     <= '0';
    ch2_updt_slverr_set     <= '0';
    ch2_updt_decerr_set     <= '0';
    ch2_dma_interr_set      <= '0';
    ch2_dma_slverr_set      <= '0';
    ch2_dma_decerr_set      <= '0';
    ch2_updt_ioc_irq_set    <= '0';
    ch2_updt_done           <= '0';
end generate GEN_NO_CH2_UPDATE;


---------------------------------------------------------------------------
-- Register Current Update Address.  Address captured from channel port
-- or queue by axi_sg_updt_queue
---------------------------------------------------------------------------
REG_UPDATE_ADDRESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                update_address   <= (others => '0');
            -- Channel 1 descriptor update pointer
            elsif(ch1_updt_curdesc_wren = '1')then
                update_address   <= std_logic_vector(unsigned(ch1_updt_curdesc)
                                        + UPDATE_CH1_ADDR_OFFSET);
            -- Channel 2 descriptor update pointer
            elsif(ch2_updt_curdesc_wren = '1')then
                update_address   <= std_logic_vector(unsigned(ch2_updt_curdesc)
                                        + UPDATE_CH2_ADDR_OFFSET);
            end if;
        end if;
    end process REG_UPDATE_ADDRESS;


-- Assigne Bytes to Transfer (BTT)
update_cmd_btt <= UPDATE_CH1_CMD_BTT when ch1_active_i = '1'
             else UPDATE_CH2_CMD_BTT;

-------------------------------------------------------------------------------
-- Build DataMover command
-------------------------------------------------------------------------------
-- When command by sm, drive command to updt_cmdsts_if
GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                updt_cmnd_wr    <= '0';
                updt_cmnd_data  <= (others => '0');

            -- Fetch SM issued a command write
            elsif(write_cmnd_cmb = '1')then
                updt_cmnd_wr    <= '1';
                updt_cmnd_data  <=  UPDATE_CMD_RSVD
                                    & UPDATE_CMD_TAG
                                    & update_address
                                    & UPDATE_MSB_IGNORED
                                    & UPDATE_CMD_TYPE
                                    & UPDATE_LSB_IGNORED
                                    & update_cmd_btt;
            else
                updt_cmnd_wr    <= '0';

            end if;
        end if;
    end process GEN_DATAMOVER_CMND;


-------------------------------------------------------------------------------
-- Capture and hold fetch address in case an error occurs
-------------------------------------------------------------------------------
LOG_ERROR_ADDR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
               updt_error_addr    <= (others => '0');
            elsif(write_cmnd_cmb = '1')then
                updt_error_addr    <= update_address(C_M_AXI_SG_ADDR_WIDTH-1 downto SG_ADDR_LSB) & "000000";
            end if;
        end if;
    end process LOG_ERROR_ADDR;



end implementation;


-------------------------------------------------------------------------------
-- axi_sg_updt_mngr
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_sg_updt_mngr.vhd
-- Description: This entity manages updating of descriptors.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Rolled axi_sg library version to version v2_00_a
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;


-------------------------------------------------------------------------------
entity  axi_sg_updt_mngr is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_INCLUDE_CH1           : integer range 0 to 1          := 1;
            -- Include or Exclude channel 1 scatter gather engine
            -- 0 = Exclude Channel 1 SG Engine
            -- 1 = Include Channel 1 SG Engine

        C_INCLUDE_CH2           : integer range 0 to 1          := 1;
            -- Include or Exclude channel 2 scatter gather engine
            -- 0 = Exclude Channel 2 SG Engine
            -- 1 = Include Channel 2 SG Engine

        C_SG_CH1_WORDS_TO_UPDATE    : integer range 1 to 16     := 8;
            -- Number of words to fetch for channel 1

        C_SG_CH1_FIRST_UPDATE_WORD     : integer range 0 to 15  := 0;
            -- Starting update word offset

        C_SG_CH2_WORDS_TO_UPDATE    : integer range 1 to 16     := 8;
            -- Number of words to fetch for channel 1

        C_SG_CH2_FIRST_UPDATE_WORD     : integer range 0 to 15  := 0
            -- Starting update word offset


    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;                   --
        m_axi_sg_aresetn            : in  std_logic                         ;                   --
                                                                                                --
                                                                                                --
        -- Channel 1 Control and Status                                                         --
        ch1_updt_queue_empty        : in  std_logic                         ;                   --
        ch1_updt_curdesc_wren       : in  std_logic                         ;                   --
        ch1_updt_curdesc            : in  std_logic_vector                                      --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --
        ch1_updt_ioc                : in  std_logic                         ;                   --
        ch1_updt_idle               : out std_logic                         ;                   --
        ch1_updt_active             : out std_logic                         ;                   --
        ch1_updt_ioc_irq_set        : out std_logic                         ;                   --
        ch1_updt_interr_set         : out std_logic                         ;                   --
        ch1_updt_slverr_set         : out std_logic                         ;                   --
        ch1_updt_decerr_set         : out std_logic                         ;                   --
        ch1_dma_interr              : in  std_logic                         ;                   --
        ch1_dma_slverr              : in  std_logic                         ;                   --
        ch1_dma_decerr              : in  std_logic                         ;                   --
        ch1_dma_interr_set          : out std_logic                         ;                   --
        ch1_dma_slverr_set          : out std_logic                         ;                   --
        ch1_dma_decerr_set          : out std_logic                         ;                   --
        ch1_updt_done               : out std_logic                         ;                   --
                                                                                                --
        -- Channel 2 Control and Status                                                         --
        ch2_updt_queue_empty        : in  std_logic                         ;                   --
        ch2_updt_curdesc_wren       : in  std_logic                         ;                   --
        ch2_updt_curdesc            : in  std_logic_vector                                      --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --
        ch2_updt_ioc                : in  std_logic                         ;                   --
        ch2_updt_idle               : out std_logic                         ;                   --
        ch2_updt_active             : out std_logic                         ;                   --
        ch2_updt_ioc_irq_set        : out std_logic                         ;                   --
        ch2_updt_interr_set         : out std_logic                         ;                   --
        ch2_updt_slverr_set         : out std_logic                         ;                   --
        ch2_updt_decerr_set         : out std_logic                         ;                   --
        ch2_dma_interr              : in  std_logic                         ;                   --
        ch2_dma_slverr              : in  std_logic                         ;                   --
        ch2_dma_decerr              : in  std_logic                         ;                   --
        ch2_dma_interr_set          : out std_logic                         ;                   --
        ch2_dma_slverr_set          : out std_logic                         ;                   --
        ch2_dma_decerr_set          : out std_logic                         ;                   --
        ch2_updt_done               : out std_logic                         ;                   --
                                                                                                --
        -- User Command Interface Ports (AXI Stream)                                            --
        s_axis_updt_cmd_tvalid      : out std_logic                         ;                   --
        s_axis_updt_cmd_tready      : in  std_logic                         ;                   --
        s_axis_updt_cmd_tdata       : out std_logic_vector                                      --
                                        ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);    --
                                                                                                --
        -- User Status Interface Ports (AXI Stream)                                             --
        m_axis_updt_sts_tvalid      : in  std_logic                         ;                   --
        m_axis_updt_sts_tready      : out std_logic                         ;                   --
        m_axis_updt_sts_tdata       : in  std_logic_vector(7 downto 0)      ;                   --
        m_axis_updt_sts_tkeep       : in  std_logic_vector(0 downto 0)      ;                   --
        s2mm_err                    : in  std_logic                         ;                   --
                                                                                                --
        ftch_error                  : in  std_logic                         ;                   --
        updt_error                  : out std_logic                         ;                   --
        updt_error_addr             : out std_logic_vector                                      --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)                      --

    );

end axi_sg_updt_mngr;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_updt_mngr is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal updt_cmnd_wr                 : std_logic := '0';
signal updt_cmnd_data               : std_logic_vector
                                        ((C_M_AXI_SG_ADDR_WIDTH
                                         +CMD_BASE_WIDTH)-1 downto 0)
                                        := (others => '0');

signal updt_done                    : std_logic := '0';
signal updt_error_i                 : std_logic := '0';
signal updt_interr                  : std_logic := '0';
signal updt_slverr                  : std_logic := '0';
signal updt_decerr                  : std_logic := '0';


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
updt_error      <= updt_error_i;


-------------------------------------------------------------------------------
--  Scatter Gather Fetch State Machine
-------------------------------------------------------------------------------
I_UPDT_SG : entity  axi_vdma_v6_3_10.axi_sg_updt_sm
    generic map(
        C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH                ,
        C_INCLUDE_CH1               => C_INCLUDE_CH1                        ,
        C_INCLUDE_CH2               => C_INCLUDE_CH2                        ,
        C_SG_CH1_WORDS_TO_UPDATE    => C_SG_CH1_WORDS_TO_UPDATE             ,
        C_SG_CH2_WORDS_TO_UPDATE    => C_SG_CH2_WORDS_TO_UPDATE             ,
        C_SG_CH1_FIRST_UPDATE_WORD  => C_SG_CH1_FIRST_UPDATE_WORD           ,
        C_SG_CH2_FIRST_UPDATE_WORD  => C_SG_CH2_FIRST_UPDATE_WORD
    )
    port map(
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               => m_axi_sg_aclk                        ,
        m_axi_sg_aresetn             => m_axi_sg_aresetn                      ,

        ftch_error                  => ftch_error                           ,

        -- Channel 1 Control and Status
        ch1_updt_queue_empty        => ch1_updt_queue_empty                 ,
        ch1_updt_active             => ch1_updt_active                      ,
        ch1_updt_idle               => ch1_updt_idle                        ,
        ch1_updt_ioc                => ch1_updt_ioc                         ,
        ch1_updt_ioc_irq_set        => ch1_updt_ioc_irq_set                 ,
        ch1_dma_interr              => ch1_dma_interr                       ,
        ch1_dma_slverr              => ch1_dma_slverr                       ,
        ch1_dma_decerr              => ch1_dma_decerr                       ,
        ch1_dma_interr_set          => ch1_dma_interr_set                   ,
        ch1_dma_slverr_set          => ch1_dma_slverr_set                   ,
        ch1_dma_decerr_set          => ch1_dma_decerr_set                   ,
        ch1_updt_interr_set         => ch1_updt_interr_set                  ,
        ch1_updt_slverr_set         => ch1_updt_slverr_set                  ,
        ch1_updt_decerr_set         => ch1_updt_decerr_set                  ,
        ch1_updt_curdesc_wren       => ch1_updt_curdesc_wren                ,
        ch1_updt_curdesc            => ch1_updt_curdesc                     ,
        ch1_updt_done               => ch1_updt_done                        ,

        -- Channel 2 Control and Status
        ch2_updt_queue_empty        => ch2_updt_queue_empty                 ,
        ch2_updt_active             => ch2_updt_active                      ,
        ch2_updt_idle               => ch2_updt_idle                        ,
        ch2_updt_ioc                => ch2_updt_ioc                         ,
        ch2_updt_ioc_irq_set        => ch2_updt_ioc_irq_set                 ,
        ch2_dma_interr              => ch2_dma_interr                       ,
        ch2_dma_slverr              => ch2_dma_slverr                       ,
        ch2_dma_decerr              => ch2_dma_decerr                       ,
        ch2_dma_interr_set          => ch2_dma_interr_set                   ,
        ch2_dma_slverr_set          => ch2_dma_slverr_set                   ,
        ch2_dma_decerr_set          => ch2_dma_decerr_set                   ,
        ch2_updt_interr_set         => ch2_updt_interr_set                  ,
        ch2_updt_slverr_set         => ch2_updt_slverr_set                  ,
        ch2_updt_decerr_set         => ch2_updt_decerr_set                  ,
        ch2_updt_curdesc_wren       => ch2_updt_curdesc_wren                ,
        ch2_updt_curdesc            => ch2_updt_curdesc                     ,
        ch2_updt_done               => ch2_updt_done                        ,

        -- DataMover Command
        updt_cmnd_wr                => updt_cmnd_wr                         ,
        updt_cmnd_data              => updt_cmnd_data                       ,

        -- DataMover Status
        updt_done                   => updt_done                            ,
        updt_error                  => updt_error_i                         ,
        updt_interr                 => updt_interr                          ,
        updt_slverr                 => updt_slverr                          ,
        updt_decerr                 => updt_decerr                          ,
        updt_error_addr             => updt_error_addr

    );


-------------------------------------------------------------------------------
--  Scatter Gather Fetch Command / Status Interface
-------------------------------------------------------------------------------
I_UPDT_CMDSTS_IF : entity  axi_vdma_v6_3_10.axi_sg_updt_cmdsts_if
    generic map(
        C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH
    )
    port map(
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               => m_axi_sg_aclk                        ,
        m_axi_sg_aresetn             => m_axi_sg_aresetn                      ,

        -- Fetch command write interface from fetch sm
        updt_cmnd_wr                => updt_cmnd_wr                         ,
        updt_cmnd_data              => updt_cmnd_data                       ,

        -- User Command Interface Ports (AXI Stream)
        s_axis_updt_cmd_tvalid      => s_axis_updt_cmd_tvalid               ,
        s_axis_updt_cmd_tready      => s_axis_updt_cmd_tready               ,
        s_axis_updt_cmd_tdata       => s_axis_updt_cmd_tdata                ,

        -- User Status Interface Ports (AXI Stream)
        m_axis_updt_sts_tvalid      => m_axis_updt_sts_tvalid               ,
        m_axis_updt_sts_tready      => m_axis_updt_sts_tready               ,
        m_axis_updt_sts_tdata       => m_axis_updt_sts_tdata                ,
        m_axis_updt_sts_tkeep       => m_axis_updt_sts_tkeep                ,

        -- Scatter Gather Fetch Status
        s2mm_err                    => s2mm_err                             ,

        updt_done                   => updt_done                            ,
        updt_error                  => updt_error_i                         ,
        updt_interr                 => updt_interr                          ,
        updt_slverr                 => updt_slverr                          ,
        updt_decerr                 => updt_decerr
    );




end implementation;


-------------------------------------------------------------------------------
-- axi_sg_ftchq_if
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_sg_updt_queue.vhd
-- Description: This entity is the descriptor fetch queue interface
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Seperated update queues into two seperate files, no queue and queue to
--  simplify maintainance.
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     11/15/10    v2_01_a
-- ^^^^^^

--  Converted all stream paraters ***_DATA_WIDTH to ***_TDATA_WIDTH
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;

library lib_pkg_v1_0_2;
library lib_fifo_v1_0_14;
use lib_fifo_v1_0_14.sync_fifo_fg;
use lib_pkg_v1_0_2.lib_pkg.all;

-------------------------------------------------------------------------------
entity  axi_sg_updt_queue is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64        := 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_M_AXIS_UPDT_DATA_WIDTH    : integer range 32 to 32        := 32;
            -- Master AXI Memory Map Data Width for Scatter Gather R/W Port

        C_S_AXIS_UPDPTR_TDATA_WIDTH  : integer range 32 to 32        := 32;
            -- 32 Update Status Bits

        C_S_AXIS_UPDSTS_TDATA_WIDTH  : integer range 33 to 33        := 33;
            -- 1 IOC bit + 32 Update Status Bits

        C_SG_UPDT_DESC2QUEUE        : integer range 0 to 8          := 0;
            -- Number of descriptors to fetch and queue for each channel.
            -- A value of zero excludes the fetch queues.

        C_SG_WORDS_TO_UPDATE        : integer range 1 to 16         := 8;
            -- Number of words to update

        C_AXIS_IS_ASYNC             : integer range 0 to 1          := 0;
            -- Channel 1 is async to sg_aclk
            -- 0 = Synchronous to SG ACLK
            -- 1 = Asynchronous to SG ACLK

        C_FAMILY                    : string            := "virtex6"
            -- Device family used for proper BRAM selection
    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;              --
        m_axi_sg_aresetn            : in  std_logic                         ;              --
        s_axis_updt_aclk            : in  std_logic                         ;              --
                                                                                           --
        --********************************--                                               --
        --** Control and Status         **--                                               --
        --********************************--                                               --
        updt_curdesc_wren           : out std_logic                         ;              --
        updt_curdesc                : out std_logic_vector                                 --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;              --
        updt_active                 : in  std_logic                         ;              --
        updt_queue_empty            : out std_logic                         ;              --
        updt_ioc                    : out std_logic                         ;              --
        updt_ioc_irq_set            : in  std_logic                         ;              --
                                                                                           --
        dma_interr                  : out std_logic                         ;              --
        dma_slverr                  : out std_logic                         ;              --
        dma_decerr                  : out std_logic                         ;              --
        dma_interr_set              : in  std_logic                         ;              --
        dma_slverr_set              : in  std_logic                         ;              --
        dma_decerr_set              : in  std_logic                         ;              --
                                                                                           --
        --********************************--                                               --
        --** Update Interfaces In       **--                                               --
        --********************************--                                               --
        -- Update Pointer Stream                                                           --
        s_axis_updtptr_tdata        : in  std_logic_vector                                 --
                                        (C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0);          --
        s_axis_updtptr_tvalid       : in  std_logic                         ;              --
        s_axis_updtptr_tready       : out std_logic                         ;              --
        s_axis_updtptr_tlast        : in  std_logic                         ;              --
                                                                                           --
        -- Update Status Stream                                                            --
        s_axis_updtsts_tdata        : in  std_logic_vector                                 --
                                        (C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0);           --
        s_axis_updtsts_tvalid       : in  std_logic                         ;              --
        s_axis_updtsts_tready       : out std_logic                         ;              --
        s_axis_updtsts_tlast        : in  std_logic                         ;              --
                                                                                           --
        --********************************--                                               --
        --** Update Interfaces Out      **--                                               --
        --********************************--                                               --
        -- S2MM Stream Out To DataMover                                                    --
        m_axis_updt_tdata           : out std_logic_vector                                 --
                                        (C_M_AXIS_UPDT_DATA_WIDTH-1 downto 0);             --
        m_axis_updt_tlast           : out std_logic                         ;              --
        m_axis_updt_tvalid          : out std_logic                         ;              --
        m_axis_updt_tready          : in  std_logic                                        --
    );

end axi_sg_updt_queue;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_updt_queue is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant USE_LOGIC_FIFOS            : integer   := 0; -- Use Logic FIFOs
constant USE_BRAM_FIFOS             : integer   := 1; -- Use BRAM FIFOs

-- Number of words deep fifo needs to be. Depth required to store 2 word
-- porters for each descriptor is C_SG_UPDT_DESC2QUEUE x 2
--constant UPDATE_QUEUE_DEPTH         : integer := max2(16,C_SG_UPDT_DESC2QUEUE * 2);
constant UPDATE_QUEUE_DEPTH         : integer := max2(16,pad_power2(C_SG_UPDT_DESC2QUEUE * 2));



-- Width of fifo rd and wr counts - only used for proper fifo operation
constant UPDATE_QUEUE_CNT_WIDTH     : integer   := clog2(UPDATE_QUEUE_DEPTH+1);

-- Select between BRAM or LOGIC memory type
constant UPD_Q_MEMORY_TYPE          : integer := bo2int(UPDATE_QUEUE_DEPTH > 16);

-- Number of words deep fifo needs to be. Depth required to store all update
-- words is C_SG_UPDT_DESC2QUEUE x C_SG_WORDS_TO_UPDATE
constant UPDATE_STS_QUEUE_DEPTH     : integer := max2(16,pad_power2(C_SG_UPDT_DESC2QUEUE
                                                    * C_SG_WORDS_TO_UPDATE));
-- Select between BRAM or LOGIC memory type
constant STS_Q_MEMORY_TYPE          : integer := bo2int(UPDATE_STS_QUEUE_DEPTH > 16);

-- Width of fifo rd and wr counts - only used for proper fifo operation
constant UPDATE_STS_QUEUE_CNT_WIDTH : integer := clog2(C_SG_UPDT_DESC2QUEUE+1);

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Channel signals
signal write_curdesc_lsb    : std_logic := '0';
signal write_curdesc_msb    : std_logic := '0';
signal updt_active_d1       : std_logic := '0';
signal updt_active_re       : std_logic := '0';


type PNTR_STATE_TYPE      is (IDLE,
                              READ_CURDESC_LSB,
                              READ_CURDESC_MSB,
                              WRITE_STATUS
                              );

signal pntr_cs              : PNTR_STATE_TYPE;
signal pntr_ns              : PNTR_STATE_TYPE;

-- State Machine Signal
signal writing_status       : std_logic := '0';
signal dataq_rden           : std_logic := '0';
signal stsq_rden            : std_logic := '0';

-- Pointer Queue FIFO Signals
signal ptr_queue_rden       : std_logic := '0';
signal ptr_queue_wren       : std_logic := '0';
signal ptr_queue_empty      : std_logic := '0';
signal ptr_queue_full       : std_logic := '0';
signal ptr_queue_din        : std_logic_vector
                                (C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0) := (others => '0');
signal ptr_queue_dout       : std_logic_vector
                                (C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0) := (others => '0');

-- Status Queue FIFO Signals
signal sts_queue_wren       : std_logic := '0';
signal sts_queue_rden       : std_logic := '0';
signal sts_queue_din        : std_logic_vector
                                (C_S_AXIS_UPDSTS_TDATA_WIDTH downto 0) := (others => '0');
signal sts_queue_dout       : std_logic_vector
                                (C_S_AXIS_UPDSTS_TDATA_WIDTH downto 0) := (others => '0');
signal sts_queue_full       : std_logic := '0';
signal sts_queue_empty      : std_logic := '0';

-- Misc Support Signals
signal writing_status_d1    : std_logic := '0';
signal writing_status_re    : std_logic := '0';
signal sinit                : std_logic := '0';
signal updt_tvalid          : std_logic := '0';
signal updt_tlast           : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
    -- Asset active strobe on rising edge of update active
    -- asertion.  This kicks off the update process for
    -- channel 1
    REG_ACTIVE : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' )then
                    updt_active_d1 <= '0';
                else
                    updt_active_d1 <= updt_active;
                end if;
            end if;
        end process REG_ACTIVE;

    updt_active_re  <= updt_active and not updt_active_d1;

    -- Current Descriptor Pointer Fetch.  This state machine controls
    -- reading out the current pointer from the Queue or channel port
    -- and writing it to the update manager for use in command
    -- generation to the DataMover for Descriptor update.
    CURDESC_PNTR_STATE : process(pntr_cs,
                                 updt_active_re,
                                 ptr_queue_empty,
                                 m_axis_updt_tready,
                                 updt_tvalid,
                                 updt_tlast)
        begin

            write_curdesc_lsb   <= '0';
            write_curdesc_msb   <= '0';
            writing_status      <= '0';
            dataq_rden          <= '0';
            stsq_rden           <= '0';
            pntr_ns             <= pntr_cs;

            case pntr_cs is

                when IDLE =>
                    if(updt_active_re = '1')then
                        pntr_ns <= READ_CURDESC_LSB;
                    else
                        pntr_ns <= IDLE;
                    end if;

                ---------------------------------------------------------------
                -- Get lower current descriptor pointer
                -- Reads one word from data queue fifo
                ---------------------------------------------------------------
                when READ_CURDESC_LSB =>
                    -- on tvalid from Queue or channel port then register
                    -- lsb curdesc and setup to register msb curdesc
                    if(ptr_queue_empty = '0')then
                        write_curdesc_lsb   <= '1';
                        dataq_rden          <= '1';
                        pntr_ns             <= READ_CURDESC_MSB;
                    else
                        pntr_ns <= READ_CURDESC_LSB;
                    end if;

                ---------------------------------------------------------------
                -- Get upper current descriptor
                -- Reads one word from data queue fifo
                ---------------------------------------------------------------
                when READ_CURDESC_MSB =>
                    -- On tvalid from Queue or channel port then register
                    -- msb.  This will also write curdesc out to update
                    -- manager.
                    if(ptr_queue_empty = '0')then
                        dataq_rden      <= '1';
                        write_curdesc_msb   <= '1';
                        pntr_ns         <= WRITE_STATUS;
                    else
                        pntr_ns         <= READ_CURDESC_MSB;
                    end if;

                ---------------------------------------------------------------
                -- Hold in this state until remainder of descriptor is
                -- written out.
                when WRITE_STATUS =>
                    -- De-MUX appropriage tvalid/tlast signals
                    writing_status <= '1';

                    -- Enable reading of Status Queue if datamover can
                    -- accept data
                    stsq_rden      <= m_axis_updt_tready;

                    -- Hold in the status state until tlast is pulled
                    -- from status fifo
                    if(updt_tvalid = '1' and m_axis_updt_tready = '1'
                    and updt_tlast = '1')then
                        pntr_ns     <= IDLE;
                    else
                        pntr_ns     <= WRITE_STATUS;
                    end if;

                when others =>
                    pntr_ns             <= IDLE;

            end case;
        end process CURDESC_PNTR_STATE;

    ---------------------------------------------------------------------------
    -- Register for CURDESC Pointer state machine
    ---------------------------------------------------------------------------
    REG_PNTR_STATES : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    pntr_cs <= IDLE;
                else
                    pntr_cs <= pntr_ns;
                end if;
            end if;
        end process REG_PNTR_STATES;

GEN_Q_FOR_SYNC : if C_AXIS_IS_ASYNC = 0 generate
begin
    -- Channel Pointer Queue (Generate Synchronous FIFO)
    I_UPDT_DATA_FIFO : entity lib_fifo_v1_0_14.sync_fifo_fg
    generic map (
        C_FAMILY                =>  C_FAMILY                    ,
        C_MEMORY_TYPE           =>  UPD_Q_MEMORY_TYPE           ,
        C_WRITE_DATA_WIDTH      =>  C_S_AXIS_UPDPTR_TDATA_WIDTH ,
        C_WRITE_DEPTH           =>  UPDATE_QUEUE_DEPTH          ,
        C_READ_DATA_WIDTH       =>  C_S_AXIS_UPDPTR_TDATA_WIDTH ,
        C_READ_DEPTH            =>  UPDATE_QUEUE_DEPTH          ,
        C_PORTS_DIFFER          =>  0,
        C_HAS_DCOUNT            =>  1, --req for proper fifo operation
        C_DCOUNT_WIDTH          =>  UPDATE_QUEUE_CNT_WIDTH,
        C_HAS_ALMOST_FULL       =>  0,
        C_HAS_RD_ACK            =>  0,
        C_HAS_RD_ERR            =>  0,
        C_HAS_WR_ACK            =>  0,
        C_HAS_WR_ERR            =>  0,
        C_RD_ACK_LOW            =>  0,
        C_RD_ERR_LOW            =>  0,
        C_WR_ACK_LOW            =>  0,
        C_WR_ERR_LOW            =>  0,
        C_PRELOAD_REGS          =>  1,-- 1 = first word fall through
        C_PRELOAD_LATENCY       =>  0 -- 0 = first word fall through
    )
    port map (

        Clk             =>  m_axi_sg_aclk           ,
        Sinit           =>  sinit                   ,
        Din             =>  ptr_queue_din           ,
        Wr_en           =>  ptr_queue_wren          ,
        Rd_en           =>  ptr_queue_rden          ,
        Dout            =>  ptr_queue_dout          ,
        Full            =>  ptr_queue_full          ,
        Empty           =>  ptr_queue_empty         ,
        Almost_full     =>  open                    ,
        Data_count      =>  open                    ,
        Rd_ack          =>  open                    ,
        Rd_err          =>  open                    ,
        Wr_ack          =>  open                    ,
        Wr_err          =>  open

    );

    -- Channel Status Queue (Generate Synchronous FIFO)
    I_UPDT_STS_FIFO : entity lib_fifo_v1_0_14.sync_fifo_fg
    generic map (
        C_FAMILY                =>  C_FAMILY                        ,
        C_MEMORY_TYPE           =>  STS_Q_MEMORY_TYPE               ,
        C_WRITE_DATA_WIDTH      =>  C_S_AXIS_UPDSTS_TDATA_WIDTH + 1 , --add 1 for tlast storage
        C_WRITE_DEPTH           =>  UPDATE_STS_QUEUE_DEPTH          ,
        C_READ_DATA_WIDTH       =>  C_S_AXIS_UPDSTS_TDATA_WIDTH + 1 , --add 1 for tlast storage
        C_READ_DEPTH            =>  UPDATE_STS_QUEUE_DEPTH          ,
        C_PORTS_DIFFER          =>  0                               ,
        C_HAS_DCOUNT            =>  1                               , --req for proper fifo operation
        C_DCOUNT_WIDTH          =>  UPDATE_STS_QUEUE_CNT_WIDTH      ,
        C_HAS_ALMOST_FULL       =>  0                               ,
        C_HAS_RD_ACK            =>  0                               ,
        C_HAS_RD_ERR            =>  0                               ,
        C_HAS_WR_ACK            =>  0                               ,
        C_HAS_WR_ERR            =>  0                               ,
        C_RD_ACK_LOW            =>  0                               ,
        C_RD_ERR_LOW            =>  0                               ,
        C_WR_ACK_LOW            =>  0                               ,
        C_WR_ERR_LOW            =>  0                               ,
        C_PRELOAD_REGS          =>  1                               ,-- 1 = first word fall through
        C_PRELOAD_LATENCY       =>  0                                -- 0 = first word fall through

    )
    port map (

        Clk             =>  m_axi_sg_aclk       ,
        Sinit           =>  sinit               ,
        Din             =>  sts_queue_din       ,
        Wr_en           =>  sts_queue_wren      ,
        Rd_en           =>  sts_queue_rden      ,
        Dout            =>  sts_queue_dout      ,
        Full            =>  sts_queue_full      ,
        Empty           =>  sts_queue_empty     ,
        Almost_full     =>  open                ,
        Data_count      =>  open                ,
        Rd_ack          =>  open                ,
        Rd_err          =>  open                ,
        Wr_ack          =>  open                ,
        Wr_err          =>  open

    );

end generate GEN_Q_FOR_SYNC;

GEN_Q_FOR_ASYNC : if C_AXIS_IS_ASYNC = 1 generate
begin


    -- Generate Asynchronous FIFO
    I_UPDT_DATA_FIFO : entity axi_vdma_v6_3_10.axi_sg_afifo_autord
      generic map(
         C_DWIDTH        => C_S_AXIS_UPDPTR_TDATA_WIDTH         ,
         C_DEPTH         => UPDATE_QUEUE_DEPTH                  ,
         C_CNT_WIDTH     => UPDATE_QUEUE_CNT_WIDTH              ,
         C_USE_BLKMEM    => UPD_Q_MEMORY_TYPE                   ,
         C_FAMILY        => C_FAMILY
        )
      port map(
        -- Inputs
         AFIFO_Ainit                => sinit                    ,
         AFIFO_Wr_clk               => m_axi_sg_aclk            ,
         AFIFO_Wr_en                => ptr_queue_wren           ,
         AFIFO_Din                  => ptr_queue_din            ,
         AFIFO_Rd_clk               => s_axis_updt_aclk         ,
         AFIFO_Rd_en                => ptr_queue_rden           ,
         AFIFO_Clr_Rd_Data_Valid    => '0'                      ,

        -- Outputs
         AFIFO_DValid               => open                     ,
         AFIFO_Dout                 => ptr_queue_dout           ,
         AFIFO_Full                 => ptr_queue_full           ,
         AFIFO_Empty                => ptr_queue_empty          ,
         AFIFO_Almost_full          => open                     ,
         AFIFO_Almost_empty         => open                     ,
         AFIFO_Wr_count             => open                     ,
         AFIFO_Rd_count             => open                     ,
         AFIFO_Corr_Rd_count        => open                     ,
         AFIFO_Corr_Rd_count_minus1 => open                     ,
         AFIFO_Rd_ack               => open
        );


    -- Generate Asynchronous FIFO
    I_UPDT_STS_FIFO : entity axi_vdma_v6_3_10.axi_sg_afifo_autord
      generic map(
         C_DWIDTH        => C_S_AXIS_UPDSTS_TDATA_WIDTH + 1     ,
         C_DEPTH         => UPDATE_STS_QUEUE_DEPTH              ,
         C_CNT_WIDTH     => UPDATE_STS_QUEUE_CNT_WIDTH          ,
         C_USE_BLKMEM    => STS_Q_MEMORY_TYPE                   ,
         C_FAMILY        => C_FAMILY
        )
      port map(
        -- Inputs
         AFIFO_Ainit                => sinit                    ,
         AFIFO_Wr_clk               => s_axis_updt_aclk         ,
         AFIFO_Wr_en                => sts_queue_wren           ,
         AFIFO_Din                  => sts_queue_din            ,
         AFIFO_Rd_clk               => m_axi_sg_aclk            ,
         AFIFO_Rd_en                => sts_queue_rden           ,
         AFIFO_Clr_Rd_Data_Valid    => '0'                      ,

        -- Outputs
         AFIFO_DValid               => open                     ,
         AFIFO_Dout                 => sts_queue_dout           ,
         AFIFO_Full                 => sts_queue_full           ,
         AFIFO_Empty                => sts_queue_empty          ,
         AFIFO_Almost_full          => open                     ,
         AFIFO_Almost_empty         => open                     ,
         AFIFO_Wr_count             => open                     ,
         AFIFO_Rd_count             => open                     ,
         AFIFO_Corr_Rd_count        => open                     ,
         AFIFO_Corr_Rd_count_minus1 => open                     ,
         AFIFO_Rd_ack               => open
        );


end generate GEN_Q_FOR_ASYNC;


    -- FIFO Reset is active high
    sinit   <= not m_axi_sg_aresetn;


    --*****************************************
    --** Channel Data Port Side of Queues
    --*****************************************

    -- Pointer Queue Update -  Descriptor Pointer (32bits)
    -- i.e. 2 current descriptor pointers and any app fields
    ptr_queue_din(C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0)   <= s_axis_updtptr_tdata(        -- DESC DATA
                                                                C_S_AXIS_UPDPTR_TDATA_WIDTH-1
                                                                downto 0);

    -- Data Queue Write Enable - based on tvalid and queue not full
    ptr_queue_wren    <=  s_axis_updtptr_tvalid    -- TValid
                          and not ptr_queue_full;      -- Data Queue NOT Full


    -- Drive channel port with ready if room in data queue
    s_axis_updtptr_tready <= not ptr_queue_full;


    --*****************************************
    --** Channel Status Port Side of Queues
    --*****************************************

    -- Status Queue Update - TLAST(1bit) & Includes IOC(1bit) & Descriptor Status(32bits)
    -- Note: Type field is stripped off
    sts_queue_din(C_S_AXIS_UPDSTS_TDATA_WIDTH)              <= s_axis_updtsts_tlast;        -- Store with tlast
    sts_queue_din(C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0)   <= s_axis_updtsts_tdata(        -- IOC & DESC STS
                                                                C_S_AXIS_UPDSTS_TDATA_WIDTH-1
                                                                downto 0);

    -- Status Queue Write Enable - based on tvalid and queue not full
    sts_queue_wren  <= s_axis_updtsts_tvalid
                          and not sts_queue_full;

    -- Drive channel port with ready if room in status queue
    s_axis_updtsts_tready <= not sts_queue_full;


    --*************************************
    --** SG Engine Side of Queues
    --*************************************
    -- Indicate NOT empty if both status queue and data queue are not empty
    updt_queue_empty    <= ptr_queue_empty
                            or sts_queue_empty;


    -- Data queue read enable
    ptr_queue_rden <= '1' when dataq_rden = '1'             -- Cur desc read enable
                               and ptr_queue_empty = '0'        -- Data Queue NOT empty
                 else '0';

    -- Status queue read enable
    sts_queue_rden <= '1' when stsq_rden = '1'          -- Writing desc status
                               and sts_queue_empty = '0'    -- Status fifo NOT empty
                     else '0';



    -----------------------------------------------------------------------
    -- TVALID - status queue not empty and writing status
    -----------------------------------------------------------------------
    updt_tvalid <= not sts_queue_empty
                       and writing_status;

    -----------------------------------------------------------------------
    -- TLAST - status queue not empty, writing status, and last asserted
    -----------------------------------------------------------------------
    -- Drive last as long as tvalid is asserted and last from fifo
    -- is asserted
    updt_tlast  <= not sts_queue_empty
                       and writing_status
                       and sts_queue_dout(C_S_AXIS_UPDSTS_TDATA_WIDTH);

    -----------------------------------------------------------------------
    -- TDATA - drive data to datamover from status queue
    -----------------------------------------------------------------------
    m_axis_updt_tdata  <= sts_queue_dout(C_S_AXIS_UPDSTS_TDATA_WIDTH-2 downto 0);
    m_axis_updt_tvalid <= updt_tvalid;
    m_axis_updt_tlast  <= updt_tlast;




--*********************************************************************
--** POINTER CAPTURE LOGIC
--*********************************************************************

    ---------------------------------------------------------------------------
    -- Write lower order Next Descriptor Pointer out to pntr_mngr
    ---------------------------------------------------------------------------
    REG_LSB_CURPNTR : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' )then
                    updt_curdesc(31 downto 0)    <= (others => '0');

                -- Capture lower pointer from FIFO or channel port
                elsif(write_curdesc_lsb = '1')then
                    updt_curdesc(31 downto 0)    <= ptr_queue_dout(C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0);

                end if;
            end if;
        end process REG_LSB_CURPNTR;

    ---------------------------------------------------------------------------
    -- 64 Bit Scatter Gather addresses enabled
    ---------------------------------------------------------------------------
    GEN_UPPER_MSB_CURDESC : if C_M_AXI_SG_ADDR_WIDTH = 64 generate
    begin
        ---------------------------------------------------------------------------
        -- Write upper order Next Descriptor Pointer out to pntr_mngr
        ---------------------------------------------------------------------------
        REG_MSB_CURPNTR : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' )then
                        updt_curdesc(63 downto 32)   <= (others => '0');
                        updt_curdesc_wren            <= '0';
                    -- Capture upper pointer from FIFO or channel port
                    -- and also write curdesc out
                    elsif(write_curdesc_msb = '1')then
                        updt_curdesc(63 downto 32)   <= ptr_queue_dout(C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0);
                        updt_curdesc_wren            <= '1';
                    -- Assert tready/wren for only 1 clock
                    else
                        updt_curdesc_wren            <= '0';
                    end if;
                end if;
            end process REG_MSB_CURPNTR;

    end generate GEN_UPPER_MSB_CURDESC;

    ---------------------------------------------------------------------------
    -- 32 Bit Scatter Gather addresses enabled
    ---------------------------------------------------------------------------
    GEN_NO_UPR_MSB_CURDESC : if C_M_AXI_SG_ADDR_WIDTH = 32 generate
    begin

        -----------------------------------------------------------------------
        -- No upper order therefore dump fetched word and write pntr lower next
        -- pointer to pntr mngr
        -----------------------------------------------------------------------
        REG_MSB_CURPNTR : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' )then
                        updt_curdesc_wren            <= '0';
                    -- Throw away second word, only write curdesc out with msb
                    -- set to zero
                    elsif(write_curdesc_msb = '1')then
                        updt_curdesc_wren            <= '1';
                    -- Assert for only 1 clock
                    else
                        updt_curdesc_wren            <= '0';
                    end if;
                end if;
            end process REG_MSB_CURPNTR;

    end generate GEN_NO_UPR_MSB_CURDESC;




--*********************************************************************
--** ERROR CAPTURE LOGIC
--*********************************************************************

    -----------------------------------------------------------------------
    -- Generate rising edge pulse on writing status signal.  This will
    -- assert at the beginning of the status write.  Coupled with status
    -- fifo set to first word fall through status will be on dout
    -- regardless of target ready.
    -----------------------------------------------------------------------
    REG_WRITE_STATUS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    writing_status_d1 <= '0';
                else
                    writing_status_d1 <= writing_status;
                end if;
            end if;
        end process REG_WRITE_STATUS;

    writing_status_re <= writing_status and not writing_status_d1;

    -----------------------------------------------------------------------
    -- Caputure IOC begin set
    -----------------------------------------------------------------------
    REG_IOC_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or updt_ioc_irq_set = '1')then
                    updt_ioc <= '0';
                elsif(writing_status_re = '1')then
                    updt_ioc <= sts_queue_dout(DESC_IOC_TAG_BIT);
                end if;
            end if;
        end process REG_IOC_PROCESS;

    -----------------------------------------------------------------------
    -- Capture DMA Internal Errors
    -----------------------------------------------------------------------
    CAPTURE_DMAINT_ERROR: process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or dma_interr_set = '1')then
                    dma_interr  <= '0';
                elsif(writing_status_re = '1')then
                    dma_interr <=  sts_queue_dout(DESC_STS_INTERR_BIT);
                end if;
            end if;
        end process CAPTURE_DMAINT_ERROR;

    -----------------------------------------------------------------------
    -- Capture DMA Slave Errors
    -----------------------------------------------------------------------
    CAPTURE_DMASLV_ERROR: process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or dma_slverr_set = '1')then
                    dma_slverr  <= '0';
                elsif(writing_status_re = '1')then
                    dma_slverr <=  sts_queue_dout(DESC_STS_SLVERR_BIT);
                end if;
            end if;
        end process CAPTURE_DMASLV_ERROR;

    -----------------------------------------------------------------------
    -- Capture DMA Decode Errors
    -----------------------------------------------------------------------
    CAPTURE_DMADEC_ERROR: process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or dma_decerr_set = '1')then
                    dma_decerr  <= '0';
                elsif(writing_status_re = '1')then
                    dma_decerr <=  sts_queue_dout(DESC_STS_DECERR_BIT);
                end if;
            end if;
        end process CAPTURE_DMADEC_ERROR;

end implementation;


-------------------------------------------------------------------------------
-- axi_sg_updt_noqueue
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_sg_updt_noqueue.vhd
-- Description: This entity provides the descriptor update for the No Queue mode
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Seperated update queues into two seperate files, no queue and queue to
--  simplify maintainance.
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     11/15/10    v2_01_a
-- ^^^^^^

--  Converted all stream paraters ***_DATA_WIDTH to ***_TDATA_WIDTH
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;

library lib_pkg_v1_0_2;
library lib_fifo_v1_0_14;
use lib_fifo_v1_0_14.sync_fifo_fg;
use lib_pkg_v1_0_2.lib_pkg.all;

-------------------------------------------------------------------------------
entity  axi_sg_updt_noqueue is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64        := 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_M_AXIS_UPDT_DATA_WIDTH    : integer range 32 to 32        := 32;
            -- Master AXI Memory Map Data Width for Scatter Gather R/W Port

        C_S_AXIS_UPDPTR_TDATA_WIDTH : integer range 32 to 32         := 32;
            -- 32 Update Status Bits

        C_S_AXIS_UPDSTS_TDATA_WIDTH : integer range 33 to 33         := 33
            -- 1 IOC bit + 32 Update Status Bits
    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk           : in  std_logic                         ;               --
        m_axi_sg_aresetn        : in  std_logic                         ;               --
                                                                                        --
        -- Channel 1 Control                                                            --
        updt_curdesc_wren       : out std_logic                         ;               --
        updt_curdesc            : out std_logic_vector                                  --
                                    (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;               --
        updt_active             : in  std_logic                         ;               --
        updt_queue_empty        : out std_logic                         ;               --
        updt_ioc                : out std_logic                         ;               --
        updt_ioc_irq_set        : in  std_logic                         ;               --
                                                                                        --
        dma_interr              : out std_logic                         ;               --
        dma_slverr              : out std_logic                         ;               --
        dma_decerr              : out std_logic                         ;               --
        dma_interr_set          : in  std_logic                         ;               --
        dma_slverr_set          : in  std_logic                         ;               --
        dma_decerr_set          : in  std_logic                         ;               --
                                                                                        --
        --*********************************--                                           --
        --** Channel Update Interface In **--                                           --
        --*********************************--                                           --
        -- Update Pointer Stream                                                        --
        s_axis_updtptr_tdata    : in  std_logic_vector                                  --
                                    (C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0) ;          --
        s_axis_updtptr_tvalid   : in  std_logic                         ;               --
        s_axis_updtptr_tready   : out std_logic                         ;               --
        s_axis_updtptr_tlast    : in  std_logic                         ;               --
                                                                                        --
        -- Update Status Stream                                                         --
        s_axis_updtsts_tdata    : in  std_logic_vector                                  --
                                     (C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0);          --
        s_axis_updtsts_tvalid   : in  std_logic                         ;               --
        s_axis_updtsts_tready   : out std_logic                         ;               --
        s_axis_updtsts_tlast    : in  std_logic                         ;               --
                                                                                        --
        --*********************************--                                           --
        --** Channel Update Interface Out**--                                           --
        --*********************************--                                           --
        -- S2MM Stream Out To DataMover                                                 --
        m_axis_updt_tdata       : out std_logic_vector                                  --
                                    (C_M_AXIS_UPDT_DATA_WIDTH-1 downto 0);              --
        m_axis_updt_tlast       : out std_logic                         ;               --
        m_axis_updt_tvalid      : out std_logic                         ;               --
        m_axis_updt_tready      : in  std_logic                                         --

    );

end axi_sg_updt_noqueue;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_updt_noqueue is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Contstants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Channel signals
signal writing_curdesc      : std_logic := '0';


signal write_curdesc_lsb    : std_logic := '0';
signal write_curdesc_msb    : std_logic := '0';
signal updt_active_d1       : std_logic := '0';
signal updt_active_re       : std_logic := '0';


type PNTR_STATE_TYPE      is (IDLE,
                              READ_CURDESC_LSB,
                              READ_CURDESC_MSB,
                              WRITE_STATUS
                              );

signal pntr_cs              : PNTR_STATE_TYPE;
signal pntr_ns              : PNTR_STATE_TYPE;

signal writing_status       : std_logic := '0';
signal curdesc_tready       : std_logic := '0';
signal writing_status_d1    : std_logic := '0';
signal writing_status_re    : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin


    -- Asset active strobe on rising edge of update active
    -- asertion.  This kicks off the update process for
    -- the channel
    REG_ACTIVE : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    updt_active_d1 <= '0';
                else
                    updt_active_d1 <= updt_active;
                end if;
            end if;
        end process REG_ACTIVE;

    updt_active_re  <= updt_active and not updt_active_d1;


    -- Current Descriptor Pointer Fetch.  This state machine controls
    -- reading out the current pointer from the Queue or channel port
    -- and writing it to the update manager for use in command
    -- generation to the DataMover for Descriptor update.
    CURDESC_PNTR_STATE : process(pntr_cs,
                                 updt_active,
                                 s_axis_updtptr_tvalid,
                                 s_axis_updtsts_tvalid,
                                 s_axis_updtsts_tlast,
                                 m_axis_updt_tready)
        begin

            write_curdesc_lsb   <= '0';
            write_curdesc_msb   <= '0';
            writing_status      <= '0';
            writing_curdesc     <= '0';
            curdesc_tready      <= '0';
            pntr_ns             <= pntr_cs;

            case pntr_cs is

                when IDLE =>
                    if(s_axis_updtptr_tvalid = '1' and updt_active = '1')then
                        writing_curdesc <= '1';
                        pntr_ns <= READ_CURDESC_LSB;
                    else
                        pntr_ns <= IDLE;
                    end if;

                ---------------------------------------------------------------
                -- Get lower current descriptor
                when READ_CURDESC_LSB =>
                    curdesc_tready  <= '1';
                    writing_curdesc <= '1';
                    -- on tvalid from Queue or channel port then register
                    -- lsb curdesc and setup to register msb curdesc
                    if(s_axis_updtptr_tvalid = '1' and updt_active = '1')then
                        write_curdesc_lsb   <= '1';
                        pntr_ns             <= READ_CURDESC_MSB;
                    else
                        pntr_ns <= READ_CURDESC_LSB;
                    end if;

                ---------------------------------------------------------------
                -- Get upper current descriptor
                when READ_CURDESC_MSB =>
                    curdesc_tready  <= '1';
                    writing_curdesc <= '1';
                    -- On tvalid from Queue or channel port then register
                    -- msb.  This will also write curdesc out to update
                    -- manager.
                    if(s_axis_updtptr_tvalid = '1')then
                        write_curdesc_msb   <= '1';
                        pntr_ns             <= WRITE_STATUS;
                    else
                        pntr_ns             <= READ_CURDESC_MSB;
                    end if;

                ---------------------------------------------------------------
                -- Hold in this state until remainder of descriptor is
                -- written out.
                when WRITE_STATUS =>
                    writing_status <= s_axis_updtsts_tvalid;
                    if(s_axis_updtsts_tvalid = '1' and m_axis_updt_tready = '1'
                    and s_axis_updtsts_tlast = '1')then
                        pntr_ns        <= IDLE;
                    else
                        pntr_ns         <= WRITE_STATUS;
                    end if;

                when others =>
                    pntr_ns             <= IDLE;

            end case;
        end process CURDESC_PNTR_STATE;

    ---------------------------------------------------------------------------
    -- Register for CURDESC Pointer state machine
    ---------------------------------------------------------------------------
    REG_PNTR_STATES : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    pntr_cs <= IDLE;
                else
                    pntr_cs <= pntr_ns;
                end if;
            end if;
        end process REG_PNTR_STATES;

    -- Status stream signals
    m_axis_updt_tdata              <= s_axis_updtsts_tdata(C_S_AXIS_UPDSTS_TDATA_WIDTH-2 downto 0);
    m_axis_updt_tvalid             <= s_axis_updtsts_tvalid and writing_status;
    m_axis_updt_tlast              <= s_axis_updtsts_tlast and writing_status;

    s_axis_updtsts_tready   <= m_axis_updt_tready and writing_status;

    -- Pointer stream signals
    s_axis_updtptr_tready   <= curdesc_tready;

    -- Indicate need for channel service for update state machine
    updt_queue_empty    <= not s_axis_updtsts_tvalid;




--*********************************************************************
--** POINTER CAPTURE LOGIC
--*********************************************************************

    ---------------------------------------------------------------------------
    -- Write lower order Next Descriptor Pointer out to pntr_mngr
    ---------------------------------------------------------------------------
    REG_LSB_CURPNTR : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' )then
                    updt_curdesc(31 downto 0)    <= (others => '0');

                -- Capture lower pointer from FIFO or channel port
                elsif(write_curdesc_lsb = '1')then
                    updt_curdesc(31 downto 0)    <= s_axis_updtptr_tdata(C_S_AXIS_UPDPTR_TDATA_WIDTH - 1 downto 0);

                end if;
            end if;
        end process REG_LSB_CURPNTR;

    ---------------------------------------------------------------------------
    -- 64 Bit Scatter Gather addresses enabled
    ---------------------------------------------------------------------------
    GEN_UPPER_MSB_CURDESC : if C_M_AXI_SG_ADDR_WIDTH = 64 generate
    begin
        ---------------------------------------------------------------------------
        -- Write upper order Next Descriptor Pointer out to pntr_mngr
        ---------------------------------------------------------------------------
        REG_MSB_CURPNTR : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' )then
                        updt_curdesc(63 downto 32)   <= (others => '0');
                        updt_curdesc_wren            <= '0';
                    -- Capture upper pointer from FIFO or channel port
                    -- and also write curdesc out
                    elsif(write_curdesc_msb = '1')then
                        updt_curdesc(63 downto 32)   <= s_axis_updtptr_tdata(C_S_AXIS_UPDPTR_TDATA_WIDTH - 1 downto 0);
                        updt_curdesc_wren            <= '1';
                    -- Assert tready/wren for only 1 clock
                    else
                        updt_curdesc_wren            <= '0';
                    end if;
                end if;
            end process REG_MSB_CURPNTR;

    end generate GEN_UPPER_MSB_CURDESC;

    ---------------------------------------------------------------------------
    -- 32 Bit Scatter Gather addresses enabled
    ---------------------------------------------------------------------------
    GEN_NO_UPR_MSB_CURDESC : if C_M_AXI_SG_ADDR_WIDTH = 32 generate
    begin

        -----------------------------------------------------------------------
        -- No upper order therefore dump fetched word and write pntr lower next
        -- pointer to pntr mngr
        -----------------------------------------------------------------------
        REG_MSB_CURPNTR : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' )then
                        updt_curdesc_wren            <= '0';
                    -- Throw away second word, only write curdesc out with msb
                    -- set to zero
                    elsif(write_curdesc_msb = '1')then
                        updt_curdesc_wren            <= '1';
                    -- Assert for only 1 clock
                    else
                        updt_curdesc_wren            <= '0';
                    end if;
                end if;
            end process REG_MSB_CURPNTR;

    end generate GEN_NO_UPR_MSB_CURDESC;




--*********************************************************************
--** ERROR CAPTURE LOGIC
--*********************************************************************
    -----------------------------------------------------------------------
    -- Generate rising edge pulse on writing status signal.  This will
    -- assert at the beginning of the status write.  Coupled with status
    -- fifo set to first word fall through status will be on dout
    -- regardless of target ready.
    -----------------------------------------------------------------------
    REG_WRITE_STATUS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    writing_status_d1 <= '0';
                else
                    writing_status_d1 <= writing_status;
                end if;
            end if;
        end process REG_WRITE_STATUS;

    writing_status_re <= writing_status and not writing_status_d1;

    ---------------------------------------------------------------------------
    -- Caputure IOC begin set
    ---------------------------------------------------------------------------
    REG_IOC_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or updt_ioc_irq_set = '1')then
                    updt_ioc <= '0';
                elsif(writing_status_re = '1')then
                    updt_ioc <= s_axis_updtsts_tdata(DESC_IOC_TAG_BIT);
                end if;
            end if;
        end process REG_IOC_PROCESS;

    -----------------------------------------------------------------------
    -- Capture DMA Internal Errors
    -----------------------------------------------------------------------
    CAPTURE_DMAINT_ERROR: process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or dma_interr_set = '1')then
                    dma_interr  <= '0';
                elsif(writing_status_re = '1')then
                    dma_interr <=  s_axis_updtsts_tdata(DESC_STS_INTERR_BIT);
                end if;
            end if;
        end process CAPTURE_DMAINT_ERROR;

    -----------------------------------------------------------------------
    -- Capture DMA Slave Errors
    -----------------------------------------------------------------------
    CAPTURE_DMASLV_ERROR: process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or dma_slverr_set = '1')then
                    dma_slverr  <= '0';
                elsif(writing_status_re = '1')then
                    dma_slverr <=  s_axis_updtsts_tdata(DESC_STS_SLVERR_BIT);
                end if;
            end if;
        end process CAPTURE_DMASLV_ERROR;

    -----------------------------------------------------------------------
    -- Capture DMA Decode Errors
    -----------------------------------------------------------------------
    CAPTURE_DMADEC_ERROR: process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or dma_decerr_set = '1')then
                    dma_decerr  <= '0';
                elsif(writing_status_re = '1')then
                    dma_decerr <=  s_axis_updtsts_tdata(DESC_STS_DECERR_BIT);
                end if;
            end if;
        end process CAPTURE_DMADEC_ERROR;

end implementation;


-------------------------------------------------------------------------------
-- axi_sg_updt_q_mngr
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_sg_updt_q_mngr.vhd
-- Description: This entity is the descriptor update queue manager
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Created top level for descriptor update queue management
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     11/15/10    v2_01_a
-- ^^^^^^
--  CR582800
--  Converted all stream paraters ***_DATA_WIDTH to ***_TDATA_WIDTH
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;

library lib_pkg_v1_0_2;
library lib_fifo_v1_0_14;
use lib_fifo_v1_0_14.sync_fifo_fg;
use lib_pkg_v1_0_2.lib_pkg.all;

-------------------------------------------------------------------------------
entity  axi_sg_updt_q_mngr is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64        := 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_M_AXI_SG_DATA_WIDTH       : integer range 32 to 32        := 32;
            -- Master AXI Memory Map Data Width for Scatter Gather R/W Port

        C_S_AXIS_UPDPTR_TDATA_WIDTH : integer range 32 to 32         := 32;
            -- 32 Update Status Bits

        C_S_AXIS_UPDSTS_TDATA_WIDTH : integer range 33 to 33         := 33;
            -- 1 IOC bit + 32 Update Status Bits

        C_SG_UPDT_DESC2QUEUE     : integer range 0 to 8             := 0;
            -- Number of descriptors to fetch and queue for each channel.
            -- A value of zero excludes the fetch queues.

        C_SG_CH1_WORDS_TO_UPDATE : integer range 1 to 16          := 8;
            -- Number of words to update

        C_SG_CH2_WORDS_TO_UPDATE : integer range 1 to 16          := 8;
            -- Number of words to update

        C_INCLUDE_CH1               : integer range 0 to 1          := 1;
            -- Include or Exclude channel 1 scatter gather engine
            -- 0 = Exclude Channel 1 SG Engine
            -- 1 = Include Channel 1 SG Engine

        C_INCLUDE_CH2               : integer range 0 to 1          := 1;
            -- Include or Exclude channel 2 scatter gather engine
            -- 0 = Exclude Channel 2 SG Engine
            -- 1 = Include Channel 2 SG Engine

        C_AXIS_IS_ASYNC             : integer range 0 to 1          := 0;
            -- Channel 1 is async to sg_aclk
            -- 0 = Synchronous to SG ACLK
            -- 1 = Asynchronous to SG ACLK

        C_FAMILY                    : string            := "virtex6"
            -- Device family used for proper BRAM selection
    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;           --
        m_axi_sg_aresetn            : in  std_logic                         ;           --
                                                                                        --
        --***********************************--                                         --
        --** Channel 1 Control             **--                                         --
        --***********************************--                                         --
        ch1_updt_curdesc_wren       : out std_logic                         ;           --
        ch1_updt_curdesc            : out std_logic_vector                              --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;           --
        ch1_updt_active             : in  std_logic                         ;           --
        ch1_updt_queue_empty        : out std_logic                         ;           --
        ch1_updt_ioc                : out std_logic                         ;           --
        ch1_updt_ioc_irq_set        : in  std_logic                         ;           --
                                                                                        --
        ch1_dma_interr              : out std_logic                         ;           --
        ch1_dma_slverr              : out std_logic                         ;           --
        ch1_dma_decerr              : out std_logic                         ;           --
        ch1_dma_interr_set          : in  std_logic                         ;           --
        ch1_dma_slverr_set          : in  std_logic                         ;           --
        ch1_dma_decerr_set          : in  std_logic                         ;           --
                                                                                        --
        --***********************************--                                         --
        --** Channel 2 Control             **--                                         --
        --***********************************--                                         --
        ch2_updt_active             : in  std_logic                         ;           --
        ch2_updt_curdesc_wren       : out std_logic                         ;           --
        ch2_updt_curdesc            : out std_logic_vector                              --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;           --
        ch2_updt_queue_empty        : out std_logic                         ;           --
        ch2_updt_ioc                : out std_logic                         ;           --
        ch2_updt_ioc_irq_set        : in  std_logic                         ;           --
                                                                                        --
        ch2_dma_interr              : out std_logic                         ;           --
        ch2_dma_slverr              : out std_logic                         ;           --
        ch2_dma_decerr              : out std_logic                         ;           --
        ch2_dma_interr_set          : in  std_logic                         ;           --
        ch2_dma_slverr_set          : in  std_logic                         ;           --
        ch2_dma_decerr_set          : in  std_logic                         ;           --
                                                                                        --
        --***********************************--                                         --
        --** Channel 1 Update Interface In **--                                         --
        --***********************************--                                         --
        s_axis_ch1_updt_aclk        : in  std_logic                         ;           --
        -- Update Pointer Stream                                                        --
        s_axis_ch1_updtptr_tdata    : in  std_logic_vector                              --
                                        (C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0);       --
        s_axis_ch1_updtptr_tvalid   : in  std_logic                         ;           --
        s_axis_ch1_updtptr_tready   : out std_logic                         ;           --
        s_axis_ch1_updtptr_tlast    : in  std_logic                         ;           --
                                                                                        --
        -- Update Status Stream                                                         --
        s_axis_ch1_updtsts_tdata    : in  std_logic_vector                              --
                                        (C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0);       --
        s_axis_ch1_updtsts_tvalid   : in  std_logic                         ;           --
        s_axis_ch1_updtsts_tready   : out std_logic                         ;           --
        s_axis_ch1_updtsts_tlast    : in  std_logic                         ;           --
                                                                                        --
        --***********************************--                                         --
        --** Channel 2 Update Interface In **--                                         --
        --***********************************--                                         --
        s_axis_ch2_updt_aclk        : in  std_logic                         ;           --
        -- Update Pointer Stream                                                        --
        s_axis_ch2_updtptr_tdata    : in  std_logic_vector                              --
                                        (C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0);       --
        s_axis_ch2_updtptr_tvalid   : in  std_logic                         ;           --
        s_axis_ch2_updtptr_tready   : out std_logic                         ;           --
        s_axis_ch2_updtptr_tlast    : in  std_logic                         ;           --
                                                                                        --
        -- Update Status Stream                                                         --
        s_axis_ch2_updtsts_tdata    : in  std_logic_vector                              --
                                        (C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0);       --
        s_axis_ch2_updtsts_tvalid   : in  std_logic                         ;           --
        s_axis_ch2_updtsts_tready   : out std_logic                         ;           --
        s_axis_ch2_updtsts_tlast    : in  std_logic                         ;           --
                                                                                        --
        --***************************************--                                     --
        --** Update Interface to AXI DataMover **--                                     --
        --***************************************--                                     --
        -- S2MM Stream Out To DataMover                                                 --
        s_axis_s2mm_tdata           : out std_logic_vector                              --
                                        (C_M_AXI_SG_DATA_WIDTH-1 downto 0)  ;           --
        s_axis_s2mm_tlast           : out std_logic                         ;           --
        s_axis_s2mm_tvalid          : out std_logic                         ;           --
        s_axis_s2mm_tready          : in  std_logic                                     --


    );

end axi_sg_updt_q_mngr;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_updt_q_mngr is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal m_axis_ch1_updt_tdata            : std_logic_vector(C_M_AXI_SG_DATA_WIDTH-1 downto 0) := (others => '0');
signal m_axis_ch1_updt_tlast            : std_logic := '0';
signal m_axis_ch1_updt_tvalid           : std_logic := '0';
signal m_axis_ch1_updt_tready           : std_logic := '0';

signal m_axis_ch2_updt_tdata            : std_logic_vector(C_M_AXI_SG_DATA_WIDTH-1 downto 0) := (others => '0');
signal m_axis_ch2_updt_tlast            : std_logic := '0';
signal m_axis_ch2_updt_tvalid           : std_logic := '0';
signal m_axis_ch2_updt_tready           : std_logic := '0';


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

--*****************************************************************************
--**                                CHANNEL 1                                **
--*****************************************************************************
-------------------------------------------------------------------------------
-- If Channel 1 is enabled then instantiate descriptor update logic.
-------------------------------------------------------------------------------
GEN_CH1_UPDATE_Q_IF : if C_INCLUDE_CH1 = 1 generate
begin

--*****************************************************************************
--**                        CHANNEL 1 - DESCRIPTOR QUEUE                     **
--*****************************************************************************
    -- If Descriptor Update queueing enabled then instantiate Queue Logic
    GEN_CH1_QUEUE : if  C_SG_UPDT_DESC2QUEUE  /= 0 generate
    begin
        -------------------------------------------------------------------------------
        I_CH1_UPDT_DESC_QUEUE : entity  axi_vdma_v6_3_10.axi_sg_updt_queue
            generic map(
                C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH                ,
                C_M_AXIS_UPDT_DATA_WIDTH    => C_M_AXI_SG_DATA_WIDTH                ,
                C_S_AXIS_UPDPTR_TDATA_WIDTH => C_S_AXIS_UPDPTR_TDATA_WIDTH          ,
                C_S_AXIS_UPDSTS_TDATA_WIDTH => C_S_AXIS_UPDSTS_TDATA_WIDTH          ,
                C_SG_UPDT_DESC2QUEUE        => C_SG_UPDT_DESC2QUEUE                 ,
                C_SG_WORDS_TO_UPDATE        => C_SG_CH1_WORDS_TO_UPDATE             ,
                C_AXIS_IS_ASYNC             => C_AXIS_IS_ASYNC                      ,
                C_FAMILY                    => C_FAMILY
            )
            port map(
                -----------------------------------------------------------------------
                -- AXI Scatter Gather Interface
                -----------------------------------------------------------------------
                m_axi_sg_aclk               => m_axi_sg_aclk                        ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn                     ,
                s_axis_updt_aclk            => s_axis_ch1_updt_aclk                 ,

                --********************************--
                --** Control and Status         **--
                --********************************--
                updt_curdesc_wren           => ch1_updt_curdesc_wren                ,
                updt_curdesc                => ch1_updt_curdesc                     ,
                updt_active                 => ch1_updt_active                      ,
                updt_queue_empty            => ch1_updt_queue_empty                 ,
                updt_ioc                    => ch1_updt_ioc                         ,
                updt_ioc_irq_set            => ch1_updt_ioc_irq_set                 ,

                dma_interr                  => ch1_dma_interr                       ,
                dma_slverr                  => ch1_dma_slverr                       ,
                dma_decerr                  => ch1_dma_decerr                       ,
                dma_interr_set              => ch1_dma_interr_set                   ,
                dma_slverr_set              => ch1_dma_slverr_set                   ,
                dma_decerr_set              => ch1_dma_decerr_set                   ,

                --********************************--
                --** Update Interfaces In       **--
                --********************************--
                -- Update Pointer Stream
                s_axis_updtptr_tdata        => s_axis_ch1_updtptr_tdata             ,
                s_axis_updtptr_tvalid       => s_axis_ch1_updtptr_tvalid            ,
                s_axis_updtptr_tready       => s_axis_ch1_updtptr_tready            ,
                s_axis_updtptr_tlast        => s_axis_ch1_updtptr_tlast             ,

                -- Update Status Stream
                s_axis_updtsts_tdata        => s_axis_ch1_updtsts_tdata             ,
                s_axis_updtsts_tvalid       => s_axis_ch1_updtsts_tvalid            ,
                s_axis_updtsts_tready       => s_axis_ch1_updtsts_tready            ,
                s_axis_updtsts_tlast        => s_axis_ch1_updtsts_tlast             ,

                --********************************--
                --** Update Interfaces Out      **--
                --********************************--
                -- S2MM Stream Out To DataMover
                m_axis_updt_tdata           => m_axis_ch1_updt_tdata                ,
                m_axis_updt_tlast           => m_axis_ch1_updt_tlast                ,
                m_axis_updt_tvalid          => m_axis_ch1_updt_tvalid               ,
                m_axis_updt_tready          => m_axis_ch1_updt_tready
            );
    end generate GEN_CH1_QUEUE;


--*****************************************************************************
--**                        CHANNEL 1 - NO DESCRIPTOR QUEUE                  **
--*****************************************************************************
    -- No update queue enabled, therefore map internal stream logic
    -- directly to channel port.
    GEN_CH1_NO_QUEUE : if C_SG_UPDT_DESC2QUEUE = 0 generate
    begin

        I_NO_CH1_UPDT_DESC_QUEUE : entity  axi_vdma_v6_3_10.axi_sg_updt_noqueue
            generic map(
                C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH                ,
                C_M_AXIS_UPDT_DATA_WIDTH    => C_M_AXI_SG_DATA_WIDTH                ,
                C_S_AXIS_UPDPTR_TDATA_WIDTH => C_S_AXIS_UPDPTR_TDATA_WIDTH          ,
                C_S_AXIS_UPDSTS_TDATA_WIDTH  => C_S_AXIS_UPDSTS_TDATA_WIDTH
            )
            port map(
                -----------------------------------------------------------------------
                -- AXI Scatter Gather Interface
                -----------------------------------------------------------------------
                m_axi_sg_aclk               => m_axi_sg_aclk                        ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn                     ,

                --********************************--
                --** Control and Status         **--
                --********************************--
                updt_curdesc_wren           => ch1_updt_curdesc_wren                ,
                updt_curdesc                => ch1_updt_curdesc                     ,
                updt_active                 => ch1_updt_active                      ,
                updt_queue_empty            => ch1_updt_queue_empty                 ,
                updt_ioc                    => ch1_updt_ioc                         ,
                updt_ioc_irq_set            => ch1_updt_ioc_irq_set                 ,

                dma_interr                  => ch1_dma_interr                       ,
                dma_slverr                  => ch1_dma_slverr                       ,
                dma_decerr                  => ch1_dma_decerr                       ,
                dma_interr_set              => ch1_dma_interr_set                   ,
                dma_slverr_set              => ch1_dma_slverr_set                   ,
                dma_decerr_set              => ch1_dma_decerr_set                   ,

                --********************************--
                --** Update Interfaces In       **--
                --********************************--
                -- Update Pointer Stream
                s_axis_updtptr_tdata        => s_axis_ch1_updtptr_tdata             ,
                s_axis_updtptr_tvalid       => s_axis_ch1_updtptr_tvalid            ,
                s_axis_updtptr_tready       => s_axis_ch1_updtptr_tready            ,
                s_axis_updtptr_tlast        => s_axis_ch1_updtptr_tlast             ,

                -- Update Status Stream
                s_axis_updtsts_tdata        => s_axis_ch1_updtsts_tdata             ,
                s_axis_updtsts_tvalid       => s_axis_ch1_updtsts_tvalid            ,
                s_axis_updtsts_tready       => s_axis_ch1_updtsts_tready            ,
                s_axis_updtsts_tlast        => s_axis_ch1_updtsts_tlast             ,

                --********************************--
                --** Update Interfaces Out      **--
                --********************************--
                -- S2MM Stream Out To DataMover
                m_axis_updt_tdata           => m_axis_ch1_updt_tdata                ,
                m_axis_updt_tlast           => m_axis_ch1_updt_tlast                ,
                m_axis_updt_tvalid          => m_axis_ch1_updt_tvalid               ,
                m_axis_updt_tready          => m_axis_ch1_updt_tready
            );

    end generate GEN_CH1_NO_QUEUE;


end generate GEN_CH1_UPDATE_Q_IF;


-- Channel 1 NOT included therefore tie ch1 outputs off
GEN_NO_CH1_UPDATE_Q_IF : if C_INCLUDE_CH1 = 0 generate
begin
    ch1_updt_curdesc_wren       <= '0';
    ch1_updt_curdesc            <= (others => '0');
    ch1_updt_queue_empty        <= '1';

    ch1_updt_ioc                <= '0';
    ch1_dma_interr              <= '0';
    ch1_dma_slverr              <= '0';
    ch1_dma_decerr              <= '0';

    m_axis_ch1_updt_tdata       <= (others => '0');
    m_axis_ch1_updt_tlast       <= '0';
    m_axis_ch1_updt_tvalid      <= '0';

    s_axis_ch1_updtptr_tready   <= '0';
    s_axis_ch1_updtsts_tready   <= '0';

end generate GEN_NO_CH1_UPDATE_Q_IF;

--*****************************************************************************
--**                                CHANNEL 2                                **
--*****************************************************************************
-------------------------------------------------------------------------------
-- If Channel 2 is enabled then instantiate descriptor update logic.
-------------------------------------------------------------------------------
GEN_CH2_UPDATE_Q_IF : if C_INCLUDE_CH2 = 1 generate

begin

    --*************************************************************************
    --**                        CHANNEL 2 - DESCRIPTOR QUEUE                 **
    --*************************************************************************
    -- If Descriptor Update queueing enabled then instantiate Queue Logic
    GEN_CH2_QUEUE : if  C_SG_UPDT_DESC2QUEUE  /= 0 generate
    begin
    ---------------------------------------------------------------------------
        I_CH2_UPDT_DESC_QUEUE : entity  axi_vdma_v6_3_10.axi_sg_updt_queue
            generic map(
                C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH        ,
                C_M_AXIS_UPDT_DATA_WIDTH    => C_M_AXI_SG_DATA_WIDTH        ,
                C_S_AXIS_UPDPTR_TDATA_WIDTH => C_S_AXIS_UPDPTR_TDATA_WIDTH  ,
                C_S_AXIS_UPDSTS_TDATA_WIDTH => C_S_AXIS_UPDSTS_TDATA_WIDTH  ,
                C_SG_UPDT_DESC2QUEUE        => C_SG_UPDT_DESC2QUEUE         ,
                C_SG_WORDS_TO_UPDATE        => C_SG_CH2_WORDS_TO_UPDATE     ,
                C_FAMILY                    => C_FAMILY
            )
            port map(
                ---------------------------------------------------------------
                -- AXI Scatter Gather Interface
                ---------------------------------------------------------------
                m_axi_sg_aclk               => m_axi_sg_aclk                ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn             ,
                s_axis_updt_aclk            => s_axis_ch2_updt_aclk         ,

                --********************************--
                --** Control and Status         **--
                --********************************--
                updt_curdesc_wren           => ch2_updt_curdesc_wren        ,
                updt_curdesc                => ch2_updt_curdesc             ,
                updt_active                 => ch2_updt_active              ,
                updt_queue_empty            => ch2_updt_queue_empty         ,
                updt_ioc                    => ch2_updt_ioc                 ,
                updt_ioc_irq_set            => ch2_updt_ioc_irq_set         ,

                dma_interr                  => ch2_dma_interr               ,
                dma_slverr                  => ch2_dma_slverr               ,
                dma_decerr                  => ch2_dma_decerr               ,
                dma_interr_set              => ch2_dma_interr_set           ,
                dma_slverr_set              => ch2_dma_slverr_set           ,
                dma_decerr_set              => ch2_dma_decerr_set           ,

                --********************************--
                --** Update Interfaces In       **--
                --********************************--
                -- Update Pointer Stream
                s_axis_updtptr_tdata        => s_axis_ch2_updtptr_tdata     ,
                s_axis_updtptr_tvalid       => s_axis_ch2_updtptr_tvalid    ,
                s_axis_updtptr_tready       => s_axis_ch2_updtptr_tready    ,
                s_axis_updtptr_tlast        => s_axis_ch2_updtptr_tlast     ,

                -- Update Status Stream
                s_axis_updtsts_tdata        => s_axis_ch2_updtsts_tdata     ,
                s_axis_updtsts_tvalid       => s_axis_ch2_updtsts_tvalid    ,
                s_axis_updtsts_tready       => s_axis_ch2_updtsts_tready    ,
                s_axis_updtsts_tlast        => s_axis_ch2_updtsts_tlast     ,

                --********************************--
                --** Update Interfaces Out      **--
                --********************************--
                -- S2MM Stream Out To DataMover
                m_axis_updt_tdata           => m_axis_ch2_updt_tdata        ,
                m_axis_updt_tlast           => m_axis_ch2_updt_tlast        ,
                m_axis_updt_tvalid          => m_axis_ch2_updt_tvalid       ,
                m_axis_updt_tready          => m_axis_ch2_updt_tready
            );

    end generate GEN_CH2_QUEUE;


    --*****************************************************************************
    --**                        CHANNEL 2 - NO DESCRIPTOR QUEUE                  **
    --*****************************************************************************

    -- No update queue enabled, therefore map internal stream logic
    -- directly to channel port.
    GEN_CH2_NO_QUEUE : if C_SG_UPDT_DESC2QUEUE = 0 generate
        I_NO_CH2_UPDT_DESC_QUEUE : entity  axi_vdma_v6_3_10.axi_sg_updt_noqueue
            generic map(
                C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH        ,
                C_M_AXIS_UPDT_DATA_WIDTH    => C_M_AXI_SG_DATA_WIDTH        ,
                C_S_AXIS_UPDPTR_TDATA_WIDTH => C_S_AXIS_UPDPTR_TDATA_WIDTH  ,
                C_S_AXIS_UPDSTS_TDATA_WIDTH => C_S_AXIS_UPDSTS_TDATA_WIDTH
            )
            port map(
                ---------------------------------------------------------------
                -- AXI Scatter Gather Interface
                ---------------------------------------------------------------
                m_axi_sg_aclk               => m_axi_sg_aclk                ,
                m_axi_sg_aresetn             => m_axi_sg_aresetn              ,

                --********************************--
                --** Control and Status         **--
                --********************************--
                updt_curdesc_wren           => ch2_updt_curdesc_wren        ,
                updt_curdesc                => ch2_updt_curdesc             ,
                updt_active                 => ch2_updt_active              ,
                updt_queue_empty            => ch2_updt_queue_empty         ,
                updt_ioc                    => ch2_updt_ioc                 ,
                updt_ioc_irq_set            => ch2_updt_ioc_irq_set         ,

                dma_interr                  => ch2_dma_interr               ,
                dma_slverr                  => ch2_dma_slverr               ,
                dma_decerr                  => ch2_dma_decerr               ,
                dma_interr_set              => ch2_dma_interr_set           ,
                dma_slverr_set              => ch2_dma_slverr_set           ,
                dma_decerr_set              => ch2_dma_decerr_set           ,

                --********************************--
                --** Update Interfaces In       **--
                --********************************--
                -- Update Pointer Stream
                s_axis_updtptr_tdata        => s_axis_ch2_updtptr_tdata     ,
                s_axis_updtptr_tvalid       => s_axis_ch2_updtptr_tvalid    ,
                s_axis_updtptr_tready       => s_axis_ch2_updtptr_tready    ,
                s_axis_updtptr_tlast        => s_axis_ch2_updtptr_tlast     ,

                -- Update Status Stream
                s_axis_updtsts_tdata        => s_axis_ch2_updtsts_tdata     ,
                s_axis_updtsts_tvalid       => s_axis_ch2_updtsts_tvalid    ,
                s_axis_updtsts_tready       => s_axis_ch2_updtsts_tready    ,
                s_axis_updtsts_tlast        => s_axis_ch2_updtsts_tlast     ,

                --********************************--
                --** Update Interfaces Out      **--
                --********************************--
                -- S2MM Stream Out To DataMover
                m_axis_updt_tdata           => m_axis_ch2_updt_tdata        ,
                m_axis_updt_tlast           => m_axis_ch2_updt_tlast        ,
                m_axis_updt_tvalid          => m_axis_ch2_updt_tvalid       ,
                m_axis_updt_tready          => m_axis_ch2_updt_tready
            );

    end generate GEN_CH2_NO_QUEUE;

end generate GEN_CH2_UPDATE_Q_IF;

-- Channel 2 NOT included therefore tie ch2 outputs off
GEN_NO_CH2_UPDATE_Q_IF : if C_INCLUDE_CH2 = 0 generate
begin
    ch2_updt_curdesc_wren       <= '0';
    ch2_updt_curdesc            <= (others => '0');
    ch2_updt_queue_empty        <= '1';

    ch2_updt_ioc                <= '0';
    ch2_dma_interr              <= '0';
    ch2_dma_slverr              <= '0';
    ch2_dma_decerr              <= '0';

    m_axis_ch2_updt_tdata       <= (others => '0');
    m_axis_ch2_updt_tlast       <= '0';
    m_axis_ch2_updt_tvalid      <= '0';

    s_axis_ch2_updtptr_tready   <= '0';
    s_axis_ch2_updtsts_tready   <= '0';

end generate GEN_NO_CH2_UPDATE_Q_IF;

-------------------------------------------------------------------------------
-- MUX For DataMover
-------------------------------------------------------------------------------
TO_DATAMVR_MUX : process(ch1_updt_active,
                         ch2_updt_active,
                         m_axis_ch1_updt_tdata,
                         m_axis_ch1_updt_tlast,
                         m_axis_ch1_updt_tvalid,
                         m_axis_ch2_updt_tdata,
                         m_axis_ch2_updt_tlast,
                         m_axis_ch2_updt_tvalid)
    begin
        if(ch1_updt_active = '1')then
            s_axis_s2mm_tdata   <= m_axis_ch1_updt_tdata;
            s_axis_s2mm_tlast   <= m_axis_ch1_updt_tlast;
            s_axis_s2mm_tvalid  <= m_axis_ch1_updt_tvalid;
        elsif(ch2_updt_active = '1')then
            s_axis_s2mm_tdata   <= m_axis_ch2_updt_tdata;
            s_axis_s2mm_tlast   <= m_axis_ch2_updt_tlast;
            s_axis_s2mm_tvalid  <= m_axis_ch2_updt_tvalid;
        else
            s_axis_s2mm_tdata   <= (others => '0');
            s_axis_s2mm_tlast   <= '0';
            s_axis_s2mm_tvalid  <= '0';
        end if;
    end process TO_DATAMVR_MUX;

m_axis_ch1_updt_tready <= s_axis_s2mm_tready;
m_axis_ch2_updt_tready <= s_axis_s2mm_tready;


end implementation;


-------------------------------------------------------------------------------
-- axi_sg_intrpt
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_sg_intrpt.vhd
-- Description: This entity handles interrupt coalescing
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_0.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     6/14/10    v1_00_a
-- ^^^^^^

--  Fixed issue where simultaneous sof and eof caused delay timer to not enable
-- thus missing a delay interrupt.  This issue occurs with small packets(i.e.
-- 2 data beats)
-- ~~~~~~
--  GAB     7/1/10    v1_00_a
-- ^^^^^^

-- Remapped interrupt threshold control to be driven based on whether update
-- engine is included or not. Renamed interrupt threshold decrement control here
-- to match change in upper level.
-- ~~~~~~
--  GAB     8/3/10    v1_00_a
-- ^^^^^^

-- Routed dlyirq_wren to reset delay timer logic on assertion
-- ~~~~~~
--  GAB     8/12/10    v1_00_a
-- ^^^^^^

-- Added ability to disable threshold count reset on delay timer timeout in
-- order to match legacy SDMA operation.
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Rolled axi_sg library version to version v2_00_a
-- ~~~~~~
--  GAB     10/21/10    v4_03
-- ^^^^^^
--  Rolled version to v4_03
-- ~~~~~~
--  GAB     6/13/11    v4_03
-- ^^^^^^
-- Update to AXI Datamover v4_03
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;
use lib_pkg_v1_0_2.lib_pkg.max2;

-------------------------------------------------------------------------------
entity  axi_sg_intrpt is
    generic(

        C_INCLUDE_CH1                  : integer range 0 to 1       := 1    ;
            -- Include or exclude MM2S primary data path
            -- 0 = Exclude MM2S primary data path
            -- 1 = Include MM2S primary data path

        C_INCLUDE_CH2                  : integer range 0 to 1       := 1    ;
            -- Include or exclude S2MM primary data path
            -- 0 = Exclude S2MM primary data path
            -- 1 = Include S2MM primary data path

        C_INCLUDE_DLYTMR            : integer range 0 to 1          := 1    ;
            -- Include/Exclude interrupt delay timer
            -- 0 = Exclude Delay timer
            -- 1 = Include Delay timer

        C_DLYTMR_RESOLUTION         : integer range 1 to 100000      := 125
            -- Interrupt Delay Timer resolution in usec

    );
    port (

        -- Secondary Clock and Reset
        m_axi_sg_aclk               : in  std_logic                         ;              --
        m_axi_sg_aresetn            : in  std_logic                         ;              --
                                                                                           --
        ch1_irqthresh_decr          : in  std_logic                         ;
        ch1_irqthresh_rstdsbl       : in  std_logic                         ;
        ch1_dlyirq_dsble            : in  std_logic                         ;              --
        ch1_irqdelay_wren           : in  std_logic                         ;              --
        ch1_irqdelay                : in  std_logic_vector(7 downto 0)      ;              --
        ch1_irqthresh_wren          : in  std_logic                         ;              --
        ch1_irqthresh               : in  std_logic_vector(7 downto 0)      ;              --
        ch1_packet_sof              : in  std_logic                         ;              --
        ch1_packet_eof              : in  std_logic                         ;              --
        ch1_ioc_irq_set             : out std_logic                         ;              --
        ch1_dly_irq_set             : out std_logic                         ;              --
        ch1_irqdelay_status         : out std_logic_vector(7 downto 0)      ;              --
        ch1_irqthresh_status        : out std_logic_vector(7 downto 0)      ;              --
                                                                                           --
        ch2_irqthresh_decr          : in  std_logic                         ;
        ch2_irqthresh_rstdsbl       : in  std_logic                         ;
        ch2_dlyirq_dsble            : in  std_logic                         ;              --
        ch2_irqdelay_wren           : in  std_logic                         ;              --
        ch2_irqdelay                : in  std_logic_vector(7 downto 0)      ;              --
        ch2_irqthresh_wren          : in  std_logic                         ;              --
        ch2_irqthresh               : in  std_logic_vector(7 downto 0)      ;              --
        ch2_packet_sof              : in  std_logic                         ;              --
        ch2_packet_eof              : in  std_logic                         ;              --
        ch2_ioc_irq_set             : out std_logic                         ;              --
        ch2_dly_irq_set             : out std_logic                         ;              --
        ch2_irqdelay_status         : out std_logic_vector(7 downto 0)      ;              --
        ch2_irqthresh_status        : out std_logic_vector(7 downto 0)                     --

    );

end axi_sg_intrpt;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg_intrpt is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- Delay interrupt fast counter width
constant FAST_COUNT_WIDTH   : integer := clog2(C_DLYTMR_RESOLUTION+1);
-- Delay interrupt fast counter terminal count
constant FAST_COUNT_TC      : std_logic_vector(FAST_COUNT_WIDTH-1 downto 0)
                                := std_logic_vector(to_unsigned(
                                (C_DLYTMR_RESOLUTION-1),FAST_COUNT_WIDTH));




-- Delay interrupt fast counter zero value
constant ZERO_FAST_COUNT    : std_logic_vector(FAST_COUNT_WIDTH-1 downto 0)
                                := (others => '0');

constant ZERO_VALUE         : std_logic_vector(7 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal ch1_thresh_count    : std_logic_vector(7 downto 0) := ONE_THRESHOLD;
signal ch1_dly_irq_set_i   : std_logic := '0';
signal ch1_ioc_irq_set_i   : std_logic := '0';

signal ch1_delay_count     : std_logic_vector(7 downto 0) := (others => '0');
signal ch1_delay_cnt_en    : std_logic := '0';
signal ch1_dly_fast_cnt    : std_logic_vector(FAST_COUNT_WIDTH-1 downto 0) := (others => '0');
signal ch1_dly_fast_incr   : std_logic := '0';
signal ch1_delay_zero      : std_logic := '0';
signal ch1_delay_tc        : std_logic := '0';
signal ch1_disable_delay   : std_logic := '0';

signal ch2_thresh_count    : std_logic_vector(7 downto 0) := ONE_THRESHOLD;
signal ch2_dly_irq_set_i   : std_logic := '0';
signal ch2_ioc_irq_set_i   : std_logic := '0';

signal ch2_delay_count     : std_logic_vector(7 downto 0) := (others => '0');
signal ch2_delay_cnt_en    : std_logic := '0';
signal ch2_dly_fast_cnt    : std_logic_vector(FAST_COUNT_WIDTH-1 downto 0) := (others => '0');
signal ch2_dly_fast_incr   : std_logic := '0';
signal ch2_delay_zero      : std_logic := '0';
signal ch2_delay_tc        : std_logic := '0';
signal ch2_disable_delay   : std_logic := '0';


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

-- Transmit channel included therefore generate transmit interrupt logic
GEN_INCLUDE_MM2S : if C_INCLUDE_CH1 = 1 generate
begin
    REG_THRESH_COUNT : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch1_thresh_count   <= ONE_THRESHOLD;
                    ch1_ioc_irq_set_i  <= '0';

                -- New Threshold set by CPU OR delay interrupt event occured.
--                 added ability to disable threshold count reset on delay timeout
--                elsif(ch1_irqthresh_wren = '1' or ch1_dly_irq_set_i = '1') then
                elsif( (ch1_irqthresh_wren = '1')
                    or (ch1_dly_irq_set_i = '1' and ch1_irqthresh_rstdsbl = '0')) then
                    ch1_thresh_count   <= ch1_irqthresh;
                    ch1_ioc_irq_set_i  <= '0';

                -- IOC event then...
                elsif(ch1_irqthresh_decr = '1')then
                    -- Threshold at zero, reload threshold and drive ioc
                    -- interrupt.
                    if(ch1_thresh_count = ONE_THRESHOLD)then
                        ch1_thresh_count    <= ch1_irqthresh;
                        ch1_ioc_irq_set_i  <= '1';
                    else
                        ch1_thresh_count   <= std_logic_vector(unsigned(ch1_thresh_count(7 downto 0)) - 1);
                        ch1_ioc_irq_set_i  <= '0';
                    end if;
                else
                    ch1_thresh_count   <= ch1_thresh_count;
                    ch1_ioc_irq_set_i  <= '0';
                end if;
            end if;
        end process REG_THRESH_COUNT;

    -- Pass current threshold count out to DMASR
    ch1_irqthresh_status <= ch1_thresh_count;
    ch1_ioc_irq_set      <= ch1_ioc_irq_set_i;

    ---------------------------------------------------------------------------
    -- Generate Delay Interrupt Timers
    ---------------------------------------------------------------------------
    GEN_CH1_DELAY_INTERRUPT : if C_INCLUDE_DLYTMR = 1 generate
    begin
        GEN_CH1_FAST_COUNTER : if C_DLYTMR_RESOLUTION /= 1 generate
        begin
            ---------------------------------------------------------------------------
            -- Delay interrupt high resolution timer
            ---------------------------------------------------------------------------
            REG_DLY_FAST_CNT : process(m_axi_sg_aclk)
                begin
                    if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then

--                        if(m_axi_sg_aresetn = '0' or ch1_delay_cnt_en = '0' or ch1_disable_delay = '1')then
--  - need to reset delay timer each time a new delay value is written.
--                        if(m_axi_sg_aresetn = '0' or ch1_delay_cnt_en = '0' or ch1_disable_delay = '1' or ch1_packet_sof = '1')then
                        if(m_axi_sg_aresetn = '0' or ch1_delay_cnt_en = '0' or ch1_disable_delay = '1'
                        or ch1_packet_sof = '1' or ch1_irqdelay_wren = '1')then
                            ch1_dly_fast_cnt   <= FAST_COUNT_TC;
                            ch1_dly_fast_incr  <= '0';
                        elsif(ch1_dly_fast_cnt = ZERO_FAST_COUNT)then
                            ch1_dly_fast_cnt   <= FAST_COUNT_TC;
                            ch1_dly_fast_incr  <= '1';
                        else
                            ch1_dly_fast_cnt   <= std_logic_vector(unsigned(ch1_dly_fast_cnt(FAST_COUNT_WIDTH-1 downto 0)) - 1);
                            ch1_dly_fast_incr  <= '0';
                        end if;
                    end if;
                end process REG_DLY_FAST_CNT;
        end generate GEN_CH1_FAST_COUNTER;

        GEN_CH1_NO_FAST_COUNTER :  if C_DLYTMR_RESOLUTION = 1 generate
            REG_DLY_FAST_CNT : process(m_axi_sg_aclk)
                begin
                    if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then

--                        if(m_axi_sg_aresetn = '0' or ch1_delay_cnt_en = '0' or ch1_disable_delay = '1')then
--  need to reset delay timer each time a new delay value is written.
--                        if(m_axi_sg_aresetn = '0' or ch1_delay_cnt_en = '0' or ch1_disable_delay = '1' or ch1_packet_sof = '1')then
                        if(m_axi_sg_aresetn = '0' or ch1_delay_cnt_en = '0' or ch1_disable_delay = '1'
                        or ch1_packet_sof = '1' or ch1_irqdelay_wren = '1')then
                            ch1_dly_fast_incr <= '0';
                        else
                            ch1_dly_fast_incr <= '1';
                        end if;
                    end if;
                end process REG_DLY_FAST_CNT;
        end generate GEN_CH1_NO_FAST_COUNTER;

        -- DMACR Delay value set to zero - disable delay interrupt
        ch1_delay_zero <= '1' when ch1_irqdelay = ZERO_DELAY
                      else '0';

        -- Delay Terminal Count reached (i.e. Delay count = DMACR delay value)
        ch1_delay_tc <= '1' when ch1_delay_count = ch1_irqdelay
                             and ch1_delay_zero = '0'
                             and ch1_packet_sof = '0'
                    else '0';

        -- 1 clock earlier delay counter disable to prevent count
        -- increment on TC hit.
        ch1_disable_delay <= '1' when ch1_delay_zero = '1'
                                   or ch1_dlyirq_dsble = '1'
                                   or ch1_dly_irq_set_i = '1'
                        else '0';

        ---------------------------------------------------------------------------
        -- Delay interrupt low resolution timer
        ---------------------------------------------------------------------------
        REG_DELAY_COUNT : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then

--                    if(m_axi_sg_aresetn = '0' or ch1_delay_cnt_en = '0' or ch1_disable_delay = '1')then
--  - need to reset delay timer each time a new delay value is written.
--                    if(m_axi_sg_aresetn = '0' or ch1_delay_cnt_en = '0' or ch1_disable_delay = '1' or ch1_packet_sof = '1')then
                    if(m_axi_sg_aresetn = '0' or ch1_delay_cnt_en = '0' or ch1_disable_delay = '1'
                    or ch1_packet_sof = '1' or ch1_irqdelay_wren = '1')then
                        ch1_delay_count    <= (others => '0');
                        ch1_dly_irq_set_i  <= '0';
                    elsif(ch1_dly_fast_incr = '1' and ch1_delay_tc = '1')then
                        ch1_delay_count    <= (others => '0');
                        ch1_dly_irq_set_i  <= '1';
                    elsif(ch1_dly_fast_incr = '1')then
                        ch1_delay_count    <= std_logic_vector(unsigned(ch1_delay_count(7 downto 0)) + 1);
                        ch1_dly_irq_set_i  <= '0';
                    else
                        ch1_delay_count    <= ch1_delay_count;
                        ch1_dly_irq_set_i  <= '0';
                    end if;
                end if;
            end process REG_DELAY_COUNT;

        -- Pass current delay count to DMASR
        ch1_irqdelay_status    <= ch1_delay_count;
        ch1_dly_irq_set        <= ch1_dly_irq_set_i;

        -- Enable control for delay counter
        REG_DELAY_CNT_ENABLE : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' or ch1_disable_delay = '1')then
                        ch1_delay_cnt_en   <= '0';

-- simulatenous sof/eof which occurs for small packets causes delay timer
-- to not enable
--                    elsif(ch1_packet_sof = '1')then
                    -- stop counting if already counting and receive an sof and
                    -- not end of another packet
                    elsif(ch1_delay_cnt_en = '1' and ch1_packet_sof = '1'
                    and ch1_packet_eof = '0')then
                        ch1_delay_cnt_en   <= '0';
                    elsif(ch1_packet_eof = '1')then
                        ch1_delay_cnt_en   <= '1';
                    end if;
                end if;
            end process REG_DELAY_CNT_ENABLE;
    end generate GEN_CH1_DELAY_INTERRUPT;

    ---------------------------------------------------------------------------
    -- Delay interrupt NOT included
    ---------------------------------------------------------------------------
    GEN_NO_CH1_DELAY_INTR : if C_INCLUDE_DLYTMR = 0  generate
    begin
        ch1_dly_irq_set     <= '0';
        ch1_dly_irq_set_i   <= '0';
        ch1_irqdelay_status <= (others => '0');
    end generate GEN_NO_CH1_DELAY_INTR;

end generate GEN_INCLUDE_MM2S;

-- Receive channel included therefore generate receive interrupt logic
GEN_INCLUDE_S2MM : if C_INCLUDE_CH2 = 1 generate
begin
    REG_THRESH_COUNT : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    ch2_thresh_count   <= ONE_THRESHOLD;
                    ch2_ioc_irq_set_i  <= '0';

                -- New Threshold set by CPU OR delay interrupt event occured.
--  - added ability to disable threshold count reset on delay timeout
--                elsif(ch2_irqthresh_wren = '1' or ch2_dly_irq_set_i = '1') then
                elsif( (ch2_irqthresh_wren = '1')
                    or (ch2_dly_irq_set_i = '1' and ch2_irqthresh_rstdsbl = '0')) then
                    ch2_thresh_count   <= ch2_irqthresh;
                    ch2_ioc_irq_set_i  <= '0';

                -- IOC event then...
                elsif(ch2_irqthresh_decr = '1')then 
                    -- Threshold at zero, reload threshold and drive ioc
                    -- interrupt.
                    if(ch2_thresh_count = ONE_THRESHOLD)then
                        ch2_thresh_count   <= ch2_irqthresh;
                        ch2_ioc_irq_set_i  <= '1';
                    else
                        ch2_thresh_count   <= std_logic_vector(unsigned(ch2_thresh_count(7 downto 0)) - 1);
                        ch2_ioc_irq_set_i  <= '0';
                    end if;
                else
                    ch2_thresh_count   <= ch2_thresh_count;
                    ch2_ioc_irq_set_i  <= '0';
                end if;
            end if;
        end process REG_THRESH_COUNT;

    -- Pass current threshold count out to DMASR
    ch2_irqthresh_status   <= ch2_thresh_count;
    ch2_ioc_irq_set        <= ch2_ioc_irq_set_i;

    ---------------------------------------------------------------------------
    -- Generate Delay Interrupt Timers
    ---------------------------------------------------------------------------
    GEN_CH2_DELAY_INTERRUPT : if C_INCLUDE_DLYTMR = 1 generate
    begin
        ---------------------------------------------------------------------------
        -- Delay interrupt high resolution timer
        ---------------------------------------------------------------------------
        GEN_CH2_FAST_COUNTER : if C_DLYTMR_RESOLUTION /= 1 generate
        begin
            REG_DLY_FAST_CNT : process(m_axi_sg_aclk)
                begin
                    if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--  - need to reset on sof due to chanes for CR
--                        if(m_axi_sg_aresetn = '0' or ch2_delay_cnt_en = '0' or ch2_disable_delay = '1')then
--  - need to reset delay timer each time a new delay value is written.
--                        if(m_axi_sg_aresetn = '0' or ch2_delay_cnt_en = '0' or ch2_disable_delay = '1' or ch2_packet_sof = '1')then
                        if(m_axi_sg_aresetn = '0' or ch2_delay_cnt_en = '0' or ch2_disable_delay = '1'
                        or ch2_packet_sof = '1' or ch2_irqdelay_wren = '1')then
                            ch2_dly_fast_cnt   <= FAST_COUNT_TC;
                            ch2_dly_fast_incr  <= '0';
                        elsif(ch2_dly_fast_cnt = ZERO_FAST_COUNT)then
                            ch2_dly_fast_cnt   <= FAST_COUNT_TC;
                            ch2_dly_fast_incr  <= '1';
                        else
                            ch2_dly_fast_cnt   <= std_logic_vector(unsigned(ch2_dly_fast_cnt(FAST_COUNT_WIDTH-1 downto 0)) - 1);
                            ch2_dly_fast_incr  <= '0';
                        end if;
                    end if;
                end process REG_DLY_FAST_CNT;
        end generate GEN_CH2_FAST_COUNTER;

        GEN_CH2_NO_FAST_COUNTER :  if C_DLYTMR_RESOLUTION = 1 generate
            REG_DLY_FAST_CNT : process(m_axi_sg_aclk)
                begin
                    if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
-- - need to reset on sof due to chanes for CR
--                        if(m_axi_sg_aresetn = '0' or ch2_delay_cnt_en = '0' or ch2_disable_delay = '1')then
-- - need to reset delay timer each time a new delay value is written.
--                        if(m_axi_sg_aresetn = '0' or ch2_delay_cnt_en = '0' or ch2_disable_delay = '1' or ch2_packet_sof = '1')then
                        if(m_axi_sg_aresetn = '0' or ch2_delay_cnt_en = '0' or ch2_disable_delay = '1'
                        or ch2_packet_sof = '1' or ch2_irqdelay_wren = '1')then
                            ch2_dly_fast_incr <= '0';
                        else
                            ch2_dly_fast_incr <= '1';
                        end if;
                    end if;
                end process REG_DLY_FAST_CNT;
        end generate GEN_CH2_NO_FAST_COUNTER;

        -- DMACR Delay value set to zero - disable delay interrupt
        ch2_delay_zero <= '1' when ch2_irqdelay = ZERO_DELAY
                      else '0';

        -- Delay Terminal Count reached (i.e. Delay count = DMACR delay value)
        ch2_delay_tc <= '1' when ch2_delay_count = ch2_irqdelay
                             and ch2_delay_zero = '0'
                             and ch2_packet_sof = '0'
                      else '0';

        -- 1 clock earlier delay counter disable to prevent count
        -- increment on TC hit.
        ch2_disable_delay <= '1' when ch2_delay_zero = '1'
                                   or ch2_dlyirq_dsble = '1'
                                   or ch2_dly_irq_set_i = '1'
                        else '0';

        ---------------------------------------------------------------------------
        -- Delay interrupt low resolution timer
        ---------------------------------------------------------------------------
        REG_DELAY_COUNT : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then

--                    if(m_axi_sg_aresetn = '0' or ch2_delay_cnt_en = '0' or ch2_disable_delay = '1')then
-- - need to reset delay timer each time a new delay value is written.
--                    if(m_axi_sg_aresetn = '0' or ch2_delay_cnt_en = '0' or ch2_disable_delay = '1' or ch2_packet_sof = '1')then
                    if(m_axi_sg_aresetn = '0' or ch2_delay_cnt_en = '0' or ch2_disable_delay = '1'
                    or ch2_packet_sof = '1' or ch2_irqdelay_wren = '1')then
                        ch2_delay_count    <= (others => '0');
                        ch2_dly_irq_set_i  <= '0';
                    elsif(ch2_dly_fast_incr = '1' and ch2_delay_tc = '1')then
                        ch2_delay_count    <= (others => '0');
                        ch2_dly_irq_set_i  <= '1';
                    elsif(ch2_dly_fast_incr = '1')then
                        ch2_delay_count    <= std_logic_vector(unsigned(ch2_delay_count(7 downto 0)) + 1);
                        ch2_dly_irq_set_i  <= '0';
                    else
                        ch2_delay_count    <= ch2_delay_count;
                        ch2_dly_irq_set_i  <= '0';
                    end if;
                end if;
            end process REG_DELAY_COUNT;

        -- Pass current delay count to DMASR
        ch2_irqdelay_status <= ch2_delay_count;
        ch2_dly_irq_set     <= ch2_dly_irq_set_i;

        -- Enable control for delay counter
        REG_DELAY_CNT_ENABLE : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' or ch2_disable_delay = '1')then
                        ch2_delay_cnt_en   <= '0';
-- simulatenous sof/eof which occurs for small packets causes delay timer
-- to not enable
--                    elsif(ch2_packet_sof = '1')then
                    -- stop counting if already counting and receive an sof and
                    -- not end of another packet
                    elsif(ch2_delay_cnt_en = '1' and ch2_packet_sof = '1'
                    and ch2_packet_eof = '0')then
                        ch2_delay_cnt_en   <= '0';
                    elsif(ch2_packet_eof = '1')then
                        ch2_delay_cnt_en   <= '1';
                    end if;
                end if;
            end process REG_DELAY_CNT_ENABLE;
    end generate GEN_CH2_DELAY_INTERRUPT;

    ---------------------------------------------------------------------------
    -- Delay interrupt NOT included
    ---------------------------------------------------------------------------
    GEN_NO_CH2_DELAY_INTR : if C_INCLUDE_DLYTMR = 0  generate
    begin
        ch2_dly_irq_set     <= '0';
        ch2_dly_irq_set_i   <= '0';
        ch2_irqdelay_status <= (others => '0');
    end generate GEN_NO_CH2_DELAY_INTR;

end generate GEN_INCLUDE_S2MM;




-- Transmit channel not included therefore associated outputs to zero
GEN_EXCLUDE_MM2S : if C_INCLUDE_CH1 = 0 generate
begin
    ch1_ioc_irq_set        <= '0';
    ch1_dly_irq_set        <= '0';
    ch1_irqdelay_status    <= (others => '0');
    ch1_irqthresh_status   <= (others => '0');
end generate GEN_EXCLUDE_MM2S;

-- Receive channel not included therefore associated outputs to zero
GEN_EXCLUDE_S2MM : if C_INCLUDE_CH2 = 0 generate
begin
    ch2_ioc_irq_set        <= '0';
    ch2_dly_irq_set        <= '0';
    ch2_irqdelay_status    <= (others => '0');
    ch2_irqthresh_status   <= (others => '0');
end generate GEN_EXCLUDE_S2MM;



end implementation;


-------------------------------------------------------------------------------
-- axi_sg
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_sg.vhd
-- Description: This entity is the top level entity for the AXI Scatter Gather
--              Engine.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_sg.vhd
--                  axi_sg_pkg.vhd
--                   |- axi_sg_ftch_mngr.vhd
--                   |   |- axi_sg_ftch_sm.vhd
--                   |   |- axi_sg_ftch_pntr.vhd
--                   |   |- axi_sg_ftch_cmdsts_if.vhd
--                   |- axi_sg_updt_mngr.vhd
--                   |   |- axi_sg_updt_sm.vhd
--                   |   |- axi_sg_updt_cmdsts_if.vhd
--                   |- axi_sg_ftch_q_mngr.vhd
--                   |   |- axi_sg_ftch_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_ftch_noqueue.vhd
--                   |- axi_sg_updt_q_mngr.vhd
--                   |   |- axi_sg_updt_queue.vhd
--                   |   |   |- proc_common_v4_0.sync_fifo_fg.vhd
--                   |   |- proc_common_v4_0.axi_sg_afifo_autord.vhd
--                   |   |- axi_sg_updt_noqueue.vhd
--                   |- axi_sg_intrpt.vhd
--                   |- axi_datamover_v5_1_24.axi_datamover.vhd
--
-------------------------------------------------------------------------------
-- Author:      Gary Burch
-- History:
--  GAB     3/19/10    v1_00_a
-- ^^^^^^
--  - Initial Release
-- ~~~~~~
--  GAB     7/1/10    v1_00_a
-- ^^^^^^

-- Remapped interrupt threshold control to be driven based on whether update
-- engine is included or not.
-- ~~~~~~
--  GAB     7/27/10    v1_00_a
-- ^^^^^^

-- Remove double driven signal for exclude update engine mode
-- ~~~~~~
--  GAB     8/12/10    v1_00_a
-- ^^^^^^

-- Added ability to disable threshold count reset on delay timer timeout in
-- order to match legacy SDMA operation.
-- ~~~~~~
--  GAB     8/26/10    v2_00_a
-- ^^^^^^
--  Rolled axi_sg library version to version v2_00_a
--  Added ch1_aclk and ch2_aclk to allow for asynchronous operation
--  Added C_ACLK_IS_ASYNC parameter to set mode of clock synchronization
-- ~~~~~~
--  GAB     10/21/10    v2_01_a
-- ^^^^^^
--  Rolled version to v2_01_a
--  Updated to axi_datamover_v3_00_a
--  Updated tstrb ports to tkeep ports
-- ~~~~~~
--  GAB     11/15/10    v2_01_a
-- ^^^^^^

--  Converted all stream paraters ***_DATA_WIDTH to ***_TDATA_WIDTH
--  Updated AXI Datamover to incorperate new ports and ***_TDATA_WIDTH parameters
-- ~~~~~~
--  GAB     2/2/11    v2_02_a
-- ^^^^^^
-- Update to AXI Datamover v2_01_a
-- ~~~~~~
--  GAB     6/13/11    v3_00_a
-- ^^^^^^
-- Update to AXI Datamover v3_00_a
-- Added aynchronous operation
-- ~~~~~~
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_sg_pkg.all;

library axi_datamover_v5_1_24;
use axi_datamover_v5_1_24.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.max2;

-------------------------------------------------------------------------------
entity  axi_sg is
    generic (
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 32    := 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_M_AXI_SG_DATA_WIDTH       : integer range 32 to 32    := 32;
            -- Master AXI Memory Map Data Width for Scatter Gather R/W Port

        C_M_AXIS_SG_TDATA_WIDTH  : integer range 32 to 32        := 32;
            -- AXI Master Stream out for descriptor fetch

        C_S_AXIS_UPDPTR_TDATA_WIDTH : integer range 32 to 32     := 32;
            -- 32 Update Status Bits

        C_S_AXIS_UPDSTS_TDATA_WIDTH : integer range 33 to 33     := 33;
            -- 1 IOC bit + 32 Update Status Bits

        C_SG_FTCH_DESC2QUEUE     : integer range 0 to 8         := 0;
            -- Number of descriptors to fetch and queue for each channel.
            -- A value of zero excludes the fetch queues.

        C_SG_UPDT_DESC2QUEUE     : integer range 0 to 8         := 0;
            -- Number of descriptors to fetch and queue for each channel.
            -- A value of zero excludes the fetch queues.

        C_SG_CH1_WORDS_TO_FETCH   : integer range 4 to 16       := 8;
            -- Number of words to fetch

        C_SG_CH1_WORDS_TO_UPDATE   : integer range 1 to 16      := 8;
            -- Number of words to update

        C_SG_CH1_FIRST_UPDATE_WORD : integer range 0 to 15      := 0;
            -- Starting update word offset

        C_SG_CH1_ENBL_STALE_ERROR   : integer range 0 to 1      := 1;
            -- Enable or disable stale descriptor check
            -- 0 = Disable stale descriptor error check
            -- 1 = Enable stale descriptor error check

        C_SG_CH2_WORDS_TO_FETCH    : integer range 4 to 16      := 8;
            -- Number of words to fetch

        C_SG_CH2_WORDS_TO_UPDATE   : integer range 1 to 16      := 8;
            -- Number of words to update

        C_SG_CH2_FIRST_UPDATE_WORD : integer range 0 to 15      := 0;
            -- Starting update word offset

        C_SG_CH2_ENBL_STALE_ERROR   : integer range 0 to 1      := 1;
            -- Enable or disable stale descriptor check
            -- 0 = Disable stale descriptor error check
            -- 1 = Enable stale descriptor error check

        C_INCLUDE_CH1               : integer range 0 to 1      := 1;
            -- Include or Exclude channel 1 scatter gather engine
            -- 0 = Exclude Channel 1 SG Engine
            -- 1 = Include Channel 1 SG Engine

        C_INCLUDE_CH2               : integer range 0 to 1      := 1;
            -- Include or Exclude channel 2 scatter gather engine
            -- 0 = Exclude Channel 2 SG Engine
            -- 1 = Include Channel 2 SG Engine

        C_AXIS_IS_ASYNC             : integer range 0 to 1      := 0;
            -- Channel 1 is async to sg_aclk
            -- 0 = Synchronous to SG ACLK
            -- 1 = Asynchronous to SG ACLK

        C_INCLUDE_DESC_UPDATE       : integer range 0 to 1      := 1;
            -- Include or Exclude Scatter Gather Descriptor Update
            -- 0 = Exclude Descriptor Update
            -- 1 = Include Descriptor Update

        C_INCLUDE_INTRPT            : integer range 0 to 1      := 1;
            -- Include/Exclude interrupt logic coalescing
            -- 0 = Exclude Delay timer
            -- 1 = Include Delay timer

        C_INCLUDE_DLYTMR            : integer range 0 to 1      := 1;
            -- Include/Exclude interrupt delay timer
            -- 0 = Exclude Delay timer
            -- 1 = Include Delay timer

        C_DLYTMR_RESOLUTION         : integer range 1 to 100000 := 125;
            -- Interrupt Delay Timer resolution in usec

        C_FAMILY                    : string                    := "virtex6"
            -- Device family used for proper BRAM selection
    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;               --
        m_axi_sg_aresetn            : in  std_logic                         ;               --
                                                                                            --
        dm_resetn                   : in  std_logic                         ;               --
                                                                                            --
        -- Scatter Gather Write Address Channel                                             --
        m_axi_sg_awaddr             : out std_logic_vector                                  --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;               --
        m_axi_sg_awlen              : out std_logic_vector(7 downto 0)      ;               --
        m_axi_sg_awsize             : out std_logic_vector(2 downto 0)      ;               --
        m_axi_sg_awburst            : out std_logic_vector(1 downto 0)      ;               --
        m_axi_sg_awprot             : out std_logic_vector(2 downto 0)      ;               --
        m_axi_sg_awcache            : out std_logic_vector(3 downto 0)      ;               --
        m_axi_sg_awvalid            : out std_logic                         ;               --
        m_axi_sg_awready            : in  std_logic                         ;               --
                                                                                            --
        -- Scatter Gather Write Data Channel                                                --
        m_axi_sg_wdata              : out std_logic_vector                                  --
                                        (C_M_AXI_SG_DATA_WIDTH-1 downto 0)  ;               --
        m_axi_sg_wstrb              : out std_logic_vector                                  --
                                        ((C_M_AXI_SG_DATA_WIDTH/8)-1 downto 0);             --
        m_axi_sg_wlast              : out std_logic                         ;               --
        m_axi_sg_wvalid             : out std_logic                         ;               --
        m_axi_sg_wready             : in  std_logic                         ;               --
                                                                                            --
        -- Scatter Gather Write Response Channel                                            --
        m_axi_sg_bresp              : in  std_logic_vector(1 downto 0)      ;               --
        m_axi_sg_bvalid             : in  std_logic                         ;               --
        m_axi_sg_bready             : out std_logic                         ;               --
                                                                                            --
        -- Scatter Gather Read Address Channel                                              --
        m_axi_sg_araddr             : out std_logic_vector                                  --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;               --
        m_axi_sg_arlen              : out std_logic_vector(7 downto 0)      ;               --
        m_axi_sg_arsize             : out std_logic_vector(2 downto 0)      ;               --
        m_axi_sg_arburst            : out std_logic_vector(1 downto 0)      ;               --
        m_axi_sg_arcache            : out std_logic_vector(3 downto 0)      ;               --
        m_axi_sg_arprot             : out std_logic_vector(2 downto 0)      ;               --
        m_axi_sg_arvalid            : out std_logic                         ;               --
        m_axi_sg_arready            : in  std_logic                         ;               --
                                                                                            --
        -- Memory Map to Stream Scatter Gather Read Data Channel                            --
        m_axi_sg_rdata              : in  std_logic_vector                                  --
                                        (C_M_AXI_SG_DATA_WIDTH-1 downto 0)  ;               --
        m_axi_sg_rresp              : in  std_logic_vector(1 downto 0)      ;               --
        m_axi_sg_rlast              : in  std_logic                         ;               --
        m_axi_sg_rvalid             : in  std_logic                         ;               --
        m_axi_sg_rready             : out std_logic                         ;               --
                                                                                            --
        -- Channel 1 Control and Status                                                     --
        ch1_run_stop                : in  std_logic                         ;               --
        ch1_desc_flush              : in  std_logic                         ;               --
        ch1_tailpntr_enabled        : in  std_logic                         ;               --
        ch1_taildesc_wren           : in  std_logic                         ;               --
        ch1_taildesc                : in  std_logic_vector                                  --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;               --
        ch1_curdesc                 : in  std_logic_vector                                  --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;               --
        ch1_ftch_idle               : out std_logic                         ;               --
        ch1_ftch_interr_set         : out std_logic                         ;               --
        ch1_ftch_slverr_set         : out std_logic                         ;               --
        ch1_ftch_decerr_set         : out std_logic                         ;               --
        ch1_ftch_err_early          : out std_logic                         ;               --
        ch1_ftch_stale_desc         : out std_logic                         ;               --
        ch1_updt_idle               : out std_logic                         ;               --
        ch1_updt_ioc_irq_set        : out std_logic                         ;               --
        ch1_updt_interr_set         : out std_logic                         ;               --
        ch1_updt_slverr_set         : out std_logic                         ;               --
        ch1_updt_decerr_set         : out std_logic                         ;               --
        ch1_dma_interr_set          : out std_logic                         ;               --
        ch1_dma_slverr_set          : out std_logic                         ;               --
        ch1_dma_decerr_set          : out std_logic                         ;               --
                                                                                            --
                                                                                            --
        -- Channel 1 Interrupt Coalescing Signals                                           --
        ch1_irqthresh_rstdsbl       : in  std_logic                         ;
        ch1_dlyirq_dsble            : in  std_logic                         ;               --
        ch1_irqdelay_wren           : in  std_logic                         ;               --
        ch1_irqdelay                : in  std_logic_vector(7 downto 0)      ;               --
        ch1_irqthresh_wren          : in  std_logic                         ;               --
        ch1_irqthresh               : in  std_logic_vector(7 downto 0)      ;               --
        ch1_packet_sof              : in  std_logic                         ;               --
        ch1_packet_eof              : in  std_logic                         ;               --
        ch1_ioc_irq_set             : out std_logic                         ;               --
        ch1_dly_irq_set             : out std_logic                         ;               --
        ch1_irqdelay_status         : out std_logic_vector(7 downto 0)      ;               --
        ch1_irqthresh_status        : out std_logic_vector(7 downto 0)      ;               --
                                                                                            --
        -- Channel 1 AXI Fetch Stream Out                                                   --
        m_axis_ch1_ftch_aclk        : in  std_logic                         ;               --
        m_axis_ch1_ftch_tdata       : out std_logic_vector                                  --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0);               --
        m_axis_ch1_ftch_tvalid      : out std_logic                         ;               --
        m_axis_ch1_ftch_tready      : in  std_logic                         ;               --
        m_axis_ch1_ftch_tlast       : out std_logic                         ;               --
                                                                                            --
                                                                                            --
        -- Channel 1 AXI Update Stream In                                                   --
        s_axis_ch1_updt_aclk        : in  std_logic                         ;               --
        s_axis_ch1_updtptr_tdata    : in  std_logic_vector                                  --
                                        (C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0);           --
        s_axis_ch1_updtptr_tvalid   : in  std_logic                         ;               --
        s_axis_ch1_updtptr_tready   : out std_logic                         ;               --
        s_axis_ch1_updtptr_tlast    : in  std_logic                         ;               --
                                                                                            --
        s_axis_ch1_updtsts_tdata    : in  std_logic_vector                                  --
                                        (C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0);           --
        s_axis_ch1_updtsts_tvalid   : in  std_logic                         ;               --
        s_axis_ch1_updtsts_tready   : out std_logic                         ;               --
        s_axis_ch1_updtsts_tlast    : in  std_logic                         ;               --
                                                                                            --
        -- Channel 2 Control and Status                                                     --
        ch2_run_stop                : in  std_logic                         ;               --
        ch2_desc_flush              : in  std_logic                         ;               --
        ch2_tailpntr_enabled        : in  std_logic                         ;               --
        ch2_taildesc_wren           : in  std_logic                         ;               --
        ch2_taildesc                : in  std_logic_vector                                  --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;               --
        ch2_curdesc                 : in  std_logic_vector                                  --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;               --
        ch2_ftch_idle               : out std_logic                         ;               --
        ch2_ftch_interr_set         : out std_logic                         ;               --
        ch2_ftch_slverr_set         : out std_logic                         ;               --
        ch2_ftch_decerr_set         : out std_logic                         ;               --
        ch2_ftch_err_early          : out std_logic                         ;               --
        ch2_ftch_stale_desc         : out std_logic                         ;               --
        ch2_updt_idle               : out std_logic                         ;               --
        ch2_updt_ioc_irq_set        : out std_logic                         ;               --
        ch2_updt_interr_set         : out std_logic                         ;               --
        ch2_updt_slverr_set         : out std_logic                         ;               --
        ch2_updt_decerr_set         : out std_logic                         ;               --
        ch2_dma_interr_set          : out std_logic                         ;               --
        ch2_dma_slverr_set          : out std_logic                         ;               --
        ch2_dma_decerr_set          : out std_logic                         ;               --
                                                                                            --
        -- Channel 2 Interrupt Coalescing Signals                                           --
        ch2_irqthresh_rstdsbl       : in  std_logic                         ;
        ch2_dlyirq_dsble            : in  std_logic                         ;               --
        ch2_irqdelay_wren           : in  std_logic                         ;               --
        ch2_irqdelay                : in  std_logic_vector(7 downto 0)      ;               --
        ch2_irqthresh_wren          : in  std_logic                         ;               --
        ch2_irqthresh               : in  std_logic_vector(7 downto 0)      ;               --
        ch2_packet_sof              : in  std_logic                         ;               --
        ch2_packet_eof              : in  std_logic                         ;               --
        ch2_ioc_irq_set             : out std_logic                         ;               --
        ch2_dly_irq_set             : out std_logic                         ;               --
        ch2_irqdelay_status         : out std_logic_vector(7 downto 0)      ;               --
        ch2_irqthresh_status        : out std_logic_vector(7 downto 0)      ;               --
                                                                                            --
        -- Channel 2 AXI Fetch Stream Out                                                   --
        m_axis_ch2_ftch_aclk        : in  std_logic                         ;               --
        m_axis_ch2_ftch_tdata       : out std_logic_vector                                  --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0);               --
        m_axis_ch2_ftch_tvalid      : out std_logic                         ;               --
        m_axis_ch2_ftch_tready      : in  std_logic                         ;               --
        m_axis_ch2_ftch_tlast       : out std_logic                         ;               --
                                                                                            --
        -- Channel 2 AXI Update Stream In                                                   --
        s_axis_ch2_updt_aclk        : in  std_logic                         ;               --
        s_axis_ch2_updtptr_tdata    : in  std_logic_vector                                  --
                                        (C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0);           --
        s_axis_ch2_updtptr_tvalid   : in  std_logic                         ;               --
        s_axis_ch2_updtptr_tready   : out std_logic                         ;               --
        s_axis_ch2_updtptr_tlast    : in  std_logic                         ;               --
                                                                                            --
                                                                                            --
        s_axis_ch2_updtsts_tdata    : in  std_logic_vector                                  --
                                        (C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0);           --
        s_axis_ch2_updtsts_tvalid   : in  std_logic                         ;               --
        s_axis_ch2_updtsts_tready   : out std_logic                         ;               --
        s_axis_ch2_updtsts_tlast    : in  std_logic                         ;               --
                                                                                            --
                                                                                            --
        -- Error addresses                                                                  --
        ftch_error                  : out std_logic                         ;               --
        ftch_error_addr             : out std_logic_vector                                  --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;               --
        updt_error                  : out std_logic                         ;               --
        updt_error_addr             : out std_logic_vector                                  --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)                  --
    );

end axi_sg;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_sg is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant AXI_LITE_MODE      : integer := 2;         -- DataMover Lite Mode
constant EXCLUDE            : integer := 0;         -- Define Exclude as 0
constant NEVER_HALT         : std_logic := '0';     -- Never halt sg datamover

-- Always include descriptor fetch (use lite datamover)
constant INCLUDE_DESC_FETCH     : integer := AXI_LITE_MODE;
-- Selectable include descriptor update (use lite datamover)
constant INCLUDE_DESC_UPDATE    : integer := AXI_LITE_MODE * C_INCLUDE_DESC_UPDATE;

-- Always allow address requests
constant ALWAYS_ALLOW       : std_logic := '1';


-- If async mode and number of descriptors to fetch is zero then set number
-- of descriptors to fetch as 1.
constant SG_FTCH_DESC2QUEUE : integer := max2(C_SG_FTCH_DESC2QUEUE,C_AXIS_IS_ASYNC);
constant SG_UPDT_DESC2QUEUE : integer := max2(C_SG_UPDT_DESC2QUEUE,C_AXIS_IS_ASYNC);



-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- DataMover MM2S Fetch Command Stream Signals
signal s_axis_ftch_cmd_tvalid   : std_logic := '0';
signal s_axis_ftch_cmd_tready   : std_logic := '0';
signal s_axis_ftch_cmd_tdata    : std_logic_vector
                                    ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0) := (others => '0');
-- DataMover MM2S Fetch Status Stream Signals
signal m_axis_ftch_sts_tvalid   : std_logic := '0';
signal m_axis_ftch_sts_tready   : std_logic := '0';
signal m_axis_ftch_sts_tdata    : std_logic_vector(7 downto 0) := (others => '0');
signal m_axis_ftch_sts_tkeep    : std_logic_vector(0 downto 0) := (others => '0');
signal mm2s_err                 : std_logic := '0';

-- DataMover MM2S Fetch Stream Signals
signal m_axis_mm2s_tdata        : std_logic_vector
                                    (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)     := (others => '0');
signal m_axis_mm2s_tkeep        : std_logic_vector
                                    ((C_M_AXIS_SG_TDATA_WIDTH/8)-1 downto 0) := (others => '0');
signal m_axis_mm2s_tlast        : std_logic := '0';
signal m_axis_mm2s_tvalid       : std_logic := '0';
signal m_axis_mm2s_tready       : std_logic := '0';

-- DataMover S2MM Update Command Stream Signals
signal s_axis_updt_cmd_tvalid   : std_logic := '0';
signal s_axis_updt_cmd_tready   : std_logic := '0';
signal s_axis_updt_cmd_tdata    : std_logic_vector
                                    ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0) := (others => '0');
-- DataMover S2MM Update Status Stream Signals
signal m_axis_updt_sts_tvalid   : std_logic := '0';
signal m_axis_updt_sts_tready   : std_logic := '0';
signal m_axis_updt_sts_tdata    : std_logic_vector(7 downto 0) := (others => '0');
signal m_axis_updt_sts_tkeep    : std_logic_vector(0 downto 0) := (others => '0');
signal s2mm_err                 : std_logic := '0';

-- DataMover S2MM Update Stream Signals
signal s_axis_s2mm_tdata        : std_logic_vector
                                    (C_M_AXI_SG_DATA_WIDTH-1 downto 0)     := (others => '0');
signal s_axis_s2mm_tkeep        : std_logic_vector
                                    ((C_M_AXI_SG_DATA_WIDTH/8)-1 downto 0) := (others => '1');
signal s_axis_s2mm_tlast        : std_logic := '0';
signal s_axis_s2mm_tvalid       : std_logic := '0';
signal s_axis_s2mm_tready       : std_logic := '0';

-- Channel 1 internals
signal ch1_ftch_active          : std_logic := '0';
signal ch1_ftch_queue_empty     : std_logic := '0';
signal ch1_ftch_queue_full      : std_logic := '0';
signal ch1_nxtdesc_wren         : std_logic := '0';
signal ch1_updt_active          : std_logic := '0';
signal ch1_updt_queue_empty     : std_logic := '0';
signal ch1_updt_curdesc_wren    : std_logic := '0';
signal ch1_updt_curdesc         : std_logic_vector
                                    (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  := (others => '0');
signal ch1_updt_ioc             : std_logic := '0';
signal ch1_updt_ioc_irq_set_i   : std_logic := '0';
signal ch1_dma_interr           : std_logic := '0';
signal ch1_dma_slverr           : std_logic := '0';
signal ch1_dma_decerr           : std_logic := '0';
signal ch1_dma_interr_set_i     : std_logic := '0';
signal ch1_dma_slverr_set_i     : std_logic := '0';
signal ch1_dma_decerr_set_i     : std_logic := '0';
signal ch1_updt_done            : std_logic := '0';
signal ch1_ftch_pause           : std_logic := '0';


-- Channel 2 internals
signal ch2_ftch_active          : std_logic := '0';
signal ch2_ftch_queue_empty     : std_logic := '0';
signal ch2_ftch_queue_full      : std_logic := '0';
signal ch2_nxtdesc_wren         : std_logic := '0';
signal ch2_updt_active          : std_logic := '0';
signal ch2_updt_queue_empty     : std_logic := '0';
signal ch2_updt_curdesc_wren    : std_logic := '0';
signal ch2_updt_curdesc         : std_logic_vector
                                    (C_M_AXI_SG_ADDR_WIDTH-1 downto 0) := (others => '0');
signal ch2_updt_ioc             : std_logic := '0';
signal ch2_updt_ioc_irq_set_i   : std_logic := '0';
signal ch2_dma_interr           : std_logic := '0';
signal ch2_dma_slverr           : std_logic := '0';
signal ch2_dma_decerr           : std_logic := '0';
signal ch2_dma_interr_set_i     : std_logic := '0';
signal ch2_dma_slverr_set_i     : std_logic := '0';
signal ch2_dma_decerr_set_i     : std_logic := '0';
signal ch2_updt_done            : std_logic := '0';
signal ch2_ftch_pause           : std_logic := '0';

signal nxtdesc                  : std_logic_vector
                                    (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)     := (others => '0');

signal ftch_cmnd_wr             : std_logic := '0';
signal ftch_cmnd_data           : std_logic_vector
                                    ((C_M_AXI_SG_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0) := (others => '0');
signal ftch_stale_desc          : std_logic := '0';
signal ftch_error_i             : std_logic := '0';
signal updt_error_i             : std_logic := '0';

signal ch1_irqthresh_decr       : std_logic := '0';
signal ch2_irqthresh_decr       : std_logic := '0'; 

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
updt_error <= updt_error_i;
ftch_error <= ftch_error_i;

-- Always valid therefore fix to '1'
s_axis_s2mm_tkeep       <= (others => '1');

-- Drive interrupt on complete set out
--ch1_updt_ioc_irq_set    <= ch1_updt_ioc_irq_set_i;  
--ch2_updt_ioc_irq_set    <= ch2_updt_ioc_irq_set_i; 

ch1_dma_interr_set      <= ch1_dma_interr_set_i;
ch1_dma_slverr_set      <= ch1_dma_slverr_set_i;
ch1_dma_decerr_set      <= ch1_dma_decerr_set_i;

ch2_dma_interr_set      <= ch2_dma_interr_set_i;
ch2_dma_slverr_set      <= ch2_dma_slverr_set_i;
ch2_dma_decerr_set      <= ch2_dma_decerr_set_i;

-------------------------------------------------------------------------------
-- Scatter Gather Fetch Manager
-------------------------------------------------------------------------------
I_SG_FETCH_MNGR : entity  axi_vdma_v6_3_10.axi_sg_ftch_mngr
    generic map(
        C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH                ,
        C_INCLUDE_CH1               => C_INCLUDE_CH1                        ,
        C_INCLUDE_CH2               => C_INCLUDE_CH2                        ,
        C_SG_CH1_WORDS_TO_FETCH     => C_SG_CH1_WORDS_TO_FETCH              ,
        C_SG_CH2_WORDS_TO_FETCH     => C_SG_CH2_WORDS_TO_FETCH              ,
        C_SG_CH1_ENBL_STALE_ERROR   => C_SG_CH1_ENBL_STALE_ERROR            ,
        C_SG_CH2_ENBL_STALE_ERROR   => C_SG_CH2_ENBL_STALE_ERROR            ,
        C_SG_FTCH_DESC2QUEUE        => SG_FTCH_DESC2QUEUE
    )
    port map(
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               => m_axi_sg_aclk                        ,
        m_axi_sg_aresetn            => m_axi_sg_aresetn                     ,

        -- Channel 1 Control and Status
        ch1_run_stop                => ch1_run_stop                         ,
        ch1_desc_flush              => ch1_desc_flush                       ,
        ch1_updt_done               => ch1_updt_done                        ,
        ch1_ftch_idle               => ch1_ftch_idle                        ,
        ch1_ftch_active             => ch1_ftch_active                      ,
        ch1_ftch_interr_set         => ch1_ftch_interr_set                  ,
        ch1_ftch_slverr_set         => ch1_ftch_slverr_set                  ,
        ch1_ftch_decerr_set         => ch1_ftch_decerr_set                  ,
        ch1_ftch_err_early          => ch1_ftch_err_early                   ,
        ch1_ftch_stale_desc         => ch1_ftch_stale_desc                  ,
        ch1_tailpntr_enabled        => ch1_tailpntr_enabled                 ,
        ch1_taildesc_wren           => ch1_taildesc_wren                    ,
        ch1_taildesc                => ch1_taildesc                         ,
        ch1_nxtdesc_wren            => ch1_nxtdesc_wren                     ,
        ch1_curdesc                 => ch1_curdesc                          ,
        ch1_ftch_queue_empty        => ch1_ftch_queue_empty                 ,
        ch1_ftch_queue_full         => ch1_ftch_queue_full                  ,
        ch1_ftch_pause              => ch1_ftch_pause                       ,

        -- Channel 2 Control and Status
        ch2_run_stop                => ch2_run_stop                         ,
        ch2_desc_flush              => ch2_desc_flush                       ,
        ch2_updt_done               => ch2_updt_done                        ,
        ch2_ftch_idle               => ch2_ftch_idle                        ,
        ch2_ftch_active             => ch2_ftch_active                      ,
        ch2_ftch_interr_set         => ch2_ftch_interr_set                  ,
        ch2_ftch_slverr_set         => ch2_ftch_slverr_set                  ,
        ch2_ftch_decerr_set         => ch2_ftch_decerr_set                  ,
        ch2_ftch_err_early          => ch2_ftch_err_early                   ,
        ch2_ftch_stale_desc         => ch2_ftch_stale_desc                  ,
        ch2_tailpntr_enabled        => ch2_tailpntr_enabled                 ,
        ch2_taildesc_wren           => ch2_taildesc_wren                    ,
        ch2_taildesc                => ch2_taildesc                         ,
        ch2_nxtdesc_wren            => ch2_nxtdesc_wren                     ,
        ch2_curdesc                 => ch2_curdesc                          ,
        ch2_ftch_queue_empty        => ch2_ftch_queue_empty                 ,
        ch2_ftch_queue_full         => ch2_ftch_queue_full                  ,
        ch2_ftch_pause              => ch2_ftch_pause                       ,

        nxtdesc                     => nxtdesc                              ,

        -- Read response for detecting slverr, decerr early
        m_axi_sg_rresp              => m_axi_sg_rresp                       ,
        m_axi_sg_rvalid             => m_axi_sg_rvalid                      ,

        -- User Command Interface Ports (AXI Stream)
        s_axis_ftch_cmd_tvalid      => s_axis_ftch_cmd_tvalid               ,
        s_axis_ftch_cmd_tready      => s_axis_ftch_cmd_tready               ,
        s_axis_ftch_cmd_tdata       => s_axis_ftch_cmd_tdata                ,

        -- User Status Interface Ports (AXI Stream)
        m_axis_ftch_sts_tvalid      => m_axis_ftch_sts_tvalid               ,
        m_axis_ftch_sts_tready      => m_axis_ftch_sts_tready               ,
        m_axis_ftch_sts_tdata       => m_axis_ftch_sts_tdata                ,
        m_axis_ftch_sts_tkeep       => m_axis_ftch_sts_tkeep                ,
        mm2s_err                    => mm2s_err                             ,

        -- DataMover Command
        ftch_cmnd_wr                => ftch_cmnd_wr                         ,
        ftch_cmnd_data              => ftch_cmnd_data                       ,
        ftch_stale_desc             => ftch_stale_desc                      ,
        updt_error                  => updt_error_i                         ,
        ftch_error                  => ftch_error_i                         ,
        ftch_error_addr             => ftch_error_addr
    );

-------------------------------------------------------------------------------
-- Scatter Gather Fetch Queue
-------------------------------------------------------------------------------
I_SG_FETCH_QUEUE : entity  axi_vdma_v6_3_10.axi_sg_ftch_q_mngr
    generic map(
        C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH                ,
        C_M_AXIS_SG_TDATA_WIDTH     => C_M_AXIS_SG_TDATA_WIDTH              ,
        C_SG_FTCH_DESC2QUEUE        => SG_FTCH_DESC2QUEUE                   ,
        C_SG_CH1_WORDS_TO_FETCH     => C_SG_CH1_WORDS_TO_FETCH              ,
        C_SG_CH2_WORDS_TO_FETCH     => C_SG_CH2_WORDS_TO_FETCH              ,
        C_SG_CH1_ENBL_STALE_ERROR   => C_SG_CH1_ENBL_STALE_ERROR            ,
        C_SG_CH2_ENBL_STALE_ERROR   => C_SG_CH2_ENBL_STALE_ERROR            ,
        C_INCLUDE_CH1               => C_INCLUDE_CH1                        ,
        C_INCLUDE_CH2               => C_INCLUDE_CH2                        ,
        C_AXIS_IS_ASYNC             => C_AXIS_IS_ASYNC                      ,
        C_FAMILY                    => C_FAMILY
    )
    port map(
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               => m_axi_sg_aclk                        ,
        m_axi_sg_aresetn            => m_axi_sg_aresetn                     ,

        -- Channel 1 Control
        ch1_desc_flush              => ch1_desc_flush                       ,
        ch1_ftch_active             => ch1_ftch_active                      ,
        ch1_nxtdesc_wren            => ch1_nxtdesc_wren                     ,
        ch1_ftch_queue_empty        => ch1_ftch_queue_empty                 ,
        ch1_ftch_queue_full         => ch1_ftch_queue_full                  ,
        ch1_ftch_pause              => ch1_ftch_pause                       ,

        -- Channel 2 Control
        ch2_ftch_active             => ch2_ftch_active                      ,
        ch2_desc_flush              => ch2_desc_flush                       ,
        ch2_nxtdesc_wren            => ch2_nxtdesc_wren                     ,
        ch2_ftch_queue_empty        => ch2_ftch_queue_empty                 ,
        ch2_ftch_queue_full         => ch2_ftch_queue_full                  ,
        ch2_ftch_pause              => ch2_ftch_pause                       ,

        nxtdesc                     => nxtdesc                              ,

        -- DataMover Command
        ftch_cmnd_wr                => ftch_cmnd_wr                         ,
        ftch_cmnd_data              => ftch_cmnd_data                       ,
        ftch_stale_desc             => ftch_stale_desc                      ,

        -- MM2S Stream In from DataMover
        m_axis_mm2s_tdata           => m_axis_mm2s_tdata                    ,
        m_axis_mm2s_tkeep           => m_axis_mm2s_tkeep                    ,
        m_axis_mm2s_tlast           => m_axis_mm2s_tlast                    ,
        m_axis_mm2s_tvalid          => m_axis_mm2s_tvalid                   ,
        m_axis_mm2s_tready          => m_axis_mm2s_tready                   ,

        -- Channel 1 AXI Fetch Stream Out
        m_axis_ch1_ftch_aclk        => m_axis_ch1_ftch_aclk                 ,
        m_axis_ch1_ftch_tdata       => m_axis_ch1_ftch_tdata                ,
        m_axis_ch1_ftch_tvalid      => m_axis_ch1_ftch_tvalid               ,
        m_axis_ch1_ftch_tready      => m_axis_ch1_ftch_tready               ,
        m_axis_ch1_ftch_tlast       => m_axis_ch1_ftch_tlast                ,

        -- Channel 2 AXI Fetch Stream Out
        m_axis_ch2_ftch_aclk        => m_axis_ch2_ftch_aclk                 ,
        m_axis_ch2_ftch_tdata       => m_axis_ch2_ftch_tdata                ,
        m_axis_ch2_ftch_tvalid      => m_axis_ch2_ftch_tvalid               ,
        m_axis_ch2_ftch_tready      => m_axis_ch2_ftch_tready               ,
        m_axis_ch2_ftch_tlast       => m_axis_ch2_ftch_tlast
    );

-- Include Scatter Gather Descriptor Update logic
GEN_DESC_UPDATE : if C_INCLUDE_DESC_UPDATE = 1 generate
begin

    
    -- Route update version of IOC set to threshold
    -- counter decrement control
    ch1_irqthresh_decr      <= ch1_updt_ioc_irq_set_i;
    ch2_irqthresh_decr      <= ch2_updt_ioc_irq_set_i;

    -- Drive interrupt on complete set out
    ch1_updt_ioc_irq_set    <= ch1_updt_ioc_irq_set_i;
    ch2_updt_ioc_irq_set    <= ch2_updt_ioc_irq_set_i;

    -------------------------------------------------------------------------------
    -- Scatter Gather Update Manager
    -------------------------------------------------------------------------------
    I_SG_UPDATE_MNGR : entity  axi_vdma_v6_3_10.axi_sg_updt_mngr
        generic map(
            C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH                ,
            C_INCLUDE_CH1               => C_INCLUDE_CH1                        ,
            C_INCLUDE_CH2               => C_INCLUDE_CH2                        ,
            C_SG_CH1_WORDS_TO_UPDATE    => C_SG_CH1_WORDS_TO_UPDATE             ,
            C_SG_CH1_FIRST_UPDATE_WORD  => C_SG_CH1_FIRST_UPDATE_WORD           ,
            C_SG_CH2_WORDS_TO_UPDATE    => C_SG_CH2_WORDS_TO_UPDATE             ,
            C_SG_CH2_FIRST_UPDATE_WORD  => C_SG_CH2_FIRST_UPDATE_WORD
        )
        port map(
            m_axi_sg_aclk               => m_axi_sg_aclk                        ,
            m_axi_sg_aresetn            => m_axi_sg_aresetn                     ,

            -- Channel 1 Control and Status
            ch1_updt_idle               => ch1_updt_idle                        ,
            ch1_updt_active             => ch1_updt_active                      ,
            ch1_updt_ioc                => ch1_updt_ioc                         ,
            ch1_updt_ioc_irq_set        => ch1_updt_ioc_irq_set_i               ,

            -- Update Descriptor Status
            ch1_dma_interr              => ch1_dma_interr                       ,
            ch1_dma_slverr              => ch1_dma_slverr                       ,
            ch1_dma_decerr              => ch1_dma_decerr                       ,
            ch1_dma_interr_set          => ch1_dma_interr_set_i                 ,
            ch1_dma_slverr_set          => ch1_dma_slverr_set_i                 ,
            ch1_dma_decerr_set          => ch1_dma_decerr_set_i                 ,
            ch1_updt_interr_set         => ch1_updt_interr_set                  ,
            ch1_updt_slverr_set         => ch1_updt_slverr_set                  ,
            ch1_updt_decerr_set         => ch1_updt_decerr_set                  ,
            ch1_updt_queue_empty        => ch1_updt_queue_empty                 ,
            ch1_updt_curdesc_wren       => ch1_updt_curdesc_wren                ,
            ch1_updt_curdesc            => ch1_updt_curdesc                     ,
            ch1_updt_done               => ch1_updt_done                        ,

            -- Channel 2 Control and Status
            ch2_dma_interr              => ch2_dma_interr                       ,
            ch2_dma_slverr              => ch2_dma_slverr                       ,
            ch2_dma_decerr              => ch2_dma_decerr                       ,
            ch2_updt_idle               => ch2_updt_idle                        ,
            ch2_updt_active             => ch2_updt_active                      ,
            ch2_updt_ioc                => ch2_updt_ioc                         ,
            ch2_updt_ioc_irq_set        => ch2_updt_ioc_irq_set_i               ,
            ch2_dma_interr_set          => ch2_dma_interr_set_i                 ,
            ch2_dma_slverr_set          => ch2_dma_slverr_set_i                 ,
            ch2_dma_decerr_set          => ch2_dma_decerr_set_i                 ,
            ch2_updt_interr_set         => ch2_updt_interr_set                  ,
            ch2_updt_slverr_set         => ch2_updt_slverr_set                  ,
            ch2_updt_decerr_set         => ch2_updt_decerr_set                  ,
            ch2_updt_queue_empty        => ch2_updt_queue_empty                 ,
            ch2_updt_curdesc_wren       => ch2_updt_curdesc_wren                ,
            ch2_updt_curdesc            => ch2_updt_curdesc                     ,
            ch2_updt_done               => ch2_updt_done                        ,

            -- User Command Interface Ports (AXI Stream)
            s_axis_updt_cmd_tvalid      => s_axis_updt_cmd_tvalid               ,
            s_axis_updt_cmd_tready      => s_axis_updt_cmd_tready               ,
            s_axis_updt_cmd_tdata       => s_axis_updt_cmd_tdata                ,

            -- User Status Interface Ports (AXI Stream)
            m_axis_updt_sts_tvalid      => m_axis_updt_sts_tvalid               ,
            m_axis_updt_sts_tready      => m_axis_updt_sts_tready               ,
            m_axis_updt_sts_tdata       => m_axis_updt_sts_tdata                ,
            m_axis_updt_sts_tkeep       => m_axis_updt_sts_tkeep                ,
            s2mm_err                    => s2mm_err                             ,
            ftch_error                  => ftch_error_i                         ,
            updt_error                  => updt_error_i                         ,
            updt_error_addr             => updt_error_addr
        );

    -------------------------------------------------------------------------------
    -- Scatter Gather Update Queue
    -------------------------------------------------------------------------------
    I_SG_UPDATE_QUEUE : entity  axi_vdma_v6_3_10.axi_sg_updt_q_mngr
        generic map(
            C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH                ,
            C_M_AXI_SG_DATA_WIDTH       => C_M_AXI_SG_DATA_WIDTH                ,
            C_S_AXIS_UPDPTR_TDATA_WIDTH => C_S_AXIS_UPDPTR_TDATA_WIDTH          ,
            C_S_AXIS_UPDSTS_TDATA_WIDTH => C_S_AXIS_UPDSTS_TDATA_WIDTH          ,
            C_SG_UPDT_DESC2QUEUE        => SG_UPDT_DESC2QUEUE                   ,
            C_SG_CH1_WORDS_TO_UPDATE    => C_SG_CH1_WORDS_TO_UPDATE             ,
            C_SG_CH2_WORDS_TO_UPDATE    => C_SG_CH2_WORDS_TO_UPDATE             ,
            C_INCLUDE_CH1               => C_INCLUDE_CH1                        ,
            C_INCLUDE_CH2               => C_INCLUDE_CH2                        ,
            C_AXIS_IS_ASYNC             => C_AXIS_IS_ASYNC                      ,
            C_FAMILY                    => C_FAMILY
        )
        port map(
            -----------------------------------------------------------------------
            -- AXI Scatter Gather Interface
            -----------------------------------------------------------------------
            m_axi_sg_aclk               => m_axi_sg_aclk                        ,
            m_axi_sg_aresetn            => m_axi_sg_aresetn                     ,

            -- Channel 1 Control
            ch1_updt_curdesc_wren       => ch1_updt_curdesc_wren                ,
            ch1_updt_curdesc            => ch1_updt_curdesc                     ,
            ch1_updt_active             => ch1_updt_active                      ,
            ch1_updt_queue_empty        => ch1_updt_queue_empty                 ,
            ch1_updt_ioc                => ch1_updt_ioc                         ,
            ch1_updt_ioc_irq_set        => ch1_updt_ioc_irq_set_i               ,

            -- Channel 1 Update Descriptor Status
            ch1_dma_interr              => ch1_dma_interr                       ,
            ch1_dma_slverr              => ch1_dma_slverr                       ,
            ch1_dma_decerr              => ch1_dma_decerr                       ,
            ch1_dma_interr_set          => ch1_dma_interr_set_i                 ,
            ch1_dma_slverr_set          => ch1_dma_slverr_set_i                 ,
            ch1_dma_decerr_set          => ch1_dma_decerr_set_i                 ,

            -- Channel 2 Control
            ch2_updt_active             => ch2_updt_active                      ,
            ch2_updt_curdesc_wren       => ch2_updt_curdesc_wren                ,
            ch2_updt_curdesc            => ch2_updt_curdesc                     ,
            ch2_updt_queue_empty        => ch2_updt_queue_empty                 ,
            ch2_updt_ioc                => ch2_updt_ioc                         ,
            ch2_updt_ioc_irq_set        => ch2_updt_ioc_irq_set_i               ,

            -- Channel 2 Update Descriptor Status
            ch2_dma_interr              => ch2_dma_interr                       ,
            ch2_dma_slverr              => ch2_dma_slverr                       ,
            ch2_dma_decerr              => ch2_dma_decerr                       ,
            ch2_dma_interr_set          => ch2_dma_interr_set_i                 ,
            ch2_dma_slverr_set          => ch2_dma_slverr_set_i                 ,
            ch2_dma_decerr_set          => ch2_dma_decerr_set_i                 ,

            -- S2MM Stream Out To DataMover
            s_axis_s2mm_tdata           => s_axis_s2mm_tdata                    ,
            s_axis_s2mm_tlast           => s_axis_s2mm_tlast                    ,
            s_axis_s2mm_tvalid          => s_axis_s2mm_tvalid                   ,
            s_axis_s2mm_tready          => s_axis_s2mm_tready                   ,

            -- Channel 1 AXI Update Stream In
            s_axis_ch1_updt_aclk        => s_axis_ch1_updt_aclk                 ,
            s_axis_ch1_updtptr_tdata    => s_axis_ch1_updtptr_tdata             ,
            s_axis_ch1_updtptr_tvalid   => s_axis_ch1_updtptr_tvalid            ,
            s_axis_ch1_updtptr_tready   => s_axis_ch1_updtptr_tready            ,
            s_axis_ch1_updtptr_tlast    => s_axis_ch1_updtptr_tlast             ,

            s_axis_ch1_updtsts_tdata    => s_axis_ch1_updtsts_tdata             ,
            s_axis_ch1_updtsts_tvalid   => s_axis_ch1_updtsts_tvalid            ,
            s_axis_ch1_updtsts_tready   => s_axis_ch1_updtsts_tready            ,
            s_axis_ch1_updtsts_tlast    => s_axis_ch1_updtsts_tlast             ,

            -- Channel 2 AXI Update Stream In
            s_axis_ch2_updt_aclk        => s_axis_ch2_updt_aclk                 ,
            s_axis_ch2_updtptr_tdata    => s_axis_ch2_updtptr_tdata             ,
            s_axis_ch2_updtptr_tvalid   => s_axis_ch2_updtptr_tvalid            ,
            s_axis_ch2_updtptr_tready   => s_axis_ch2_updtptr_tready            ,
            s_axis_ch2_updtptr_tlast    => s_axis_ch2_updtptr_tlast             ,

            s_axis_ch2_updtsts_tdata    => s_axis_ch2_updtsts_tdata             ,
            s_axis_ch2_updtsts_tvalid   => s_axis_ch2_updtsts_tvalid            ,
            s_axis_ch2_updtsts_tready   => s_axis_ch2_updtsts_tready            ,
            s_axis_ch2_updtsts_tlast    => s_axis_ch2_updtsts_tlast
        );

end generate GEN_DESC_UPDATE;

-- Exclude Scatter Gather Descriptor Update logic
GEN_NO_DESC_UPDATE : if C_INCLUDE_DESC_UPDATE = 0 generate
begin

        ch1_updt_idle               <= '1';
        ch1_updt_active             <= '0';
--        ch1_updt_ioc_irq_set        <= '0';
        ch1_updt_interr_set         <= '0';
        ch1_updt_slverr_set         <= '0';
        ch1_updt_decerr_set         <= '0';
        ch1_dma_interr_set_i        <= '0';
        ch1_dma_slverr_set_i        <= '0';
        ch1_dma_decerr_set_i        <= '0';
        ch1_updt_done               <= '1'; -- Always done
        ch2_updt_idle               <= '1';
        ch2_updt_active             <= '0';
--        ch2_updt_ioc_irq_set        <= '0';
        ch2_updt_interr_set         <= '0';
        ch2_updt_slverr_set         <= '0';
        ch2_updt_decerr_set         <= '0';
        ch2_dma_interr_set_i        <= '0';
        ch2_dma_slverr_set_i        <= '0';
        ch2_dma_decerr_set_i        <= '0';
        ch2_updt_done               <= '1'; -- Always done
        s_axis_updt_cmd_tvalid      <= '0';
        s_axis_updt_cmd_tdata       <= (others => '0');
        m_axis_updt_sts_tready      <= '0';
        updt_error_i                <= '0';
        updt_error_addr             <= (others => '0');
        ch1_updt_curdesc_wren       <= '0';
        ch1_updt_curdesc            <= (others => '0');
        ch1_updt_queue_empty        <= '0';
        ch1_updt_ioc                <= '0';
        ch1_dma_interr              <= '0';
        ch1_dma_slverr              <= '0';
        ch1_dma_decerr              <= '0';
        ch2_updt_curdesc_wren       <= '0';
        ch2_updt_curdesc            <= (others => '0');
        ch2_updt_queue_empty        <= '0';
        ch2_updt_ioc                <= '0';
        ch2_dma_interr              <= '0';
        ch2_dma_slverr              <= '0';
        ch2_dma_decerr              <= '0';
        s_axis_s2mm_tdata           <= (others => '0');
        s_axis_s2mm_tlast           <= '0';
        s_axis_s2mm_tvalid          <= '0';
        s_axis_ch1_updtptr_tready   <= '0';
        s_axis_ch2_updtptr_tready   <= '0';
        s_axis_ch1_updtsts_tready   <= '0';
        s_axis_ch2_updtsts_tready   <= '0';

        
        -- Route packet eof to threshold counter decrement control
        ch1_irqthresh_decr      <= ch1_packet_eof;
        ch2_irqthresh_decr      <= ch2_packet_eof;

        -- Drive interrupt on complete set out
        ch1_updt_ioc_irq_set    <= ch1_packet_eof;
        ch2_updt_ioc_irq_set    <= ch2_packet_eof;


end generate GEN_NO_DESC_UPDATE;

-------------------------------------------------------------------------------
-- Scatter Gather Interrupt Coalescing
-------------------------------------------------------------------------------
GEN_INTERRUPT_LOGIC : if C_INCLUDE_INTRPT = 1 generate
begin
    I_AXI_SG_INTRPT : entity  axi_vdma_v6_3_10.axi_sg_intrpt
        generic map(

            C_INCLUDE_CH1              => C_INCLUDE_CH1                     ,
            C_INCLUDE_CH2              => C_INCLUDE_CH2                     ,
            C_INCLUDE_DLYTMR           => C_INCLUDE_DLYTMR                  ,
            C_DLYTMR_RESOLUTION        => C_DLYTMR_RESOLUTION
        )
        port map(

            -- Secondary Clock and Reset
            m_axi_sg_aclk               => m_axi_sg_aclk                    ,
            m_axi_sg_aresetn            => m_axi_sg_aresetn                 ,

            ch1_irqthresh_decr          => ch1_irqthresh_decr               , 
            ch1_irqthresh_rstdsbl       => ch1_irqthresh_rstdsbl            ,
            ch1_dlyirq_dsble            => ch1_dlyirq_dsble                 ,
            ch1_irqdelay_wren           => ch1_irqdelay_wren                ,
            ch1_irqdelay                => ch1_irqdelay                     ,
            ch1_irqthresh_wren          => ch1_irqthresh_wren               ,
            ch1_irqthresh               => ch1_irqthresh                    ,
            ch1_packet_sof              => ch1_packet_sof                   ,
            ch1_packet_eof              => ch1_packet_eof                   ,
            ch1_ioc_irq_set             => ch1_ioc_irq_set                  ,
            ch1_dly_irq_set             => ch1_dly_irq_set                  ,
            ch1_irqdelay_status         => ch1_irqdelay_status              ,
            ch1_irqthresh_status        => ch1_irqthresh_status             ,

            ch2_irqthresh_decr          => ch2_irqthresh_decr               ,
            ch2_irqthresh_rstdsbl       => ch2_irqthresh_rstdsbl            ,
            ch2_dlyirq_dsble            => ch2_dlyirq_dsble                 ,
            ch2_irqdelay_wren           => ch2_irqdelay_wren                ,
            ch2_irqdelay                => ch2_irqdelay                     ,
            ch2_irqthresh_wren          => ch2_irqthresh_wren               ,
            ch2_irqthresh               => ch2_irqthresh                    ,
            ch2_packet_sof              => ch2_packet_sof                   ,
            ch2_packet_eof              => ch2_packet_eof                   ,
            ch2_ioc_irq_set             => ch2_ioc_irq_set                  ,
            ch2_dly_irq_set             => ch2_dly_irq_set                  ,
            ch2_irqdelay_status         => ch2_irqdelay_status              ,
            ch2_irqthresh_status        => ch2_irqthresh_status
        );
end generate GEN_INTERRUPT_LOGIC;

GEN_NO_INTRPT_LOGIC : if C_INCLUDE_INTRPT = 0 generate
begin
    ch1_ioc_irq_set         <= '0';
    ch1_dly_irq_set         <= '0';
    ch1_irqdelay_status     <= (others => '0');
    ch1_irqthresh_status    <= (others => '0');

    ch2_ioc_irq_set         <= '0';
    ch2_dly_irq_set         <= '0';
    ch2_irqdelay_status     <= (others => '0');
    ch2_irqthresh_status    <= (others => '0');
end generate GEN_NO_INTRPT_LOGIC;

-------------------------------------------------------------------------------
-- Scatter Gather DataMover Lite
-------------------------------------------------------------------------------
I_SG_AXI_DATAMOVER : entity axi_datamover_v5_1_24.axi_datamover
    generic map(
        C_INCLUDE_MM2S              => INCLUDE_DESC_FETCH,          -- Lite
        C_M_AXI_MM2S_ADDR_WIDTH     => C_M_AXI_SG_ADDR_WIDTH,       -- 32 or 64
        C_M_AXI_MM2S_DATA_WIDTH     => C_M_AXI_SG_DATA_WIDTH,       -- Fixed at 32
        C_M_AXIS_MM2S_TDATA_WIDTH   => C_M_AXI_SG_DATA_WIDTH,       -- Fixed at 32
        C_INCLUDE_MM2S_STSFIFO      => 0,                           -- Exclude
        C_MM2S_STSCMD_FIFO_DEPTH    => 1,                           -- Set to Min
        C_MM2S_STSCMD_IS_ASYNC      => 0,                           -- Synchronous
        C_INCLUDE_MM2S_DRE          => 0,                           -- No DRE
        C_MM2S_BURST_SIZE           => 16,                          -- Set to Min
        C_MM2S_ADDR_PIPE_DEPTH      => 1,                           -- Only 1 outstanding request
        C_MM2S_INCLUDE_SF           => 0,                           -- Exclude Store-and-Forward

        C_INCLUDE_S2MM              => INCLUDE_DESC_UPDATE,         -- Lite
        C_M_AXI_S2MM_ADDR_WIDTH     => C_M_AXI_SG_ADDR_WIDTH,       -- 32 or 64
        C_M_AXI_S2MM_DATA_WIDTH     => C_M_AXI_SG_DATA_WIDTH,       -- Fixed at 32
        C_S_AXIS_S2MM_TDATA_WIDTH   => C_M_AXI_SG_DATA_WIDTH,       -- Fixed at 32
        C_INCLUDE_S2MM_STSFIFO      => 0,                           -- Exclude
        C_S2MM_STSCMD_FIFO_DEPTH    => 1,                           -- Set to Min
        C_S2MM_STSCMD_IS_ASYNC      => 0,                           -- Synchronous
        C_INCLUDE_S2MM_DRE          => 0,                           -- No DRE
        C_S2MM_BURST_SIZE           => 16,                          -- Set to Min;
        C_S2MM_ADDR_PIPE_DEPTH      => 1,                           -- Only 1 outstanding request
        C_S2MM_INCLUDE_SF           => 0,                           -- Exclude Store-and-Forward
        C_FAMILY                    => C_FAMILY
    )
    port map(
        -- MM2S Primary Clock / Reset input
        m_axi_mm2s_aclk             => m_axi_sg_aclk                        ,
        m_axi_mm2s_aresetn          => dm_resetn                            ,
        mm2s_halt                   => NEVER_HALT                           ,
        mm2s_halt_cmplt             => open                                 ,
        mm2s_err                    => mm2s_err                             ,
        mm2s_allow_addr_req         => ALWAYS_ALLOW                         ,
        mm2s_addr_req_posted        => open                                 ,
        mm2s_rd_xfer_cmplt          => open                                 ,

        -- Memory Map to Stream Command FIFO and Status FIFO I/O --------------
        m_axis_mm2s_cmdsts_aclk     => m_axi_sg_aclk                        ,
        m_axis_mm2s_cmdsts_aresetn  => dm_resetn                            ,

        -- User Command Interface Ports (AXI Stream)
        s_axis_mm2s_cmd_tvalid      => s_axis_ftch_cmd_tvalid               ,
        s_axis_mm2s_cmd_tready      => s_axis_ftch_cmd_tready               ,
        s_axis_mm2s_cmd_tdata       => s_axis_ftch_cmd_tdata                ,

        -- User Status Interface Ports (AXI Stream)
        m_axis_mm2s_sts_tvalid      => m_axis_ftch_sts_tvalid               ,
        m_axis_mm2s_sts_tready      => m_axis_ftch_sts_tready               ,
        m_axis_mm2s_sts_tdata       => m_axis_ftch_sts_tdata                ,
        m_axis_mm2s_sts_tkeep       => m_axis_ftch_sts_tkeep                ,
        -- Datamover v4_032_a addional signals not needed for SG 
        --sg_ctl                      => (others => '0')                      ,
        m_axi_mm2s_aruser           => open                                 ,
        m_axi_s2mm_awuser           => open                                 ,



        -- MM2S AXI Address Channel I/O  --------------------------------------
        m_axi_mm2s_arid             => open                                 ,
        m_axi_mm2s_araddr           => m_axi_sg_araddr                      ,
        m_axi_mm2s_arlen            => m_axi_sg_arlen                       ,
        m_axi_mm2s_arsize           => m_axi_sg_arsize                      ,
        m_axi_mm2s_arburst          => m_axi_sg_arburst                     ,
        m_axi_mm2s_arprot           => m_axi_sg_arprot                      ,
        m_axi_mm2s_arcache          => m_axi_sg_arcache                     ,
        m_axi_mm2s_arvalid          => m_axi_sg_arvalid                     ,
        m_axi_mm2s_arready          => m_axi_sg_arready                     ,

        -- MM2S AXI MMap Read Data Channel I/O  -------------------------------
        m_axi_mm2s_rdata            => m_axi_sg_rdata                       ,
        m_axi_mm2s_rresp            => m_axi_sg_rresp                       ,
        m_axi_mm2s_rlast            => m_axi_sg_rlast                       ,
        m_axi_mm2s_rvalid           => m_axi_sg_rvalid                      ,
        m_axi_mm2s_rready           => m_axi_sg_rready                      ,

        -- MM2S AXI Master Stream Channel I/O  --------------------------------
        m_axis_mm2s_tdata           => m_axis_mm2s_tdata                    ,
        m_axis_mm2s_tkeep           => m_axis_mm2s_tkeep                    ,
        m_axis_mm2s_tlast           => m_axis_mm2s_tlast                    ,
        m_axis_mm2s_tvalid          => m_axis_mm2s_tvalid                   ,
        m_axis_mm2s_tready          => m_axis_mm2s_tready                   ,

        -- Testing Support I/O
        mm2s_dbg_sel                => (others => '0')                      ,
        mm2s_dbg_data               => open                                 ,

        -- S2MM Primary Clock/Reset input
        m_axi_s2mm_aclk             => m_axi_sg_aclk                        ,
        m_axi_s2mm_aresetn          => dm_resetn                            ,
        s2mm_halt                   => NEVER_HALT                           ,
        s2mm_halt_cmplt             => open                                 ,
        s2mm_err                    => s2mm_err                             ,
        s2mm_allow_addr_req         => ALWAYS_ALLOW                         ,
        s2mm_addr_req_posted        => open                                 ,
        s2mm_wr_xfer_cmplt          => open                                 ,
        s2mm_ld_nxt_len             => open                                 ,
        s2mm_wr_len                 => open                                 ,

        -- Stream to Memory Map Command FIFO and Status FIFO I/O --------------
        m_axis_s2mm_cmdsts_awclk    => m_axi_sg_aclk                        ,
        m_axis_s2mm_cmdsts_aresetn  => dm_resetn                            ,

        -- User Command Interface Ports (AXI Stream)
        s_axis_s2mm_cmd_tvalid      => s_axis_updt_cmd_tvalid               ,
        s_axis_s2mm_cmd_tready      => s_axis_updt_cmd_tready               ,
        s_axis_s2mm_cmd_tdata       => s_axis_updt_cmd_tdata                ,

        -- User Status Interface Ports (AXI Stream)
        m_axis_s2mm_sts_tvalid      => m_axis_updt_sts_tvalid               ,
        m_axis_s2mm_sts_tready      => m_axis_updt_sts_tready               ,
        m_axis_s2mm_sts_tdata       => m_axis_updt_sts_tdata                ,
        m_axis_s2mm_sts_tkeep       => m_axis_updt_sts_tkeep                ,

        -- S2MM AXI Address Channel I/O  --------------------------------------
        m_axi_s2mm_awid             => open                                 ,
        m_axi_s2mm_awaddr           => m_axi_sg_awaddr                      ,
        m_axi_s2mm_awlen            => m_axi_sg_awlen                       ,
        m_axi_s2mm_awsize           => m_axi_sg_awsize                      ,
        m_axi_s2mm_awburst          => m_axi_sg_awburst                     ,
        m_axi_s2mm_awprot           => m_axi_sg_awprot                      ,
        m_axi_s2mm_awcache          => m_axi_sg_awcache                     ,
        m_axi_s2mm_awvalid          => m_axi_sg_awvalid                     ,
        m_axi_s2mm_awready          => m_axi_sg_awready                     ,

        -- S2MM AXI MMap Write Data Channel I/O  ------------------------------
        m_axi_s2mm_wdata            => m_axi_sg_wdata                       ,
        m_axi_s2mm_wstrb            => m_axi_sg_wstrb                       ,
        m_axi_s2mm_wlast            => m_axi_sg_wlast                       ,
        m_axi_s2mm_wvalid           => m_axi_sg_wvalid                      ,
        m_axi_s2mm_wready           => m_axi_sg_wready                      ,

        -- S2MM AXI MMap Write response Channel I/O  --------------------------
        m_axi_s2mm_bresp            => m_axi_sg_bresp                       ,
        m_axi_s2mm_bvalid           => m_axi_sg_bvalid                      ,
        m_axi_s2mm_bready           => m_axi_sg_bready                      ,

        -- S2MM AXI Slave Stream Channel I/O  ---------------------------------
        s_axis_s2mm_tdata           => s_axis_s2mm_tdata                    ,
        s_axis_s2mm_tkeep           => s_axis_s2mm_tkeep                    ,
        s_axis_s2mm_tlast           => s_axis_s2mm_tlast                    ,
        s_axis_s2mm_tvalid          => s_axis_s2mm_tvalid                   ,
        s_axis_s2mm_tready          => s_axis_s2mm_tready                   ,

        -- Testing Support I/O
        s2mm_dbg_sel                  => (others => '0')                    ,
        s2mm_dbg_data                 => open
    );


end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_pkg
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_pkg.vhd
-- Description: This package contains various constants and functions for
--              AXI VDMA operations.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;
use lib_pkg_v1_0_2.lib_pkg.max2;

package axi_vdma_pkg is

-------------------------------------------------------------------------------
-- Function declarations
-------------------------------------------------------------------------------
function enable_tkeep_connectivity (tdata_dwidth         : integer; tdata_width_calculated : integer; DRE_ON : integer)
            return  integer;




-- CALCULATE mm2s_tdata_width for axi_vdma
function calculated_mm2s_tdata_width (mm2s_tdata_dwidth         : integer)
            return  integer;

function calculated_s2mm_tdata_width (s2mm_tdata_dwidth         : integer)
            return  integer;




function calculated_minimum_mm2s_linebuffer_thresh (mm2s_included : integer; mm2s_tdata_dwidth         : integer; mm2s_linebuffer_depth: integer)
            return  integer;


function calculated_minimum_s2mm_linebuffer_thresh (s2mm_included : integer; s2mm_tdata_dwidth         : integer; s2mm_linebuffer_depth: integer)
            return  integer;


function find_mm2s_fsync      (use_fsync     : integer;
                               mm2s_included : integer;
                               s2mm_included : integer)
            return  integer;


function find_s2mm_fsync      (use_fsync     : integer;
                               mm2s_included : integer;
                               s2mm_included : integer)
            return  integer;

function find_s2mm_fsync_01      (use_s2mm_fsync     : integer)
            return  integer;


function find_mm2s_flush      (use_fsync         : integer;
                               mm2s_included     : integer;
                               s2mm_included     : integer;
                               flush_on_fsync    : integer)
            return  integer;


function find_s2mm_flush      (use_fsync         : integer;
                               mm2s_included     : integer;
                               s2mm_included     : integer;
                               flush_on_fsync    : integer)
            return  integer;





-- Find minimum required btt width
function required_btt_width (dwidth         : integer;
                             burst_size     : integer;
                             btt_width      : integer)
            return  integer;

-- Converts string to interger
function string2int(strngbuf: string)
            return integer;

-- Return number of registers
function get_num_registers(mode             : integer;
                           sg_num           : integer;
                           regdir_num       : integer)
    return integer;

-- Return correct hertz paramter value
function hertz_prmtr_select(included        : integer;
                            lite_frequency  : integer;
                            sg_frequency    : integer)
    return integer;

-- Return SnF enable or disable
function enable_snf (sf_enabled         : integer;
                     axi_data_width     : integer;
                     axis_tdata_width   : integer)
    return integer;

-- Return mm2s index or converted s2mm index
function convert_base_index(channel_is_mm2s : integer;
                            mm2s_index      : integer)
    return integer;

-- Return mm2s index or converted s2mm index
function convert_regdir_index(channel_is_mm2s : integer;
                              mm2s_index      : integer)
    return integer;

-- Return enable genlock bus
function enable_internal_genloc(mm2s_enabled    : integer;
				s2mm_enabled    : integer;
				internal_genlock    : integer;
                                mm2s_genlock_mode   : integer;
                                s2mm_genlock_mode   : integer)
    return integer;

-------------------------------------------------------------------------------
-- Constant Declarations
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- AXI Responce Values
-------------------------------------------------------------------------------
constant OKAY_RESP                  : std_logic_vector(1 downto 0)  := "00";
constant EXOKAY_RESP                : std_logic_vector(1 downto 0)  := "01";
constant SLVERR_RESP                : std_logic_vector(1 downto 0)  := "10";
constant DECERR_RESP                : std_logic_vector(1 downto 0)  := "11";

-------------------------------------------------------------------------------
-- Misc Constants
-------------------------------------------------------------------------------

constant NUM_REG_TOTAL_SG           : integer := 62;
constant NUM_REG_TOTAL_REGDIR       : integer := 62;



----constant NUM_REG_TOTAL_SG           : integer := 20;
----constant NUM_REG_TOTAL_REGDIR       : integer := 59;

--constant NUM_REG_TOTAL_REGDIR       : integer := 156;
--constant NUM_REG_TOTAL_REGDIR       : integer := 123;


constant NUM_REG_PER_CHANNEL        : integer := 8;
constant NUM_DIRECT_REG_PER_CHANNEL : integer := 19;
--constant NUM_DIRECT_REG_PER_CHANNEL : integer := 67;

--constant REG_MSB_ADDR_BIT           : integer := clog2(NUM_REG_TOTAL)-1;
constant CMD_BASE_WIDTH             : integer := 40;
constant BUFFER_LENGTH_WIDTH        : integer := 23;

-- Constants Used in Desc Updates
constant DESC_STS_TYPE              : std_logic := '1';
constant DESC_DATA_TYPE             : std_logic := '0';
constant DESC_LAST                  : std_logic := '1';
constant DESC_NOT_LAST              : std_logic := '0';

-- Clock Domain Crossing Constants
constant CDC_TYPE_PULSE_P_S             : integer := 0;
constant CDC_TYPE_LEVEL_P_S             : integer := 1;
constant CDC_TYPE_PULSE_S_P             : integer := 2;
constant CDC_TYPE_LEVEL_S_P             : integer := 3;
constant CDC_TYPE_VECTR_P_S             : integer := 4;
constant CDC_TYPE_VECTR_S_P             : integer := 5;

constant CDC_TYPE_PULSE_P_S_NO_RST             : integer := 6;
constant CDC_TYPE_LEVEL_P_S_NO_RST             : integer := 7;
constant CDC_TYPE_PULSE_S_P_NO_RST             : integer := 8;
constant CDC_TYPE_LEVEL_S_P_NO_RST             : integer := 9;

constant CDC_TYPE_PULSE_P_S_LL             : integer := 10;

constant CDC_TYPE_PULSE_S_P_LL             : integer := 11;
constant CDC_TYPE_PULSE_P_S_OPEN_ENDED             : integer := 12;
constant CDC_TYPE_PULSE_S_P_OPEN_ENDED             : integer := 13;
constant CDC_TYPE_PULSE_P_S_OPEN_ENDED_NO_RST      : integer := 14;
constant CDC_TYPE_PULSE_S_P_OPEN_ENDED_NO_RST      : integer := 15;

constant MTBF_STAGES             : integer := 4;
constant MTBF_STAGES_LITE        : integer := 3;

-- Interrupt Coalescing
constant ZERO_THRESHOLD             : std_logic_vector(7 downto 0) := (others => '0');
constant ONE_THRESHOLD              : std_logic_vector(7 downto 0) := "00000001";
constant ZERO_DELAY                 : std_logic_vector(7 downto 0) := (others => '0');

-- Frame Store
constant NUM_FRM_STORE_WIDTH        : integer := 6;
constant FRAME_NUMBER_WIDTH         : integer := NUM_FRM_STORE_WIDTH - 1;
constant ZERO_FRAMESTORE            : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0) := (others => '0');
constant ONE_FRAMESTORE             : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0)
                                        := std_logic_vector(to_unsigned(1,NUM_FRM_STORE_WIDTH));
constant MAX_FSTORES                : integer := 32;

-- Line Buffer
constant LINEBUFFER_THRESH_WIDTH    : integer := 17;


-- Video parameter constants
constant VSIZE_DWIDTH               : integer := 13;
constant HSIZE_DWIDTH               : integer := 16;
constant STRIDE_DWIDTH              : integer := 16;
constant FRMDLY_DWIDTH              : integer := FRAME_NUMBER_WIDTH;

constant FRMDLY_MSB                 : integer := 28;
constant FRMDLY_LSB                 : integer := 24;

constant RSVD_BITS_31TO29           : std_logic_vector(2 downto 0) := (others => '0');
constant RSVD_BITS_23TO16           : std_logic_vector(7 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- AXI Lite AXI DMA Register Offsets
-------------------------------------------------------------------------------
constant MM2S_DMACR_INDEX           : integer := 0;
constant MM2S_DMASR_INDEX           : integer := 1;
constant MM2S_CURDESC_LSB_INDEX     : integer := 2;
constant MM2S_CURDESC_MSB_INDEX     : integer := 3;
constant MM2S_TAILDESC_LSB_INDEX    : integer := 4;
constant MM2S_TAILDESC_MSB_INDEX    : integer := 5;
constant MM2S_REG_IND             : integer := 5;
constant MM2S_FRAME_STORE_INDEX     : integer := 6;
constant MM2S_THRESHOLD_INDEX       : integer := 7;
constant RESERVED_20_INDEX          : integer := 8;
constant VDMA_GLPTR_INDEX          : integer := 9;
constant VDMA_PARKPTR_INDEX         : integer := 10;
constant VDMA_VERISON_INDEX         : integer := 11;
constant S2MM_DMACR_INDEX           : integer := 12;
constant S2MM_DMASR_INDEX           : integer := 13;
constant S2MM_CURDESC_LSB_INDEX     : integer := 14;
constant S2MM_CURDESC_MSB_INDEX     : integer := 15;
constant S2MM_DMA_IRQ_MASK          : integer := 15;
constant S2MM_TAILDESC_LSB_INDEX    : integer := 16;
constant S2MM_TAILDESC_MSB_INDEX    : integer := 17;
constant S2MM_REG_IND             : integer := 17;
constant S2MM_FRAME_STORE_INDEX     : integer := 18;
constant S2MM_THRESHOLD_INDEX       : integer := 19;
constant VERTICAL_FLIP_INDEX        : integer := 59; -- Vertical Flip Index
-- Register direct

constant MM2S_VSIZE_INDEX           : integer := 20;
constant MM2S_HSIZE_INDEX           : integer := 21;
constant MM2S_DLYSTRD_INDEX         : integer := 22;

constant MM2S_STARTADDR1_INDEX      : integer := 23;
constant MM2S_STARTADDR2_INDEX      : integer := 24;
constant MM2S_STARTADDR3_INDEX      : integer := 25;
constant MM2S_STARTADDR4_INDEX      : integer := 26;
constant MM2S_STARTADDR5_INDEX      : integer := 27;
constant MM2S_STARTADDR6_INDEX      : integer := 28;
constant MM2S_STARTADDR7_INDEX      : integer := 29;
constant MM2S_STARTADDR8_INDEX      : integer := 30;
constant MM2S_STARTADDR9_INDEX      : integer := 31;
constant MM2S_STARTADDR10_INDEX     : integer := 32;
constant MM2S_STARTADDR11_INDEX     : integer := 33;
constant MM2S_STARTADDR12_INDEX     : integer := 34;
constant MM2S_STARTADDR13_INDEX     : integer := 35;
constant MM2S_STARTADDR14_INDEX     : integer := 36;
constant MM2S_STARTADDR15_INDEX     : integer := 37;
constant MM2S_STARTADDR16_INDEX     : integer := 38;
constant RESERVED_9C_INDEX          : integer := 39;
constant S2MM_VSIZE_INDEX           : integer := 40;
constant S2MM_HSIZE_INDEX           : integer := 41;
constant S2MM_DLYSTRD_INDEX         : integer := 42;
constant S2MM_STARTADDR1_INDEX      : integer := 43;
constant S2MM_STARTADDR2_INDEX      : integer := 44;
constant S2MM_STARTADDR3_INDEX      : integer := 45;
constant S2MM_STARTADDR4_INDEX      : integer := 46;
constant S2MM_STARTADDR5_INDEX      : integer := 47;
constant S2MM_STARTADDR6_INDEX      : integer := 48;
constant S2MM_STARTADDR7_INDEX      : integer := 49;
constant S2MM_STARTADDR8_INDEX      : integer := 50;
constant S2MM_STARTADDR9_INDEX      : integer := 51;
constant S2MM_STARTADDR10_INDEX     : integer := 52;
constant S2MM_STARTADDR11_INDEX     : integer := 53;
constant S2MM_STARTADDR12_INDEX     : integer := 54;
constant S2MM_STARTADDR13_INDEX     : integer := 55;
constant S2MM_STARTADDR14_INDEX     : integer := 56;
constant S2MM_STARTADDR15_INDEX     : integer := 57;
constant S2MM_STARTADDR16_INDEX     : integer := 58;

constant RESERVED_EC_INDEX          : integer := 59;
--constant RESERVED_F0_INDEX          : integer := 60;
constant HSIZE_AT_LLESS_ERR_F0_INDEX          : integer := 60;
--constant RESERVED_F4_INDEX          : integer := 61;
constant VSIZE_AT_FLESS_ERR_F4_INDEX          : integer := 61;
constant RESERVED_F8_INDEX          : integer := 62;
constant RESERVED_FC_INDEX          : integer := 63;
constant RESERVED_100_INDEX         : integer := 64;
constant RESERVED_104_INDEX         : integer := 65;
constant RESERVED_108_INDEX         : integer := 66;
constant RESERVED_10C_INDEX         : integer := 67;
constant RESERVED_110_INDEX         : integer := 68;
constant RESERVED_114_INDEX         : integer := 69;
constant RESERVED_118_INDEX         : integer := 70;
constant RESERVED_11C_INDEX         : integer := 71;
constant RESERVED_120_INDEX         : integer := 72;
constant RESERVED_124_INDEX         : integer := 73;
constant RESERVED_128_INDEX         : integer := 74;
constant RESERVED_12C_INDEX         : integer := 75;
constant RESERVED_130_INDEX         : integer := 76;
constant RESERVED_134_INDEX         : integer := 77;
constant RESERVED_138_INDEX         : integer := 78;
constant RESERVED_13C_INDEX         : integer := 79;
constant RESERVED_140_INDEX         : integer := 80;
constant RESERVED_144_INDEX         : integer := 81;
constant RESERVED_148_INDEX         : integer := 82;
constant RESERVED_14C_INDEX         : integer := 83;
constant RESERVED_150_INDEX         : integer := 84;
constant RESERVED_154_INDEX         : integer := 85;
constant RESERVED_158_INDEX         : integer := 86;


constant MM2S_STARTADDR17_INDEX      : integer := 87;
constant MM2S_STARTADDR18_INDEX      : integer := 88;
constant MM2S_STARTADDR19_INDEX      : integer := 89;
constant MM2S_STARTADDR20_INDEX      : integer := 90;
constant MM2S_STARTADDR21_INDEX      : integer := 91;
constant MM2S_STARTADDR22_INDEX      : integer := 92;
constant MM2S_STARTADDR23_INDEX      : integer := 93;
constant MM2S_STARTADDR24_INDEX      : integer := 94;
constant MM2S_STARTADDR25_INDEX      : integer := 95;
constant MM2S_STARTADDR26_INDEX      : integer := 96;
constant MM2S_STARTADDR27_INDEX      : integer := 97;
constant MM2S_STARTADDR28_INDEX      : integer := 98;
constant MM2S_STARTADDR29_INDEX      : integer := 99;
constant MM2S_STARTADDR30_INDEX      : integer := 100;
constant MM2S_STARTADDR31_INDEX      : integer := 101;
constant MM2S_STARTADDR32_INDEX      : integer := 102;


constant RESERVED_19C_INDEX          : integer := 103;
constant RESERVED_1A0_INDEX          : integer := 104;
constant RESERVED_1A4_INDEX          : integer := 105;
constant RESERVED_1A8_INDEX          : integer := 106;

constant S2MM_STARTADDR17_INDEX      : integer := 107;
constant S2MM_STARTADDR18_INDEX      : integer := 108;
constant S2MM_STARTADDR19_INDEX      : integer := 109;
constant S2MM_STARTADDR20_INDEX      : integer := 110;
constant S2MM_STARTADDR21_INDEX      : integer := 111;
constant S2MM_STARTADDR22_INDEX      : integer := 112;
constant S2MM_STARTADDR23_INDEX      : integer := 113;
constant S2MM_STARTADDR24_INDEX      : integer := 114;
constant S2MM_STARTADDR25_INDEX      : integer := 115;
constant S2MM_STARTADDR26_INDEX      : integer := 116;
constant S2MM_STARTADDR27_INDEX      : integer := 117;
constant S2MM_STARTADDR28_INDEX      : integer := 118;
constant S2MM_STARTADDR29_INDEX      : integer := 119;
constant S2MM_STARTADDR30_INDEX      : integer := 120;
constant S2MM_STARTADDR31_INDEX      : integer := 121;
constant S2MM_STARTADDR32_INDEX      : integer := 122;


-- READ MUX Offsets


constant MM2S_REG_INDEX_OFFSET_90      : std_logic_vector(8 downto 0)  := "000010100";  -- 14
constant S2MM_REG_INDEX_OFFSET_90      : std_logic_vector(8 downto 0)  := "001000100";  -- 44
constant MM2S_REG_INDEX_OFFSET_91      : std_logic_vector(8 downto 0)  := "100010100";  -- 14
constant S2MM_REG_INDEX_OFFSET_91      : std_logic_vector(8 downto 0)  := "101000100";  -- 44

constant MM2S_REG_INDEX_OFFSET_8      : std_logic_vector(7 downto 0)  := "00010100";  -- 14
constant S2MM_REG_INDEX_OFFSET_8      : std_logic_vector(7 downto 0)  := "01000100";  -- 44
-- }                                                                              

                                                                                  
constant MM2S_DMACR_OFFSET_SG          : std_logic_vector(7 downto 0)  := "00000000";  -- 00
constant MM2S_DMASR_OFFSET_SG          : std_logic_vector(7 downto 0)  := "00000100";  -- 04
constant MM2S_CURDESC_LSB_OFFSET_SG    : std_logic_vector(7 downto 0)  := "00001000";  -- 08
constant MM2S_CURDESC_MSB_OFFSET_SG    : std_logic_vector(7 downto 0)  := "00001100";  -- 0C
constant MM2S_TAILDESC_LSB_OFFSET_SG   : std_logic_vector(7 downto 0)  := "00010000";  -- 10
constant MM2S_TAILDESC_MSB_OFFSET_SG   : std_logic_vector(7 downto 0)  := "00010100";  -- 14
constant MM2S_FRAME_STORE_OFFSET_SG    : std_logic_vector(7 downto 0)  := "00011000";  -- 18
constant MM2S_THRESHOLD_OFFSET_SG      : std_logic_vector(7 downto 0)  := "00011100";  -- 1C
constant RESERVED_20_OFFSET_SG         : std_logic_vector(7 downto 0)  := "00100000";  -- 20
constant RESERVED_24_OFFSET_SG         : std_logic_vector(7 downto 0)  := "00100100";  -- 24
constant VDMA_PARK_PTRREF_OFFSET    : std_logic_vector(7 downto 0)  := "00101000";  -- 28
constant VDMA_VERSION_OFFSET        : std_logic_vector(7 downto 0)  := "00101100";  -- 2C
constant VDMA_PARK_PTRREF_OFFSET_SG    : std_logic_vector(7 downto 0)  := "00101000";  -- 28
constant VDMA_VERSION_OFFSET_SG        : std_logic_vector(7 downto 0)  := "00101100";  -- 2C
constant S2MM_DMACR_OFFSET_SG          : std_logic_vector(7 downto 0)  := "00110000";  -- 30
constant S2MM_DMASR_OFFSET_SG          : std_logic_vector(7 downto 0)  := "00110100";  -- 34
constant S2MM_CURDESC_LSB_OFFSET_SG    : std_logic_vector(7 downto 0)  := "00111000";  -- 38
constant S2MM_CURDESC_MSB_OFFSET_SG    : std_logic_vector(7 downto 0)  := "00111100";  -- 3C
constant S2MM_DMA_IRQ_MASK_SG          : std_logic_vector(7 downto 0)  := "00111100";  -- 3C
constant S2MM_TAILDESC_LSB_OFFSET_SG   : std_logic_vector(7 downto 0)  := "01000000";  -- 40
constant S2MM_TAILDESC_MSB_OFFSET_SG   : std_logic_vector(7 downto 0)  := "01000100";  -- 44
constant S2MM_FRAME_STORE_OFFSET_SG    : std_logic_vector(7 downto 0)  := "01001000";  -- 48
constant S2MM_THRESHOLD_OFFSET_SG      : std_logic_vector(7 downto 0)  := "01001100";  -- 4C
------



                                                                                  
constant MM2S_DMACR_OFFSET_8          : std_logic_vector(7 downto 0)  := "00000000";  -- 00
constant MM2S_DMASR_OFFSET_8          : std_logic_vector(7 downto 0)  := "00000100";  -- 04
constant MM2S_CURDESC_LSB_OFFSET_8    : std_logic_vector(7 downto 0)  := "00001000";  -- 08
constant MM2S_CURDESC_MSB_OFFSET_8    : std_logic_vector(7 downto 0)  := "00001100";  -- 0C
constant MM2S_TAILDESC_LSB_OFFSET_8   : std_logic_vector(7 downto 0)  := "00010000";  -- 10
constant MM2S_TAILDESC_MSB_OFFSET_8   : std_logic_vector(7 downto 0)  := "00010100";  -- 14
constant MM2S_FRAME_STORE_OFFSET_8    : std_logic_vector(7 downto 0)  := "00011000";  -- 18
constant MM2S_THRESHOLD_OFFSET_8      : std_logic_vector(7 downto 0)  := "00011100";  -- 1C
constant RESERVED_20_OFFSET_8         : std_logic_vector(7 downto 0)  := "00100000";  -- 20
constant RESERVED_24_OFFSET_8         : std_logic_vector(7 downto 0)  := "00100100";  -- 24
constant VDMA_PARK_PTRREF_OFFSET_8    : std_logic_vector(7 downto 0)  := "00101000";  -- 28
constant VDMA_VERSION_OFFSET_8        : std_logic_vector(7 downto 0)  := "00101100";  -- 2C
constant S2MM_DMACR_OFFSET_8          : std_logic_vector(7 downto 0)  := "00110000";  -- 30
constant S2MM_DMASR_OFFSET_8          : std_logic_vector(7 downto 0)  := "00110100";  -- 34
constant S2MM_CURDESC_LSB_OFFSET_8    : std_logic_vector(7 downto 0)  := "00111000";  -- 38
constant S2MM_CURDESC_MSB_OFFSET_8    : std_logic_vector(7 downto 0)  := "00111100";  -- 3C
constant S2MM_DMA_IRQ_MASK_8          : std_logic_vector(7 downto 0)  := "00111100";  -- 3C
constant S2MM_TAILDESC_LSB_OFFSET_8   : std_logic_vector(7 downto 0)  := "01000000";  -- 40
constant S2MM_TAILDESC_MSB_OFFSET_8   : std_logic_vector(7 downto 0)  := "01000100";  -- 44
constant S2MM_FRAME_STORE_OFFSET_8    : std_logic_vector(7 downto 0)  := "01001000";  -- 48
constant S2MM_THRESHOLD_OFFSET_8      : std_logic_vector(7 downto 0)  := "01001100";  -- 4C
------


                                                                                  
constant MM2S_DMACR_OFFSET_90          : std_logic_vector(8 downto 0)  := "000000000";  -- 000
constant MM2S_DMASR_OFFSET_90          : std_logic_vector(8 downto 0)  := "000000100";  -- 004
constant MM2S_CURDESC_LSB_OFFSET_90    : std_logic_vector(8 downto 0)  := "000001000";  -- 008
constant MM2S_CURDESC_MSB_OFFSET_90    : std_logic_vector(8 downto 0)  := "000001100";  -- 00C
constant MM2S_TAILDESC_LSB_OFFSET_90   : std_logic_vector(8 downto 0)  := "000010000";  -- 010
constant MM2S_TAILDESC_MSB_OFFSET_90   : std_logic_vector(8 downto 0)  := "000010100";  -- 014
constant MM2S_FRAME_STORE_OFFSET_90    : std_logic_vector(8 downto 0)  := "000011000";  -- 018
constant MM2S_THRESHOLD_OFFSET_90      : std_logic_vector(8 downto 0)  := "000011100";  -- 01C
constant RESERVED_20_OFFSET_90         : std_logic_vector(8 downto 0)  := "000100000";  -- 020
constant RESERVED_24_OFFSET_90         : std_logic_vector(8 downto 0)  := "000100100";  -- 024
constant VDMA_PARK_PTRREF_OFFSET_90    : std_logic_vector(8 downto 0)  := "000101000";  -- 028
constant VDMA_VERSION_OFFSET_90        : std_logic_vector(8 downto 0)  := "000101100";  -- 02C
constant S2MM_DMACR_OFFSET_90          : std_logic_vector(8 downto 0)  := "000110000";  -- 030
constant S2MM_DMASR_OFFSET_90          : std_logic_vector(8 downto 0)  := "000110100";  -- 034
constant S2MM_CURDESC_LSB_OFFSET_90    : std_logic_vector(8 downto 0)  := "000111000";  -- 038
constant S2MM_CURDESC_MSB_OFFSET_90    : std_logic_vector(8 downto 0)  := "000111100";  -- 03C
constant S2MM_DMA_IRQ_MASK_OFFSET_90    : std_logic_vector(8 downto 0)  := "000111100";  -- 03C
constant S2MM_TAILDESC_LSB_OFFSET_90   : std_logic_vector(8 downto 0)  := "001000000";  -- 040
constant S2MM_TAILDESC_MSB_OFFSET_90   : std_logic_vector(8 downto 0)  := "001000100";  -- 044
constant S2MM_FRAME_STORE_OFFSET_90    : std_logic_vector(8 downto 0)  := "001001000";  -- 048
constant S2MM_THRESHOLD_OFFSET_90      : std_logic_vector(8 downto 0)  := "001001100";  -- 04C
------

                                                                                  
constant MM2S_DMACR_OFFSET_91          : std_logic_vector(8 downto 0)  := "100000000";  -- 100
constant MM2S_DMASR_OFFSET_91          : std_logic_vector(8 downto 0)  := "100000100";  -- 104
constant MM2S_CURDESC_LSB_OFFSET_91    : std_logic_vector(8 downto 0)  := "100001000";  -- 108
constant MM2S_CURDESC_MSB_OFFSET_91    : std_logic_vector(8 downto 0)  := "100001100";  -- 10C
constant MM2S_TAILDESC_LSB_OFFSET_91   : std_logic_vector(8 downto 0)  := "100010000";  -- 110
constant MM2S_TAILDESC_MSB_OFFSET_91   : std_logic_vector(8 downto 0)  := "100010100";  -- 114
constant MM2S_FRAME_STORE_OFFSET_91    : std_logic_vector(8 downto 0)  := "100011000";  -- 118
constant MM2S_THRESHOLD_OFFSET_91      : std_logic_vector(8 downto 0)  := "100011100";  -- 11C
constant RESERVED_20_OFFSET_91         : std_logic_vector(8 downto 0)  := "100100000";  -- 120
constant RESERVED_24_OFFSET_91         : std_logic_vector(8 downto 0)  := "100100100";  -- 124
constant VDMA_PARK_PTRREF_OFFSET_91    : std_logic_vector(8 downto 0)  := "100101000";  -- 128
constant VDMA_VERSION_OFFSET_91        : std_logic_vector(8 downto 0)  := "100101100";  -- 12C
constant S2MM_DMACR_OFFSET_91          : std_logic_vector(8 downto 0)  := "100110000";  -- 130
constant S2MM_DMASR_OFFSET_91          : std_logic_vector(8 downto 0)  := "100110100";  -- 134
constant S2MM_CURDESC_LSB_OFFSET_91    : std_logic_vector(8 downto 0)  := "100111000";  -- 138
constant S2MM_CURDESC_MSB_OFFSET_91    : std_logic_vector(8 downto 0)  := "100111100";  -- 13C
constant S2MM_DMA_IRQ_MASK_OFFSET_91    : std_logic_vector(8 downto 0)  := "100111100";  -- 13C
constant S2MM_TAILDESC_LSB_OFFSET_91   : std_logic_vector(8 downto 0)  := "101000000";  -- 140
constant S2MM_TAILDESC_MSB_OFFSET_91   : std_logic_vector(8 downto 0)  := "101000100";  -- 144
constant S2MM_FRAME_STORE_OFFSET_91    : std_logic_vector(8 downto 0)  := "101001000";  -- 148
constant S2MM_THRESHOLD_OFFSET_91      : std_logic_vector(8 downto 0)  := "101001100";  -- 14C
------







-------- Register direct READ MUX Offsets
constant MM2S_VSIZE_OFFSET_8          : std_logic_vector(7 downto 0)  := "01010000";  -- 50
constant MM2S_HSIZE_OFFSET_8          : std_logic_vector(7 downto 0)  := "01010100";  -- 54
constant MM2S_DLYSTRD_OFFSET_8        : std_logic_vector(7 downto 0)  := "01011000";  -- 58

constant MM2S_VSIZE_OFFSET_90          : std_logic_vector(8 downto 0)  := "001010000";  -- 050
constant MM2S_HSIZE_OFFSET_90          : std_logic_vector(8 downto 0)  := "001010100";  -- 054
constant MM2S_DLYSTRD_OFFSET_90        : std_logic_vector(8 downto 0)  := "001011000";  -- 058

constant MM2S_VSIZE_OFFSET_91          : std_logic_vector(8 downto 0)  := "101010000";  -- 050
constant MM2S_HSIZE_OFFSET_91          : std_logic_vector(8 downto 0)  := "101010100";  -- 054
constant MM2S_DLYSTRD_OFFSET_91        : std_logic_vector(8 downto 0)  := "101011000";  -- 058




constant MM2S_STARTADDR1_OFFSET_8     : std_logic_vector(7 downto 0)  := "01011100";  -- 5C
constant MM2S_STARTADDR2_OFFSET_8     : std_logic_vector(7 downto 0)  := "01100000";  -- 60
constant MM2S_STARTADDR3_OFFSET_8     : std_logic_vector(7 downto 0)  := "01100100";  -- 64
constant MM2S_STARTADDR4_OFFSET_8     : std_logic_vector(7 downto 0)  := "01101000";  -- 68
constant MM2S_STARTADDR5_OFFSET_8     : std_logic_vector(7 downto 0)  := "01101100";  -- 6C
constant MM2S_STARTADDR6_OFFSET_8     : std_logic_vector(7 downto 0)  := "01110000";  -- 70
constant MM2S_STARTADDR7_OFFSET_8     : std_logic_vector(7 downto 0)  := "01110100";  -- 74
constant MM2S_STARTADDR8_OFFSET_8     : std_logic_vector(7 downto 0)  := "01111000";  -- 78
constant MM2S_STARTADDR9_OFFSET_8     : std_logic_vector(7 downto 0)  := "01111100";  -- 7C
constant MM2S_STARTADDR10_OFFSET_8    : std_logic_vector(7 downto 0)  := "10000000";  -- 80
constant MM2S_STARTADDR11_OFFSET_8    : std_logic_vector(7 downto 0)  := "10000100";  -- 84
constant MM2S_STARTADDR12_OFFSET_8    : std_logic_vector(7 downto 0)  := "10001000";  -- 88
constant MM2S_STARTADDR13_OFFSET_8    : std_logic_vector(7 downto 0)  := "10001100";  -- 8C
constant MM2S_STARTADDR14_OFFSET_8    : std_logic_vector(7 downto 0)  := "10010000";  -- 90
constant MM2S_STARTADDR15_OFFSET_8    : std_logic_vector(7 downto 0)  := "10010100";  -- 94
constant MM2S_STARTADDR16_OFFSET_8    : std_logic_vector(7 downto 0)  := "10011000";  -- 98


constant MM2S_STARTADDR1_OFFSET_90     : std_logic_vector(8 downto 0)  := "001011100";  -- 05C
constant MM2S_STARTADDR2_OFFSET_90     : std_logic_vector(8 downto 0)  := "001100000";  -- 060
constant MM2S_STARTADDR3_OFFSET_90     : std_logic_vector(8 downto 0)  := "001100100";  -- 064
constant MM2S_STARTADDR4_OFFSET_90     : std_logic_vector(8 downto 0)  := "001101000";  -- 068
constant MM2S_STARTADDR5_OFFSET_90     : std_logic_vector(8 downto 0)  := "001101100";  -- 06C
constant MM2S_STARTADDR6_OFFSET_90     : std_logic_vector(8 downto 0)  := "001110000";  -- 070
constant MM2S_STARTADDR7_OFFSET_90     : std_logic_vector(8 downto 0)  := "001110100";  -- 074
constant MM2S_STARTADDR8_OFFSET_90     : std_logic_vector(8 downto 0)  := "001111000";  -- 078
constant MM2S_STARTADDR9_OFFSET_90     : std_logic_vector(8 downto 0)  := "001111100";  -- 07C
constant MM2S_STARTADDR10_OFFSET_90    : std_logic_vector(8 downto 0)  := "010000000";  -- 080
constant MM2S_STARTADDR11_OFFSET_90    : std_logic_vector(8 downto 0)  := "010000100";  -- 084
constant MM2S_STARTADDR12_OFFSET_90    : std_logic_vector(8 downto 0)  := "010001000";  -- 088
constant MM2S_STARTADDR13_OFFSET_90    : std_logic_vector(8 downto 0)  := "010001100";  -- 08C
constant MM2S_STARTADDR14_OFFSET_90    : std_logic_vector(8 downto 0)  := "010010000";  -- 090
constant MM2S_STARTADDR15_OFFSET_90    : std_logic_vector(8 downto 0)  := "010010100";  -- 094
constant MM2S_STARTADDR16_OFFSET_90    : std_logic_vector(8 downto 0)  := "010011000";  -- 098


constant MM2S_STARTADDR1_OFFSET_91     : std_logic_vector(8 downto 0)  := "101011100";  -- 15C
constant MM2S_STARTADDR2_OFFSET_91     : std_logic_vector(8 downto 0)  := "101100000";  -- 160
constant MM2S_STARTADDR3_OFFSET_91     : std_logic_vector(8 downto 0)  := "101100100";  -- 164
constant MM2S_STARTADDR4_OFFSET_91     : std_logic_vector(8 downto 0)  := "101101000";  -- 168
constant MM2S_STARTADDR5_OFFSET_91     : std_logic_vector(8 downto 0)  := "101101100";  -- 16C
constant MM2S_STARTADDR6_OFFSET_91     : std_logic_vector(8 downto 0)  := "101110000";  -- 170
constant MM2S_STARTADDR7_OFFSET_91     : std_logic_vector(8 downto 0)  := "101110100";  -- 174
constant MM2S_STARTADDR8_OFFSET_91     : std_logic_vector(8 downto 0)  := "101111000";  -- 178
constant MM2S_STARTADDR9_OFFSET_91     : std_logic_vector(8 downto 0)  := "101111100";  -- 17C
constant MM2S_STARTADDR10_OFFSET_91    : std_logic_vector(8 downto 0)  := "110000000";  -- 180
constant MM2S_STARTADDR11_OFFSET_91    : std_logic_vector(8 downto 0)  := "110000100";  -- 184
constant MM2S_STARTADDR12_OFFSET_91    : std_logic_vector(8 downto 0)  := "110001000";  -- 188
constant MM2S_STARTADDR13_OFFSET_91    : std_logic_vector(8 downto 0)  := "110001100";  -- 18C
constant MM2S_STARTADDR14_OFFSET_91    : std_logic_vector(8 downto 0)  := "110010000";  -- 190
constant MM2S_STARTADDR15_OFFSET_91    : std_logic_vector(8 downto 0)  := "110010100";  -- 194
constant MM2S_STARTADDR16_OFFSET_91    : std_logic_vector(8 downto 0)  := "110011000";  -- 198



constant RESERVED_9C_OFFSET_90         : std_logic_vector(8 downto 0)  := "010011100";  -- 9C


constant S2MM_VSIZE_OFFSET_8          : std_logic_vector(7 downto 0)  := "10100000";  -- A0
constant S2MM_HSIZE_OFFSET_8          : std_logic_vector(7 downto 0)  := "10100100";  -- A4
constant S2MM_DLYSTRD_OFFSET_8        : std_logic_vector(7 downto 0)  := "10101000";  -- A8
constant VFLIP_OFFSET_8               : std_logic_vector(7 downto 0) := "11101100";  -- EC  

constant S2MM_VSIZE_OFFSET_90          : std_logic_vector(8 downto 0)  := "010100000";  -- A0
constant S2MM_HSIZE_OFFSET_90          : std_logic_vector(8 downto 0)  := "010100100";  -- A4
constant S2MM_DLYSTRD_OFFSET_90        : std_logic_vector(8 downto 0)  := "010101000";  -- A8
constant VFLIP_OFFSET_90               : std_logic_vector(8 downto 0) := "011101100";  -- EC  

constant S2MM_VSIZE_OFFSET_91          : std_logic_vector(8 downto 0)  := "110100000";  -- A0
constant S2MM_HSIZE_OFFSET_91          : std_logic_vector(8 downto 0)  := "110100100";  -- A4
constant S2MM_DLYSTRD_OFFSET_91        : std_logic_vector(8 downto 0)  := "110101000";  -- A8
constant VFLIP_OFFSET_91               : std_logic_vector(8 downto 0) := "111101100";  -- EC  




constant S2MM_STARTADDR1_OFFSET_8     : std_logic_vector(7 downto 0)  := "10101100";  -- AC
constant S2MM_STARTADDR2_OFFSET_8     : std_logic_vector(7 downto 0)  := "10110000";  -- B0
constant S2MM_STARTADDR3_OFFSET_8     : std_logic_vector(7 downto 0)  := "10110100";  -- B4
constant S2MM_STARTADDR4_OFFSET_8     : std_logic_vector(7 downto 0)  := "10111000";  -- B8
constant S2MM_STARTADDR5_OFFSET_8     : std_logic_vector(7 downto 0)  := "10111100";  -- BC
constant S2MM_STARTADDR6_OFFSET_8     : std_logic_vector(7 downto 0)  := "11000000";  -- C0
constant S2MM_STARTADDR7_OFFSET_8     : std_logic_vector(7 downto 0)  := "11000100";  -- C4
constant S2MM_STARTADDR8_OFFSET_8     : std_logic_vector(7 downto 0)  := "11001000";  -- C8
constant S2MM_STARTADDR9_OFFSET_8     : std_logic_vector(7 downto 0)  := "11001100";  -- CC
constant S2MM_STARTADDR10_OFFSET_8    : std_logic_vector(7 downto 0)  := "11010000";  -- D0
constant S2MM_STARTADDR11_OFFSET_8    : std_logic_vector(7 downto 0)  := "11010100";  -- D4
constant S2MM_STARTADDR12_OFFSET_8    : std_logic_vector(7 downto 0)  := "11011000";  -- D8
constant S2MM_STARTADDR13_OFFSET_8    : std_logic_vector(7 downto 0)  := "11011100";  -- DC
constant S2MM_STARTADDR14_OFFSET_8    : std_logic_vector(7 downto 0)  := "11100000";  -- E0
constant S2MM_STARTADDR15_OFFSET_8    : std_logic_vector(7 downto 0)  := "11100100";  -- E4
constant S2MM_STARTADDR16_OFFSET_8    : std_logic_vector(7 downto 0)  := "11101000";  -- E8


constant S2MM_STARTADDR1_OFFSET_90     : std_logic_vector(8 downto 0)  := "010101100";  -- 0AC
constant S2MM_STARTADDR2_OFFSET_90     : std_logic_vector(8 downto 0)  := "010110000";  -- 0B0
constant S2MM_STARTADDR3_OFFSET_90     : std_logic_vector(8 downto 0)  := "010110100";  -- 0B4
constant S2MM_STARTADDR4_OFFSET_90     : std_logic_vector(8 downto 0)  := "010111000";  -- 0B8
constant S2MM_STARTADDR5_OFFSET_90     : std_logic_vector(8 downto 0)  := "010111100";  -- 0BC
constant S2MM_STARTADDR6_OFFSET_90     : std_logic_vector(8 downto 0)  := "011000000";  -- 0C0
constant S2MM_STARTADDR7_OFFSET_90     : std_logic_vector(8 downto 0)  := "011000100";  -- 0C4
constant S2MM_STARTADDR8_OFFSET_90     : std_logic_vector(8 downto 0)  := "011001000";  -- 0C8
constant S2MM_STARTADDR9_OFFSET_90     : std_logic_vector(8 downto 0)  := "011001100";  -- 0CC
constant S2MM_STARTADDR10_OFFSET_90    : std_logic_vector(8 downto 0)  := "011010000";  -- 0D0
constant S2MM_STARTADDR11_OFFSET_90    : std_logic_vector(8 downto 0)  := "011010100";  -- 0D4
constant S2MM_STARTADDR12_OFFSET_90    : std_logic_vector(8 downto 0)  := "011011000";  -- 0D8
constant S2MM_STARTADDR13_OFFSET_90    : std_logic_vector(8 downto 0)  := "011011100";  -- 0DC
constant S2MM_STARTADDR14_OFFSET_90    : std_logic_vector(8 downto 0)  := "011100000";  -- 0E0
constant S2MM_STARTADDR15_OFFSET_90    : std_logic_vector(8 downto 0)  := "011100100";  -- 0E4
constant S2MM_STARTADDR16_OFFSET_90    : std_logic_vector(8 downto 0)  := "011101000";  -- 0E8


--constant RESERVED_EC_OFFSET        : std_logic_vector(8 downto 0) := "011101100";  -- 0EC  
constant RESERVED_F0_OFFSET          : std_logic_vector(8 downto 0) := "011110000";  -- 0F0  
constant RESERVED_F4_OFFSET          : std_logic_vector(8 downto 0) := "011110100";  -- 0F4  
constant RESERVED_F8_OFFSET          : std_logic_vector(8 downto 0) := "011111000";  -- 0F8  
constant RESERVED_FC_OFFSET          : std_logic_vector(8 downto 0) := "011111100";  -- 0FC  
constant RESERVED_100_OFFSET         : std_logic_vector(8 downto 0) := "100000000";  -- 100  
constant RESERVED_104_OFFSET         : std_logic_vector(8 downto 0) := "100000100";  -- 104  
constant RESERVED_108_OFFSET         : std_logic_vector(8 downto 0) := "100001000";  -- 108  
constant RESERVED_10C_OFFSET         : std_logic_vector(8 downto 0) := "100001100";  -- 10C  
constant RESERVED_110_OFFSET         : std_logic_vector(8 downto 0) := "100010000";  -- 110  
constant RESERVED_114_OFFSET         : std_logic_vector(8 downto 0) := "100010100";  -- 114  
constant RESERVED_118_OFFSET         : std_logic_vector(8 downto 0) := "100011000";  -- 118  
constant RESERVED_11C_OFFSET         : std_logic_vector(8 downto 0) := "100011100";  -- 11C  
constant RESERVED_120_OFFSET         : std_logic_vector(8 downto 0) := "100100000";  -- 120  
constant RESERVED_124_OFFSET         : std_logic_vector(8 downto 0) := "100100100";  -- 124  
constant RESERVED_128_OFFSET         : std_logic_vector(8 downto 0) := "100101000";  -- 128  
constant RESERVED_12C_OFFSET         : std_logic_vector(8 downto 0) := "100101100";  -- 12C  
constant RESERVED_130_OFFSET         : std_logic_vector(8 downto 0) := "100110000";  -- 130  
constant RESERVED_134_OFFSET         : std_logic_vector(8 downto 0) := "100110100";  -- 134  
constant RESERVED_138_OFFSET         : std_logic_vector(8 downto 0) := "100111000";  -- 138  
constant RESERVED_13C_OFFSET         : std_logic_vector(8 downto 0) := "100111100";  -- 13C  
constant RESERVED_140_OFFSET         : std_logic_vector(8 downto 0) := "101000000";  -- 140  
constant RESERVED_144_OFFSET         : std_logic_vector(8 downto 0) := "101000100";  -- 144  
constant RESERVED_148_OFFSET         : std_logic_vector(8 downto 0) := "101001000";  -- 148  
constant RESERVED_14C_OFFSET         : std_logic_vector(8 downto 0) := "101001100";  -- 14C  
constant RESERVED_150_OFFSET         : std_logic_vector(8 downto 0) := "101010000";  -- 150  
constant RESERVED_154_OFFSET         : std_logic_vector(8 downto 0) := "101010100";  -- 154  
constant RESERVED_158_OFFSET         : std_logic_vector(8 downto 0) := "101011000";  -- 158  


constant MM2S_STARTADDR17_OFFSET_91     : std_logic_vector(8 downto 0)  := "101011100";  -- 15C
constant MM2S_STARTADDR18_OFFSET_91     : std_logic_vector(8 downto 0)  := "101100000";  -- 160
constant MM2S_STARTADDR19_OFFSET_91     : std_logic_vector(8 downto 0)  := "101100100";  -- 164
constant MM2S_STARTADDR20_OFFSET_91     : std_logic_vector(8 downto 0)  := "101101000";  -- 168
constant MM2S_STARTADDR21_OFFSET_91     : std_logic_vector(8 downto 0)  := "101101100";  -- 16C
constant MM2S_STARTADDR22_OFFSET_91     : std_logic_vector(8 downto 0)  := "101110000";  -- 170
constant MM2S_STARTADDR23_OFFSET_91     : std_logic_vector(8 downto 0)  := "101110100";  -- 174
constant MM2S_STARTADDR24_OFFSET_91     : std_logic_vector(8 downto 0)  := "101111000";  -- 178
constant MM2S_STARTADDR25_OFFSET_91     : std_logic_vector(8 downto 0)  := "101111100";  -- 17C
constant MM2S_STARTADDR26_OFFSET_91     : std_logic_vector(8 downto 0)  := "110000000";  -- 180
constant MM2S_STARTADDR27_OFFSET_91     : std_logic_vector(8 downto 0)  := "110000100";  -- 184
constant MM2S_STARTADDR28_OFFSET_91     : std_logic_vector(8 downto 0)  := "110001000";  -- 188
constant MM2S_STARTADDR29_OFFSET_91     : std_logic_vector(8 downto 0)  := "110001100";  -- 18C
constant MM2S_STARTADDR30_OFFSET_91     : std_logic_vector(8 downto 0)  := "110010000";  -- 190
constant MM2S_STARTADDR31_OFFSET_91     : std_logic_vector(8 downto 0)  := "110010100";  -- 194
constant MM2S_STARTADDR32_OFFSET_91     : std_logic_vector(8 downto 0)  := "110011000";  -- 198


constant RESERVED_19C_OFFSET         : std_logic_vector(8 downto 0)  := "110011100";  -- 19C
constant RESERVED_1A0_OFFSET         : std_logic_vector(8 downto 0)  := "110100000";  -- 1A0
constant RESERVED_1A4_OFFSET         : std_logic_vector(8 downto 0)  := "110100100";  -- 1A4
constant RESERVED_1A8_OFFSET         : std_logic_vector(8 downto 0)  := "110101000";  -- 1A8



constant S2MM_STARTADDR17_OFFSET_91     : std_logic_vector(8 downto 0)  := "110101100";  -- 1AC
constant S2MM_STARTADDR18_OFFSET_91     : std_logic_vector(8 downto 0)  := "110110000";  -- 1B0
constant S2MM_STARTADDR19_OFFSET_91     : std_logic_vector(8 downto 0)  := "110110100";  -- 1B4
constant S2MM_STARTADDR20_OFFSET_91     : std_logic_vector(8 downto 0)  := "110111000";  -- 1B8
constant S2MM_STARTADDR21_OFFSET_91     : std_logic_vector(8 downto 0)  := "110111100";  -- 1BC
constant S2MM_STARTADDR22_OFFSET_91     : std_logic_vector(8 downto 0)  := "111000000";  -- 1C0
constant S2MM_STARTADDR23_OFFSET_91     : std_logic_vector(8 downto 0)  := "111000100";  -- 1C4
constant S2MM_STARTADDR24_OFFSET_91     : std_logic_vector(8 downto 0)  := "111001000";  -- 1C8
constant S2MM_STARTADDR25_OFFSET_91     : std_logic_vector(8 downto 0)  := "111001100";  -- 1CC
constant S2MM_STARTADDR26_OFFSET_91     : std_logic_vector(8 downto 0)  := "111010000";  -- 1D0
constant S2MM_STARTADDR27_OFFSET_91     : std_logic_vector(8 downto 0)  := "111010100";  -- 1D4
constant S2MM_STARTADDR28_OFFSET_91     : std_logic_vector(8 downto 0)  := "111011000";  -- 1D8
constant S2MM_STARTADDR29_OFFSET_91     : std_logic_vector(8 downto 0)  := "111011100";  -- 1DC
constant S2MM_STARTADDR30_OFFSET_91     : std_logic_vector(8 downto 0)  := "111100000";  -- 1E0
constant S2MM_STARTADDR31_OFFSET_91     : std_logic_vector(8 downto 0)  := "111100100";  -- 1E4
constant S2MM_STARTADDR32_OFFSET_91     : std_logic_vector(8 downto 0)  := "111101000";  -- 1E8


-------------------------------------------------------------------------------
-- Register Bit Constants
-------------------------------------------------------------------------------
-- DMACR
constant DMACR_RS_BIT                   : integer := 0;
constant DMACR_CRCLPRK_BIT              : integer := 1;
constant DMACR_RESET_BIT                : integer := 2;
constant DMACR_SYNCEN_BIT               : integer := 3;
constant DMACR_FRMCNTEN_BIT             : integer := 4;
constant DMACR_FSYNCSEL_LSB             : integer := 5;
constant DMACR_FSYNCSEL_MSB             : integer := 6;
constant DMACR_GENLOCK_SEL_BIT          : integer := 7;
constant DMACR_PNTR_NUM_LSB             : integer := 8;
constant DMACR_PNTR_NUM_MSB             : integer := 11;
constant DMACR_IOC_IRQEN_BIT            : integer := 12;
constant DMACR_DLY_IRQEN_BIT            : integer := 13;
constant DMACR_ERR_IRQEN_BIT            : integer := 14;
--constant DMACR_RESERVED15_BIT           : integer := 15;
constant DMACR_REPEAT_EN_BIT            : integer := 15;
constant DMACR_IRQTHRESH_LSB_BIT        : integer := 16;
constant DMACR_IRQTHRESH_MSB_BIT        : integer := 23;
constant DMACR_IRQDELAY_LSB_BIT         : integer := 24;
constant DMACR_IRQDELAY_MSB_BIT         : integer := 31;

-- DMASR
constant DMASR_HALTED_BIT               : integer := 0;
constant DMASR_IDLE_BIT                 : integer := 1;
constant DMASR_RESERVED2_BIT            : integer := 2;
constant DMASR_ERR_BIT                : integer := 3;
constant DMASR_DMAINTERR_BIT            : integer := 4;
constant DMASR_DMASLVERR_BIT            : integer := 5;
constant DMASR_DMADECERR_BIT            : integer := 6;
constant DMASR_FSIZEERR_BIT            : integer := 7;
constant DMASR_LSIZEERR_BIT            : integer := 8;
constant DMASR_SGSLVERR_BIT             : integer := 9;
constant DMASR_SGDECERR_BIT             : integer := 10;
--constant DMASR_RESERVED11_BIT           : integer := 11;
constant DMASR_FSIZE_MORE_OR_SOF_LATE_ERR_BIT           : integer := 11;
constant DMASR_IOCIRQ_BIT               : integer := 12;
constant DMASR_DLYIRQ_BIT               : integer := 13;
constant DMASR_ERRIRQ_BIT               : integer := 14;
constant DMASR_LSIZE_MORE_ERR_BIT           : integer := 15;
constant DMASR_IRQTHRESH_LSB_BIT        : integer := 16;
constant DMASR_IRQTHRESH_MSB_BIT        : integer := 23;
constant DMASR_IRQDELAY_LSB_BIT         : integer := 24;
constant DMASR_IRQDELAY_MSB_BIT         : integer := 31;

-- CURDESC
constant CURDESC_LOWER_MSB_BIT          : integer := 31;
constant CURDESC_LOWER_LSB_BIT          : integer := 5;
constant CURDESC_RESERVED_BIT4          : integer := 4;

-- TAILDESC
constant TAILDESC_LOWER_MSB_BIT         : integer := 31;
constant TAILDESC_LOWER_LSB_BIT         : integer := 5;
constant TAILDESC_RESERVED_BIT4         : integer := 4;
constant TAILDESC_RESERVED_BIT3         : integer := 3;
constant TAILDESC_RESERVED_BIT2         : integer := 2;
constant TAILDESC_RESERVED_BIT1         : integer := 1;
constant TAILDESC_RESERVED_BIT0         : integer := 0;


constant PARKPTR_FRMSTR_RSVD_BIT31      : integer := 31;
constant PARKPTR_FRMSTR_S2MM_MSB_BIT    : integer := 28;
constant PARKPTR_FRMSTR_S2MM_LSB_BIT    : integer := 24;
constant PARKPTR_FRMSTR_MM2S_MSB_BIT    : integer := 20;
constant PARKPTR_FRMSTR_MM2S_LSB_BIT    : integer := 16;
constant PARKPTR_FRMSTR_RSVD_BIT15      : integer := 15;
constant PARKPTR_FRMPTR_S2MM_MSB_BIT    : integer := 12;
constant PARKPTR_FRMPTR_S2MM_LSB_BIT    : integer := 8;
constant PARKPTR_FRMPTR_MM2S_MSB_BIT    : integer := 4;
constant PARKPTR_FRMPTR_MM2S_LSB_BIT    : integer := 0;

-- FRAMESTORE
constant FRMSTORE_LSB_BIT               : integer := 0;
constant FRMSTORE_MSB_BIT               : integer := NUM_FRM_STORE_WIDTH-1;

-- LineBuffer Threshold
constant THRESH_LSB_BIT                 : integer := 0;
constant THRESH_MSB_BIT                 : integer := LINEBUFFER_THRESH_WIDTH-1;

-- DataMover Command / Status Constants
constant DATAMOVER_CMDDONE_BIT          : integer := 7;
constant DATAMOVER_SLVERR_BIT           : integer := 6;
constant DATAMOVER_DECERR_BIT           : integer := 5;
constant DATAMOVER_INTERR_BIT           : integer := 4;
constant DATAMOVER_TAGMSB_BIT           : integer := 3;
constant DATAMOVER_TAGLSB_BIT           : integer := 0;


-- Descriptor Word 0 : NXTDESC PTR LS-WORD
-- Descriptor Word 1 : NXTDESC PTR MS-WORD
-- Descriptor Word 2 : STARTADDR PTR LS-WORD
-- Descriptor Word 3 : STARTADDR PTR MS-WORD
-- Descriptor Word 4
constant DESC_WRD4_VSIZE_LSB_BIT  : integer := 0;
constant DESC_WRD4_VSIZE_MSB_BIT  : integer := 12;
-- Descriptor Word 5
constant DESC_WRD5_HSIZE_LSB_BIT  : integer := 0;
constant DESC_WRD5_HSIZE_MSB_BIT  : integer := 15;
-- Descriptor Word 6
constant DESC_WRD6_STRIDE_LSB_BIT : integer := 0;
constant DESC_WRD6_STRIDE_MSB_BIT : integer := 15;
constant DESC_WRD6_FRMDLY_LSB_BIT : integer := 24;
constant DESC_WRD6_FRMDLY_MSB_BIT : integer := 28;




-- DataMover Command / Status Constants
constant DATAMOVER_STS_CMDDONE_BIT  : integer := 7;
constant DATAMOVER_STS_SLVERR_BIT   : integer := 6;
constant DATAMOVER_STS_DECERR_BIT   : integer := 5;
constant DATAMOVER_STS_INTERR_BIT   : integer := 4;
constant DATAMOVER_STS_TAGMSB_BIT   : integer := 3;
constant DATAMOVER_STS_TAGLSB_BIT   : integer := 0;

constant DATAMOVER_STS_TAGEOF_BIT   : integer := 1;
constant DATAMOVER_STS_TLAST_BIT    : integer := 31;

constant DATAMOVER_CMD_BTTLSB_BIT   : integer := 0;
constant DATAMOVER_CMD_BTTMSB_BIT   : integer := 22;
constant DATAMOVER_CMD_TYPE_BIT     : integer := 23;
constant DATAMOVER_CMD_DSALSB_BIT   : integer := 24;
constant DATAMOVER_CMD_DSAMSB_BIT   : integer := 29;
constant DATAMOVER_CMD_EOF_BIT      : integer := 30;
constant DATAMOVER_CMD_DRR_BIT      : integer := 31;
constant DATAMOVER_CMD_ADDRLSB_BIT  : integer := 32;

-- Note: Bit offset require adding ADDR WIDTH to get to actual bit index
constant DATAMOVER_CMD_ADDRMSB_BOFST: integer := 31;
constant DATAMOVER_CMD_TAGLSB_BOFST : integer := 32;
constant DATAMOVER_CMD_TAGMSB_BOFST : integer := 35;
constant DATAMOVER_CMD_RSVLSB_BOFST : integer := 36;
constant DATAMOVER_CMD_RSVMSB_BOFST : integer := 39;


-- Gen-Lock constants
constant MSTR0              : std_logic_vector(3 downto 0) := "0000";
constant MSTR1              : std_logic_vector(3 downto 0) := "0001";
constant MSTR2              : std_logic_vector(3 downto 0) := "0010";
constant MSTR3              : std_logic_vector(3 downto 0) := "0011";
constant MSTR4              : std_logic_vector(3 downto 0) := "0100";
constant MSTR5              : std_logic_vector(3 downto 0) := "0101";
constant MSTR6              : std_logic_vector(3 downto 0) := "0110";
constant MSTR7              : std_logic_vector(3 downto 0) := "0111";
constant MSTR8              : std_logic_vector(3 downto 0) := "1000";
constant MSTR9              : std_logic_vector(3 downto 0) := "1001";
constant MSTR10             : std_logic_vector(3 downto 0) := "1010";
constant MSTR11             : std_logic_vector(3 downto 0) := "1011";
constant MSTR12             : std_logic_vector(3 downto 0) := "1100";
constant MSTR13             : std_logic_vector(3 downto 0) := "1101";
constant MSTR14             : std_logic_vector(3 downto 0) := "1110";
constant MSTR15             : std_logic_vector(3 downto 0) := "1111";

constant MSTR0_LO_INDEX     : integer := 0;
constant MSTR0_HI_INDEX     : integer := 5;

constant MSTR1_LO_INDEX     : integer := 6;
constant MSTR1_HI_INDEX     : integer := 11;

constant MSTR2_LO_INDEX     : integer := 12;
constant MSTR2_HI_INDEX     : integer := 17;

constant MSTR3_LO_INDEX     : integer := 18;
constant MSTR3_HI_INDEX     : integer := 23;

constant MSTR4_LO_INDEX     : integer := 24;
constant MSTR4_HI_INDEX     : integer := 29;

constant MSTR5_LO_INDEX     : integer := 30;
constant MSTR5_HI_INDEX     : integer := 35;

constant MSTR6_LO_INDEX     : integer := 36;
constant MSTR6_HI_INDEX     : integer := 41;

constant MSTR7_LO_INDEX     : integer := 42;
constant MSTR7_HI_INDEX     : integer := 47;

constant MSTR8_LO_INDEX     : integer := 48;
constant MSTR8_HI_INDEX     : integer := 53;

constant MSTR9_LO_INDEX     : integer := 54;
constant MSTR9_HI_INDEX     : integer := 59;

constant MSTR10_LO_INDEX    : integer := 60;
constant MSTR10_HI_INDEX    : integer := 65;

constant MSTR11_LO_INDEX    : integer := 66;
constant MSTR11_HI_INDEX    : integer := 71;

constant MSTR12_LO_INDEX    : integer := 72;
constant MSTR12_HI_INDEX    : integer := 77;

constant MSTR13_LO_INDEX    : integer := 78;
constant MSTR13_HI_INDEX    : integer := 83;

constant MSTR14_LO_INDEX    : integer := 84;
constant MSTR14_HI_INDEX    : integer := 89;

constant MSTR15_LO_INDEX    : integer := 90;
constant MSTR15_HI_INDEX    : integer := 95;



-------------------------------------------------------------------------------
-- Types
-------------------------------------------------------------------------------
constant BITS_PER_REG       : integer := 32;
constant BITS_PER_REG_64       : integer := 64;

type STARTADDR_ARRAY_TYPE        is array(natural range <>)
                                 of std_logic_vector(BITS_PER_REG - 1 downto 0);

type STARTADDR_ARRAY_TYPE_64        is array(natural range <>)
                                 of std_logic_vector(BITS_PER_REG_64 - 1 downto 0);

end axi_vdma_pkg;

-------------------------------------------------------------------------------
-- PACKAGE BODY
-------------------------------------------------------------------------------
package body axi_vdma_pkg is


    -- coverage off

-------------------------------------------------------------------------------
-- Function to determine minimum bits required for BTT_SIZE field
-------------------------------------------------------------------------------
function required_btt_width (dwidth     : integer;
                             burst_size : integer;
                             btt_width  : integer)
    return integer  is
variable min_width : integer;

begin
    min_width := clog2((dwidth/8)*burst_size)+1;
    if(min_width > btt_width)then
        return min_width;
    else
        return btt_width;
    end if;
end function required_btt_width;

-------------------------------------------------------------------------------
-- String to Integer Function
-------------------------------------------------------------------------------
function string2int(strngbuf: string)
  return integer is
  variable result : integer := 0;
  begin
    for i in 1 to strngbuf'length loop
            case strngbuf(i) is
                    when '0' => result := result*10;
                    when '1' => result := result*10 + 1;
                    when '2' => result := result*10 + 2;
                    when '3' => result := result*10 + 3;
                    when '4' => result := result*10 + 4;
                    when '5' => result := result*10 + 5;
                    when '6' => result := result*10 + 6;
                    when '7' => result := result*10 + 7;
                    when '8' => result := result*10 + 8;
                    when '9' => result := result*10 + 9;
    -- coverage off
                    when others => null;
    -- coverage on
            end case;
    end loop;
    return result;
  end;

--------------------------------------------------------------------------------
--Channel Fsync & Flush decoding
--------------------------------------------------------------------------------

function find_mm2s_fsync      (use_fsync     : integer;
                               mm2s_included : integer;
                               s2mm_included : integer)
            return  integer is
begin
      if   ((mm2s_included = 0 and s2mm_included = 1) or (mm2s_included = 1 and s2mm_included = 0)) then
             if (use_fsync = 0 or  use_fsync = 1)then
             return use_fsync;
             else
             return 0;
             end if;
      elsif(mm2s_included = 1 and s2mm_included = 1) then
             if    (use_fsync = 1 or use_fsync = 2) then
             return 1;
    -- coverage off
             else
             return 0;
    -- coverage on
             end if;
      elsif(mm2s_included = 0 and s2mm_included = 0) then
      return 0;
    -- coverage off
      else
      return 0;
    -- coverage on
      end if;


end function find_mm2s_fsync;

function find_s2mm_fsync_01      (use_s2mm_fsync     : integer)
            return  integer is 
begin
             if (use_s2mm_fsync = 1 or  use_s2mm_fsync = 2)then
             return 1;
             else
             return 0;
             end if;

end function find_s2mm_fsync_01;


function find_s2mm_fsync      (use_fsync     : integer;
                               mm2s_included : integer;
                               s2mm_included : integer)
            return  integer is
begin
      if   ((mm2s_included = 0 and s2mm_included = 1) or (mm2s_included = 1 and s2mm_included = 0)) then
             if (use_fsync = 0 or  use_fsync = 1)then
             return use_fsync;
             else
             return 0;
             end if;
      elsif(mm2s_included = 1 and s2mm_included = 1) then
             if    (use_fsync = 1 or use_fsync = 3) then
             return 1;
    -- coverage off
             else
             return 0;
    -- coverage on
             end if;
      elsif(mm2s_included = 0 and s2mm_included = 0) then
      return 0;
    -- coverage off
      else
      return 0;
    -- coverage on
      end if;


end function find_s2mm_fsync;




function find_mm2s_flush      (use_fsync         : integer;
                               mm2s_included     : integer;
                               s2mm_included     : integer;
                               flush_on_fsync    : integer)
            return  integer is

begin
      if   ((mm2s_included = 0 and s2mm_included = 1) or (mm2s_included = 1 and s2mm_included = 0)) then
             if (use_fsync = 1 and (flush_on_fsync = 0 or flush_on_fsync = 1)) then
             return flush_on_fsync;
             else
             return 0;
             end if;
      elsif(mm2s_included = 1 and s2mm_included = 1) then
             if (use_fsync = 1 and  ( flush_on_fsync = 1 or flush_on_fsync = 2))then
             return 1;
             elsif (use_fsync = 2 and flush_on_fsync = 2)then
             return 1;
             else
             return 0;
             end if;
      elsif(mm2s_included = 0 and s2mm_included = 0) then
      return 0;
    -- coverage off
      else
      return 0;
    -- coverage on
      end if;


end function find_mm2s_flush;



function find_s2mm_flush      (use_fsync         : integer;
                               mm2s_included     : integer;
                               s2mm_included     : integer;
                               flush_on_fsync    : integer)
            return  integer is

begin
      if   ((mm2s_included = 0 and s2mm_included = 1) or (mm2s_included = 1 and s2mm_included = 0)) then
             if (use_fsync = 1 and (flush_on_fsync = 0 or flush_on_fsync = 1)) then
             return flush_on_fsync;
             else
             return 0;
             end if;
      elsif(mm2s_included = 1 and s2mm_included = 1) then
             if (use_fsync = 1 and  ( flush_on_fsync = 1 or flush_on_fsync = 3))then
             return 1;
             elsif (use_fsync = 3 and flush_on_fsync = 3)then
             return 1;
             else
             return 0;
             end if;
      elsif(mm2s_included = 0 and s2mm_included = 0) then
      return 0;
    -- coverage off
      else
      return 0;
    -- coverage on
      end if;


end function find_s2mm_flush;

    -- coverage on

----------------------------------------------------------------------------------------------------------
-- Function to calculate minimum threshold value for MM2S Line buffer based on TDATA, and LineBuffer Depth 
----------------------------------------------------------------------------------------------------------


function calculated_minimum_mm2s_linebuffer_thresh (mm2s_included : integer; mm2s_tdata_dwidth         : integer; mm2s_linebuffer_depth : integer)
            return  integer is



begin
    if(mm2s_included = 0 or mm2s_linebuffer_depth = 0)then
        return 4;
    elsif(mm2s_included = 1 and mm2s_linebuffer_depth > 0 and mm2s_tdata_dwidth = 8) then
        return 1;
    elsif(mm2s_included = 1 and mm2s_linebuffer_depth > 0 and mm2s_tdata_dwidth = 16) then
        return 2;
    elsif(mm2s_included = 1 and mm2s_linebuffer_depth > 0 and mm2s_tdata_dwidth = 32) then
        return 4;
    elsif(mm2s_included = 1 and mm2s_linebuffer_depth > 0 and mm2s_tdata_dwidth = 64) then
        return 8;
    elsif(mm2s_included = 1 and mm2s_linebuffer_depth > 0 and mm2s_tdata_dwidth = 128) then
        return 16;
    elsif(mm2s_included = 1 and mm2s_linebuffer_depth > 0 and mm2s_tdata_dwidth = 256) then
        return 32;
    elsif(mm2s_included = 1 and mm2s_linebuffer_depth > 0 and mm2s_tdata_dwidth = 512) then
        return 64;
    elsif(mm2s_included = 1 and mm2s_linebuffer_depth > 0 and mm2s_tdata_dwidth = 1024) then
        return 128;
        -- coverage off
    else
        return 128 ;
    -- coverage on
    end if;
end function calculated_minimum_mm2s_linebuffer_thresh;


function calculated_minimum_s2mm_linebuffer_thresh (s2mm_included : integer; s2mm_tdata_dwidth         : integer; s2mm_linebuffer_depth : integer)
            return  integer is



begin
    if(s2mm_included = 0 or s2mm_linebuffer_depth = 0)then
        return 4;
    elsif(s2mm_included = 1 and s2mm_linebuffer_depth > 0 and s2mm_tdata_dwidth = 8) then
        return 1;
    elsif(s2mm_included = 1 and s2mm_linebuffer_depth > 0 and s2mm_tdata_dwidth = 16) then
        return 2;
    elsif(s2mm_included = 1 and s2mm_linebuffer_depth > 0 and s2mm_tdata_dwidth = 32) then
        return 4;
    elsif(s2mm_included = 1 and s2mm_linebuffer_depth > 0 and s2mm_tdata_dwidth = 64) then
        return 8;
    elsif(s2mm_included = 1 and s2mm_linebuffer_depth > 0 and s2mm_tdata_dwidth = 128) then
        return 16;
    elsif(s2mm_included = 1 and s2mm_linebuffer_depth > 0 and s2mm_tdata_dwidth = 256) then
        return 32;
    elsif(s2mm_included = 1 and s2mm_linebuffer_depth > 0 and s2mm_tdata_dwidth = 512) then
        return 64;
    elsif(s2mm_included = 1 and s2mm_linebuffer_depth > 0 and s2mm_tdata_dwidth = 1024) then
        return 128;
        -- coverage off
    else
        return 128 ;
    -- coverage on
    end if;
end function calculated_minimum_s2mm_linebuffer_thresh;




-------------------------------------------------------------------------------
-- Function to calculate C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED from C_M_AXIS_MM2S_TDATA_WIDTH 
-------------------------------------------------------------------------------
function calculated_mm2s_tdata_width (mm2s_tdata_dwidth         : integer)
            return  integer is


begin
    if(mm2s_tdata_dwidth <= 16)then
        return mm2s_tdata_dwidth;
    elsif(mm2s_tdata_dwidth > 16 and mm2s_tdata_dwidth <= 32) then
        return 32;
    elsif(mm2s_tdata_dwidth > 32 and mm2s_tdata_dwidth <= 64) then
        return 64;
    elsif(mm2s_tdata_dwidth > 64 and mm2s_tdata_dwidth <= 128) then
        return 128;
    elsif(mm2s_tdata_dwidth > 128 and mm2s_tdata_dwidth <= 256) then
        return 256;
    elsif(mm2s_tdata_dwidth > 256 and mm2s_tdata_dwidth <= 512) then
        return 512;
    elsif(mm2s_tdata_dwidth > 512 and mm2s_tdata_dwidth <= 1024) then
        return 1024;
    -- coverage off
    else
        return 32 ;
    -- coverage on
    end if;
end function calculated_mm2s_tdata_width;


function calculated_s2mm_tdata_width (s2mm_tdata_dwidth         : integer)
            return  integer is


begin
    if(s2mm_tdata_dwidth <= 16)then
        return s2mm_tdata_dwidth;
    elsif(s2mm_tdata_dwidth > 16 and s2mm_tdata_dwidth <= 32) then
        return 32;
    elsif(s2mm_tdata_dwidth > 32 and s2mm_tdata_dwidth <= 64) then
        return 64;
    elsif(s2mm_tdata_dwidth > 64 and s2mm_tdata_dwidth <= 128) then
        return 128;
    elsif(s2mm_tdata_dwidth > 128 and s2mm_tdata_dwidth <= 256) then
        return 256;
    elsif(s2mm_tdata_dwidth > 256 and s2mm_tdata_dwidth <= 512) then
        return 512;
    elsif(s2mm_tdata_dwidth > 512 and s2mm_tdata_dwidth <= 1024) then
        return 1024;
    -- coverage off
    else
        return 32 ;
    -- coverage on
    end if;
end function calculated_s2mm_tdata_width;



function enable_tkeep_connectivity (tdata_dwidth         : integer; tdata_width_calculated : integer; DRE_ON : integer)
            return  integer is

begin

    if(DRE_ON = 1 or ( tdata_width_calculated /=  tdata_dwidth))then
        return 1;

    else
        return 0 ;
    end if;



end function enable_tkeep_connectivity;






-------------------------------------------------------------------------------
-- function to return number of registers depending on mode of operation
-------------------------------------------------------------------------------
function get_num_registers(mode         : integer;
                           sg_num       : integer;
                           regdir_num   : integer)
    return integer is
    begin
        -- 1 = Scatter Gather Mode
        -- 0 = Register Direct Mode
        if(mode = 1)then
            return sg_num;
        else
            return regdir_num;
        end if;
    end;

    -- coverage off
-------------------------------------------------------------------------------
-- function to return Frequency Hertz parameter based on inclusion of sg engine
-------------------------------------------------------------------------------
function hertz_prmtr_select(included        : integer;
                            lite_frequency  : integer;
                            sg_frequency    : integer)
    return integer is
    begin
        -- 1 = Scatter Gather Included
        -- 0 = Scatter Gather Excluded
        if(included = 1)then
            return sg_frequency;
        else
            return lite_frequency;
        end if;
    end;

    -- coverage on
-------------------------------------------------------------------------------
-- function to enable store and forward based on data width mismatch
-- or directly enabled
-------------------------------------------------------------------------------
function enable_snf (sf_enabled         : integer;
                     axi_data_width     : integer;
                     axis_tdata_width   : integer)
    return integer is
    begin
        -- If store and forward enable or data widths do not
        -- match then return 1 to enable snf
        if( (sf_enabled = 1) or (axi_data_width /= axis_tdata_width))then
            return 1;
        else
            return 0;
        end if;
    end;



-------------------------------------------------------------------------------
-- Convert mm2s index to an s2mm index for the base registers
-------------------------------------------------------------------------------
function convert_base_index(channel_is_mm2s : integer;
                            mm2s_index      : integer)
    return integer is
    variable new_index : integer := 0;
    begin
        if(channel_is_mm2s = 1)then
            return mm2s_index;
        else
            new_index := mm2s_index + 12;
            return new_index;
        end if;
    end;

-------------------------------------------------------------------------------
-- Convert mm2s index to an s2mm index for the regdir registers
-------------------------------------------------------------------------------
function convert_regdir_index(channel_is_mm2s : integer;
                              mm2s_index      : integer)
    return integer is
    variable new_index : integer := 0;
    begin
        if(channel_is_mm2s = 1)then
            return mm2s_index;
        else
            --new_index := mm2s_index + 68;
            new_index := mm2s_index + 20;
            return new_index;
        end if;
    end;

-------------------------------------------------------------------------------
-- enable internal genlock bus based on genlock modes and internal genlock
-- parameters.
-------------------------------------------------------------------------------
function enable_internal_genloc(mm2s_enabled    : integer;
				s2mm_enabled    : integer;
				internal_genlock    : integer;
                                mm2s_genlock_mode   : integer;
                                s2mm_genlock_mode   : integer)

    return integer is


    begin
        -- internal genlock turned OFF at parameter or if NOT both channel enabled.
        if(internal_genlock = 0 or mm2s_enabled = 0 or s2mm_enabled = 0)then
            return 0;
        -- at least one channel must be a master and one be a slave
        -- before turning ON the internal genlock bus
        elsif( (mm2s_genlock_mode = 0 and  s2mm_genlock_mode = 1)
             or (mm2s_genlock_mode = 1 and  s2mm_genlock_mode = 0))then
                return 1;
        elsif( (mm2s_genlock_mode = 2 and  s2mm_genlock_mode = 3)
             or (mm2s_genlock_mode = 3 and  s2mm_genlock_mode = 2))then
                return 1;
        -- either both are maters or both are slaves therefore
        -- turn OFF internal genlock bus
        else
            return 0;
        end if;
    end;





end package body axi_vdma_pkg;


-------------------------------------------------------------------------------
-- axi_vdma_cdc
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_vdma_cdc.vhd
-- Description: This entity encompases the Clock Domain Crossing Pulse
--              Generator
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_cdc is
    generic (
        C_CDC_TYPE                  : integer range 0 to 15 := 0                 ;
            -- Clock domain crossing type
            -- 0 = pulse primary to secondary clk
            -- 1 = level primary to secondary clk
            -- 2 = pulse secondary to primary clk
            -- 3 = level secondary to primary clk
            -- 4 = vectr primary to secondary clk
            -- 5 = vectr secondary to primary clk

            -- 6 = pulse primary to secondary clk  --No reset
            -- 7 = level primary to secondary clk  --No reset
            -- 8 = pulse secondary to primary clk  --No reset
            -- 9 = level secondary to primary clk  --No reset
            -- 10 = pulse primary to secondary clk  --Low latency
            -- 11 = pulse secondary to primary clk  --Low latency
            -- 12 = pulse primary to secondary clk open ended
            -- 13 = pulse secondary to primary clk open ended
            -- 12 = pulse primary to secondary clk open ended -No reset
            -- 13 = pulse secondary to primary clk open ended -No reset

        C_RESET_STATE               : integer range 0 to 1 := 0                 ;

        C_VECTOR_WIDTH              : integer := 32
            -- Vector Data witdth
    );

    port (
        prmry_aclk                  : in  std_logic                             ;               --
        prmry_resetn                : in  std_logic                             ;               --
                                                                                                --
        scndry_aclk                 : in  std_logic                             ;               --
        scndry_resetn               : in  std_logic                             ;               --
                                                                                                --
        -- Secondary to Primary Clock Crossing                                                  --
        scndry_in                   : in  std_logic                             ;               --
        prmry_out                   : out std_logic                             ;               --
                                                                                                --
        -- Primary to Secondary Clock Crossing                                                  --
        prmry_in                    : in  std_logic                             ;               --
        scndry_out                  : out std_logic                             ;               --
                                                                                                --
        scndry_vect_s_h             : in  std_logic                             ;               --
        scndry_vect_in              : in  std_logic_vector                                      --
                                        (C_VECTOR_WIDTH - 1 downto 0)           ;               --
        prmry_vect_out              : out std_logic_vector                                      --
                                        (C_VECTOR_WIDTH - 1 downto 0)           ;               --
                                                                                                --
        prmry_vect_s_h              : in  std_logic                             ;               --
        prmry_vect_in               : in  std_logic_vector                                      --
                                        (C_VECTOR_WIDTH - 1 downto 0)           ;               --
        scndry_vect_out             : out std_logic_vector                                      --
                                        (C_VECTOR_WIDTH - 1 downto 0)                           --

    );

end axi_vdma_cdc;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_cdc is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
-- Generate PULSE clock domain crossing
GENERATE_PULSE_P_S_CDC_OPEN_ENDED : if C_CDC_TYPE = CDC_TYPE_PULSE_P_S_OPEN_ENDED generate

-- Primary to Secondary
signal s_out_d1_cdc_to          : std_logic := '0';
signal s_out_d2           	: std_logic := '0';
signal s_out_d3           	: std_logic := '0';
signal s_out_d4           	: std_logic := '0';
signal s_out_re           	: std_logic := '0';
signal prmry_in_xored           : std_logic := '0';
signal p_in_d1_cdc_from   	: std_logic := '0';



 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      	: STRING;
  ATTRIBUTE async_reg OF s_out_d1_cdc_to  	: SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_out_d2  		: SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_out_d3  		: SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_out_d4  		: SIGNAL IS "true"; 

begin

    --*****************************************************************************
    --**                  Asynchronous Pulse Clock Crossing                      **
    --**                        PRIMARY TO SECONDARY     OPEN-ENDED                          **
    --*****************************************************************************

prmry_in_xored <= prmry_in xor p_in_d1_cdc_from;
 
    REG_P_IN : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(prmry_resetn = '0')then
                    p_in_d1_cdc_from  <= '0';
                else
                    p_in_d1_cdc_from  <= prmry_in_xored;
                end if;
            end if;
        end process REG_P_IN;


    P_IN_CROSS2SCNDRY : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(scndry_resetn = '0')then
                    s_out_d1_cdc_to  	<= '0';
                    s_out_d2  		<= '0';
                    s_out_d3  		<= '0';
                    s_out_d4  		<= '0';
                else
                    s_out_d1_cdc_to  	<= p_in_d1_cdc_from;
                    s_out_d2  		<= s_out_d1_cdc_to;
                    s_out_d3  		<= s_out_d2;
                    s_out_d4  		<= s_out_d3;
                end if;
            end if;
        end process P_IN_CROSS2SCNDRY;


                    s_out_re  <= s_out_d3 xor s_out_d4;

   -- Feed secondary pulse out
    scndry_out <= s_out_re;
    prmry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');


end generate GENERATE_PULSE_P_S_CDC_OPEN_ENDED;

GENERATE_PULSE_P_S_CDC_OPEN_ENDED_NO_RST : if C_CDC_TYPE = CDC_TYPE_PULSE_P_S_OPEN_ENDED_NO_RST generate

-- Primary to Secondary
signal s_out_d1_cdc_to          : std_logic := '0';
signal s_out_d2           	: std_logic := '0';
signal s_out_d3           	: std_logic := '0';
signal s_out_d4           	: std_logic := '0';
signal s_out_re           	: std_logic := '0';
signal prmry_in_xored           : std_logic := '0';
signal p_in_d1_cdc_from   	: std_logic := '0';



 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      	: STRING;
  ATTRIBUTE async_reg OF s_out_d1_cdc_to  	: SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_out_d2  		: SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_out_d3  		: SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_out_d4  		: SIGNAL IS "true"; 

begin

    --*****************************************************************************
    --**                  Asynchronous Pulse Clock Crossing                      **
    --**                        PRIMARY TO SECONDARY     OPEN-ENDED                          **
    --*****************************************************************************

prmry_in_xored <= prmry_in xor p_in_d1_cdc_from;
 
    REG_P_IN : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                --if(prmry_resetn = '0')then
                --    p_in_d1_cdc_from  <= '0';
                --else
                    p_in_d1_cdc_from  <= prmry_in_xored;
                --end if;
            end if;
        end process REG_P_IN;


    P_IN_CROSS2SCNDRY : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                --if(scndry_resetn = '0')then
                --    s_out_d1_cdc_to  	<= '0';
                --    s_out_d2  		<= '0';
                --    s_out_d3  		<= '0';
                --    s_out_d4  		<= '0';
                --else
                    s_out_d1_cdc_to  	<= p_in_d1_cdc_from;
                    s_out_d2  		<= s_out_d1_cdc_to;
                    s_out_d3  		<= s_out_d2;
                    s_out_d4  		<= s_out_d3;
                --end if;
            end if;
        end process P_IN_CROSS2SCNDRY;


                    s_out_re  <= s_out_d3 xor s_out_d4;

   -- Feed secondary pulse out
    scndry_out <= s_out_re;
    prmry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');


end generate GENERATE_PULSE_P_S_CDC_OPEN_ENDED_NO_RST;

GENERATE_PULSE_S_P_CDC_OPEN_ENDED : if C_CDC_TYPE = CDC_TYPE_PULSE_S_P_OPEN_ENDED generate

-- Primary to Secondary
signal p_out_d1_cdc_to          : std_logic := '0';
signal p_out_d2           	: std_logic := '0';
signal p_out_d3           	: std_logic := '0';
signal p_out_d4           	: std_logic := '0';
signal p_out_re           	: std_logic := '0';
signal scndry_in_xored          : std_logic := '0';
signal s_in_d1_cdc_from   	: std_logic := '0';



 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      	: STRING;
  ATTRIBUTE async_reg OF p_out_d1_cdc_to  	: SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_out_d2  		: SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_out_d3  		: SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_out_d4  		: SIGNAL IS "true"; 

begin

    --*****************************************************************************
    --**                  Asynchronous Pulse Clock Crossing                      **
    --**                        PRIMARY TO SECONDARY     OPEN-ENDED                          **
    --*****************************************************************************

scndry_in_xored <= scndry_in xor s_in_d1_cdc_from;
 
    REG_S_IN : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(scndry_resetn = '0')then
                    s_in_d1_cdc_from  <= '0';
                else
                    s_in_d1_cdc_from  <= scndry_in_xored;
                end if;
            end if;
        end process REG_S_IN;


    S_IN_CROSS2PRMRY : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(prmry_resetn = '0')then
                    p_out_d1_cdc_to  	<= '0';
                    p_out_d2  		<= '0';
                    p_out_d3  		<= '0';
                    p_out_d4  		<= '0';
                else
                    p_out_d1_cdc_to  	<= s_in_d1_cdc_from;
                    p_out_d2  		<= p_out_d1_cdc_to;
                    p_out_d3  		<= p_out_d2;
                    p_out_d4  		<= p_out_d3;
                end if;
            end if;
        end process S_IN_CROSS2PRMRY;


                    p_out_re  <= p_out_d3 xor p_out_d4;

   -- Feed secondary pulse out
    prmry_out <= p_out_re;
    scndry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');


end generate GENERATE_PULSE_S_P_CDC_OPEN_ENDED;

GENERATE_PULSE_S_P_CDC_OPEN_ENDED_NO_RST : if C_CDC_TYPE = CDC_TYPE_PULSE_S_P_OPEN_ENDED_NO_RST generate

-- Primary to Secondary
signal p_out_d1_cdc_to          : std_logic := '0';
signal p_out_d2           	: std_logic := '0';
signal p_out_d3           	: std_logic := '0';
signal p_out_d4           	: std_logic := '0';
signal p_out_re           	: std_logic := '0';
signal scndry_in_xored          : std_logic := '0';
signal s_in_d1_cdc_from   	: std_logic := '0';



 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      	: STRING;
  ATTRIBUTE async_reg OF p_out_d1_cdc_to  	: SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_out_d2  		: SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_out_d3  		: SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_out_d4  		: SIGNAL IS "true"; 

begin

    --*****************************************************************************
    --**                  Asynchronous Pulse Clock Crossing                      **
    --**                        PRIMARY TO SECONDARY     OPEN-ENDED                          **
    --*****************************************************************************

scndry_in_xored <= scndry_in xor s_in_d1_cdc_from;
 
    REG_S_IN : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                --if(scndry_resetn = '0')then
                --    s_in_d1_cdc_from  <= '0';
                --else
                    s_in_d1_cdc_from  <= scndry_in_xored;
                --end if;
            end if;
        end process REG_S_IN;


    S_IN_CROSS2PRMRY : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                --if(prmry_resetn = '0')then
                --    p_out_d1_cdc_to  	<= '0';
                --    p_out_d2  		<= '0';
                --    p_out_d3  		<= '0';
                --    p_out_d4  		<= '0';
                --else
                    p_out_d1_cdc_to  	<= s_in_d1_cdc_from;
                    p_out_d2  		<= p_out_d1_cdc_to;
                    p_out_d3  		<= p_out_d2;
                    p_out_d4  		<= p_out_d3;
                --end if;
            end if;
        end process S_IN_CROSS2PRMRY;


                    p_out_re  <= p_out_d3 xor p_out_d4;

   -- Feed secondary pulse out
    prmry_out <= p_out_re;
    scndry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');




end generate GENERATE_PULSE_S_P_CDC_OPEN_ENDED_NO_RST;




-- Generate PULSE clock domain crossing
GENERATE_PULSE_P_S_CDC : if C_CDC_TYPE = CDC_TYPE_PULSE_P_S generate

-- Primary to Secondary
signal p_pulse_in_s_h_cdc_from           : std_logic := '0';
signal p_pulse_in_s_h_clr       : std_logic := '0';
signal s_pulse_out_d1_cdc_to           : std_logic := '0';
signal s_pulse_out_d2           : std_logic := '0';
signal s_pulse_out_d3           : std_logic := '0';
signal s_pulse_out_re           : std_logic := '0';
signal s_pulse_out_s_h_cdc_from          : std_logic := '0';
signal p_pulse_out_s_h_d1_cdc_to       : std_logic := '0';
signal p_pulse_out_s_h_d2       : std_logic := '0';
signal p_pulse_out_s_h_d3       : std_logic := '0';



 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF s_pulse_out_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_d2  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_d3  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_re  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_s_h_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_s_h_d2  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_s_h_d3  : SIGNAL IS "true"; 


begin

    --*****************************************************************************
    --**                  Asynchronous Pulse Clock Crossing                      **
    --**                        PRIMARY TO SECONDARY                             **
    --*****************************************************************************
    -- Limitations:
    -- For prmry_aclk faster than scndry_aclk then limited to pulse period greater
    -- than (prmry_clk_freq / scndry_clk_freq) * 5
    -- For prmry_aclk slower than scndry_aclk then limited to pulse period greater
    -- than (scndry_clk_freq / prmry_clk_freq) / 5

    -- Sample and hold primary pulse
    PRMRY_IN_S_H_PULSE : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(prmry_resetn = '0' or p_pulse_in_s_h_clr='1')then
                    p_pulse_in_s_h_cdc_from <= '0';
                elsif(prmry_in = '1')then
                    p_pulse_in_s_h_cdc_from <= '1';
                end if;
            end if;
        end process PRMRY_IN_S_H_PULSE;

    -- Cross sample and held pulse to secondary domain
    P_IN_CROSS2SCNDRY : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(scndry_resetn = '0')then
                    s_pulse_out_d1_cdc_to  <= '0';
                    s_pulse_out_d2  <= '0';
                    s_pulse_out_d3  <= '0';
                    s_pulse_out_re  <= '0';
                else
                    s_pulse_out_d1_cdc_to  <= p_pulse_in_s_h_cdc_from;
                    s_pulse_out_d2  <= s_pulse_out_d1_cdc_to;
                    s_pulse_out_d3  <= s_pulse_out_d2;
                    s_pulse_out_re  <= s_pulse_out_d2 and not s_pulse_out_d3;
                end if;
            end if;
        end process P_IN_CROSS2SCNDRY;

    -- Sample and hold secondary pulse for clearing primary sampled
    -- and held pulse
    SCNDRY_OUT_S_H_PULSE : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(scndry_resetn = '0' or s_pulse_out_d2='0')then
                    s_pulse_out_s_h_cdc_from <= '0';
                elsif(s_pulse_out_re = '1')then
                    s_pulse_out_s_h_cdc_from <= '1';
                end if;
            end if;
        end process SCNDRY_OUT_S_H_PULSE;

    -- Cross sample and held pulse to primary domain
    S_OUT_CROSS2PRMRY : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(prmry_resetn = '0')then
                    p_pulse_out_s_h_d1_cdc_to   <= '0';
                    p_pulse_out_s_h_d2   <= '0';
                    p_pulse_out_s_h_d3   <= '0';
                else
                    p_pulse_out_s_h_d1_cdc_to   <= s_pulse_out_s_h_cdc_from;
                    p_pulse_out_s_h_d2   <= p_pulse_out_s_h_d1_cdc_to;
                    p_pulse_out_s_h_d3   <= p_pulse_out_s_h_d2;
                end if;
            end if;
        end process S_OUT_CROSS2PRMRY;

    -- Create sample and hold clear
    p_pulse_in_s_h_clr <= p_pulse_out_s_h_d2 and not p_pulse_out_s_h_d3;

    -- Feed secondary pulse out
    scndry_out <= s_pulse_out_re;
    prmry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');


end generate GENERATE_PULSE_P_S_CDC;

GENERATE_PULSE_P_S_CDC_LL : if C_CDC_TYPE = CDC_TYPE_PULSE_P_S_LL generate

-- Primary to Secondary
signal p_pulse_in_s_h_cdc_from           : std_logic := '0';
signal p_pulse_in_s_h_clr       : std_logic := '0';
signal s_pulse_out_d1_cdc_to           : std_logic := '0';
signal s_pulse_out_d2           : std_logic := '0';
signal s_pulse_out_d3           : std_logic := '0';
signal s_pulse_out_re           : std_logic := '0';
signal s_pulse_out_s_h_cdc_from          : std_logic := '0';
signal p_pulse_out_s_h_d1_cdc_to       : std_logic := '0';
signal p_pulse_out_s_h_d2       : std_logic := '0';
signal p_pulse_out_s_h_d3       : std_logic := '0';



 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF s_pulse_out_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_d2  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_d3  : SIGNAL IS "true"; 
  --ATTRIBUTE async_reg OF s_pulse_out_re  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_s_h_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_s_h_d2  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_s_h_d3  : SIGNAL IS "true"; 


begin

    --*****************************************************************************
    --**                  Asynchronous Pulse Clock Crossing                      **
    --**                        PRIMARY TO SECONDARY                             **
    --*****************************************************************************
    -- Limitations:
    -- For prmry_aclk faster than scndry_aclk then limited to pulse period greater
    -- than (prmry_clk_freq / scndry_clk_freq) * 5
    -- For prmry_aclk slower than scndry_aclk then limited to pulse period greater
    -- than (scndry_clk_freq / prmry_clk_freq) / 5

    -- Sample and hold primary pulse
    PRMRY_IN_S_H_PULSE : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(prmry_resetn = '0' or p_pulse_in_s_h_clr='1')then
                    p_pulse_in_s_h_cdc_from <= '0';
                elsif(prmry_in = '1')then
                    p_pulse_in_s_h_cdc_from <= '1';
                end if;
            end if;
        end process PRMRY_IN_S_H_PULSE;

    -- Cross sample and held pulse to secondary domain
    P_IN_CROSS2SCNDRY : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(scndry_resetn = '0')then
                    s_pulse_out_d1_cdc_to  <= '0';
                    s_pulse_out_d2  <= '0';
                    s_pulse_out_d3  <= '0';
                    --s_pulse_out_re  <= '0';
                else
                    s_pulse_out_d1_cdc_to  <= p_pulse_in_s_h_cdc_from;
                    s_pulse_out_d2  <= s_pulse_out_d1_cdc_to;
                    s_pulse_out_d3  <= s_pulse_out_d2;
                    --s_pulse_out_re  <= s_pulse_out_d2 and not s_pulse_out_d3;
                end if;
            end if;
        end process P_IN_CROSS2SCNDRY;

                    s_pulse_out_re  <= s_pulse_out_d2 and not s_pulse_out_d3;
 

   -- Sample and hold secondary pulse for clearing primary sampled
    -- and held pulse
    SCNDRY_OUT_S_H_PULSE : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(scndry_resetn = '0' or s_pulse_out_d2='0')then
                    s_pulse_out_s_h_cdc_from <= '0';
                elsif(s_pulse_out_re = '1')then
                    s_pulse_out_s_h_cdc_from <= '1';
                end if;
            end if;
        end process SCNDRY_OUT_S_H_PULSE;

    -- Cross sample and held pulse to primary domain
    S_OUT_CROSS2PRMRY : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(prmry_resetn = '0')then
                    p_pulse_out_s_h_d1_cdc_to   <= '0';
                    p_pulse_out_s_h_d2   <= '0';
                    p_pulse_out_s_h_d3   <= '0';
                else
                    p_pulse_out_s_h_d1_cdc_to   <= s_pulse_out_s_h_cdc_from;
                    p_pulse_out_s_h_d2   <= p_pulse_out_s_h_d1_cdc_to;
                    p_pulse_out_s_h_d3   <= p_pulse_out_s_h_d2;
                end if;
            end if;
        end process S_OUT_CROSS2PRMRY;

    -- Create sample and hold clear
    p_pulse_in_s_h_clr <= p_pulse_out_s_h_d2 and not p_pulse_out_s_h_d3;

    -- Feed secondary pulse out
    scndry_out <= s_pulse_out_re;
    prmry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');


end generate GENERATE_PULSE_P_S_CDC_LL;




-- Generate PULSE clock domain crossing --No reset (resetn = 1)
GENERATE_PULSE_P_S_CDC_NO_RST : if C_CDC_TYPE = CDC_TYPE_PULSE_P_S_NO_RST generate

-- Primary to Secondary
signal p_pulse_in_s_h_cdc_from           : std_logic := '0';
signal p_pulse_in_s_h_clr       : std_logic := '0';
signal s_pulse_out_d1_cdc_to           : std_logic := '0';
signal s_pulse_out_d2           : std_logic := '0';
signal s_pulse_out_d3           : std_logic := '0';
signal s_pulse_out_re           : std_logic := '0';
signal s_pulse_out_s_h_cdc_from          : std_logic := '0';
signal p_pulse_out_s_h_d1_cdc_to       : std_logic := '0';
signal p_pulse_out_s_h_d2       : std_logic := '0';
signal p_pulse_out_s_h_d3       : std_logic := '0';



 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF s_pulse_out_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_d2  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_d3  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_re  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_s_h_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_s_h_d2  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_s_h_d3  : SIGNAL IS "true"; 


begin

    --*****************************************************************************
    --**                  Asynchronous Pulse Clock Crossing                      **
    --**                        PRIMARY TO SECONDARY                             **
    --*****************************************************************************
    -- Limitations:
    -- For prmry_aclk faster than scndry_aclk then limited to pulse period greater
    -- than (prmry_clk_freq / scndry_clk_freq) * 5
    -- For prmry_aclk slower than scndry_aclk then limited to pulse period greater
    -- than (scndry_clk_freq / prmry_clk_freq) / 5

    -- Sample and hold primary pulse
    PRMRY_IN_S_H_PULSE : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(p_pulse_in_s_h_clr='1')then
                    p_pulse_in_s_h_cdc_from <= '0';
                elsif(prmry_in = '1')then
                    p_pulse_in_s_h_cdc_from <= '1';
                end if;
            end if;
        end process PRMRY_IN_S_H_PULSE;

    -- Cross sample and held pulse to secondary domain
    P_IN_CROSS2SCNDRY : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                    s_pulse_out_d1_cdc_to  <= p_pulse_in_s_h_cdc_from;
                    s_pulse_out_d2  <= s_pulse_out_d1_cdc_to;
                    s_pulse_out_d3  <= s_pulse_out_d2;
                    s_pulse_out_re  <= s_pulse_out_d2 and not s_pulse_out_d3;
                end if;
        end process P_IN_CROSS2SCNDRY;

    -- Sample and hold secondary pulse for clearing primary sampled
    -- and held pulse
    SCNDRY_OUT_S_H_PULSE : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(s_pulse_out_d2='0')then
                    s_pulse_out_s_h_cdc_from <= '0';
                elsif(s_pulse_out_re = '1')then
                    s_pulse_out_s_h_cdc_from <= '1';
                end if;
            end if;
        end process SCNDRY_OUT_S_H_PULSE;

    -- Cross sample and held pulse to primary domain
    S_OUT_CROSS2PRMRY : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                    p_pulse_out_s_h_d1_cdc_to   <= s_pulse_out_s_h_cdc_from;
                    p_pulse_out_s_h_d2   <= p_pulse_out_s_h_d1_cdc_to;
                    p_pulse_out_s_h_d3   <= p_pulse_out_s_h_d2;
            end if;
        end process S_OUT_CROSS2PRMRY;

    -- Create sample and hold clear
    p_pulse_in_s_h_clr <= p_pulse_out_s_h_d2 and not p_pulse_out_s_h_d3;

    -- Feed secondary pulse out
    scndry_out <= s_pulse_out_re;
    prmry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');


end generate GENERATE_PULSE_P_S_CDC_NO_RST;



-- Generate PULSE clock domain crossing
GENERATE_PULSE_CDC_S_P : if C_CDC_TYPE = CDC_TYPE_PULSE_S_P generate
-- Secondary to Primary
signal s_pulse_in_s_h_cdc_from           : std_logic := '0';
signal s_pulse_in_s_h_clr       : std_logic := '0';
signal p_pulse_out_d1_cdc_to           : std_logic := '0';
signal p_pulse_out_d2           : std_logic := '0';
signal p_pulse_out_d3           : std_logic := '0';
signal p_pulse_out_re           : std_logic := '0';
signal p_pulse_out_s_h_cdc_from          : std_logic := '0';
signal s_pulse_out_s_h_d1_cdc_to       : std_logic := '0';
signal s_pulse_out_s_h_d2       : std_logic := '0';
signal s_pulse_out_s_h_d3       : std_logic := '0';


 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF p_pulse_out_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_d2  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_d3  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_re  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_s_h_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_s_h_d2  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_s_h_d3  : SIGNAL IS "true"; 


begin


    --*****************************************************************************
    --**                  Asynchronous Pulse Clock Crossing                      **
    --**                        SECONDARY TO PRIMARY                             **
    --*****************************************************************************
    -- Limitations:
    -- For scndry_aclk faster than prmry_aclk then limited to pulse period greater
    -- than (prmry_clk_freq / scndry_clk_freq) * 5
    -- For scndry_aclk slower than prmry_aclk then limited to pulse period greater
    -- than (scndry_clk_freq / prmry_clk_freq) / 5

    -- Sample and hold secondary pulse
    SCNDRY_IN_S_H_PULSE : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(scndry_resetn = '0' or s_pulse_in_s_h_clr='1')then
                    s_pulse_in_s_h_cdc_from <= '0';
                elsif(scndry_in = '1')then
                    s_pulse_in_s_h_cdc_from <= '1';
                end if;
            end if;
        end process SCNDRY_IN_S_H_PULSE;

    -- Cross sample and held pulse to primary domain
    S_IN_CROSS2PRMRY : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(prmry_resetn = '0')then
                    p_pulse_out_d1_cdc_to  <= '0';
                    p_pulse_out_d2  <= '0';
                    p_pulse_out_d3  <= '0';
                    p_pulse_out_re  <= '0';
                else
                    p_pulse_out_d1_cdc_to  <= s_pulse_in_s_h_cdc_from;
                    p_pulse_out_d2  <= p_pulse_out_d1_cdc_to;
                    p_pulse_out_d3  <= p_pulse_out_d2;
                    p_pulse_out_re  <= p_pulse_out_d2 and not p_pulse_out_d3;
                end if;
            end if;
        end process S_IN_CROSS2PRMRY;

    -- Sample and hold primary pulse for clearing secondary sampled
    -- and held pulse
    PRMRY_OUT_S_H_PULSE : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(prmry_resetn = '0' or p_pulse_out_d2='0')then
                    p_pulse_out_s_h_cdc_from <= '0';
                elsif(p_pulse_out_re = '1')then
                    p_pulse_out_s_h_cdc_from <= '1';
                end if;
            end if;
        end process PRMRY_OUT_S_H_PULSE;

    -- Cross sample and held pulse to secondary domain
    P_OUT_CROSS2SCDNRY : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(scndry_resetn = '0')then
                    s_pulse_out_s_h_d1_cdc_to   <= '0';
                    s_pulse_out_s_h_d2   <= '0';
                    s_pulse_out_s_h_d3   <= '0';
                else
                    s_pulse_out_s_h_d1_cdc_to   <= p_pulse_out_s_h_cdc_from;
                    s_pulse_out_s_h_d2   <= s_pulse_out_s_h_d1_cdc_to;
                    s_pulse_out_s_h_d3   <= s_pulse_out_s_h_d2;
                end if;
            end if;
        end process P_OUT_CROSS2SCDNRY;

    -- Create sample and hold clear
    s_pulse_in_s_h_clr <= s_pulse_out_s_h_d2 and not s_pulse_out_s_h_d3;

    -- Feed primary pulse out
    prmry_out <= p_pulse_out_re;
    scndry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');
end generate GENERATE_PULSE_CDC_S_P;


GENERATE_PULSE_CDC_S_P_LL : if C_CDC_TYPE = CDC_TYPE_PULSE_S_P_LL generate
-- Secondary to Primary
signal s_pulse_in_s_h_cdc_from           : std_logic := '0';
signal s_pulse_in_s_h_clr       : std_logic := '0';
signal p_pulse_out_d1_cdc_to           : std_logic := '0';
signal p_pulse_out_d2           : std_logic := '0';
signal p_pulse_out_d3           : std_logic := '0';
signal p_pulse_out_re           : std_logic := '0';
signal p_pulse_out_s_h_cdc_from          : std_logic := '0';
signal s_pulse_out_s_h_d1_cdc_to       : std_logic := '0';
signal s_pulse_out_s_h_d2       : std_logic := '0';
signal s_pulse_out_s_h_d3       : std_logic := '0';


 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF p_pulse_out_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_d2  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_d3  : SIGNAL IS "true"; 
  --ATTRIBUTE async_reg OF p_pulse_out_re  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_s_h_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_s_h_d2  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_s_h_d3  : SIGNAL IS "true"; 


begin


    --*****************************************************************************
    --**                  Asynchronous Pulse Clock Crossing                      **
    --**                        SECONDARY TO PRIMARY                             **
    --*****************************************************************************
    -- Limitations:
    -- For scndry_aclk faster than prmry_aclk then limited to pulse period greater
    -- than (prmry_clk_freq / scndry_clk_freq) * 5
    -- For scndry_aclk slower than prmry_aclk then limited to pulse period greater
    -- than (scndry_clk_freq / prmry_clk_freq) / 5

    -- Sample and hold secondary pulse
    SCNDRY_IN_S_H_PULSE : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(scndry_resetn = '0' or s_pulse_in_s_h_clr='1')then
                    s_pulse_in_s_h_cdc_from <= '0';
                elsif(scndry_in = '1')then
                    s_pulse_in_s_h_cdc_from <= '1';
                end if;
            end if;
        end process SCNDRY_IN_S_H_PULSE;

    -- Cross sample and held pulse to primary domain
    S_IN_CROSS2PRMRY : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(prmry_resetn = '0')then
                    p_pulse_out_d1_cdc_to  <= '0';
                    p_pulse_out_d2  <= '0';
                    p_pulse_out_d3  <= '0';
                    --p_pulse_out_re  <= '0';
                else
                    p_pulse_out_d1_cdc_to  <= s_pulse_in_s_h_cdc_from;
                    p_pulse_out_d2  <= p_pulse_out_d1_cdc_to;
                    p_pulse_out_d3  <= p_pulse_out_d2;
                    --p_pulse_out_re  <= p_pulse_out_d2 and not p_pulse_out_d3;
                end if;
            end if;
        end process S_IN_CROSS2PRMRY;

                    p_pulse_out_re  <= p_pulse_out_d2 and not p_pulse_out_d3;
    -- Sample and hold primary pulse for clearing secondary sampled
    -- and held pulse
    PRMRY_OUT_S_H_PULSE : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(prmry_resetn = '0' or p_pulse_out_d2='0')then
                    p_pulse_out_s_h_cdc_from <= '0';
                elsif(p_pulse_out_re = '1')then
                    p_pulse_out_s_h_cdc_from <= '1';
                end if;
            end if;
        end process PRMRY_OUT_S_H_PULSE;

    -- Cross sample and held pulse to secondary domain
    P_OUT_CROSS2SCDNRY : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(scndry_resetn = '0')then
                    s_pulse_out_s_h_d1_cdc_to   <= '0';
                    s_pulse_out_s_h_d2   <= '0';
                    s_pulse_out_s_h_d3   <= '0';
                else
                    s_pulse_out_s_h_d1_cdc_to   <= p_pulse_out_s_h_cdc_from;
                    s_pulse_out_s_h_d2   <= s_pulse_out_s_h_d1_cdc_to;
                    s_pulse_out_s_h_d3   <= s_pulse_out_s_h_d2;
                end if;
            end if;
        end process P_OUT_CROSS2SCDNRY;

    -- Create sample and hold clear
    s_pulse_in_s_h_clr <= s_pulse_out_s_h_d2 and not s_pulse_out_s_h_d3;

    -- Feed primary pulse out
    prmry_out <= p_pulse_out_re;
    scndry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');
end generate GENERATE_PULSE_CDC_S_P_LL;


-- Generate PULSE clock domain crossing
GENERATE_PULSE_CDC_S_P_NO_RST : if C_CDC_TYPE = CDC_TYPE_PULSE_S_P_NO_RST generate
-- Secondary to Primary
signal s_pulse_in_s_h_cdc_from           : std_logic := '0';
signal s_pulse_in_s_h_clr       : std_logic := '0';
signal p_pulse_out_d1_cdc_to           : std_logic := '0';
signal p_pulse_out_d2           : std_logic := '0';
signal p_pulse_out_d3           : std_logic := '0';
signal p_pulse_out_re           : std_logic := '0';
signal p_pulse_out_s_h_cdc_from          : std_logic := '0';
signal s_pulse_out_s_h_d1_cdc_to       : std_logic := '0';
signal s_pulse_out_s_h_d2       : std_logic := '0';
signal s_pulse_out_s_h_d3       : std_logic := '0';


 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF p_pulse_out_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_d2  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_d3  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_pulse_out_re  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_s_h_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_s_h_d2  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_pulse_out_s_h_d3  : SIGNAL IS "true"; 


begin


    --*****************************************************************************
    --**                  Asynchronous Pulse Clock Crossing                      **
    --**                        SECONDARY TO PRIMARY                             **
    --*****************************************************************************
    -- Limitations:
    -- For scndry_aclk faster than prmry_aclk then limited to pulse period greater
    -- than (prmry_clk_freq / scndry_clk_freq) * 5
    -- For scndry_aclk slower than prmry_aclk then limited to pulse period greater
    -- than (scndry_clk_freq / prmry_clk_freq) / 5

    -- Sample and hold secondary pulse
    SCNDRY_IN_S_H_PULSE : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(s_pulse_in_s_h_clr='1')then
                    s_pulse_in_s_h_cdc_from <= '0';
                elsif(scndry_in = '1')then
                    s_pulse_in_s_h_cdc_from <= '1';
                end if;
            end if;
        end process SCNDRY_IN_S_H_PULSE;

    -- Cross sample and held pulse to primary domain
    S_IN_CROSS2PRMRY : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                    p_pulse_out_d1_cdc_to  <= s_pulse_in_s_h_cdc_from;
                    p_pulse_out_d2  <= p_pulse_out_d1_cdc_to;
                    p_pulse_out_d3  <= p_pulse_out_d2;
                    p_pulse_out_re  <= p_pulse_out_d2 and not p_pulse_out_d3;
            end if;
        end process S_IN_CROSS2PRMRY;

    -- Sample and hold primary pulse for clearing secondary sampled
    -- and held pulse
    PRMRY_OUT_S_H_PULSE : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(p_pulse_out_d2='0')then
                    p_pulse_out_s_h_cdc_from <= '0';
                elsif(p_pulse_out_re = '1')then
                    p_pulse_out_s_h_cdc_from <= '1';
                end if;
            end if;
        end process PRMRY_OUT_S_H_PULSE;

    -- Cross sample and held pulse to secondary domain
    P_OUT_CROSS2SCDNRY : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                    s_pulse_out_s_h_d1_cdc_to   <= p_pulse_out_s_h_cdc_from;
                    s_pulse_out_s_h_d2   <= s_pulse_out_s_h_d1_cdc_to;
                    s_pulse_out_s_h_d3   <= s_pulse_out_s_h_d2;
            end if;
        end process P_OUT_CROSS2SCDNRY;

    -- Create sample and hold clear
    s_pulse_in_s_h_clr <= s_pulse_out_s_h_d2 and not s_pulse_out_s_h_d3;

    -- Feed primary pulse out
    prmry_out <= p_pulse_out_re;
    scndry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');
end generate GENERATE_PULSE_CDC_S_P_NO_RST;







-- Generate LEVEL clock domain crossing with reset state = 0
GENERATE_LEVEL_P_S_CDC : if C_CDC_TYPE = CDC_TYPE_LEVEL_P_S and C_RESET_STATE = 0 generate
-- Primary to Secondary



signal p_level_in_d1_cdc_from        : std_logic := '0';
signal s_level_out_d1_cdc_to       : std_logic := '0';
signal s_level_out_d2       : std_logic := '0';
 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF s_level_out_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_level_out_d2  : SIGNAL IS "true"; 



begin

    --*****************************************************************************
    --**                  Asynchronous Level Clock Crossing                      **
    --**                        PRIMARY TO SECONDARY                             **
    --*****************************************************************************
    -- register is scndry to provide clean ff output to clock crossing logic
    REG_PLEVEL_IN : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(prmry_resetn = '0')then
                    p_level_in_d1_cdc_from  <= '0';
                else
                    p_level_in_d1_cdc_from  <= prmry_in;
                end if;
            end if;
        end process REG_PLEVEL_IN;

    CROSS_PLEVEL_IN2SCNDRY : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(scndry_resetn = '0')then
                    s_level_out_d1_cdc_to  <= '0';
                    s_level_out_d2  <= '0';
                else
                    s_level_out_d1_cdc_to  <= p_level_in_d1_cdc_from;
                    s_level_out_d2  <= s_level_out_d1_cdc_to;
                end if;
            end if;
        end process CROSS_PLEVEL_IN2SCNDRY;

    scndry_out <= s_level_out_d2;
    prmry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');

end generate GENERATE_LEVEL_P_S_CDC;


-- Generate LEVEL clock domain crossing with reset state = 0
GENERATE_LEVEL_P_S_CDC_NO_RST : if C_CDC_TYPE = CDC_TYPE_LEVEL_P_S_NO_RST generate
-- Primary to Secondary



signal p_level_in_d1_cdc_from        : std_logic := '0';
signal s_level_out_d1_cdc_to       : std_logic := '0';
signal s_level_out_d2       : std_logic := '0';
 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF s_level_out_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_level_out_d2  : SIGNAL IS "true"; 



begin

    --*****************************************************************************
    --**                  Asynchronous Level Clock Crossing                      **
    --**                        PRIMARY TO SECONDARY                             **
    --*****************************************************************************
    -- register is scndry to provide clean ff output to clock crossing logic
    REG_PLEVEL_IN : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                    p_level_in_d1_cdc_from  <= prmry_in;
            end if;
        end process REG_PLEVEL_IN;

    CROSS_PLEVEL_IN2SCNDRY : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                    s_level_out_d1_cdc_to  <= p_level_in_d1_cdc_from;
                    s_level_out_d2  <= s_level_out_d1_cdc_to;
                end if;
        end process CROSS_PLEVEL_IN2SCNDRY;

    scndry_out <= s_level_out_d2;
    prmry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');

end generate GENERATE_LEVEL_P_S_CDC_NO_RST;





-- Generate LEVEL clock domain crossing with reset state = 0
GENERATE_LEVEL_S_P_CDC : if C_CDC_TYPE = CDC_TYPE_LEVEL_S_P and C_RESET_STATE = 0 generate
-- Secondray to Primary
signal s_level_in_d1_cdc_from        : std_logic := '0';
signal p_level_out_d1_cdc_to       : std_logic := '0';
signal p_level_out_d2       : std_logic := '0';

 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF p_level_out_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_level_out_d2  : SIGNAL IS "true"; 




begin

    --*****************************************************************************
    --**                  Asynchronous Level Clock Crossing                      **
    --**                        SECONDARY TO PRIMARY                             **
    --*****************************************************************************
    -- register is scndry to provide clean ff output to clock crossing logic
    REG_SLEVEL_IN : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(scndry_resetn = '0')then
                    s_level_in_d1_cdc_from  <= '0';
                else
                    s_level_in_d1_cdc_from  <= scndry_in;
                end if;
            end if;
        end process REG_SLEVEL_IN;

    CROSS_SLEVEL_IN2PRMRY : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(prmry_resetn = '0')then
                    p_level_out_d1_cdc_to  <= '0';
                    p_level_out_d2  <= '0';
                else
                    p_level_out_d1_cdc_to  <= s_level_in_d1_cdc_from;
                    p_level_out_d2  <= p_level_out_d1_cdc_to;
                end if;
            end if;
        end process CROSS_SLEVEL_IN2PRMRY;

    prmry_out <= p_level_out_d2;
    scndry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');

end generate GENERATE_LEVEL_S_P_CDC;

-- Generate LEVEL clock domain crossing with reset state = 0
GENERATE_LEVEL_S_P_CDC_NO_RST : if C_CDC_TYPE = CDC_TYPE_LEVEL_S_P_NO_RST generate
-- Secondray to Primary
signal s_level_in_d1_cdc_from        : std_logic := '0';
signal p_level_out_d1_cdc_to       : std_logic := '0';
signal p_level_out_d2       : std_logic := '0';

 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF p_level_out_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_level_out_d2  : SIGNAL IS "true"; 




begin

    --*****************************************************************************
    --**                  Asynchronous Level Clock Crossing                      **
    --**                        SECONDARY TO PRIMARY                             **
    --*****************************************************************************
    -- register is scndry to provide clean ff output to clock crossing logic
    REG_SLEVEL_IN : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                    s_level_in_d1_cdc_from  <= scndry_in;
                end if;
        end process REG_SLEVEL_IN;

    CROSS_SLEVEL_IN2PRMRY : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                    p_level_out_d1_cdc_to  <= s_level_in_d1_cdc_from;
                    p_level_out_d2  <= p_level_out_d1_cdc_to;
                end if;
        end process CROSS_SLEVEL_IN2PRMRY;

    prmry_out <= p_level_out_d2;
    scndry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');

end generate GENERATE_LEVEL_S_P_CDC_NO_RST;





-- Generate LEVEL clock domain crossing with reset state = 1
GENERATE_LEVEL_S_P_CDC2 : if C_CDC_TYPE = CDC_TYPE_LEVEL_S_P and C_RESET_STATE = 1 generate
-- Secondray to Primary
signal s_level_in_d1_cdc_from        : std_logic := '0';
signal p_level_out_d1_cdc_to       : std_logic := '0';
signal p_level_out_d2       : std_logic := '0';

 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF p_level_out_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_level_out_d2  : SIGNAL IS "true"; 



begin

    --*****************************************************************************
    --**                  Asynchronous Level Clock Crossing                      **
    --**                        SECONDARY TO PRIMARY                             **
    --*****************************************************************************
    -- register is scndry to provide clean ff output to clock crossing logic
    REG_SLEVEL_IN : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk ='1')then
                if(scndry_resetn = '0')then
                    s_level_in_d1_cdc_from  <= '1';
                else
                    s_level_in_d1_cdc_from  <= scndry_in;
                end if;
            end if;
        end process REG_SLEVEL_IN;

    CROSS_SLEVEL_IN2PRMRY : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                if(prmry_resetn = '0')then
                    p_level_out_d1_cdc_to  <= '1';
                    p_level_out_d2  <= '1';
                else
                    p_level_out_d1_cdc_to  <= s_level_in_d1_cdc_from;
                    p_level_out_d2  <= p_level_out_d1_cdc_to;
                end if;
            end if;
        end process CROSS_SLEVEL_IN2PRMRY;

    prmry_out <= p_level_out_d2;
    scndry_out <= '0';
scndry_vect_out <= (others => '0');
prmry_vect_out <= (others => '0');

end generate GENERATE_LEVEL_S_P_CDC2;


GENERATE_VECT_P_S_CDC : if C_CDC_TYPE = CDC_TYPE_VECTR_P_S generate

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal p_vect_in_d1_cdc_from     : std_logic_vector(C_VECTOR_WIDTH-1 downto 0) := (others => '0');
signal s_vect_out_d1_cdc_to    : std_logic_vector(C_VECTOR_WIDTH-1 downto 0) := (others => '0');
signal s_vect_out_d2    : std_logic_vector(C_VECTOR_WIDTH-1 downto 0) := (others => '0');
 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF s_vect_out_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s_vect_out_d2  : SIGNAL IS "true"; 


begin




-- Register signal in to give clear FF output to CDC
P_REG_GREY_IN : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk ='1')then
            if(prmry_resetn = '0')then
                p_vect_in_d1_cdc_from   <= (others => '0');
            elsif(prmry_vect_s_h = '1')then
                p_vect_in_d1_cdc_from   <= prmry_vect_in;
            end if;
        end if;
    end process P_REG_GREY_IN;

-- Double register to secondary
S_REG_GREY_OUT : process(scndry_aclk)
    begin
        if(scndry_aclk'EVENT and scndry_aclk ='1')then
            if(scndry_resetn = '0')then
                s_vect_out_d1_cdc_to   <= (others => '0');
                s_vect_out_d2   <= (others => '0');
            else
                s_vect_out_d1_cdc_to   <= p_vect_in_d1_cdc_from;
                s_vect_out_d2   <= s_vect_out_d1_cdc_to;
            end if;
        end if;
    end process S_REG_GREY_OUT;

scndry_vect_out <= s_vect_out_d2;
prmry_vect_out <= (others => '0');
    scndry_out <= '0';
    prmry_out <= '0';

end generate GENERATE_VECT_P_S_CDC;

--*****************************************************************************
--**                  Asynchronous Level Clock Crossing                      **
--**                        SECONDARY TO PRIMARY                             **
--*****************************************************************************

GENERATE_VECT_S_P_CDC : if C_CDC_TYPE = CDC_TYPE_VECTR_S_P generate

signal s_vect_in_d1_cdc_from     : std_logic_vector(C_VECTOR_WIDTH-1 downto 0) := (others => '0');
signal p_vect_out_d1_cdc_to    : std_logic_vector(C_VECTOR_WIDTH-1 downto 0) := (others => '0');
signal p_vect_out_d2    : std_logic_vector(C_VECTOR_WIDTH-1 downto 0) := (others => '0');
 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF p_vect_out_d1_cdc_to  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF p_vect_out_d2  : SIGNAL IS "true"; 

begin
-- Register signal in to give clear FF output to CDC
S_REG_GREY_IN : process(scndry_aclk)
    begin
        if(scndry_aclk'EVENT and scndry_aclk ='1')then
            if(scndry_resetn = '0')then
                s_vect_in_d1_cdc_from   <= (others => '0');
            elsif(scndry_vect_s_h = '1')then
                s_vect_in_d1_cdc_from   <= scndry_vect_in;
            end if;
        end if;
    end process S_REG_GREY_IN;

-- Double register to primary
P_REG_GREY_OUT : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk ='1')then
            if(prmry_resetn = '0')then
                p_vect_out_d1_cdc_to   <= (others => '0');
                p_vect_out_d2   <= (others => '0');
            else
                p_vect_out_d1_cdc_to   <= s_vect_in_d1_cdc_from;
                p_vect_out_d2   <= p_vect_out_d1_cdc_to;
            end if;
        end if;
    end process P_REG_GREY_OUT;

prmry_vect_out <= p_vect_out_d2;
scndry_vect_out <= (others => '0');
    scndry_out <= '0';
    prmry_out <= '0';

end generate GENERATE_VECT_S_P_CDC;


--GENERATE_AFIFO_CDC :
--

end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_vid_cdc
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_vdma_vid_cdc.vhd
-- Description: This entity encompases the Clock Domain Crossing Pulse
--              Generator
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

library lib_cdc_v1_0_2;


-------------------------------------------------------------------------------
entity  axi_vdma_vid_cdc is
    generic (
        C_PRMRY_IS_ACLK_ASYNC       : integer range 0 to 1      := 0            ;
        C_GENLOCK_MSTR_PTR_DWIDTH   : integer                   := 32           ;
        C_GENLOCK_SLVE_PTR_DWIDTH   : integer                   := 32           ;
        C_INTERNAL_GENLOCK_ENABLE   : integer range 0 to 1      := 0
    );
    port (
        prmry_aclk                  : in  std_logic                             ;       --
        prmry_resetn                : in  std_logic                             ;       --
                                                                                        --
        scndry_aclk                 : in  std_logic                             ;       --
        scndry_resetn               : in  std_logic                             ;       --
                                                                                        --
        -- Cross pntr/fsync to opposing channel                                         --
        othrchnl_aclk               : in  std_logic                             ;       --
        othrchnl_resetn             : in  std_logic                             ;       --
        othrchnl2cdc_frame_ptr_out  : in  std_logic_vector                              --
                                        (C_GENLOCK_MSTR_PTR_DWIDTH-1 downto 0)  ;       --
        cdc2othrchnl_frame_ptr_in   : out std_logic_vector                              --
                                        (C_GENLOCK_MSTR_PTR_DWIDTH-1 downto 0)  ;       --

        cdc2othrchnl_fsync          : out std_logic                             ;       --
                                                                                        --
                                                                                        --
        -- GEN-LOCK Clock Domain Crossing                                               --
        dmac2cdc_frame_ptr_out      : in  std_logic_vector                              --
                                        (C_GENLOCK_MSTR_PTR_DWIDTH-1 downto 0)  ;       --
        cdc2top_frame_ptr_out       : out std_logic_vector                              --
                                        (C_GENLOCK_MSTR_PTR_DWIDTH-1 downto 0)  ;       --
                                                                                        --
        top2cdc_frame_ptr_in        : in  std_logic_vector                              --
                                        (C_GENLOCK_SLVE_PTR_DWIDTH-1 downto 0)  ;       --
        cdc2dmac_frame_ptr_in       : out std_logic_vector                              --
                                        (C_GENLOCK_SLVE_PTR_DWIDTH-1 downto 0)  ;       --
                                                                                        --
        dmac2cdc_mstrfrm_tstsync    : in  std_logic                             ;       --
        cdc2dmac_mstrfrm_tstsync    : out std_logic                             ;       --
                                                                                        --
        -- SOF Detection Domain Crossing (secondary to primary)                         --
        vid2cdc_packet_sof          : in  std_logic                             ;       --
        cdc2dmac_packet_sof         : out std_logic                             ;       --
                                                                                        --
        -- Frame Sync Generation Domain Crossing                                        --
        vid2cdc_fsync               : in  std_logic                             ;       --
        cdc2dmac_fsync              : out std_logic                             ;       --
                                                                                        --
        dmac2cdc_fsync_out          : in  std_logic                             ;       --
        cdc2vid_fsync_out           : out std_logic                             ;       --
                                                                                        --
        dmac2cdc_prmtr_update       : in  std_logic                             ;       --
        cdc2vid_prmtr_update        : out std_logic                                     --

    );

end axi_vdma_vid_cdc;


-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_vid_cdc is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant ZERO_VALUE_VECT    : std_logic_vector(128 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Cross sample and held fsync to secondary
signal s_fsync_d1               : std_logic := '0';
signal s_fsync_d2               : std_logic := '0';
signal s_fsync_fe               : std_logic := '0';

signal frame_ptr_in_d1_cdc_tig          : std_logic_vector(C_GENLOCK_SLVE_PTR_DWIDTH-1 downto 0) := (others => '0');
signal frame_ptr_in_d2		        : std_logic_vector(C_GENLOCK_SLVE_PTR_DWIDTH-1 downto 0) := (others => '0');
signal frame_ptr_out_d1_cdc_tig         : std_logic_vector(C_GENLOCK_MSTR_PTR_DWIDTH-1 downto 0) := (others => '0');
signal frame_ptr_out_d2		        : std_logic_vector(C_GENLOCK_MSTR_PTR_DWIDTH-1 downto 0) := (others => '0');

signal othrchnl_frame_ptr_in_d1_cdc_tig : std_logic_vector(C_GENLOCK_MSTR_PTR_DWIDTH-1 downto 0) := (others => '0');
signal othrchnl_frame_ptr_in_d2	        : std_logic_vector(C_GENLOCK_MSTR_PTR_DWIDTH-1 downto 0) := (others => '0');
signal cdc2dmac_fsync_i         	: std_logic := '0';


  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF frame_ptr_in_d1_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF frame_ptr_in_d2          : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF frame_ptr_out_d1_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF frame_ptr_out_d2          : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF othrchnl_frame_ptr_in_d1_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF othrchnl_frame_ptr_in_d2	   : SIGNAL IS "true"; 

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

cdc2dmac_fsync  <= cdc2dmac_fsync_i;


-- register fsync in and set up for creating fall edge
REG_FSYNC_IN : process(scndry_aclk)
    begin
        if(scndry_aclk'EVENT and scndry_aclk ='1')then
            if(scndry_resetn = '0')then
                s_fsync_d1  <= '0';
                s_fsync_d2  <= '0';
            else
                s_fsync_d1  <= vid2cdc_fsync;
                s_fsync_d2  <= s_fsync_d1;
            end if;
        end if;
    end process REG_FSYNC_IN;

 -- Pass scndry fe out for frame sync if running
s_fsync_fe <= not s_fsync_d1 and s_fsync_d2;


-- Aysnchronous mode therefore instantiate clock domain crossing logic
GEN_CDC_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin

--*****************************************************************************
--** GenLock CDC
--*****************************************************************************

    -- From GenLock manager to AXIS clock domain
----    M_PTR_OUT_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_PULSE_P_S_OPEN_ENDED                           ,
----            C_VECTOR_WIDTH          => C_GENLOCK_MSTR_PTR_DWIDTH
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                            ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                           ,
----            scndry_in               => '0'                                      ,
----            prmry_out               => open                                     ,
----            prmry_in                => dmac2cdc_mstrfrm_tstsync                 ,
----            scndry_out              => cdc2dmac_mstrfrm_tstsync                 ,
----            scndry_vect_s_h         => '0'                                      ,
----            scndry_vect_in          => ZERO_VALUE_VECT
----                                        (C_GENLOCK_MSTR_PTR_DWIDTH-1 downto 0)  ,
----            prmry_vect_out          => open                                     ,
----            prmry_vect_s_h          => '0'                                      ,
----            prmry_vect_in           => ZERO_VALUE_VECT
----                                        (C_GENLOCK_MSTR_PTR_DWIDTH-1 downto 0)  ,
----            scndry_vect_out         => open
----        );
----


M_PTR_OUT_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_aclk,
        prmry_resetn               => prmry_resetn, 
        prmry_in                   => dmac2cdc_mstrfrm_tstsync, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => scndry_aclk, 
        scndry_resetn              => scndry_resetn,
        scndry_out                 => cdc2dmac_mstrfrm_tstsync,
        scndry_vect_out            => open
    );





    -- frame_ptr is grey coded and thus double register is all that is needed
    CROSS_FRMPTR_IN_1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    frame_ptr_in_d1_cdc_tig         <= top2cdc_frame_ptr_in;
                    frame_ptr_in_d2         	    <= frame_ptr_in_d1_cdc_tig;
            end if;
        end process CROSS_FRMPTR_IN_1;

    CROSS_FRMPTR_IN_2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    cdc2dmac_frame_ptr_in   <= (others => '0');
                else
                    cdc2dmac_frame_ptr_in   <= frame_ptr_in_d2;
                end if;
            end if;
        end process CROSS_FRMPTR_IN_2;


    -- frame_ptr is grey coded and thus double register is all that is needed
    CROSS_FRMPTR_OUT_1 : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk = '1')then
                    frame_ptr_out_d1_cdc_tig        <= dmac2cdc_frame_ptr_out;
                    frame_ptr_out_d2        	    <= frame_ptr_out_d1_cdc_tig;
            end if;
        end process CROSS_FRMPTR_OUT_1;

    CROSS_FRMPTR_OUT_2 : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk = '1')then
                if(scndry_resetn = '0')then
                    cdc2top_frame_ptr_out   <= (others => '0');
                else
                    cdc2top_frame_ptr_out   <= frame_ptr_out_d2;
                end if;
            end if;
        end process CROSS_FRMPTR_OUT_2;




    GEN_FOR_INTERNAL_GENLOCK : if C_INTERNAL_GENLOCK_ENABLE = 1 generate
    begin
        -- Cross from primary channel to other channel
        -- (or opposing channel, i.e. mm2s to s2mm or s2mm to mm2s)
        -- Used for internal genlock option
        CROSS_TO_OTHR_CHANNEL_1 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                        othrchnl_frame_ptr_in_d1_cdc_tig    <= othrchnl2cdc_frame_ptr_out;
                        othrchnl_frame_ptr_in_d2    	    <= othrchnl_frame_ptr_in_d1_cdc_tig;
                end if;
            end process CROSS_TO_OTHR_CHANNEL_1;

        CROSS_TO_OTHR_CHANNEL_2 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        cdc2othrchnl_frame_ptr_in   <= (others => '0');
                    else
                        cdc2othrchnl_frame_ptr_in   <= othrchnl_frame_ptr_in_d2;
                    end if;
                end if;
            end process CROSS_TO_OTHR_CHANNEL_2;




    end generate GEN_FOR_INTERNAL_GENLOCK;

    GEN_FOR_NO_INTERNAL_GENLOCK : if C_INTERNAL_GENLOCK_ENABLE = 0 generate
    begin
        cdc2othrchnl_frame_ptr_in   <= (others => '0');
    end generate GEN_FOR_NO_INTERNAL_GENLOCK;


    -- Cross other fsync into primary clock domain
----    OTHR_FSYNC_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_PULSE_S_P_OPEN_ENDED                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => othrchnl_aclk                            ,
----            prmry_resetn            => othrchnl_resetn                          ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----            scndry_in               => s_fsync_fe                               ,
----            prmry_out               => cdc2othrchnl_fsync                       ,
----            prmry_in                => '0'                                      ,
----            scndry_out              => open                                     ,
----            scndry_vect_s_h         => '0'                                      ,
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----            prmry_vect_out          => open                                     ,
----            prmry_vect_s_h          => '0'                                      ,
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----            scndry_vect_out         => open
----        );

OTHR_FSYNC_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => scndry_aclk,
        prmry_resetn               => scndry_resetn, 
        prmry_in                   => s_fsync_fe, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => othrchnl_aclk, 
        scndry_resetn              => othrchnl_resetn,
        scndry_out                 => cdc2othrchnl_fsync,
        scndry_vect_out            => open
    );





--*****************************************************************************
--** SOF CDC
--*****************************************************************************
----    SOF_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_PULSE_S_P_OPEN_ENDED                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                            ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                           ,
----            scndry_in               => vid2cdc_packet_sof                       ,
----            prmry_out               => cdc2dmac_packet_sof                      ,
----            prmry_in                => '0'                                      ,
----            scndry_out              => open                                     ,
----            scndry_vect_s_h         => '0'                                      ,
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----            prmry_vect_out          => open                                     ,
----            prmry_vect_s_h          => '0'                                      ,
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----            scndry_vect_out         => open
----        );
----



SOF_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => scndry_aclk,
        prmry_resetn               => scndry_resetn, 
        prmry_in                   => vid2cdc_packet_sof, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_aclk, 
        scndry_resetn              => prmry_resetn,
        scndry_out                 => cdc2dmac_packet_sof,
        scndry_vect_out            => open
    );




--*****************************************************************************
--** Frame Sync CDC
--*****************************************************************************
    -- From axi vdma top out (scndry_aclk) to frame sync gen (prmry_aclk)
----    FSYNC_IN_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_PULSE_S_P_OPEN_ENDED                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                             ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----
----            scndry_in               => s_fsync_fe                               ,
----            prmry_out               => cdc2dmac_fsync_i                         ,
----            prmry_in                => '0'                                      ,
----            scndry_out              => open                                     ,
----
----            scndry_vect_s_h         => '0'                                      ,
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----            prmry_vect_out          => open                                     ,
----            prmry_vect_s_h          => '0'                                      ,
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----            scndry_vect_out         => open
----        );
----



FSYNC_IN_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => scndry_aclk,
        prmry_resetn               => scndry_resetn, 
        prmry_in                   => s_fsync_fe, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_aclk, 
        scndry_resetn              => prmry_resetn,
        scndry_out                 => cdc2dmac_fsync_i,
        scndry_vect_out            => open
    );





    -- From frame sync gen (prmry_aclk) to axi vdma top out (scndry_aclk)
----    FSYNC_OUT_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_PULSE_P_S_OPEN_ENDED                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                            ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                           ,
----            scndry_in               => '0'                                      ,
----            prmry_out               => open                                     ,
----            prmry_in                => dmac2cdc_fsync_out                       ,
----            scndry_out              => cdc2vid_fsync_out                        ,
----            scndry_vect_s_h         => '0'                                      ,
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----            prmry_vect_out          => open                                     ,
----            prmry_vect_s_h          => '0'                                      ,
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----            scndry_vect_out         => open
----        );
----





FSYNC_OUT_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_aclk,
        prmry_resetn               => prmry_resetn, 
        prmry_in                   => dmac2cdc_fsync_out, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => scndry_aclk, 
        scndry_resetn              => scndry_resetn,
        scndry_out                 => cdc2vid_fsync_out,
        scndry_vect_out            => open
    );







    -- From frame sync gen (prmry_aclk) to axi vdma top out (scndry_aclk)
----    PRMTR_UPDT_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_PULSE_P_S_OPEN_ENDED                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                            ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                           ,
----            scndry_in               => '0'                                      ,
----            prmry_out               => open                                     ,
----            prmry_in                => dmac2cdc_prmtr_update                    ,
----            scndry_out              => cdc2vid_prmtr_update                     ,
----            scndry_vect_s_h         => '0'                                      ,
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----            prmry_vect_out          => open                                     ,
----            prmry_vect_s_h          => '0'                                      ,
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----            scndry_vect_out         => open
----        );



PRMTR_UPDT_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_aclk,
        prmry_resetn               => prmry_resetn, 
        prmry_in                   => dmac2cdc_prmtr_update, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => scndry_aclk, 
        scndry_resetn              => scndry_resetn,
        scndry_out                 => cdc2vid_prmtr_update,
        scndry_vect_out            => open
    );





end generate GEN_CDC_FOR_ASYNC;


-- Synchronous Mode therefore map inputs to associated
-- outputs directly.
GEN_NO_CDC_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin

    cdc2top_frame_ptr_out       <= dmac2cdc_frame_ptr_out   ;
    cdc2dmac_frame_ptr_in       <= top2cdc_frame_ptr_in     ;
    cdc2dmac_mstrfrm_tstsync    <= dmac2cdc_mstrfrm_tstsync ;
    cdc2dmac_packet_sof         <= vid2cdc_packet_sof;
    cdc2dmac_fsync_i            <= s_fsync_fe               ;
    cdc2vid_fsync_out           <= dmac2cdc_fsync_out       ;
    cdc2vid_prmtr_update        <= dmac2cdc_prmtr_update    ;
    cdc2othrchnl_fsync          <= s_fsync_fe               ;

    GEN_FOR_INTERNAL_GENLOCK : if C_INTERNAL_GENLOCK_ENABLE = 1 generate
    begin

        cdc2othrchnl_frame_ptr_in <= othrchnl2cdc_frame_ptr_out;

    end generate GEN_FOR_INTERNAL_GENLOCK;

    GEN_FOR_NO_INTERNAL_GENLOCK : if C_INTERNAL_GENLOCK_ENABLE = 0 generate
    begin
        cdc2othrchnl_frame_ptr_in   <= (others => '0');
    end generate GEN_FOR_NO_INTERNAL_GENLOCK;


end generate GEN_NO_CDC_FOR_SYNC;



end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_sg_cdc
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_vdma_sg_cdc.vhd
-- Description: This entity encompases the Clock Domain Crossing Pulse
--              Generator for Scatter Gather signals
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

library lib_cdc_v1_0_2;
-------------------------------------------------------------------------------
entity  axi_vdma_sg_cdc is
    generic (
        C_PRMRY_IS_ACLK_ASYNC       : integer range 0 to 1      := 0            ;
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 32    := 32
    );
    port (
        prmry_aclk                  : in  std_logic                             ;       --
        prmry_resetn                : in  std_logic                             ;       --
                                                                                        --
        scndry_aclk                 : in  std_logic                             ;       --
        scndry_resetn               : in  std_logic                             ;       --
                                                                                        --
        -- From Register Module (Primary Clk Domain)                                    --
        reg2cdc_run_stop            : in  std_logic                             ;       --
        reg2cdc_stop                : in  std_logic                             ;       --
        reg2cdc_taildesc_wren       : in  std_logic                             ;       --
        reg2cdc_taildesc            : in  std_logic_vector                              --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)      ;       --
                                                                                        --
        reg2cdc_curdesc             : in  std_logic_vector                              --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)      ;       --
                                                                                        --
        -- To Scatter Gather Engine (Secondary Clk Domain                               --
        cdc2sg_run_stop             : out std_logic                             ;       --
        cdc2sg_stop                 : out std_logic                             ;       --
        cdc2sg_taildesc_wren        : out std_logic                             ;       --
        cdc2sg_taildesc             : out std_logic_vector                              --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)      ;       --
        cdc2sg_curdesc              : out std_logic_vector                              --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)      ;       --
                                                                                        --
        -- From Scatter Gather Engine (Secondary Clk Domain)                            --
        sg2cdc_ftch_idle            : in  std_logic                             ;       --
        sg2cdc_ftch_interr_set      : in  std_logic                             ;       --
        sg2cdc_ftch_slverr_set      : in  std_logic                             ;       --
        sg2cdc_ftch_decerr_set      : in  std_logic                             ;       --
        sg2cdc_ftch_err_addr        : in  std_logic_vector                              --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)      ;       --
        sg2cdc_ftch_err             : in  std_logic                             ;       --
                                                                                        --
        -- To DMA Controller                                                            --
        cdc2dmac_ftch_idle          : out std_logic                             ;       --
                                                                                        --
        -- To Register Module                                                           --
        cdc2reg_ftch_interr_set     : out std_logic                             ;       --
        cdc2reg_ftch_slverr_set     : out std_logic                             ;       --
        cdc2reg_ftch_decerr_set     : out std_logic                             ;       --
        cdc2reg_ftch_err_addr       : out std_logic_vector                              --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)      ;       --
        cdc2reg_ftch_err            : out std_logic                                     --





    );

end axi_vdma_sg_cdc;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_sg_cdc is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant ZERO_VALUE_VECT    : std_logic_vector(128 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------

signal        reg2cdc_taildesc_i            : std_logic_vector                              --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)   := (others => '0')   ;       --
signal        sg2cdc_ftch_err_addr_i        : std_logic_vector                              --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)   := (others => '0')   ;       --
signal        reg2cdc_curdesc_i             : std_logic_vector                              --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)   := (others => '0')   ;       --
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin


-- Aysnchronous mode therefore instantiate clock domain crossing logic
GEN_CDC_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin

    -- From register module (primary clock domain) to
    -- scatter gather engine (secondary clock domain)
----    CUR_DESC_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_VECTR_P_S                           ,
----            C_VECTOR_WIDTH          => C_M_AXI_SG_ADDR_WIDTH
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                             ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => '0'                                      ,   -- Not Used
----            scndry_out              => open                                     ,   -- Not Used
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT                              -- Not Used
----                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)      ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '1'                                      ,
----            prmry_vect_in           => reg2cdc_curdesc                          ,
----            scndry_vect_out         => cdc2sg_curdesc
----        );


-- Register signal in to give clear FF output to CDC
P_IN_CUR_DESC : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk ='1')then
            if(prmry_resetn = '0')then
                reg2cdc_curdesc_i   <= (others => '0');
            else
                reg2cdc_curdesc_i   <= reg2cdc_curdesc;
            end if;
        end if;
    end process P_IN_CUR_DESC;





CUR_DESC_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 0,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => C_M_AXI_SG_ADDR_WIDTH,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_aclk,
        prmry_resetn               => prmry_resetn, 
        prmry_in                   => '0', 
        prmry_vect_in              => reg2cdc_curdesc_i,
        prmry_ack                  => open,
                                    
        scndry_aclk                => scndry_aclk, 
        scndry_resetn              => scndry_resetn,
        scndry_out                 => open,
        scndry_vect_out            => cdc2sg_curdesc
    );







    -- From register module (primary clock domain) to
    -- scatter gather engine (secondary clock domain)
----    TAIL_DESC_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_PULSE_P_S_OPEN_ENDED                           ,
----            C_VECTOR_WIDTH          => C_M_AXI_SG_ADDR_WIDTH
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                             ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => reg2cdc_taildesc_wren                    ,
----            scndry_out              => cdc2sg_taildesc_wren                     ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT                              -- Not Used
----                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)      ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                    ,
----            prmry_vect_in           => ZERO_VALUE_VECT                         
----                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)      ,   -- Not Used
----            scndry_vect_out         => open
----        );





TAIL_DESC_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_aclk,
        prmry_resetn               => prmry_resetn, 
        prmry_in                   => reg2cdc_taildesc_wren, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => scndry_aclk, 
        scndry_resetn              => scndry_resetn,
        scndry_out                 => cdc2sg_taildesc_wren,
        scndry_vect_out            => open
    );



    -- From register module (primary clock domain) to
    -- scatter gather engine (secondary clock domain)
----    TAIL_DESC_VECT_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_VECTR_P_S                           ,
----            C_VECTOR_WIDTH          => C_M_AXI_SG_ADDR_WIDTH
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                             ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => '0'                    ,
----            scndry_out              => open                     ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT                              -- Not Used
----                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)      ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => reg2cdc_taildesc_wren                    ,
----            prmry_vect_in           => reg2cdc_taildesc                         ,
----            scndry_vect_out         => cdc2sg_taildesc
----        );
----


-- Register signal in to give clear FF output to CDC
P_IN_TAIL_DESC : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk ='1')then
            if(prmry_resetn = '0')then
                reg2cdc_taildesc_i   <= (others => '0');
            elsif(reg2cdc_taildesc_wren = '1')then
                reg2cdc_taildesc_i   <= reg2cdc_taildesc;
            end if;
        end if;
    end process P_IN_TAIL_DESC;



TAIL_DESC_VECT_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 0,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => C_M_AXI_SG_ADDR_WIDTH,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_aclk,
        prmry_resetn               => prmry_resetn, 
        prmry_in                   => '0', 
        prmry_vect_in              => reg2cdc_taildesc_i,
        prmry_ack                  => open,
                                    
        scndry_aclk                => scndry_aclk, 
        scndry_resetn              => scndry_resetn,
        scndry_out                 => open,
        scndry_vect_out            => cdc2sg_taildesc
    );




    -- From register module (primary clock domain) to
    -- scatter gather engine (secondary clock domain)
----    RUNSTOP_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_P_S                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                             ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => reg2cdc_run_stop                         ,
----            scndry_out              => cdc2sg_run_stop                          ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );



RUNSTOP_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_aclk,
        prmry_resetn               => prmry_resetn, 
        prmry_in                   => reg2cdc_run_stop, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => scndry_aclk, 
        scndry_resetn              => scndry_resetn,
        scndry_out                 => cdc2sg_run_stop,
        scndry_vect_out            => open
    );







    -- From register module (primary clock domain) to
    -- scatter gather engine (secondary clock domain)
----    STOP_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_P_S                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                             ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => reg2cdc_stop                             ,
----            scndry_out              => cdc2sg_stop                              ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----


STOP_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_aclk,
        prmry_resetn               => prmry_resetn, 
        prmry_in                   => reg2cdc_stop, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => scndry_aclk, 
        scndry_resetn              => scndry_resetn,
        scndry_out                 => cdc2sg_stop,
        scndry_vect_out            => open
    );







    -- From SG Engine (secondary clock domain) to
    -- DMA Controller (primary clock domain)
----    FTCH_IDLE_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_S_P                           ,
----            C_VECTOR_WIDTH          => 1                                        ,
----            C_RESET_STATE           => 1
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                             ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----            scndry_in               => sg2cdc_ftch_idle                         ,
----            prmry_out               => cdc2dmac_ftch_idle                       ,
----            prmry_in                => '0'                                      ,   -- Not Used
----            scndry_out              => open                                     ,   -- Not Used
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----



FTCH_IDLE_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => scndry_aclk,
        prmry_resetn               => scndry_resetn, 
        prmry_in                   => sg2cdc_ftch_idle, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_aclk, 
        scndry_resetn              => prmry_resetn,
        scndry_out                 => cdc2dmac_ftch_idle,
        scndry_vect_out            => open
    );






    --sg to reg
    -- From SG Engine (secondary clock domain) to
    -- Register Block (primary clock domain)
----    FTCH_INTERR_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_S_P                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                             ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----            scndry_in               => sg2cdc_ftch_interr_set                   ,
----            prmry_out               => cdc2reg_ftch_interr_set                  ,
----            prmry_in                => '0'                                      ,   -- Not Used
----            scndry_out              => open                                     ,   -- Not Used
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----


FTCH_INTERR_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => scndry_aclk,
        prmry_resetn               => scndry_resetn, 
        prmry_in                   => sg2cdc_ftch_interr_set, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_aclk, 
        scndry_resetn              => prmry_resetn,
        scndry_out                 => cdc2reg_ftch_interr_set,
        scndry_vect_out            => open
    );








----    FTCH_SLVERR_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_S_P                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                             ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----            scndry_in               => sg2cdc_ftch_slverr_set                   ,
----            prmry_out               => cdc2reg_ftch_slverr_set                  ,
----            prmry_in                => '0'                                      ,   -- Not Used
----            scndry_out              => open                                     ,   -- Not Used
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----



FTCH_SLVERR_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => scndry_aclk,
        prmry_resetn               => scndry_resetn, 
        prmry_in                   => sg2cdc_ftch_slverr_set, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_aclk, 
        scndry_resetn              => prmry_resetn,
        scndry_out                 => cdc2reg_ftch_slverr_set,
        scndry_vect_out            => open
    );







----    FTCH_DECERR_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_S_P                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                             ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----            scndry_in               => sg2cdc_ftch_decerr_set                   ,
----            prmry_out               => cdc2reg_ftch_decerr_set                  ,
----            prmry_in                => '0'                                      ,   -- Not Used
----            scndry_out              => open                                     ,   -- Not Used
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----



FTCH_DECERR_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => scndry_aclk,
        prmry_resetn               => scndry_resetn, 
        prmry_in                   => sg2cdc_ftch_decerr_set, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_aclk, 
        scndry_resetn              => prmry_resetn,
        scndry_out                 => cdc2reg_ftch_decerr_set,
        scndry_vect_out            => open
    );











----    ERR_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_S_P                           ,
----            C_VECTOR_WIDTH          => C_M_AXI_SG_ADDR_WIDTH
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                             ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----            scndry_in               => sg2cdc_ftch_err                        ,
----            prmry_out               => cdc2reg_ftch_err                       ,
----            prmry_in                => '0'                                      ,   -- Not Used
----            scndry_out              => open                                     ,   -- Not Used
----            scndry_vect_s_h         => '0'                        ,
----            scndry_vect_in          =>  ZERO_VALUE_VECT(C_M_AXI_SG_ADDR_WIDTH-1 downto 0)                  ,
----            prmry_vect_out          => open                  ,
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(C_M_AXI_SG_ADDR_WIDTH-1 downto 0),   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----



ERR_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => scndry_aclk,
        prmry_resetn               => scndry_resetn, 
        prmry_in                   => sg2cdc_ftch_err, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_aclk, 
        scndry_resetn              => prmry_resetn,
        scndry_out                 => cdc2reg_ftch_err,
        scndry_vect_out            => open
    );








----    ERR_VECT_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_VECTR_S_P                           ,
----            C_VECTOR_WIDTH          => C_M_AXI_SG_ADDR_WIDTH
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                             ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----            scndry_in               => '0'                        ,
----            prmry_out               => open                       ,
----            prmry_in                => '0'                                      ,   -- Not Used
----            scndry_out              => open                                     ,   -- Not Used
----            scndry_vect_s_h         => sg2cdc_ftch_err                        ,
----            scndry_vect_in          => sg2cdc_ftch_err_addr                   ,
----            prmry_vect_out          => cdc2reg_ftch_err_addr                  ,
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(C_M_AXI_SG_ADDR_WIDTH-1 downto 0),   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----



-- Register signal in to give clear FF output to CDC
P_IN_ERR_VECT : process(scndry_aclk)
    begin
        if(scndry_aclk'EVENT and scndry_aclk ='1')then
            if(scndry_resetn = '0')then
                sg2cdc_ftch_err_addr_i   <= (others => '0');
            elsif(sg2cdc_ftch_err = '1')then
                sg2cdc_ftch_err_addr_i   <= sg2cdc_ftch_err_addr;
            end if;
        end if;
    end process P_IN_ERR_VECT;



ERR_VECT_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 0,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => C_M_AXI_SG_ADDR_WIDTH,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => scndry_aclk,
        prmry_resetn               => scndry_resetn, 
        prmry_in                   => '0', 
        prmry_vect_in              => sg2cdc_ftch_err_addr_i,
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_aclk, 
        scndry_resetn              => prmry_resetn,
        scndry_out                 => open,
        scndry_vect_out            => cdc2reg_ftch_err_addr
    );






end generate GEN_CDC_FOR_ASYNC;


-- Synchronous Mode therefore map inputs to associated
-- outputs directly.
GEN_NO_CDC_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin

    cdc2sg_run_stop         <= reg2cdc_run_stop         ;
    cdc2sg_stop             <= reg2cdc_stop             ;
    cdc2sg_taildesc_wren    <= reg2cdc_taildesc_wren    ;
    cdc2sg_taildesc         <= reg2cdc_taildesc         ;
    cdc2sg_curdesc          <= reg2cdc_curdesc          ;
    cdc2dmac_ftch_idle      <= sg2cdc_ftch_idle         ;
    cdc2reg_ftch_interr_set <= sg2cdc_ftch_interr_set   ;
    cdc2reg_ftch_slverr_set <= sg2cdc_ftch_slverr_set   ;
    cdc2reg_ftch_decerr_set <= sg2cdc_ftch_decerr_set   ;
    cdc2reg_ftch_err        <= sg2cdc_ftch_err          ;
    cdc2reg_ftch_err_addr   <= sg2cdc_ftch_err_addr     ;

end generate GEN_NO_CDC_FOR_SYNC;



end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_reset
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_reset.vhd
-- Description: This entity encompasses the reset logic (soft and hard) for
--              distribution to the axi_vdma core.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

library lib_cdc_v1_0_2;


-------------------------------------------------------------------------------
entity  axi_vdma_reset is
    generic(
        C_PRMRY_IS_ACLK_ASYNC           : integer range 0 to 1 := 0;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.
        C_INCLUDE_SG                    : integer range 0 to 1 := 0
            -- Include or Exclude Scatter Gather Engine
            -- 0 = Exclude Scatter Gather Engine (Enables Register Direct Mode)
            -- 1 = Include Scatter Gather Engine
    );
    port (
        -- Clock Sources
        s_axi_lite_aclk             : in  std_logic                         ;               --
        m_axi_sg_aclk               : in  std_logic                         ;               --
        prmry_axi_aclk              : in  std_logic                         ;               --
        prmry_axis_aclk             : in  std_logic                         ;               --
                                                                                            --
        -- Hard Reset                                                                       --
        axi_resetn                  : in  std_logic                         ;               --
                                                                                            --
        -- Soft Reset                                                                       --
        soft_reset                  : in  std_logic                         ;               --
        soft_reset_clr              : out std_logic  := '0'                 ;               --
                                                                                            --
                                                                                            --
        run_stop                    : in  std_logic                         ;               --
        all_idle                    : in  std_logic                         ;               --
        stop                        : in  std_logic                         ;               --
        halt                        : out std_logic := '0'                  ;               --
        halt_cmplt                  : in  std_logic                         ;               --
        fsize_mismatch_err          : in  std_logic                         ;               -- 
        hrd_axi_resetn              : out std_logic                         ;               --
                                                                                            --
        -- MM2S or S2MM Main Primary Reset (Hard and Soft)                                  --
        prmry_resetn                : out std_logic := '0'                  ;               --
        -- MM2S or S2MM Main Datamover Primary Reset (RAW) (Hard and Soft)                  --
        dm_prmry_resetn             : out std_logic := '1'                  ;               --
        -- AXI Stream Reset (Hard and Soft)                                                 --
        axis_resetn                 : out std_logic := '1'                  ;               --
        -- AXI Stream Reset Out (Hard and Soft)                                             --
        axis_reset_out_n            : out std_logic                         ;               --
        -- AXI Scatter/Gather Reset (Hard and Soft)                                         --
        axi_sg_resetn               : out std_logic                         ;               --
        -- AXI Scatter/Gather Reset (RAW) (Hard and Soft)                                   --
        axi_dm_sg_resetn            : out std_logic                                         --
    );

end axi_vdma_reset;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_reset is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

constant ZERO_VALUE_VECT    : std_logic_vector(128 downto 0) := (others => '0');
constant SEVEN_COUNT        : std_logic_vector(2 downto 0)   := (others => '1');
constant FIFTEEN_COUNT        : std_logic_vector(3 downto 0)   := (others => '1');

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Soft Reset Support
signal s_soft_reset_i               : std_logic := '0';
signal s_soft_reset_i_d1            : std_logic := '0';
signal s_soft_reset_i_re            : std_logic := '0';
signal assert_sftrst_d1             : std_logic := '0';
signal min_assert_sftrst            : std_logic := '0';
--signal min_assert_sftrst_d1         : std_logic := '0';
signal sft_rst_dly1                 : std_logic := '0';
signal sft_rst_dly2                 : std_logic := '0';
signal sft_rst_dly3                 : std_logic := '0';
signal sft_rst_dly4                 : std_logic := '0';
signal sft_rst_dly5                 : std_logic := '0';
signal sft_rst_dly6                 : std_logic := '0';
signal sft_rst_dly7                 : std_logic := '0';
signal sft_rst_dly8                 : std_logic := '0';
signal sft_rst_dly9                 : std_logic := '0';
signal sft_rst_dly10                : std_logic := '0';
signal sft_rst_dly11                : std_logic := '0';
signal sft_rst_dly12                : std_logic := '0';
signal sft_rst_dly13                : std_logic := '0';
signal sft_rst_dly14                : std_logic := '0';
signal sft_rst_dly15                : std_logic := '0';
signal soft_reset_d1                : std_logic := '0';
signal soft_reset_re                : std_logic := '0';

-- Composite reset (hard and soft)
signal resetn_i                     : std_logic := '1';

-- Data Mover Halt
signal halt_i                       : std_logic := '0';
signal halt_reset                   : std_logic := '0';

signal run_stop_d1                  : std_logic := '0'; -- 
signal run_stop_fe                  : std_logic := '0'; -- 

-- Reset outputs
signal axis_resetn_i                : std_logic := '1';
signal prmry_resetn_i               : std_logic := '1';
signal axi_sg_resetn_i              : std_logic := '1';

signal hrd_axi_resetn_i               : std_logic := '1';
signal sg_min_assert_sftrst         : std_logic := '0';
signal sg_soft_reset_re             : std_logic := '0';
signal sg_all_idle                  : std_logic := '0';
signal lite_min_assert_sftrst       : std_logic := '0';
signal lite_soft_reset_re           : std_logic := '0';
signal lite_all_idle                : std_logic := '0';
signal axis_min_assert_sftrst       : std_logic := '0';
signal axis_soft_reset_re           : std_logic := '0';
signal axis_all_idle                : std_logic := '0';
-- Soft reset support
signal prmry_min_assert_sftrst      : std_logic := '0';
signal p_sg_min_assert_sftrst       : std_logic := '0';
signal p_lite_min_assert_sftrst     : std_logic := '0';
signal p_axis_min_assert_sftrst     : std_logic := '0';
signal clear_sft_rst_hold           : std_logic := '0';
signal sg_clear_sft_rst_hold        : std_logic := '0';
signal lite_clear_sft_rst_hold      : std_logic := '0';
signal axis_clear_sft_rst_hold      : std_logic := '0';
signal prmry_min_count              : std_logic_vector(3 downto 0)  := (others => '0');
signal sg_min_count                 : std_logic_vector(3 downto 0)  := (others => '0');
signal lite_min_count               : std_logic_vector(3 downto 0)  := (others => '0');
signal axis_min_count               : std_logic_vector(3 downto 0)  := (others => '0');

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

hrd_axi_resetn <= hrd_axi_resetn_i;
-------------------------------------------------------------------------------
-- Internal Hard Reset
-- Generate reset on hardware reset or soft reset
-------------------------------------------------------------------------------
resetn_i    <= '0' when s_soft_reset_i = '1'
                     or min_assert_sftrst = '1'
                     or hrd_axi_resetn_i = '0'
          else '1';

-------------------------------------------------------------------------------
-- Minimum Reset Logic for Soft Reset
-------------------------------------------------------------------------------
-- Register to generate rising edge on soft reset and falling edge
-- on reset assertion.
REG_SFTRST_FOR_RE : process(prmry_axi_aclk)
    begin
        if(prmry_axi_aclk'EVENT and prmry_axi_aclk = '1')then
            s_soft_reset_i_d1 <= s_soft_reset_i;
            assert_sftrst_d1  <= min_assert_sftrst;

            -- Register soft reset from DMACR to create
            -- rising edge pulse
            soft_reset_d1     <= soft_reset;

        end if;
    end process REG_SFTRST_FOR_RE;

-- rising edge pulse on internal soft reset
s_soft_reset_i_re <=  s_soft_reset_i and not s_soft_reset_i_d1;

-- rising edge pulse on DMACR soft reset
soft_reset_re   <= soft_reset and not soft_reset_d1;

-- falling edge detection on min soft rst to clear soft reset
-- bit in register module
soft_reset_clr <= (not min_assert_sftrst and assert_sftrst_d1)
                    or (not hrd_axi_resetn_i);

-------------------------------------------------------------------------------
-- Run Stop turned off by user (i.e. not an error and not a soft reset)
-------------------------------------------------------------------------------
-- 
-- Generate falling edge pulse for run_stop de-assertion
-- indicating run_stop turned off.
-- Only assert if not soft_reset and not stop (i.e. error)
REG_RUN_STOP_FE : process(prmry_axi_aclk)
    begin
        if(prmry_axi_aclk'EVENT and prmry_axi_aclk = '1')then
            if(resetn_i = '0' or soft_reset = '1' or stop = '1')then
                run_stop_d1 <= '0';
            else
                run_stop_d1 <= run_stop;
            end if;
        end if;
     end process REG_RUN_STOP_FE;

run_stop_fe <=   not run_stop and run_stop_d1;


---------------------------------------------------------------------------
-- Minimum soft reset in primary domain
---------------------------------------------------------------------------





GEN_MIN_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin

    PRMRY_MIN_RESET_ASSERTION : process(prmry_axi_aclk)
        begin
            if(prmry_axi_aclk'EVENT and prmry_axi_aclk = '1')then
                if(clear_sft_rst_hold = '1')then
                    prmry_min_count <= (others => '0');
                    prmry_min_assert_sftrst <= '0';
                elsif(s_soft_reset_i_re = '1')then
                    prmry_min_count <= (others => '0');
                    prmry_min_assert_sftrst <= '1';
                elsif(prmry_min_assert_sftrst='1' and prmry_min_count = FIFTEEN_COUNT)then
                    prmry_min_count <= FIFTEEN_COUNT;
                    prmry_min_assert_sftrst <= '1';
                elsif(prmry_min_assert_sftrst='1' and all_idle = '1')then
                    prmry_min_count <= std_logic_vector(unsigned(prmry_min_count) + 1);
                    prmry_min_assert_sftrst <= '1';
                end if;
            end if;
        end process PRMRY_MIN_RESET_ASSERTION;


    ---------------------------------------------------------------------------
    -- Minimum soft reset in lite domain
    ---------------------------------------------------------------------------
----    LITE_RESET_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE          => CDC_TYPE_PULSE_P_S_OPEN_ENDED_NO_RST                   ,
----            C_VECTOR_WIDTH      => 1
----        )
----        port map(
----            prmry_aclk                  => prmry_axi_aclk           ,
----            prmry_resetn                => '1'                      ,
----            scndry_aclk                 => s_axi_lite_aclk          ,
----            scndry_resetn               => '1'                      ,
----            scndry_in                   => '0'                      ,
----            prmry_out                   => open                     ,
----            prmry_in                    => s_soft_reset_i_re        ,
----            scndry_out                  => lite_soft_reset_re       ,
----            scndry_vect_s_h             => '0'                      ,
----            scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----            prmry_vect_out              => open                     ,
----            prmry_vect_s_h              => '0'                      ,
----            prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----            scndry_vect_out             => open
----        );



LITE_RESET_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_axi_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => s_soft_reset_i_re, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axi_lite_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => lite_soft_reset_re,
        scndry_vect_out            => open
    );







----    LITE_IDLE_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE          => CDC_TYPE_LEVEL_P_S_NO_RST                   ,
----            C_VECTOR_WIDTH      => 1
----        )
----        port map(
----            prmry_aclk                  => prmry_axi_aclk           ,
----            prmry_resetn                => '1'                      ,
----            scndry_aclk                 => s_axi_lite_aclk          ,
----            scndry_resetn               => '1'                      ,
----            scndry_in                   => '0'                      ,
----            prmry_out                   => open                     ,
----            prmry_in                    => all_idle                 ,
----            scndry_out                  => lite_all_idle            ,
----            scndry_vect_s_h             => '0'                      ,
----            scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----            prmry_vect_out              => open                     ,
----            prmry_vect_s_h              => '0'                      ,
----            prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----            scndry_vect_out             => open
----        );


LITE_IDLE_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_axi_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => all_idle, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axi_lite_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => lite_all_idle,
        scndry_vect_out            => open
    );










    LITE_MIN_RESET_ASSERTION : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(lite_clear_sft_rst_hold = '1')then
                    lite_min_count          <= (others => '0');
                    lite_min_assert_sftrst  <= '0';
                elsif(lite_soft_reset_re = '1')then
                    lite_min_count <= (others => '0');
                    lite_min_assert_sftrst <= '1';
                elsif(lite_min_assert_sftrst='1' and lite_min_count = FIFTEEN_COUNT)then
                    lite_min_count <= FIFTEEN_COUNT;
                    lite_min_assert_sftrst <= '1';
                elsif(lite_min_assert_sftrst ='1' and lite_all_idle = '1')then
                    lite_min_count <= std_logic_vector(unsigned(lite_min_count) + 1);
                    lite_min_assert_sftrst <= '1';
                end if;
            end if;
        end process LITE_MIN_RESET_ASSERTION;

    -- Cross back to primary
----    LITE_MIN_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE          => CDC_TYPE_LEVEL_S_P_NO_RST                   ,
----            C_VECTOR_WIDTH      => 1
----        )
----        port map(
----            prmry_aclk                  => prmry_axi_aclk           ,
----            prmry_resetn                => '1'                      ,
----            scndry_aclk                 => s_axi_lite_aclk          ,
----            scndry_resetn               => '1'                      ,
----            scndry_in                   => lite_min_assert_sftrst   ,
----            prmry_out                   => p_lite_min_assert_sftrst ,
----            prmry_in                    => '0'                      ,
----            scndry_out                  => open                     ,
----            scndry_vect_s_h             => '0'                      ,
----            scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----            prmry_vect_out              => open                     ,
----            prmry_vect_s_h              => '0'                      ,
----            prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----            scndry_vect_out             => open
----        );
----


LITE_MIN_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axi_lite_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => lite_min_assert_sftrst, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_axi_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => p_lite_min_assert_sftrst,
        scndry_vect_out            => open
    );





----    LITE_CLR_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE          => CDC_TYPE_PULSE_P_S_OPEN_ENDED_NO_RST                   ,
----            C_VECTOR_WIDTH      => 1
----        )
----        port map(
----            prmry_aclk                  => prmry_axi_aclk           ,
----            prmry_resetn                => '1'                      ,
----            scndry_aclk                 => s_axi_lite_aclk          ,
----            scndry_resetn               => '1'                      ,
----            scndry_in                   => '0'                      ,
----            prmry_out                   => open                     ,
----            prmry_in                    => clear_sft_rst_hold       ,
----            scndry_out                  => lite_clear_sft_rst_hold  ,
----            scndry_vect_s_h             => '0'                      ,
----            scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----            prmry_vect_out              => open                     ,
----            prmry_vect_s_h              => '0'                      ,
----            prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----            scndry_vect_out             => open
----        );
----


LITE_CLR_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_axi_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => clear_sft_rst_hold, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axi_lite_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => lite_clear_sft_rst_hold,
        scndry_vect_out            => open
    );








    ---------------------------------------------------------------------------
    -- Minimum soft reset in axis domain
    ---------------------------------------------------------------------------
----    AXIS_RESET_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE          => CDC_TYPE_PULSE_P_S_OPEN_ENDED_NO_RST                   ,
----            C_VECTOR_WIDTH      => 1
----        )
----        port map(
----            prmry_aclk                  => prmry_axi_aclk           ,
----            prmry_resetn                => '1'                      ,
----            scndry_aclk                 => prmry_axis_aclk          ,
----            scndry_resetn               => '1'                      ,
----            scndry_in                   => '0'                      ,
----            prmry_out                   => open                     ,
----            prmry_in                    => s_soft_reset_i_re        ,
----            scndry_out                  => axis_soft_reset_re       ,
----            scndry_vect_s_h             => '0'                      ,
----            scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----            prmry_vect_out              => open                     ,
----            prmry_vect_s_h              => '0'                      ,
----            prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----            scndry_vect_out             => open
----        );


AXIS_RESET_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_axi_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => s_soft_reset_i_re, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_axis_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => axis_soft_reset_re,
        scndry_vect_out            => open
    );








----    AXIS_IDLE_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE          => CDC_TYPE_LEVEL_P_S_NO_RST                   ,
----            C_VECTOR_WIDTH      => 1
----        )
----        port map(
----            prmry_aclk                  => prmry_axi_aclk           ,
----            prmry_resetn                => '1'                      ,
----            scndry_aclk                 => prmry_axis_aclk          ,
----            scndry_resetn               => '1'                      ,
----            scndry_in                   => '0'                      ,
----            prmry_out                   => open                     ,
----            prmry_in                    => all_idle                 ,
----            scndry_out                  => axis_all_idle            ,
----            scndry_vect_s_h             => '0'                      ,
----            scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----            prmry_vect_out              => open                     ,
----            prmry_vect_s_h              => '0'                      ,
----            prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----            scndry_vect_out             => open
----        );
----

AXIS_IDLE_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_axi_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => all_idle, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_axis_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => axis_all_idle,
        scndry_vect_out            => open
    );





    AXIS_MIN_RESET_ASSERTION : process(prmry_axis_aclk)
        begin
            if(prmry_axis_aclk'EVENT and prmry_axis_aclk = '1')then
                if(axis_clear_sft_rst_hold = '1')then
                    axis_min_count          <= (others => '0');
                    axis_min_assert_sftrst  <= '0';
                elsif(axis_soft_reset_re = '1')then
                    axis_min_count <= (others => '0');
                    axis_min_assert_sftrst <= '1';
                elsif(axis_min_assert_sftrst='1' and axis_min_count = FIFTEEN_COUNT)then
                    axis_min_count <= FIFTEEN_COUNT;
                    axis_min_assert_sftrst <= '1';
                elsif(axis_min_assert_sftrst ='1' and axis_all_idle = '1')then
                    axis_min_count <= std_logic_vector(unsigned(axis_min_count) + 1);
                    axis_min_assert_sftrst <= '1';
                end if;
            end if;
        end process AXIS_MIN_RESET_ASSERTION;

    -- Cross back to primary
----    AXIS_MIN_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE          => CDC_TYPE_LEVEL_S_P_NO_RST                   ,
----            C_VECTOR_WIDTH      => 1
----        )
----        port map(
----            prmry_aclk                  => prmry_axi_aclk           ,
----            prmry_resetn                => '1'                      ,
----            scndry_aclk                 => prmry_axis_aclk          ,
----            scndry_resetn               => '1'                      ,
----            scndry_in                   => axis_min_assert_sftrst   ,
----            prmry_out                   => p_axis_min_assert_sftrst ,
----            prmry_in                    => '0'                      ,
----            scndry_out                  => open                     ,
----            scndry_vect_s_h             => '0'                      ,
----            scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----            prmry_vect_out              => open                     ,
----            prmry_vect_s_h              => '0'                      ,
----            prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----            scndry_vect_out             => open
----        );



AXIS_MIN_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_axis_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => axis_min_assert_sftrst, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_axi_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => p_axis_min_assert_sftrst,
        scndry_vect_out            => open
    );





----    AXIS_CLR_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE          => CDC_TYPE_PULSE_P_S_OPEN_ENDED_NO_RST                   ,
----            C_VECTOR_WIDTH      => 1
----        )
----        port map(
----            prmry_aclk                  => prmry_axi_aclk           ,
----            prmry_resetn                => '1'                      ,
----            scndry_aclk                 => prmry_axis_aclk          ,
----            scndry_resetn               => '1'                      ,
----            scndry_in                   => '0'                      ,
----            prmry_out                   => open                     ,
----            prmry_in                    => clear_sft_rst_hold       ,
----            scndry_out                  => axis_clear_sft_rst_hold  ,
----            scndry_vect_s_h             => '0'                      ,
----            scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----            prmry_vect_out              => open                     ,
----            prmry_vect_s_h              => '0'                      ,
----            prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----            scndry_vect_out             => open
----        );




AXIS_CLR_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_axi_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => clear_sft_rst_hold, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_axis_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => axis_clear_sft_rst_hold,
        scndry_vect_out            => open
    );





    ---------------------------------------------------------------------------
    -- Minimum soft reset in sg domain
    ---------------------------------------------------------------------------
    GEN_FOR_SG : if C_INCLUDE_SG = 1 generate
    begin

----        SG_RESET_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE          => CDC_TYPE_PULSE_P_S_OPEN_ENDED_NO_RST                   ,
----                C_VECTOR_WIDTH      => 1
----            )
----            port map(
----                prmry_aclk                  => prmry_axi_aclk           ,
----                prmry_resetn                => '1'                      ,
----                scndry_aclk                 => m_axi_sg_aclk            ,
----                scndry_resetn               => '1'                      ,
----                scndry_in                   => '0'                      ,
----                prmry_out                   => open                     ,
----                prmry_in                    => s_soft_reset_i_re        ,
----                scndry_out                  => sg_soft_reset_re         ,
----                scndry_vect_s_h             => '0'                      ,
----                scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----                prmry_vect_out              => open                     ,
----                prmry_vect_s_h              => '0'                      ,
----                prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----                scndry_vect_out             => open
----            );
----


SG_RESET_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_axi_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => s_soft_reset_i_re, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axi_sg_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => sg_soft_reset_re,
        scndry_vect_out            => open
    );






----        SG_IDLE_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE          => CDC_TYPE_LEVEL_P_S_NO_RST                   ,
----                C_VECTOR_WIDTH      => 1
----            )
----            port map(
----                prmry_aclk                  => prmry_axi_aclk           ,
----                prmry_resetn                => '1'                      ,
----                scndry_aclk                 => m_axi_sg_aclk            ,
----                scndry_resetn               => '1'                      ,
----                scndry_in                   => '0'                      ,
----                prmry_out                   => open                     ,
----                prmry_in                    => all_idle                 ,
----                scndry_out                  => sg_all_idle              ,
----                scndry_vect_s_h             => '0'                      ,
----                scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----                prmry_vect_out              => open                     ,
----                prmry_vect_s_h              => '0'                      ,
----                prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----                scndry_vect_out             => open
----            );
----

SG_IDLE_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_axi_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => all_idle, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axi_sg_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => sg_all_idle,
        scndry_vect_out            => open
    );








        SG_MIN_RESET_ASSERTION : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(sg_clear_sft_rst_hold = '1')then
                        sg_min_count <= (others => '0');
                        sg_min_assert_sftrst <= '0';
                    elsif(sg_soft_reset_re = '1')then
                        sg_min_count <= (others => '0');
                        sg_min_assert_sftrst <= '1';
                    elsif(sg_min_assert_sftrst='1' and sg_min_count = FIFTEEN_COUNT)then
                        sg_min_count <= FIFTEEN_COUNT;
                        sg_min_assert_sftrst <= '1';
                    elsif(sg_min_assert_sftrst ='1' and sg_all_idle = '1')then
                        sg_min_count <= std_logic_vector(unsigned(sg_min_count) + 1);
                        sg_min_assert_sftrst <= '1';
                    end if;
                end if;
            end process SG_MIN_RESET_ASSERTION;

        -- Cross back to primary
----        SG_MIN_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE          => CDC_TYPE_LEVEL_S_P_NO_RST                   ,
----                C_VECTOR_WIDTH      => 1
----            )
----            port map(
----                prmry_aclk                  => prmry_axi_aclk           ,
----                prmry_resetn                => '1'                      ,
----                scndry_aclk                 => m_axi_sg_aclk            ,
----                scndry_resetn               => '1'                      ,
----                scndry_in                   => sg_min_assert_sftrst     ,
----                prmry_out                   => p_sg_min_assert_sftrst   ,
----                prmry_in                    => '0'                      ,
----                scndry_out                  => open                     ,
----                scndry_vect_s_h             => '0'                      ,
----                scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----                prmry_vect_out              => open                     ,
----                prmry_vect_s_h              => '0'                      ,
----                prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----                scndry_vect_out             => open
----            );
----


SG_MIN_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axi_sg_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => sg_min_assert_sftrst, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_axi_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => p_sg_min_assert_sftrst,
        scndry_vect_out            => open
    );






----        SG_CLR_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE          => CDC_TYPE_PULSE_P_S_OPEN_ENDED_NO_RST                   ,
----                C_VECTOR_WIDTH      => 1
----            )
----            port map(
----                prmry_aclk                  => prmry_axi_aclk           ,
----                prmry_resetn                => '1'                      ,
----                scndry_aclk                 => m_axi_sg_aclk            ,
----                scndry_resetn               => '1'                      ,
----                scndry_in                   => '0'                      ,
----                prmry_out                   => open                     ,
----                prmry_in                    => clear_sft_rst_hold       ,
----                scndry_out                  => sg_clear_sft_rst_hold    ,
----                scndry_vect_s_h             => '0'                      ,
----                scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----                prmry_vect_out              => open                     ,
----                prmry_vect_s_h              => '0'                      ,
----                prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----                scndry_vect_out             => open
----            );
----


SG_CLR_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_axi_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => clear_sft_rst_hold, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axi_sg_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => sg_clear_sft_rst_hold,
        scndry_vect_out            => open
    );





        clear_sft_rst_hold <=  prmry_min_assert_sftrst
                              and p_sg_min_assert_sftrst
                              and p_lite_min_assert_sftrst
                              and p_axis_min_assert_sftrst;

        -- Assert minimum soft reset.
        REG_MIN_SFTRST : process(prmry_axi_aclk)
            begin
                if(prmry_axi_aclk'EVENT and prmry_axi_aclk = '1')then
                    if(s_soft_reset_i_re='1')then
                        min_assert_sftrst <= '1';
                    elsif(min_assert_sftrst = '1'
                    and prmry_min_assert_sftrst = '0'
                    and p_sg_min_assert_sftrst = '0'
                    and p_lite_min_assert_sftrst = '0'
                    and p_axis_min_assert_sftrst = '0')then
                        min_assert_sftrst <= '0';
                    end if;
                end if;
            end process REG_MIN_SFTRST;


    end generate GEN_FOR_SG;

    -- No SG so do not look at sg_min_assert signal
    GEN_FOR_NO_SG : if C_INCLUDE_SG = 0 generate
    begin
        clear_sft_rst_hold <=  prmry_min_assert_sftrst
                              and p_lite_min_assert_sftrst
                              and p_axis_min_assert_sftrst;

        -- Assert minimum soft reset.
        REG_MIN_SFTRST : process(prmry_axi_aclk)
            begin
                if(prmry_axi_aclk'EVENT and prmry_axi_aclk = '1')then
                    if(s_soft_reset_i_re='1')then
                        min_assert_sftrst <= '1';
                    elsif(min_assert_sftrst = '1'
                    and prmry_min_assert_sftrst = '0'
                    and p_lite_min_assert_sftrst = '0'
                    and p_axis_min_assert_sftrst = '0')then
                        min_assert_sftrst <= '0';
                    end if;
                end if;
            end process REG_MIN_SFTRST;

    end generate GEN_FOR_NO_SG;



end generate GEN_MIN_FOR_ASYNC;


GEN_MIN_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin
    -- On start of soft reset shift pulse through to assert
    -- 15 clock later.  Used to set minimum 16clk assertion of
    -- reset.  Shift starts when all is idle and internal reset
    -- is asserted.
    MIN_PULSE_GEN : process(prmry_axi_aclk)
        begin
            if(prmry_axi_aclk'EVENT and prmry_axi_aclk = '1')then
                if(s_soft_reset_i_re = '1')then
                    sft_rst_dly1    <= '1';
                    sft_rst_dly2    <= '0';
                    sft_rst_dly3    <= '0';
                    sft_rst_dly4    <= '0';
                    sft_rst_dly5    <= '0';
                    sft_rst_dly6    <= '0';
                    sft_rst_dly7    <= '0';
                    sft_rst_dly8    <= '0';
                    sft_rst_dly9    <= '0';
                    sft_rst_dly10   <= '0';
                    sft_rst_dly11   <= '0';
                    sft_rst_dly12   <= '0';
                    sft_rst_dly13   <= '0';
                    sft_rst_dly14   <= '0';
                    sft_rst_dly15   <= '0';
                elsif(all_idle = '1')then
                    sft_rst_dly1    <= '0';
                    sft_rst_dly2    <= sft_rst_dly1;
                    sft_rst_dly3    <= sft_rst_dly2;
                    sft_rst_dly4    <= sft_rst_dly3;
                    sft_rst_dly5    <= sft_rst_dly4;
                    sft_rst_dly6    <= sft_rst_dly5;
                    sft_rst_dly7    <= sft_rst_dly6;
                    sft_rst_dly8    <= sft_rst_dly7;
                    sft_rst_dly9    <= sft_rst_dly8;
                    sft_rst_dly10    <= sft_rst_dly9;
                    sft_rst_dly11    <= sft_rst_dly10;
                    sft_rst_dly12    <= sft_rst_dly11;
                    sft_rst_dly13    <= sft_rst_dly12;
                    sft_rst_dly14    <= sft_rst_dly13;
                    sft_rst_dly15    <= sft_rst_dly14;
                end if;
            end if;
        end process MIN_PULSE_GEN;

    -- Drive minimum reset assertion for 16 clocks.
    PRMRY_MIN_RESET_ASSERTION : process(prmry_axi_aclk)
        begin
            if(prmry_axi_aclk'EVENT and prmry_axi_aclk = '1')then

                if(s_soft_reset_i_re = '1')then
                    min_assert_sftrst <= '1';
                elsif(sft_rst_dly15 = '1')then
                    min_assert_sftrst <= '0';
                end if;
            end if;
        end process PRMRY_MIN_RESET_ASSERTION;

end generate GEN_MIN_FOR_SYNC;

-------------------------------------------------------------------------------
-- Soft Reset Support
-------------------------------------------------------------------------------
-- Generate reset on hardware reset or soft reset if system is idle
-- On soft reset or error
-- mm2s dma controller will idle immediatly
-- sg fetch engine will complete current task and idle (desc's will flush)
-- sg update engine will update all completed descriptors then idle
REG_SOFT_RESET : process(prmry_axi_aclk)
    begin
        if(prmry_axi_aclk'EVENT and prmry_axi_aclk = '1')then
            if(soft_reset = '1'
            and all_idle = '1' and (halt_cmplt = '1' or halt_reset = '1'))then
                s_soft_reset_i <= '1';
            else
                s_soft_reset_i <= '0';
            end if;
        end if;
    end process REG_SOFT_RESET;

-- Halt datamover on soft_reset or on error.  Halt will stay
-- asserted until s_soft_reset_i assertion which occurs when
-- halt is complete or hard reset
REG_DM_HALT : process(prmry_axi_aclk)
    begin
        if(prmry_axi_aclk'EVENT and prmry_axi_aclk = '1')then
            if(resetn_i = '0')then
                halt_i <= '0';

            -- 
            -- Soft reset or error or turned off therefore issue halt to datamover
            --elsif(soft_reset_re = '1' or stop = '1' or run_stop = '0')then
            --elsif(soft_reset_re = '1' or stop = '1' or run_stop_fe = '1')then
            --
            -- 
            -- flush out datamover and prep for starting up again on next frame sync.  This is really
            -- only needed for flush on frame sync mode.  Signal is redundant in non-flush on frame sync mode
            elsif(soft_reset_re = '1' or stop = '1' or run_stop_fe = '1' or fsize_mismatch_err = '1')then
                halt_i <= '1';
            -- If halt due to turn off then clear on halt reset else will
            -- clear once resetn_i asserts for soft reset
            --elsif(halt_reset = '1' and stop = '0' and run_stop = '1')then
            elsif(halt_reset = '1' and stop = '0' and run_stop = '1')then
                halt_i <= '0';
            end if;
        end if;
    end process REG_DM_HALT;

-- Halt To DataMover
halt <= halt_i;

-- AXI Stream reset output
--REG_AXIS_RESET_OUT : process(prmry_axi_aclk)
--    begin
--        if(prmry_axi_aclk'EVENT and prmry_axi_aclk = '1')then
--            axis_resetn_i   <= resetn_i and not s_soft_reset_i;
--        end if;
--    end process REG_AXIS_RESET_OUT;

-- Registered primary and secondary resets out
REG_RESET_OUT : process(prmry_axi_aclk)
    begin
        if(prmry_axi_aclk'EVENT and prmry_axi_aclk = '1')then
            prmry_resetn_i <= resetn_i;
        end if;
    end process REG_RESET_OUT;


-- Issue hard reset to DM on halt completed
-- specifically for when run_stop is cleared in DMACR
-- Note: If soft_reset then do not issue halt_reset because this will
-- terminate the halt_cmplt too soon and it will not get captured
-- by soft_reset process above. Reset to dm will occur
-- based on resetn_i for the soft_reset case.
HRDRST_DM : process(prmry_axi_aclk)
    begin
        if(prmry_axi_aclk'EVENT and prmry_axi_aclk = '1')then
            --
            -- halt_reset never asserted causing a system hang
            --if(halt_cmplt = '1' and run_stop = '0' and soft_reset = '0')then
            -- 
            --if(halt_cmplt = '1' and halt_i = '1' and soft_reset = '0')then
            if(halt_cmplt = '1' and halt_i = '1' and soft_reset = '0' and stop = '0')then
                halt_reset <= '1';
            elsif(halt_reset = '1' and run_stop = '1')then
                halt_reset <= '0';
            end if;
        end if;
    end process HRDRST_DM;



-- System is asynchronous therefore use CDC module to cross
-- resets to appropriate clock domain
GEN_RESET_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin

    -- Cross top level hard reset in from axi_lite to primary (mm2s or s2mm)
----    HARD_RESET_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE          => CDC_TYPE_LEVEL_P_S_NO_RST                   ,
----            C_VECTOR_WIDTH      => 1
----        )
----        port map(
----            prmry_aclk                  => s_axi_lite_aclk          ,
----            prmry_resetn                => '1'                      ,
----
----            scndry_aclk                 => prmry_axi_aclk           ,
----            scndry_resetn               => '1'                      ,
----
----            -- Secondary to Primary Clock Crossing
----            scndry_in                   => '0'                      ,
----            prmry_out                   => open                     ,
----
----            -- Primary to Secondary Clock Crossing
----            prmry_in                    => axi_resetn               ,
----            scndry_out                  => hrd_axi_resetn_i           ,
----
----            -- Secondary Vector to Primary Vector Clock Crossing
----            scndry_vect_s_h             => '0'                      ,
----            scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----            prmry_vect_out              => open                     ,
----
----            -- Primary Vector to Secondary Vector Clock Crossing
----            prmry_vect_s_h              => '0'                      ,
----            prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----            scndry_vect_out             => open
----
----        );
----


HARD_RESET_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axi_lite_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => axi_resetn, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_axi_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => hrd_axi_resetn_i,
        scndry_vect_out            => open
    );













    -- AXI DataMover Primary Reset (Raw) and primary logic reset
    dm_prmry_resetn         <= resetn_i and not halt_reset;
    prmry_resetn            <= prmry_resetn_i;

    -- Scatter Gather Mode
    GEN_FOR_SG : if C_INCLUDE_SG = 1 generate
    begin
--        AXI_SG_RESET_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
--            generic map(
--                C_CDC_TYPE          => CDC_TYPE_LEVEL_P_S_NO_RST                   ,
--                C_VECTOR_WIDTH      => 1
--            )
--            port map(
--                prmry_aclk                  => prmry_axi_aclk           ,
--                prmry_resetn                => '1'                      ,
--
--                scndry_aclk                 => m_axi_sg_aclk            ,
--                scndry_resetn               => '1'                      ,
--
--                -- Secondary to Primary Clock Crossing
--                scndry_in                   => '0'                      ,
--                prmry_out                   => open                     ,
--
--                -- Primary to Secondary Clock Crossing
--                prmry_in                    => resetn_i                 ,
--                scndry_out                  => axi_sg_resetn_i          ,
--
--                -- Secondary Vector to Primary Vector Clock Crossing
--                scndry_vect_s_h             => '0'                      ,
--                scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
--                prmry_vect_out              => open                     ,
--
--                -- Primary Vector to Secondary Vector Clock Crossing
--                prmry_vect_s_h              => '0'                      ,
--                prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
--                scndry_vect_out             => open
--
--            );
--

AXI_SG_RESET_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_axi_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => resetn_i, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axi_sg_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => axi_sg_resetn_i,
        scndry_vect_out            => open
    );










        -- Scatter Gather Datamover and Logic Reset
        axi_dm_sg_resetn    <= axi_sg_resetn_i;
        axi_sg_resetn       <= axi_sg_resetn_i;
    end generate GEN_FOR_SG;
    -- Register Direct Mode
    GEN_FOR_NO_SG : if C_INCLUDE_SG = 0 generate
        axi_dm_sg_resetn <= '1';
        axi_sg_resetn    <= '1';
    end generate GEN_FOR_NO_SG;

----    AXIS_RESET_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE          => CDC_TYPE_LEVEL_P_S_NO_RST                   ,
----            C_VECTOR_WIDTH      => 1
----        )
----        port map(
----            prmry_aclk                  => prmry_axi_aclk           ,
----            prmry_resetn                => '1'                      ,
----
----            scndry_aclk                 => prmry_axis_aclk          ,
----            scndry_resetn               => '1'                      ,
----
----            -- Secondary to Primary Clock Crossing
----            scndry_in                   => '0'                      ,
----            prmry_out                   => open                     ,
----
----            -- Primary to Secondary Clock Crossing
----            prmry_in                    => resetn_i                 ,
----            scndry_out                  => axis_resetn_i            ,
----
----            -- Secondary Vector to Primary Vector Clock Crossing
----            scndry_vect_s_h             => '0'                      ,
----            scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----            prmry_vect_out              => open                     ,
----
----            -- Primary Vector to Secondary Vector Clock Crossing
----            prmry_vect_s_h              => '0'                      ,
----            prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----            scndry_vect_out             => open
----
----        );


AXIS_RESET_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => prmry_axi_aclk,
        prmry_resetn               => '1', 
        prmry_in                   => resetn_i, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_axis_aclk, 
        scndry_resetn              => '1',
        scndry_out                 => axis_resetn_i,
        scndry_vect_out            => open
    );








    -- AXIS (MM2S or S2MM) logic reset and reset out
    axis_resetn       <= axis_resetn_i;
    axis_reset_out_n  <= axis_resetn_i;

end generate GEN_RESET_FOR_ASYNC;


-- System is synchronous therefore map internal resets to all
-- reset outputs
GEN_RESET_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin

    -- Hard reset in
    hrd_axi_resetn_i          <= axi_resetn;

    -- AXI DataMover Primary Reset (Raw) and primary logic reset
    prmry_resetn            <= prmry_resetn_i;
    dm_prmry_resetn         <= resetn_i and not halt_reset;

    -- Scatter Gather Mode
    GEN_FOR_SG : if C_INCLUDE_SG = 1 generate
    begin
        -- Scatter Gather Engine Reset
        axi_sg_resetn           <= prmry_resetn_i;
        axi_dm_sg_resetn        <= resetn_i;
    end generate GEN_FOR_SG;
    -- Register Direct Mode
    GEN_FOR_NO_SG : if C_INCLUDE_SG = 0 generate
    begin
        -- Scatter Gather Engine Reset
        axi_sg_resetn           <= '1';
        axi_dm_sg_resetn        <= '1';
    end generate GEN_FOR_NO_SG;


    -- AXIS (MM2S or S2MM) logic reset and reset out
    axis_resetn       <= prmry_resetn_i;
    axis_reset_out_n  <= prmry_resetn_i;

end  generate GEN_RESET_FOR_SYNC;




end implementation;



-------------------------------------------------------------------------------
-- axi_vdma_rst_module
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_rst_module.vhd
-- Description: This entity is the top level reset module entity for the
--              AXI VDMA core.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

--use proc_common_v4_0.family_support.all;


-------------------------------------------------------------------------------
entity  axi_vdma_rst_module is
    generic(
        C_INCLUDE_MM2S                  : integer range 0 to 1      := 1;
            -- Include or exclude MM2S primary data path
            -- 0 = Exclude MM2S primary data path
            -- 1 = Include MM2S primary data path

        C_INCLUDE_S2MM                  : integer range 0 to 1      := 1;
            -- Include or exclude S2MM primary data path
            -- 0 = Exclude S2MM primary data path
            -- 1 = Include S2MM primary data path

        C_INCLUDE_SG                    : integer range 0 to 1      := 1;
            -- Include or Exclude Scatter Gather Engine
            -- 0 = Exclude Scatter Gather Engine (Enables Register Direct Mode)
            -- 1 = Include Scatter Gather Engine

        C_PRMRY_IS_ACLK_ASYNC       	: integer range 0 to 1          := 0
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.
    );
    port (
        -----------------------------------------------------------------------
        -- Clock Sources
        -----------------------------------------------------------------------
        s_axi_lite_aclk             : in  std_logic                         ;           --
        m_axi_sg_aclk               : in  std_logic                         ;           --
        m_axi_mm2s_aclk             : in  std_logic                         ;           --
        m_axis_mm2s_aclk            : in  std_logic                         ;           --
        m_axi_s2mm_aclk             : in  std_logic                         ;           --
        s_axis_s2mm_aclk            : in  std_logic                         ;           --
                                                                                        --
        -----------------------------------------------------------------------         --
        -- Hard Reset                                                                   --
        -----------------------------------------------------------------------         --
        axi_resetn                  : in  std_logic                         ;           --
                                                                                        --
        -----------------------------------------------------------------------         --
        -- MM2S Soft Reset Support                                                      --
        -----------------------------------------------------------------------         --
        mm2s_soft_reset             : in  std_logic                         ;           --
        mm2s_soft_reset_clr         : out std_logic := '0'                  ;           --
        mm2s_all_idle               : in  std_logic                         ;           --
        mm2s_fsize_mismatch_err     : in  std_logic                         ;           -- 
        mm2s_stop                   : in  std_logic                         ;           --
        mm2s_halt                   : out std_logic := '0'                  ;           --
        mm2s_halt_cmplt             : in  std_logic                         ;           --
        mm2s_run_stop               : in  std_logic                         ;           --
                                                                                        --
        -----------------------------------------------------------------------         --
        -- S2MM Soft Reset Support                                                      --
        -----------------------------------------------------------------------         --
        s2mm_soft_reset             : in  std_logic                         ;           --
        s2mm_soft_reset_clr         : out std_logic := '0'                  ;           --
        s2mm_all_idle               : in  std_logic                         ;           --
        s2mm_fsize_mismatch_err     : in  std_logic                         ;           -- 
        s2mm_stop                   : in  std_logic                         ;           --
        s2mm_halt                   : out std_logic := '0'                  ;           --
        s2mm_halt_cmplt             : in  std_logic                         ;           --
        s2mm_run_stop               : in  std_logic                         ;           --
                                                                                        --
        -----------------------------------------------------------------------         --
        -- SG Status                                                                    --
        -----------------------------------------------------------------------         --
        ftch_err                    : in  std_logic                         ;           --
                                                                                        --
        -----------------------------------------------------------------------         --
        -- MM2S Distributed Reset Out                                                   --
        -----------------------------------------------------------------------         --
        -- AXI Upsizer and Line Buffer                                                  --
        mm2s_prmry_resetn           : out std_logic := '1'                  ;           --
        -- AXI DataMover Primary Reset (Raw)                                            --
        mm2s_dm_prmry_resetn        : out std_logic := '1'                  ;           --
        -- AXI Stream Logic Reset                                                       --
        mm2s_axis_resetn            : out std_logic := '1'                  ;           --
        -- AXI Stream Reset Outputs                                                     --
        mm2s_axis_reset_out_n       : out std_logic := '1'                  ;           --
                                                                                        --
        -----------------------------------------------------------------------         --
        -- S2MM Distributed Reset Out                                                   --
        -----------------------------------------------------------------------         --
        -- AXI Upsizer and Line Buffer                                                  --
        s2mm_prmry_resetn           : out std_logic := '1'                  ;           --
        -- AXI DataMover Primary Reset (Raw)                                            --
        s2mm_dm_prmry_resetn        : out std_logic := '1'                  ;           --
        -- AXI Stream Logic Reset                                                       --
        s2mm_axis_resetn            : out std_logic := '1'                  ;           --
        -- AXI Stream Reset Outputs                                                     --
        s2mm_axis_reset_out_n       : out std_logic := '1'                  ;           --
                                                                                        --
        -----------------------------------------------------------------------         --
        -- Scatter Gather Distributed Reset Out                                         --
        -----------------------------------------------------------------------         --
        m_axi_sg_resetn             : out std_logic := '1'                  ;           --
        m_axi_dm_sg_resetn          : out std_logic := '1'                  ;           --
                                                                                        --
        -----------------------------------------------------------------------         --
        -- Hard Reset Out                                                               --
        -----------------------------------------------------------------------         --
        s_axi_lite_resetn           : out std_logic := '1'                  ;           --
        mm2s_hrd_resetn             : out std_logic := '1'                  ;           --
        s2mm_hrd_resetn             : out std_logic := '1'                              --
    );

end axi_vdma_rst_module;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_rst_module is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------


signal hrd_resetn_i                     : std_logic := '1';
--signal axi_lite_resetn_d1               : std_logic := '1';
signal mm2s_axi_sg_resetn               : std_logic := '1';
signal mm2s_dm_axi_sg_resetn            : std_logic := '1';
signal s2mm_axi_sg_resetn               : std_logic := '1';
signal s2mm_dm_axi_sg_resetn            : std_logic := '1';



Attribute KEEP : string; -- declaration
Attribute EQUIVALENT_REGISTER_REMOVAL : string; -- declaration




-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin




REG_HRD_RST : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            hrd_resetn_i        <= axi_resetn;
        end if;
    end process REG_HRD_RST;

s_axi_lite_resetn   <= hrd_resetn_i;



-- Generate MM2S reset signals
GEN_RESET_FOR_MM2S : if C_INCLUDE_MM2S = 1 generate
signal sig_mm2s_dm_prmry_resetn              : std_logic := '1';
signal sig_mm2s_axis_resetn                  : std_logic := '1';

signal sig_mm2s_prmry_resetn                     : std_logic := '1';
Attribute KEEP of sig_mm2s_prmry_resetn         : signal is "TRUE";
Attribute EQUIVALENT_REGISTER_REMOVAL of sig_mm2s_prmry_resetn        : signal is "no";
Attribute KEEP of sig_mm2s_dm_prmry_resetn      : signal is "TRUE";
Attribute EQUIVALENT_REGISTER_REMOVAL of sig_mm2s_dm_prmry_resetn     : signal is "no";
Attribute KEEP of sig_mm2s_axis_resetn          : signal is "TRUE";
Attribute EQUIVALENT_REGISTER_REMOVAL of sig_mm2s_axis_resetn         : signal is "no";


begin

mm2s_prmry_resetn <= sig_mm2s_prmry_resetn;
mm2s_dm_prmry_resetn <= sig_mm2s_dm_prmry_resetn;

mm2s_axis_resetn <= sig_mm2s_axis_resetn;

    RESET_I : entity  axi_vdma_v6_3_10.axi_vdma_reset
        generic map(
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC        ,
            C_INCLUDE_SG                => C_INCLUDE_SG                 -- 
        )
        port map(
            -- Clock Sources
            s_axi_lite_aclk             => s_axi_lite_aclk              ,
            m_axi_sg_aclk               => m_axi_sg_aclk                ,
            prmry_axi_aclk              => m_axi_mm2s_aclk              ,
            prmry_axis_aclk             => m_axis_mm2s_aclk             ,

            -- Hard Reset
            axi_resetn                  => hrd_resetn_i                 ,
            hrd_axi_resetn              => mm2s_hrd_resetn                 ,

            -- Soft Reset
            soft_reset                  => mm2s_soft_reset              ,
            soft_reset_clr              => mm2s_soft_reset_clr          ,

            run_stop                    => mm2s_run_stop                ,
            all_idle                    => mm2s_all_idle                ,
            stop                        => mm2s_stop                    ,
            halt                        => mm2s_halt                    ,
            halt_cmplt                  => mm2s_halt_cmplt              ,
            fsize_mismatch_err          => mm2s_fsize_mismatch_err      ,   -- 


            -- MM2S Main Primary Reset (Hard and Soft)
            prmry_resetn                => sig_mm2s_prmry_resetn            ,
            -- MM2S Main Datamover Primary Reset (RAW) (Hard and Soft)
            dm_prmry_resetn             => sig_mm2s_dm_prmry_resetn         ,
            -- AXI Stream Reset (Hard and Soft)
            axis_resetn                 => sig_mm2s_axis_resetn             ,
            -- AXI Stream Reset Out (Hard and Soft)
            axis_reset_out_n            => mm2s_axis_reset_out_n        ,
            -- AXI Scatter/Gather Reset (Hard and Soft)
            axi_sg_resetn               => mm2s_axi_sg_resetn           ,
            -- AXI Scatter/Gather Reset (RAW) (Hard and Soft)
            axi_dm_sg_resetn            => mm2s_dm_axi_sg_resetn
        );


end generate GEN_RESET_FOR_MM2S;


-- No MM2S therefore tie off mm2s reset signals
GEN_NO_RESET_FOR_MM2S : if C_INCLUDE_MM2S = 0 generate
begin
    mm2s_prmry_resetn       <= '1';
    mm2s_dm_prmry_resetn    <= '1';
    mm2s_axis_resetn        <= '1';
    mm2s_axis_reset_out_n   <= '1';
    mm2s_axi_sg_resetn      <= '1';
    mm2s_dm_axi_sg_resetn   <= '1';
    mm2s_halt               <= '0';
    mm2s_soft_reset_clr     <= '0';
end generate GEN_NO_RESET_FOR_MM2S;


-- Generate S2MM reset signals
GEN_RESET_FOR_S2MM : if C_INCLUDE_S2MM = 1 generate
signal sig_s2mm_dm_prmry_resetn              : std_logic := '1';
signal sig_s2mm_axis_resetn                  : std_logic := '1';

signal sig_s2mm_prmry_resetn                 : std_logic := '1';
Attribute KEEP of sig_s2mm_prmry_resetn         : signal is "TRUE";
Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s2mm_prmry_resetn        : signal is "no";
Attribute KEEP of sig_s2mm_dm_prmry_resetn      : signal is "TRUE";
Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s2mm_dm_prmry_resetn     : signal is "no";
Attribute KEEP of sig_s2mm_axis_resetn          : signal is "TRUE";
Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s2mm_axis_resetn         : signal is "no";



begin

s2mm_prmry_resetn <= sig_s2mm_prmry_resetn;
s2mm_dm_prmry_resetn <= sig_s2mm_dm_prmry_resetn;
s2mm_axis_resetn <= sig_s2mm_axis_resetn;

    RESET_I : entity  axi_vdma_v6_3_10.axi_vdma_reset
        generic map(
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC        ,
            C_INCLUDE_SG                => C_INCLUDE_SG                 -- 
        )
        port map(
            -- Clock Sources
            s_axi_lite_aclk             => s_axi_lite_aclk              ,
            m_axi_sg_aclk               => m_axi_sg_aclk                ,
            prmry_axi_aclk              => m_axi_s2mm_aclk              ,
            prmry_axis_aclk             => s_axis_s2mm_aclk             ,

            -- Hard Reset
            axi_resetn                  => hrd_resetn_i                 ,
            hrd_axi_resetn              => s2mm_hrd_resetn                 ,

            -- Soft Reset
            soft_reset                  => s2mm_soft_reset              ,
            soft_reset_clr              => s2mm_soft_reset_clr          ,

            run_stop                    => s2mm_run_stop                ,
            all_idle                    => s2mm_all_idle                ,
            stop                        => s2mm_stop                    ,
            halt                        => s2mm_halt                    ,
            halt_cmplt                  => s2mm_halt_cmplt              ,
            fsize_mismatch_err          => s2mm_fsize_mismatch_err      ,   -- 

            -- MM2S Main Primary Reset (Hard and Soft)
            prmry_resetn                => sig_s2mm_prmry_resetn            ,
            -- MM2S Main Datamover Primary Reset (RAW) (Hard and Soft)
            dm_prmry_resetn             => sig_s2mm_dm_prmry_resetn         ,
            -- AXI Stream Reset (Hard and Soft)
            axis_resetn                 => sig_s2mm_axis_resetn             ,
            -- AXI Stream Reset Out (Hard and Soft)
            axis_reset_out_n            => s2mm_axis_reset_out_n        ,
            -- AXI Scatter/Gather Reset (Hard and Soft)
            axi_sg_resetn               => s2mm_axi_sg_resetn           ,
            -- AXI Scatter/Gather Reset (RAW) (Hard and Soft)
            axi_dm_sg_resetn            => s2mm_dm_axi_sg_resetn
        );

end generate GEN_RESET_FOR_S2MM;

-- No SsMM therefore tie off mm2s reset signals
GEN_NO_RESET_FOR_S2MM : if C_INCLUDE_S2MM = 0 generate
begin
    s2mm_prmry_resetn       <= '1';
    s2mm_dm_prmry_resetn    <= '1';
    s2mm_axis_resetn        <= '1';
    s2mm_axis_reset_out_n   <= '1';
    s2mm_axi_sg_resetn      <= '1';
    s2mm_dm_axi_sg_resetn   <= '1';
    s2mm_halt               <= '0';
    s2mm_soft_reset_clr     <= '0';
end generate GEN_NO_RESET_FOR_S2MM;

-- Scatter Gather Mode
GEN_FOR_SG : if C_INCLUDE_SG = 1 generate
begin
    REG_SG_RESET_OUT : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then

                -- If there is a scatter gather error, then a reset on either channel
                -- (soft or hard) will reset axi_sg engine
                if(ftch_err = '1')then
                    m_axi_sg_resetn     <= mm2s_axi_sg_resetn and s2mm_axi_sg_resetn;
                    m_axi_dm_sg_resetn  <= mm2s_dm_axi_sg_resetn and s2mm_dm_axi_sg_resetn;
                -- If no scatter gather erros then only a hard reset will reset scatter gather engine
                else
                    m_axi_sg_resetn     <= hrd_resetn_i;
                    m_axi_dm_sg_resetn  <= hrd_resetn_i;
                end if;
            end if;
        end process REG_SG_RESET_OUT;
end generate GEN_FOR_SG;

-- Register Direct Mode
GEN_FOR_NO_SG : if C_INCLUDE_SG = 0 generate
begin
    m_axi_sg_resetn    <= '1';
    m_axi_dm_sg_resetn <= '1';
end generate GEN_FOR_NO_SG;



end implementation;



-------------------------------------------------------------------------------
-- axi_vdma_lite_if
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_lite_if.vhd
-- Description: This entity is AXI Lite Interface Module for the AXI DMA
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

library lib_cdc_v1_0_2;
library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;


-------------------------------------------------------------------------------
entity  axi_vdma_lite_if is
    generic(


        C_MM2S_IS              		: integer range 0 to 1      	:= 1;
            -- Include or exclude MM2S channel
            -- 0 = exclude mm2s channel
            -- 1 = include mm2s channel

        C_S2MM_IS              		: integer range 0 to 1      	:= 1;
            -- Include or exclude S2MM channel
            -- 0 = exclude s2mm channel
            -- 1 = include s2mm channel


        C_PRMRY_IS_ACLK_ASYNC         	: integer range 0 to 1     	:= 1;
            -- Specifies the AXI Lite clock is asynchronous
            -- 0 = AXI Clocks are Synchronous
            -- 1 = AXI Clocks are Asynchronous
        C_NUM_CE                	: integer                	:= 8           ;
        C_S_AXI_LITE_ADDR_WIDTH     	: integer range 9 to 9   	:= 9           ;
        C_S_AXI_LITE_DATA_WIDTH     	: integer range 32 to 32 	:= 32
    );
    port (
        -----------------------------------------------------------------------         --
        -- AXI Lite Control Interface                                                   --
        -----------------------------------------------------------------------         --
        s_axi_lite_aclk             : in  std_logic                         ;           --
        s_axi_lite_aresetn          : in  std_logic                         ;           --

        m_axi_mm2s_aclk             : in  std_logic                                 ;       --
        mm2s_hrd_resetn             : in  std_logic                                 ;       --


        m_axi_s2mm_aclk             : in  std_logic                                 ;       --
        s2mm_hrd_resetn             : in  std_logic                                 ;       --

                                                                                       --
        -- AXI Lite Write Address Channel                                               --
        s_axi_lite_awvalid          : in  std_logic                         ;           --
        s_axi_lite_awready          : out std_logic                         ;           --
        s_axi_lite_awaddr           : in  std_logic_vector                              --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0);           --
                                                                                        --
        -- AXI Lite Write Data Channel                                                  --
        s_axi_lite_wvalid           : in  std_logic                         ;           --
        s_axi_lite_wready           : out std_logic                         ;           --
        s_axi_lite_wdata            : in  std_logic_vector                              --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);           --
                                                                                        --
        -- AXI Lite Write Response Channel                                              --
        s_axi_lite_bresp            : out std_logic_vector(1 downto 0)      ;           --
        s_axi_lite_bvalid           : out std_logic                         ;           --
        s_axi_lite_bready           : in  std_logic                         ;           --
                                                                                        --
        -- AXI Lite Read Address Channel                                                --
        s_axi_lite_arvalid          : in  std_logic                         ;           --
        s_axi_lite_arready          : out std_logic                         ;           --
        s_axi_lite_araddr           : in  std_logic_vector                              --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0);           --
        s_axi_lite_rvalid           : out std_logic                         ;           --
        s_axi_lite_rready           : in  std_logic                         ;           --
        s_axi_lite_rdata            : out std_logic_vector                              --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);           --
        s_axi_lite_rresp            : out std_logic_vector(1 downto 0)      ;           --
                                                                                        --
        axi2ip_lite_rdaddr          : out std_logic_vector                              --
                                    (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0);           --
        -- MM2S Reg Interface  signals                                                          --
        mm2s_axi2ip_wrdata          : out std_logic_vector                              --
                                    (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);           --
        mm2s_axi2ip_wrce            : out std_logic_vector                              --
                                    (C_NUM_CE-1 downto 0)               ;           --
        mm2s_ip2axi_rddata          : in std_logic_vector                               --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  ;          --
        mm2s_axi2ip_rdaddr          : out std_logic_vector                              --
                                    (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0);           --

        -- S2MM Reg Interface  signals                                                          --
        s2mm_axi2ip_wrdata          : out std_logic_vector                              --
                                    (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);           --
        s2mm_axi2ip_wrce            : out std_logic_vector                              --
                                    (C_NUM_CE-1 downto 0)               ;           --
        s2mm_ip2axi_rddata          : in std_logic_vector                               --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  ;          --
        s2mm_axi2ip_rdaddr          : out std_logic_vector                              --
                                    (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0);           --


        axi2ip_common_region_1_rden : out std_logic                         ;           --
        axi2ip_common_region_2_rden : out std_logic                         ;           --
                                                                                        --
                                                                                        --
        ip2axi_rddata_common_region : in std_logic_vector                               --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)            --
    );
end axi_vdma_lite_if;


-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_lite_if is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- Register I/F Address offset
constant ADDR_OFFSET    : integer := clog2(C_S_AXI_LITE_DATA_WIDTH/8);
-- Register I/F CE number
constant CE_ADDR_SIZE   : integer := clog2(C_NUM_CE);

constant ZERO_VALUE_VECT    : std_logic_vector(128 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- AXI Lite slave interface signals
signal awvalid              				: std_logic := '0';
signal wvalid               				: std_logic := '0';
signal arvalid              				: std_logic := '0';
signal awaddr               : std_logic_vector
                                (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');
signal wdata                : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');


signal araddr               : std_logic_vector
                                (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');



signal mm2s_ip2axi_rddata_d1           : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) :=(others => '0');
signal s2mm_ip2axi_rddata_d1           : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) :=(others => '0');

signal write_response_accepted     			: std_logic := '0';
signal write_has_started     				: std_logic := '0';


signal awready_out_i            			: std_logic := '0';
signal wready_out_i            				: std_logic := '0';
signal wrce_gen                 			: std_logic_vector(C_NUM_CE-1 downto 0);
signal bvalid_out_i             			: std_logic := '0';



signal read_data_res_accepted     			: std_logic := '0';
signal read_has_started_i     				: std_logic := '0';
signal sig_arvalid_arrived		     		: std_logic := '0';
signal sig_arvalid_arrived_d1		     		: std_logic := '0';
signal sig_arvalid_arrived_d2		     		: std_logic := '0';
signal sig_arvalid_arrived_d3		     		: std_logic := '0';
signal sig_arvalid_arrived_d4		     		: std_logic := '0';
signal sig_arvalid_detected		     		: std_logic := '0';


signal arready_out_i_cmb            			: std_logic := '0';
signal arready_out_i            			: std_logic := '0';
signal arready_out_i_mm2s            			: std_logic := '0';
signal arready_out_i_s2mm            			: std_logic := '0';
signal arready_out_i_common            			: std_logic := '0';
signal rvalid_out_i             			: std_logic := '0';


----Async_mode

signal wready_out_to_bvalid            				: std_logic := '0'; 
signal mm2s_wrce_gen                 				: std_logic_vector(C_NUM_CE-1 downto 0);
signal s2mm_wrce_gen                 				: std_logic_vector(C_NUM_CE-1 downto 0);


signal addr_region_mm2s_rden_cmb		     		: std_logic := '0';
signal addr_region_s2mm_rden_cmb		     		: std_logic := '0';
signal addr_region_1_common_rden_cmb			     	: std_logic := '0';
signal addr_region_2_common_rden_cmb			     	: std_logic := '0';

signal ip2axi_rddata_captured					: std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');                         	--
signal ip2axi_rddata_captured_d1				: std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');                         	--
signal ip2axi_rddata_captured_mm2s_cdc_tig			: std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');                         	--
signal ip2axi_rddata_captured_s2mm_cdc_tig			: std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');                         	--
signal axi2ip_rdaddr_captured					: std_logic_vector(7 downto 2)  := (others => '0');                         	--
--signal axi2ip_rdaddr_captured_mm2s_cdc_tig			: std_logic_vector(C_S_AXI_LITE_ADDR_WIDTH-1 downto 0)  := (others => '0');                         	--
--signal axi2ip_rdaddr_captured_s2mm_cdc_tig			: std_logic_vector(C_S_AXI_LITE_ADDR_WIDTH-1 downto 0)  := (others => '0');                         	--
signal axi2ip_rdaddr_captured_mm2s_cdc_tig			: std_logic_vector(7 downto 2)  := (others => '0');                         	--
signal axi2ip_rdaddr_captured_s2mm_cdc_tig			: std_logic_vector(7 downto 2)  := (others => '0');                         	--
signal axi2ip_wraddr_captured					: std_logic_vector(7 downto 2)  := (others => '0');                         	--
--signal axi2ip_wraddr_captured_mm2s_cdc_tig			: std_logic_vector(C_S_AXI_LITE_ADDR_WIDTH-1 downto 0)  := (others => '0');                         	--
--signal axi2ip_wraddr_captured_s2mm_cdc_tig			: std_logic_vector(C_S_AXI_LITE_ADDR_WIDTH-1 downto 0)  := (others => '0');                         	--
signal axi2ip_wraddr_captured_mm2s_cdc_tig			: std_logic_vector(7 downto 2)  := (others => '0');                         	--
signal axi2ip_wraddr_captured_s2mm_cdc_tig			: std_logic_vector(7 downto 2)  := (others => '0');                         	--
signal arready_out_i_d1            				: std_logic := '0';


signal sig_awvalid_arrived_d1            			: std_logic := '0';
signal sig_awvalid_arrived            				: std_logic := '0';
signal sig_awvalid_detected            				: std_logic := '0';
signal sig_wvalid_arrived            				: std_logic := '0';
signal lite_wr_addr_phase_finished_data_phase_started		: std_logic := '0';
signal prepare_wrce            					: std_logic := '0';
signal prepare_wrce_d1            				: std_logic := '0';

signal prepare_wrce_pulse_lite 					: std_logic := '0';
signal prepare_wrce_pulse_lite_d1 					: std_logic := '0';
signal prepare_wrce_pulse_lite_d2 					: std_logic := '0';
signal prepare_wrce_pulse_lite_d3 					: std_logic := '0';
signal prepare_wrce_pulse_lite_d4 					: std_logic := '0';
signal prepare_wrce_pulse_lite_d5 					: std_logic := '0';
signal prepare_wrce_pulse_lite_d6 					: std_logic := '0';
signal prepare_wrce_pulse_mm2s 					: std_logic := '0';
signal prepare_wrce_pulse_s2mm 					: std_logic := '0';
signal wready_mm2s    	        				: std_logic := '0';
signal wready_s2mm    	        				: std_logic := '0';
signal lite_mm2s_wr_done        				: std_logic := '0';
signal lite_s2mm_wr_done        				: std_logic := '0';
signal lite_wr_done	        				: std_logic := '0';
signal lite_wr_done_d1	        				: std_logic := '0';
signal sig_arvalid_arrived_d1_mm2s_rd_lite_domain     		: std_logic := '0';
signal sig_arvalid_arrived_d1_mm2s		     		: std_logic := '0';
signal sig_arvalid_arrived_d1_s2mm_rd_lite_domain     		: std_logic := '0';
signal sig_arvalid_arrived_d1_s2mm		     		: std_logic := '0';


signal mm2s_axi2ip_wrdata_cdc_tig          			: std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');           --
signal s2mm_axi2ip_wrdata_cdc_tig          			: std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');           --


  ATTRIBUTE async_reg                      : STRING;

  ATTRIBUTE async_reg OF ip2axi_rddata_captured_mm2s_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF ip2axi_rddata_captured_s2mm_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF axi2ip_rdaddr_captured_mm2s_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF axi2ip_rdaddr_captured_s2mm_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF axi2ip_wraddr_captured_mm2s_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF axi2ip_wraddr_captured_s2mm_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF ip2axi_rddata_captured_d1  : SIGNAL IS "true"; 

  ATTRIBUTE async_reg OF mm2s_axi2ip_wrdata_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s2mm_axi2ip_wrdata_cdc_tig  : SIGNAL IS "true"; 

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin


s_axi_lite_awready  <= awready_out_i;
s_axi_lite_wready   <= wready_out_i;
s_axi_lite_bvalid   <= bvalid_out_i;

s_axi_lite_arready  <= arready_out_i;
s_axi_lite_rvalid   <= rvalid_out_i;

axi2ip_lite_rdaddr(8)  <= '0';
axi2ip_lite_rdaddr(7 downto 2)  <= axi2ip_rdaddr_captured(7 downto 2);
axi2ip_lite_rdaddr(1)  <= '0';
axi2ip_lite_rdaddr(0)  <= '0';


mm2s_axi2ip_rdaddr(8)  <= '0';
mm2s_axi2ip_rdaddr(1)  <= '0';
mm2s_axi2ip_rdaddr(0)  <= '0';
s2mm_axi2ip_rdaddr(8)  <= '0';
s2mm_axi2ip_rdaddr(1)  <= '0';
s2mm_axi2ip_rdaddr(0)  <= '0';
s_axi_lite_bresp    <= OKAY_RESP;
s_axi_lite_rresp    <= OKAY_RESP;

-------------------------------------------------------------------------------------------------
--------------------------- Register AXI4-LITE Control signals ----------------------------------
-------------------------------------------------------------------------------------------------
REG_INPUTS : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
                awvalid <=  '0'                 ;
                wvalid  <=  '0'                 ;
                arvalid <=  '0'                 ;
                awaddr  <=  (others => '0')     ;
                wdata   <=  (others => '0')     ;
                araddr  <=  (others => '0')     ;


            else
                awvalid <= s_axi_lite_awvalid   ;
                wvalid  <= s_axi_lite_wvalid    ;
                arvalid <= s_axi_lite_arvalid   ;
                awaddr  <= s_axi_lite_awaddr    ;
                wdata   <= s_axi_lite_wdata     ;
                araddr  <= s_axi_lite_araddr    ;


            end if;
        end if;
    end process REG_INPUTS;


-------------------------------------------------------------------------------
-------------------------------AXI4-LITE WRITE---------------------------------
-------------------------------------------------------------------------------
sig_awvalid_arrived 	<= awvalid;
sig_wvalid_arrived 	<= wvalid;

D1_LITE_WR_ADDR_PHASE_DETECT : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or write_has_started = '1')then
                sig_awvalid_arrived_d1  <= '0';
            else
                sig_awvalid_arrived_d1  <= sig_awvalid_arrived;
            end if;
        end if;
    end process D1_LITE_WR_ADDR_PHASE_DETECT;

AXI4_LITE_WR_STARTED : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or write_response_accepted = '1')then
                write_has_started <= '0';
            elsif(sig_awvalid_detected = '1')then
                write_has_started <= '1';
            end if;
        end if;
    end process AXI4_LITE_WR_STARTED;


sig_awvalid_detected <= sig_awvalid_arrived and not (sig_awvalid_arrived_d1) and not (write_has_started);

--axi2ip_wraddr_captured    <= awaddr when sig_awvalid_detected = '1';
   CAPTURE_AWADDR : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
                axi2ip_wraddr_captured(7 downto 2) 	<= (others => '0');
            elsif(sig_awvalid_detected = '1')then
		axi2ip_wraddr_captured(7 downto 2)  <= awaddr(7 downto 2);
            end if;
        end if;
    end process CAPTURE_AWADDR;





   GEN_LITE_AWREADY : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
                awready_out_i <= '0';
            else
                awready_out_i <= sig_awvalid_detected;
            end if;
        end if;
    end process GEN_LITE_AWREADY;

   GEN_WR_ADDR_PHASE_TO_DATA_PHASE : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or wready_out_i = '1')then
                lite_wr_addr_phase_finished_data_phase_started <= '0';
            elsif(awready_out_i = '1')then
                lite_wr_addr_phase_finished_data_phase_started <= '1';
            end if;
        end if;
    end process GEN_WR_ADDR_PHASE_TO_DATA_PHASE;


--------------------------------------------------------------------------------------------------
--***** SYNC_MODE
--------------------------------------------------------------------------------------------------
GEN_LITE_IS_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate

prepare_wrce <= sig_wvalid_arrived and lite_wr_addr_phase_finished_data_phase_started;

   GEN_WRCE_PULSE : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
              prepare_wrce_d1   <= '0';
            else
              prepare_wrce_d1   <= prepare_wrce;
            end if;
        end if;
    end process GEN_WRCE_PULSE;



-------------------------------------------------------------------------------
-- Decode and assert proper chip enable per captured axi lite write address
-------------------------------------------------------------------------------
AXI4_LITE_WRCE_GEN: for j in 0 to C_NUM_CE - 1 generate

constant BAR    : std_logic_vector(CE_ADDR_SIZE-1 downto 0) :=
                std_logic_vector(to_unsigned(j,CE_ADDR_SIZE));
begin

    wrce_gen(j) <= (prepare_wrce and not prepare_wrce_d1) when axi2ip_wraddr_captured
                                ((CE_ADDR_SIZE + ADDR_OFFSET) - 1
                                                    downto ADDR_OFFSET)

                                = BAR(CE_ADDR_SIZE-1 downto 0)
          else '0';

   end generate AXI4_LITE_WRCE_GEN;

	 mm2s_axi2ip_wrce    <= wrce_gen;
	 s2mm_axi2ip_wrce    <= wrce_gen;



   GEN_LITE_WREADY : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
                wready_out_i  <= '0';
            else
                wready_out_i  <= (prepare_wrce and not prepare_wrce_d1);
            end if;
        end if;
    end process GEN_LITE_WREADY;


	wready_out_to_bvalid 	<= wready_out_i;

-------------------------
--*READ
-------------------------

GEN_LITE_ARREADY_SYNC : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
                arready_out_i <= '0';
            else
                arready_out_i <= sig_arvalid_arrived_d1;
            end if;
        end if;
    end process GEN_LITE_ARREADY_SYNC;



s_axi_lite_rdata    <= ip2axi_rddata_captured_d1;

   process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then

	   ip2axi_rddata_captured_d1 <= ip2axi_rddata_captured;

        end if;
    end process ;





ip2axi_rddata_captured  <=   	ip2axi_rddata_common_region 	when addr_region_1_common_rden_cmb = '1' or addr_region_2_common_rden_cmb = '1'
           		else    mm2s_ip2axi_rddata 		when addr_region_mm2s_rden_cmb = '1'
           		else    s2mm_ip2axi_rddata;

AXI4_LITE_RRESP_PROCESS : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then

                rvalid_out_i        		<= '0';

            elsif(rvalid_out_i = '1' and s_axi_lite_rready = '1')then

                rvalid_out_i        		<= '0';

            elsif(arready_out_i = '1')then       

                rvalid_out_i        <= '1';

            end if;
        end if;
    end process AXI4_LITE_RRESP_PROCESS;
-------------------------
--*READ
-------------------------

mm2s_axi2ip_wrdata  <= wdata;
s2mm_axi2ip_wrdata  <= wdata;
mm2s_axi2ip_rdaddr(7 downto 2)  <= axi2ip_rdaddr_captured(7 downto 2);
s2mm_axi2ip_rdaddr(7 downto 2)  <= axi2ip_rdaddr_captured(7 downto 2);

end generate GEN_LITE_IS_SYNC;
--------------------------------------------------------------------------------------------------
--***** SYNC_MODE
--------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-------------------------------AXI4-LITE READ----------------------------------
-------------------------------------------------------------------------------

sig_arvalid_arrived <= arvalid;

D1_LITE_RD_DETECT : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or read_has_started_i = '1')then
                sig_arvalid_arrived_d1  <= '0';
            else
                sig_arvalid_arrived_d1  <= sig_arvalid_arrived;
            end if;
        end if;
    end process D1_LITE_RD_DETECT;

AXI4_LITE_RD_STARTED : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or read_data_res_accepted = '1')then
                read_has_started_i <= '0';
            elsif(sig_arvalid_detected = '1')then
                read_has_started_i <= '1';
            end if;
        end if;
    end process AXI4_LITE_RD_STARTED;

sig_arvalid_detected 		<= sig_arvalid_arrived and not (sig_arvalid_arrived_d1) and not (read_has_started_i);
read_data_res_accepted 		<= rvalid_out_i and s_axi_lite_rready;

CAPTURE_ARADDR : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
                axi2ip_rdaddr_captured(7 downto 2) 	<= (others => '0');
            elsif(sig_arvalid_detected = '1')then
		axi2ip_rdaddr_captured(7 downto 2)  <= araddr(7 downto 2);
            end if;
        end if;
    end process CAPTURE_ARADDR;

-------------------------------------------------------------------------------
-- Decode read_lite_addr MSB to get the region of read access
-------------------------------------------------------------------------------
--*****************************************************************************
-- MM2S_Region_1 	(0x00 to 0x1C)
-- MM2S_Region_2 	(0x50 to 0x9C)
-- S2MM_Region_1 	(0x30 to 0x3C)
-- S2MM_Region_2 	(0xA0 to 0xEC)
-- Common_Region_1 	(0x20 to 0x2C)	(common read only register)
-- Common_Region_2 	(0xF0 to 0xFC)	(s2mm read-only registers)
--*****************************************************************************


 
	addr_region_1_common_rden_cmb <= ((not axi2ip_rdaddr_captured(7)) and (not axi2ip_rdaddr_captured(6)) and (axi2ip_rdaddr_captured(5)) and (not axi2ip_rdaddr_captured(4)));

	addr_region_2_common_rden_cmb <=     (axi2ip_rdaddr_captured(7) and     axi2ip_rdaddr_captured(6) and axi2ip_rdaddr_captured(5) and     axi2ip_rdaddr_captured(4));

--MM2S Region read


addr_region_mm2s_rden_cmb <= 	(((not axi2ip_rdaddr_captured(6)) and (not axi2ip_rdaddr_captured(5))) 

					or

				((not axi2ip_rdaddr_captured(7)) and (not axi2ip_rdaddr_captured(5)) and (axi2ip_rdaddr_captured(4)))
					
					or

				((not axi2ip_rdaddr_captured(7)) and (axi2ip_rdaddr_captured(6)) and (axi2ip_rdaddr_captured(5))))

				;


--S2MM Region read


addr_region_s2mm_rden_cmb <= 	(((axi2ip_rdaddr_captured(7)) and (axi2ip_rdaddr_captured(5)) and (not axi2ip_rdaddr_captured(4)))
				
					or

				((not axi2ip_rdaddr_captured(6)) and (axi2ip_rdaddr_captured(5)) and (axi2ip_rdaddr_captured(4)))

					or

				((axi2ip_rdaddr_captured(6)) and (not axi2ip_rdaddr_captured(5)) and (not axi2ip_rdaddr_captured(4)))

					or

				((axi2ip_rdaddr_captured(7)) and (axi2ip_rdaddr_captured(6)) and (not axi2ip_rdaddr_captured(5))));
					

-------------------------------------------------------------------------------
-- Write Response
-------------------------------------------------------------------------------

AXI4_LITE_WRESP_PROCESS : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then

                bvalid_out_i        		<= '0';

            elsif(bvalid_out_i = '1' and s_axi_lite_bready = '1')then

                bvalid_out_i        		<= '0';

            elsif(wready_out_to_bvalid = '1')then       

                bvalid_out_i        <= '1';

            end if;
        end if;
    end process AXI4_LITE_WRESP_PROCESS;

write_response_accepted <= bvalid_out_i and s_axi_lite_bready;



  axi2ip_common_region_1_rden <= addr_region_1_common_rden_cmb;

GEN_S2MM_COM_REG2_READ : if C_S2MM_IS = 1 generate

  axi2ip_common_region_2_rden <= addr_region_2_common_rden_cmb;

end generate GEN_S2MM_COM_REG2_READ;

GEN_NO_S2MM_COM_REG2_READ : if C_S2MM_IS = 0 generate

  axi2ip_common_region_2_rden <= '0';

end generate GEN_NO_S2MM_COM_REG2_READ;




--------------------------------------------------------------------------------------------------
--***** ASYNC_MODE
--------------------------------------------------------------------------------------------------

GEN_LITE_IS_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
--Both channels exist and async mode
 GEN_ASYNC_LITE_ACCESS : if C_MM2S_IS = 1  and C_S2MM_IS = 1 generate


prepare_wrce <= sig_wvalid_arrived and lite_wr_addr_phase_finished_data_phase_started;


   GEN_WRCE_PULSE : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
              prepare_wrce_d1   <= '0';
            else
              prepare_wrce_d1   <= prepare_wrce;
            end if;
        end if;
    end process GEN_WRCE_PULSE;


prepare_wrce_pulse_lite <= prepare_wrce and not prepare_wrce_d1;

--MM2S

----
----      	LITE_WVALID_MM2S_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----      	    generic map(
----      	        C_CDC_TYPE              => CDC_TYPE_PULSE_P_S_OPEN_ENDED                           ,
----      	        C_VECTOR_WIDTH          => 1 
----      	    )
----      	    port map (
----      	        prmry_aclk              => s_axi_lite_aclk                          ,
----      	        prmry_resetn            => s_axi_lite_aresetn                       ,
----      	        scndry_aclk             => m_axi_mm2s_aclk                          ,
----      	        scndry_resetn           => mm2s_hrd_resetn                          ,
----      	        scndry_in               => '0'                                      ,
----      	        prmry_out               => open                                     ,
----      	        prmry_in                => prepare_wrce_pulse_lite           ,
----      	        scndry_out              => prepare_wrce_pulse_mm2s      ,
----      	        scndry_vect_s_h         => '0'                                      ,
----      	        scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0),
----      	        prmry_vect_out          => open                                     ,
----      	        prmry_vect_s_h          => '0'                                      ,
----      	        prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----      	        scndry_vect_out         => open
----      	    );
----


LITE_WVALID_MM2S_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axi_lite_aclk,
        prmry_resetn               => s_axi_lite_aresetn, 
        prmry_in                   => prepare_wrce_pulse_lite, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axi_mm2s_aclk, 
        scndry_resetn              => mm2s_hrd_resetn,
        scndry_out                 => prepare_wrce_pulse_mm2s,
        scndry_vect_out            => open
    );




-------------------------------------------------------------------------------
-- Decode and assert proper chip enable per captured axi lite write address
-------------------------------------------------------------------------------

AXI4_LITE_WRCE_MM2S_GEN: for j in 0 to C_NUM_CE - 1 generate

constant BAR    : std_logic_vector(CE_ADDR_SIZE-1 downto 0) :=
                std_logic_vector(to_unsigned(j,CE_ADDR_SIZE));
begin

    mm2s_wrce_gen(j) <= prepare_wrce_pulse_mm2s when axi2ip_wraddr_captured_mm2s_cdc_tig
                                ((CE_ADDR_SIZE + ADDR_OFFSET) - 1
                                                    downto ADDR_OFFSET)

                                = BAR(CE_ADDR_SIZE-1 downto 0)
          else '0';

   end generate AXI4_LITE_WRCE_MM2S_GEN;


mm2s_axi2ip_wrce     <= mm2s_wrce_gen;


--S2MM


----      	LITE_WVALID_S2MM_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----      	    generic map(
----      	        C_CDC_TYPE              => CDC_TYPE_PULSE_P_S_OPEN_ENDED                           ,
----      	        C_VECTOR_WIDTH          => 1 
----      	    )
----      	    port map (
----      	        prmry_aclk              => s_axi_lite_aclk                          ,
----      	        prmry_resetn            => s_axi_lite_aresetn                       ,
----      	        scndry_aclk             => m_axi_s2mm_aclk                          ,
----      	        scndry_resetn           => s2mm_hrd_resetn                          ,
----      	        scndry_in               => '0'                                      ,
----      	        prmry_out               => open                                     ,
----      	        prmry_in                => prepare_wrce_pulse_lite           ,
----      	        scndry_out              => prepare_wrce_pulse_s2mm      ,
----      	        scndry_vect_s_h         => '0'                                      ,
----      	        scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0),
----      	        prmry_vect_out          => open                                     ,
----      	        prmry_vect_s_h          => '0'                                      ,
----      	        prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----      	        scndry_vect_out         => open
----      	    );
----


LITE_WVALID_S2MM_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axi_lite_aclk,
        prmry_resetn               => s_axi_lite_aresetn, 
        prmry_in                   => prepare_wrce_pulse_lite, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axi_s2mm_aclk, 
        scndry_resetn              => s2mm_hrd_resetn,
        scndry_out                 => prepare_wrce_pulse_s2mm,
        scndry_vect_out            => open
    );






-------------------------------------------------------------------------------
-- Decode and assert proper chip enable per captured axi lite write address
-------------------------------------------------------------------------------

AXI4_LITE_WRCE_S2MM_GEN: for j in 0 to C_NUM_CE - 1 generate

constant BAR    : std_logic_vector(CE_ADDR_SIZE-1 downto 0) :=
                std_logic_vector(to_unsigned(j,CE_ADDR_SIZE));
begin

    s2mm_wrce_gen(j) <= prepare_wrce_pulse_s2mm when axi2ip_wraddr_captured_s2mm_cdc_tig
                                ((CE_ADDR_SIZE + ADDR_OFFSET) - 1
                                                    downto ADDR_OFFSET)

                                = BAR(CE_ADDR_SIZE-1 downto 0)
          else '0';

   end generate AXI4_LITE_WRCE_S2MM_GEN;


s2mm_axi2ip_wrce     <= s2mm_wrce_gen;



   GEN_LITE_WREADY_OUT_D : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
        	prepare_wrce_pulse_lite_d1  <= prepare_wrce_pulse_lite;
        	prepare_wrce_pulse_lite_d2  <= prepare_wrce_pulse_lite_d1;
        	prepare_wrce_pulse_lite_d3  <= prepare_wrce_pulse_lite_d2;
        	prepare_wrce_pulse_lite_d4  <= prepare_wrce_pulse_lite_d3;
        	prepare_wrce_pulse_lite_d5  <= prepare_wrce_pulse_lite_d4;
        	prepare_wrce_pulse_lite_d6  <= prepare_wrce_pulse_lite_d5;
        end if;
    end process GEN_LITE_WREADY_OUT_D;



   GEN_LITE_WREADY_OUT : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
        	wready_out_i  		    <= '0';
            else
        	wready_out_i  		    <= prepare_wrce_pulse_lite_d6;
            end if;
        end if;
    end process GEN_LITE_WREADY_OUT;




	wready_out_to_bvalid 	<= wready_out_i;

-------------------------
--*READ
-------------------------

--MM2S

GEN_LITE_ARREADY_ASYNC_D : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                sig_arvalid_arrived_d2 <= sig_arvalid_arrived_d1;
                sig_arvalid_arrived_d3 <= sig_arvalid_arrived_d2;
                sig_arvalid_arrived_d4 <= sig_arvalid_arrived_d3;
        end if;
    end process GEN_LITE_ARREADY_ASYNC_D;


GEN_LITE_ARREADY_ASYNC : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
                arready_out_i     <= '0';
            else
                arready_out_i     <= sig_arvalid_arrived_d4;
            end if;
        end if;
    end process GEN_LITE_ARREADY_ASYNC;




AXI4_LITE_RRESP_ASYNC_PROCESS : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then

                rvalid_out_i        		<= '0';

            elsif(rvalid_out_i = '1' and s_axi_lite_rready = '1')then

                rvalid_out_i        		<= '0';

            elsif(arready_out_i = '1')then       

                rvalid_out_i        <= '1';

            end if;
        end if;
    end process AXI4_LITE_RRESP_ASYNC_PROCESS;



s_axi_lite_rdata    <= ip2axi_rddata_captured_d1;

   process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then

	   ip2axi_rddata_captured_d1 <= ip2axi_rddata_captured;

        end if;
    end process ;



ip2axi_rddata_captured  <=   	ip2axi_rddata_common_region 			when addr_region_1_common_rden_cmb = '1' or addr_region_2_common_rden_cmb = '1'
           		else    ip2axi_rddata_captured_mm2s_cdc_tig 		when addr_region_mm2s_rden_cmb = '1'
           		else    ip2axi_rddata_captured_s2mm_cdc_tig;






   process(m_axi_mm2s_aclk)
    begin
        if(m_axi_mm2s_aclk'EVENT and m_axi_mm2s_aclk = '1')then

	   mm2s_ip2axi_rddata_d1 <= mm2s_ip2axi_rddata;

        end if;
    end process ;


GEN_LITE_MM2S_RDATA_CROSSING : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then

	   ip2axi_rddata_captured_mm2s_cdc_tig <= mm2s_ip2axi_rddata_d1;

        end if;
    end process GEN_LITE_MM2S_RDATA_CROSSING;




   process(m_axi_s2mm_aclk)
    begin
        if(m_axi_s2mm_aclk'EVENT and m_axi_s2mm_aclk = '1')then

	   s2mm_ip2axi_rddata_d1 <= s2mm_ip2axi_rddata;

        end if;
    end process ;


GEN_LITE_S2MM_RDATA_CROSSING : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then

	   ip2axi_rddata_captured_s2mm_cdc_tig <= s2mm_ip2axi_rddata_d1;

        end if;
    end process GEN_LITE_S2MM_RDATA_CROSSING;




GEN_LITE_MM2S_WDATA_CROSSING : process(m_axi_mm2s_aclk)
    begin
        if(m_axi_mm2s_aclk'EVENT and m_axi_mm2s_aclk = '1')then

	   mm2s_axi2ip_wrdata_cdc_tig  <= wdata;

        end if;
    end process GEN_LITE_MM2S_WDATA_CROSSING;



GEN_LITE_S2MM_WDATA_CROSSING : process(m_axi_s2mm_aclk)
    begin
        if(m_axi_s2mm_aclk'EVENT and m_axi_s2mm_aclk = '1')then

	   s2mm_axi2ip_wrdata_cdc_tig  <= wdata;

        end if;
    end process GEN_LITE_S2MM_WDATA_CROSSING;




mm2s_axi2ip_wrdata  <= mm2s_axi2ip_wrdata_cdc_tig;
s2mm_axi2ip_wrdata  <= s2mm_axi2ip_wrdata_cdc_tig;



GEN_LITE_MM2S_RDADDR_CROSSING : process(m_axi_mm2s_aclk)
    begin
        if(m_axi_mm2s_aclk'EVENT and m_axi_mm2s_aclk = '1')then

	  axi2ip_rdaddr_captured_mm2s_cdc_tig(7 downto 2)  <= axi2ip_rdaddr_captured(7 downto 2);

        end if;
    end process GEN_LITE_MM2S_RDADDR_CROSSING;



GEN_LITE_S2MM_RDADDR_CROSSING : process(m_axi_s2mm_aclk)
    begin
        if(m_axi_s2mm_aclk'EVENT and m_axi_s2mm_aclk = '1')then

	  axi2ip_rdaddr_captured_s2mm_cdc_tig(7 downto 2)  <= axi2ip_rdaddr_captured(7 downto 2);

        end if;
    end process GEN_LITE_S2MM_RDADDR_CROSSING;



mm2s_axi2ip_rdaddr(7 downto 2)  <= axi2ip_rdaddr_captured_mm2s_cdc_tig(7 downto 2);
s2mm_axi2ip_rdaddr(7 downto 2)  <= axi2ip_rdaddr_captured_s2mm_cdc_tig(7 downto 2);


GEN_LITE_MM2S_WRADDR_CROSSING : process(m_axi_mm2s_aclk)
    begin
        if(m_axi_mm2s_aclk'EVENT and m_axi_mm2s_aclk = '1')then

	  axi2ip_wraddr_captured_mm2s_cdc_tig(7 downto 2)  <= axi2ip_wraddr_captured(7 downto 2);

        end if;
    end process GEN_LITE_MM2S_WRADDR_CROSSING;



GEN_LITE_S2MM_WRADDR_CROSSING : process(m_axi_s2mm_aclk)
    begin
        if(m_axi_s2mm_aclk'EVENT and m_axi_s2mm_aclk = '1')then

	  axi2ip_wraddr_captured_s2mm_cdc_tig(7 downto 2)  <= axi2ip_wraddr_captured(7 downto 2);

        end if;
    end process GEN_LITE_S2MM_WRADDR_CROSSING;






 end generate GEN_ASYNC_LITE_ACCESS;

--------------------------------------------
--ASYNC_MODE but only single channel enabled 
--------------------------------------------

GEN_S2MM_ONLY_ASYNC_LITE_ACCESS : if C_MM2S_IS = 0  and C_S2MM_IS = 1 generate

--Write
prepare_wrce <= sig_wvalid_arrived and lite_wr_addr_phase_finished_data_phase_started;


   GEN_WRCE_PULSE : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
              prepare_wrce_d1   <= '0';
            else
              prepare_wrce_d1   <= prepare_wrce;
            end if;
        end if;
    end process GEN_WRCE_PULSE;


prepare_wrce_pulse_lite <= prepare_wrce and not prepare_wrce_d1;

--S2MM


----      	LITE_WVALID_S2MM_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----      	    generic map(
----      	        C_CDC_TYPE              => CDC_TYPE_PULSE_P_S_OPEN_ENDED                           ,
----      	        C_VECTOR_WIDTH          => 1 
----      	    )
----      	    port map (
----      	        prmry_aclk              => s_axi_lite_aclk                          ,
----      	        prmry_resetn            => s_axi_lite_aresetn                       ,
----      	        scndry_aclk             => m_axi_s2mm_aclk                          ,
----      	        scndry_resetn           => s2mm_hrd_resetn                          ,
----      	        scndry_in               => '0'                                      ,
----      	        prmry_out               => open                                     ,
----      	        prmry_in                => prepare_wrce_pulse_lite           ,
----      	        scndry_out              => prepare_wrce_pulse_s2mm      ,
----      	        scndry_vect_s_h         => '0'                                      ,
----      	        scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0),
----      	        prmry_vect_out          => open                                     ,
----      	        prmry_vect_s_h          => '0'                                      ,
----      	        prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----      	        scndry_vect_out         => open
----      	    );



LITE_WVALID_S2MM_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axi_lite_aclk,
        prmry_resetn               => s_axi_lite_aresetn, 
        prmry_in                   => prepare_wrce_pulse_lite, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axi_s2mm_aclk, 
        scndry_resetn              => s2mm_hrd_resetn,
        scndry_out                 => prepare_wrce_pulse_s2mm,
        scndry_vect_out            => open
    );




-------------------------------------------------------------------------------
-- Decode and assert proper chip enable per captured axi lite write address
-------------------------------------------------------------------------------

AXI4_LITE_WRCE_S2MM_GEN: for j in 0 to C_NUM_CE - 1 generate

constant BAR    : std_logic_vector(CE_ADDR_SIZE-1 downto 0) :=
                std_logic_vector(to_unsigned(j,CE_ADDR_SIZE));
begin

    s2mm_wrce_gen(j) <= prepare_wrce_pulse_s2mm when axi2ip_wraddr_captured_s2mm_cdc_tig
                                ((CE_ADDR_SIZE + ADDR_OFFSET) - 1
                                                    downto ADDR_OFFSET)

                                = BAR(CE_ADDR_SIZE-1 downto 0)
          else '0';

   end generate AXI4_LITE_WRCE_S2MM_GEN;


s2mm_axi2ip_wrce     <= s2mm_wrce_gen;


   GEN_LITE_WREADY_OUT_D : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
        	prepare_wrce_pulse_lite_d1  <= prepare_wrce_pulse_lite;
        	prepare_wrce_pulse_lite_d2  <= prepare_wrce_pulse_lite_d1;
        	prepare_wrce_pulse_lite_d3  <= prepare_wrce_pulse_lite_d2;
        	prepare_wrce_pulse_lite_d4  <= prepare_wrce_pulse_lite_d3;
        	prepare_wrce_pulse_lite_d5  <= prepare_wrce_pulse_lite_d4;
        	prepare_wrce_pulse_lite_d6  <= prepare_wrce_pulse_lite_d5;
        end if;
    end process GEN_LITE_WREADY_OUT_D;



   GEN_LITE_WREADY_OUT : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
        	wready_out_i  		    <= '0';
            else
        	wready_out_i  		    <= prepare_wrce_pulse_lite_d6;
            end if;
        end if;
    end process GEN_LITE_WREADY_OUT;



	wready_out_to_bvalid 	<= wready_out_i;

--Read

--S2MM

GEN_LITE_ARREADY_ASYNC_D : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                sig_arvalid_arrived_d2 <= sig_arvalid_arrived_d1;
                sig_arvalid_arrived_d3 <= sig_arvalid_arrived_d2;
                sig_arvalid_arrived_d4 <= sig_arvalid_arrived_d3;
        end if;
    end process GEN_LITE_ARREADY_ASYNC_D;


GEN_LITE_ARREADY_ASYNC : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
                arready_out_i     <= '0';
            else
                arready_out_i     <= sig_arvalid_arrived_d4;
            end if;
        end if;
    end process GEN_LITE_ARREADY_ASYNC;



AXI4_LITE_RRESP_ASYNC_PROCESS : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then

                rvalid_out_i        		<= '0';

            elsif(rvalid_out_i = '1' and s_axi_lite_rready = '1')then

                rvalid_out_i        		<= '0';

            elsif(arready_out_i = '1')then       

                rvalid_out_i        <= '1';

            end if;
        end if;
    end process AXI4_LITE_RRESP_ASYNC_PROCESS;


s_axi_lite_rdata    <= ip2axi_rddata_captured_d1;

   process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then

	   ip2axi_rddata_captured_d1 <= ip2axi_rddata_captured;

        end if;
    end process ;


ip2axi_rddata_captured  <=   	ip2axi_rddata_common_region 	when addr_region_1_common_rden_cmb = '1' or addr_region_2_common_rden_cmb = '1'
           		else    mm2s_ip2axi_rddata 		when addr_region_mm2s_rden_cmb = '1'
           		else    ip2axi_rddata_captured_s2mm_cdc_tig;


   process(m_axi_s2mm_aclk)
    begin
        if(m_axi_s2mm_aclk'EVENT and m_axi_s2mm_aclk = '1')then

	   s2mm_ip2axi_rddata_d1 <= s2mm_ip2axi_rddata;

        end if;
    end process ;


GEN_LITE_S2MM_RDATA_CROSSING : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then

	   ip2axi_rddata_captured_s2mm_cdc_tig <= s2mm_ip2axi_rddata_d1;

        end if;
    end process GEN_LITE_S2MM_RDATA_CROSSING;







   mm2s_axi2ip_wrdata  <= wdata;

GEN_LITE_S2MM_WDATA_CROSSING : process(m_axi_s2mm_aclk)
    begin
        if(m_axi_s2mm_aclk'EVENT and m_axi_s2mm_aclk = '1')then

	   s2mm_axi2ip_wrdata_cdc_tig  <= wdata;

        end if;
    end process GEN_LITE_S2MM_WDATA_CROSSING;


s2mm_axi2ip_wrdata  <= s2mm_axi2ip_wrdata_cdc_tig;





GEN_LITE_S2MM_RDADDR_CROSSING : process(m_axi_s2mm_aclk)
    begin
        if(m_axi_s2mm_aclk'EVENT and m_axi_s2mm_aclk = '1')then

	  axi2ip_rdaddr_captured_s2mm_cdc_tig(7 downto 2)  <= axi2ip_rdaddr_captured(7 downto 2);

        end if;
    end process GEN_LITE_S2MM_RDADDR_CROSSING;



mm2s_axi2ip_rdaddr(7 downto 2)  <= axi2ip_rdaddr_captured(7 downto 2);
s2mm_axi2ip_rdaddr(7 downto 2)  <= axi2ip_rdaddr_captured_s2mm_cdc_tig(7 downto 2);

GEN_LITE_S2MM_WRADDR_CROSSING : process(m_axi_s2mm_aclk)
    begin
        if(m_axi_s2mm_aclk'EVENT and m_axi_s2mm_aclk = '1')then

	  axi2ip_wraddr_captured_s2mm_cdc_tig(7 downto 2)  <= axi2ip_wraddr_captured(7 downto 2);

        end if;
    end process GEN_LITE_S2MM_WRADDR_CROSSING;




mm2s_axi2ip_wrce     <= (others => '0');

 end generate GEN_S2MM_ONLY_ASYNC_LITE_ACCESS;





GEN_MM2S_ONLY_ASYNC_LITE_ACCESS : if C_MM2S_IS = 1  and C_S2MM_IS = 0 generate

--Write
prepare_wrce <= sig_wvalid_arrived and lite_wr_addr_phase_finished_data_phase_started;


   GEN_WRCE_PULSE : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
              prepare_wrce_d1   <= '0';
            else
              prepare_wrce_d1   <= prepare_wrce;
            end if;
        end if;
    end process GEN_WRCE_PULSE;


prepare_wrce_pulse_lite <= prepare_wrce and not prepare_wrce_d1;

--MM2S


----      	LITE_WVALID_MM2S_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----      	    generic map(
----      	        C_CDC_TYPE              => CDC_TYPE_PULSE_P_S_OPEN_ENDED                           ,
----      	        C_VECTOR_WIDTH          => 1 
----      	    )
----      	    port map (
----      	        prmry_aclk              => s_axi_lite_aclk                          ,
----      	        prmry_resetn            => s_axi_lite_aresetn                       ,
----      	        scndry_aclk             => m_axi_mm2s_aclk                          ,
----      	        scndry_resetn           => mm2s_hrd_resetn                          ,
----      	        scndry_in               => '0'                                      ,
----      	        prmry_out               => open                                     ,
----      	        prmry_in                => prepare_wrce_pulse_lite           ,
----      	        scndry_out              => prepare_wrce_pulse_mm2s      ,
----      	        scndry_vect_s_h         => '0'                                      ,
----      	        scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0),
----      	        prmry_vect_out          => open                                     ,
----      	        prmry_vect_s_h          => '0'                                      ,
----      	        prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----      	        scndry_vect_out         => open
----      	    );


LITE_WVALID_MM2S_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axi_lite_aclk,
        prmry_resetn               => s_axi_lite_aresetn, 
        prmry_in                   => prepare_wrce_pulse_lite, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axi_mm2s_aclk, 
        scndry_resetn              => mm2s_hrd_resetn,
        scndry_out                 => prepare_wrce_pulse_mm2s,
        scndry_vect_out            => open
    );



-------------------------------------------------------------------------------
-- Decode and assert proper chip enable per captured axi lite write address
-------------------------------------------------------------------------------

AXI4_LITE_WRCE_MM2S_GEN: for j in 0 to C_NUM_CE - 1 generate

constant BAR    : std_logic_vector(CE_ADDR_SIZE-1 downto 0) :=
                std_logic_vector(to_unsigned(j,CE_ADDR_SIZE));
begin

    mm2s_wrce_gen(j) <= prepare_wrce_pulse_mm2s when axi2ip_wraddr_captured_mm2s_cdc_tig
                                ((CE_ADDR_SIZE + ADDR_OFFSET) - 1
                                                    downto ADDR_OFFSET)

                                = BAR(CE_ADDR_SIZE-1 downto 0)
          else '0';

   end generate AXI4_LITE_WRCE_MM2S_GEN;


mm2s_axi2ip_wrce     <= mm2s_wrce_gen;

   GEN_LITE_WREADY_OUT_D : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
        	prepare_wrce_pulse_lite_d1  <= prepare_wrce_pulse_lite;
        	prepare_wrce_pulse_lite_d2  <= prepare_wrce_pulse_lite_d1;
        	prepare_wrce_pulse_lite_d3  <= prepare_wrce_pulse_lite_d2;
        	prepare_wrce_pulse_lite_d4  <= prepare_wrce_pulse_lite_d3;
        	prepare_wrce_pulse_lite_d5  <= prepare_wrce_pulse_lite_d4;
        	prepare_wrce_pulse_lite_d6  <= prepare_wrce_pulse_lite_d5;
        end if;
    end process GEN_LITE_WREADY_OUT_D;



   GEN_LITE_WREADY_OUT : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
        	wready_out_i  		    <= '0';
            else
        	wready_out_i  		    <= prepare_wrce_pulse_lite_d6;
            end if;
        end if;
    end process GEN_LITE_WREADY_OUT;


	wready_out_to_bvalid 	<= wready_out_i;

--Read

--MM2S

GEN_LITE_ARREADY_ASYNC_D : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                sig_arvalid_arrived_d2 <= sig_arvalid_arrived_d1;
                sig_arvalid_arrived_d3 <= sig_arvalid_arrived_d2;
                sig_arvalid_arrived_d4 <= sig_arvalid_arrived_d3;
        end if;
    end process GEN_LITE_ARREADY_ASYNC_D;


GEN_LITE_ARREADY_ASYNC : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
                arready_out_i     <= '0';
            else
                arready_out_i     <= sig_arvalid_arrived_d4;
            end if;
        end if;
    end process GEN_LITE_ARREADY_ASYNC;


AXI4_LITE_RRESP_ASYNC_PROCESS : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then

                rvalid_out_i        		<= '0';

            elsif(rvalid_out_i = '1' and s_axi_lite_rready = '1')then

                rvalid_out_i        		<= '0';

            elsif(arready_out_i = '1')then       

                rvalid_out_i        <= '1';

            end if;
        end if;
    end process AXI4_LITE_RRESP_ASYNC_PROCESS;


s_axi_lite_rdata    <= ip2axi_rddata_captured_d1;

   process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then

	   ip2axi_rddata_captured_d1 <= ip2axi_rddata_captured;

        end if;
    end process ;


ip2axi_rddata_captured  <=   	ip2axi_rddata_common_region 			when addr_region_1_common_rden_cmb = '1' or addr_region_2_common_rden_cmb = '1'
           		else    ip2axi_rddata_captured_mm2s_cdc_tig 		when addr_region_mm2s_rden_cmb = '1'
           		else    s2mm_ip2axi_rddata;

   process(m_axi_mm2s_aclk)
    begin
        if(m_axi_mm2s_aclk'EVENT and m_axi_mm2s_aclk = '1')then

	   mm2s_ip2axi_rddata_d1 <= mm2s_ip2axi_rddata;

        end if;
    end process ;


GEN_LITE_MM2S_RDATA_CROSSING : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then

	   ip2axi_rddata_captured_mm2s_cdc_tig <= mm2s_ip2axi_rddata_d1;

        end if;
    end process GEN_LITE_MM2S_RDATA_CROSSING;




GEN_LITE_MM2S_WDATA_CROSSING : process(m_axi_mm2s_aclk)
    begin
        if(m_axi_mm2s_aclk'EVENT and m_axi_mm2s_aclk = '1')then

	   mm2s_axi2ip_wrdata_cdc_tig  <= wdata;

        end if;
    end process GEN_LITE_MM2S_WDATA_CROSSING;



  s2mm_axi2ip_wrdata  <= wdata;

mm2s_axi2ip_wrdata  <= mm2s_axi2ip_wrdata_cdc_tig;



GEN_LITE_MM2S_RDADDR_CROSSING : process(m_axi_mm2s_aclk)
    begin
        if(m_axi_mm2s_aclk'EVENT and m_axi_mm2s_aclk = '1')then

	  axi2ip_rdaddr_captured_mm2s_cdc_tig(7 downto 2)  <= axi2ip_rdaddr_captured(7 downto 2);

        end if;
    end process GEN_LITE_MM2S_RDADDR_CROSSING;


mm2s_axi2ip_rdaddr(7 downto 2)  <= axi2ip_rdaddr_captured_mm2s_cdc_tig(7 downto 2);
s2mm_axi2ip_rdaddr(7 downto 2)  <= axi2ip_rdaddr_captured(7 downto 2);


GEN_LITE_MM2S_WRADDR_CROSSING : process(m_axi_mm2s_aclk)
    begin
        if(m_axi_mm2s_aclk'EVENT and m_axi_mm2s_aclk = '1')then

	  axi2ip_wraddr_captured_mm2s_cdc_tig(7 downto 2)  <= axi2ip_wraddr_captured(7 downto 2);

        end if;
    end process GEN_LITE_MM2S_WRADDR_CROSSING;


s2mm_axi2ip_wrce     <= (others => '0');
 end generate GEN_MM2S_ONLY_ASYNC_LITE_ACCESS;





end generate GEN_LITE_IS_ASYNC;
end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_register
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_register.vhd
--
-- Description:     This entity encompasses the channel register set.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_register is
    generic(
        C_NUM_REGISTERS             : integer                   := 8        ;
        C_NUM_FSTORES               : integer range 1 to 32     := 3        ;
        C_NUM_FSTORES_64               : integer range 1 to 32     := 3        ;
        C_CHANNEL_IS_MM2S           : integer range 0 to 1   := 1       ;

        C_LINEBUFFER_THRESH         : integer range 1 to 65536  := 1        ;
        --C_ENABLE_DEBUG_INFO         : string := "1111111111111111";		-- 1 to 16 -- 
        --C_ENABLE_DEBUG_INFO             : bit_vector(15 downto 0) 	:= (others => '1');		--15 downto 0  -- 

        C_ENABLE_DEBUG_ALL       : integer range 0 to 1      	:= 1;
            -- Setting this make core backward compatible to 2012.4 version in terms of ports and registers
        C_ENABLE_DEBUG_INFO_0       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 0
        C_ENABLE_DEBUG_INFO_1       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 1
        C_ENABLE_DEBUG_INFO_2       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 2
        C_ENABLE_DEBUG_INFO_3       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 3
        C_ENABLE_DEBUG_INFO_4       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 4
        C_ENABLE_DEBUG_INFO_5       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 5
        C_ENABLE_DEBUG_INFO_6       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 6
        C_ENABLE_DEBUG_INFO_7       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 7
        C_ENABLE_DEBUG_INFO_8       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 8
        C_ENABLE_DEBUG_INFO_9       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 9
        C_ENABLE_DEBUG_INFO_10      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 10
        C_ENABLE_DEBUG_INFO_11      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 11
        C_ENABLE_DEBUG_INFO_12      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 12
        C_ENABLE_DEBUG_INFO_13      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 13
        C_ENABLE_DEBUG_INFO_14      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 14
        C_ENABLE_DEBUG_INFO_15      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 15





        C_INTERNAL_GENLOCK_ENABLE   	: integer range 0 to 1          := 0;

        C_INCLUDE_SG                : integer range 0 to 1      := 1        ;
        C_GENLOCK_MODE              : integer range 0 to 3      := 0        ;
        C_ENABLE_FLUSH_ON_FSYNC     : integer range 0 to 1      := 0        ; -- 
        C_S_AXI_LITE_DATA_WIDTH     : integer range 32 to 32    := 32       ;
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64    := 32
    );
    port (
        prmry_aclk                  : in  std_logic                         ;               --
        prmry_resetn                : in  std_logic                         ;               --
                                                                                            --
        -- AXI Interface Control                                                            --
        axi2ip_wrce                 : in  std_logic_vector                                  --
                                        (C_NUM_REGISTERS-1 downto 0)        ;               --
        axi2ip_wrdata               : in  std_logic_vector                                  --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);               --
        -- DMASR Control                                                                    --
        stop_dma                    : in  std_logic                         ;               --
        halted_clr                  : in  std_logic                         ;               --
        halted_set                  : in  std_logic                         ;               --
        idle_set                    : in  std_logic                         ;               --
        idle_clr                    : in  std_logic                         ;               --
        ioc_irq_set                 : in  std_logic                         ;               --
        dly_irq_set                 : in  std_logic                         ;               --
        frame_sync                  : in  std_logic                         ;               --
        fsync_mask                  : in  std_logic                         ;               -- 
        irqdelay_status             : in  std_logic_vector(7 downto 0)      ;               --
        irqthresh_status            : in  std_logic_vector(7 downto 0)      ;               --
        irqdelay_wren               : out std_logic                         ;               --
        irqthresh_wren              : out std_logic                         ;               --
        dlyirq_dsble                : out std_logic                         ;               --
                                                                                            --
        -- Error Control                                                                    --


        fsize_mismatch_err          : in  std_logic                         ;       --
        lsize_mismatch_err          : in  std_logic                         ;       --
        lsize_more_mismatch_err     : in  std_logic                         ;       --
        s2mm_fsize_more_or_sof_late : in  std_logic                         ;       --


        dma_interr_set_minus_frame_errors              : in  std_logic                         ;               --
        dma_interr_set              : in  std_logic                         ;               --
        dma_slverr_set              : in  std_logic                         ;               --
        dma_decerr_set              : in  std_logic                         ;               --
        ftch_slverr_set             : in  std_logic                         ;               --
        ftch_decerr_set             : in  std_logic                         ;               --
        ftch_err_addr               : in  std_logic_vector                                  --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;               --
        frmstr_err_addr             : in  std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        soft_reset_clr              : in  std_logic                         ;               --
                                                                                            --
        -- CURDESC Update                                                                   --
        update_curdesc              : in  std_logic                         ;               --
        new_curdesc                 : in  std_logic_vector                                  --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;               --
        update_frmstore             : in  std_logic                         ;               --
        new_frmstr                  : in  std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        frm_store                   : out std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
                                                                                            --
        -- TAILDESC Update                                                                  --
        tailpntr_updated            : out std_logic                         ;               --
                                                                                            --
        -- Channel Register Out                                                             --
        dma_irq_mask                       : out std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);            --

        reg_index                       : out std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);            --


        dmacr                       : out std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);            --
        dmasr                       : out std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);            --
        curdesc_lsb                 : out std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);            --
        curdesc_msb                 : out std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);            --
        taildesc_lsb                : out std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);            --
        taildesc_msb                : out std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);            --
        num_frame_store_regmux      : out std_logic_vector                                  --
                                           (FRMSTORE_MSB_BIT downto 0);                     --
        num_frame_store             : out std_logic_vector                                  --
                                           (FRMSTORE_MSB_BIT downto 0);                     --
        linebuf_threshold           : out std_logic_vector                                  --
                                            (THRESH_MSB_BIT downto 0);                      --
                                                                                            --
        introut                     : out std_logic                                         --

    );
end axi_vdma_register;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_register is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant DMACR_INDEX            : integer := 0;         -- DMACR Register index
constant DMASR_INDEX            : integer := 1;         -- DMASR Register index
constant CURDESC_LSB_INDEX      : integer := 2;         -- CURDESC LSB Reg index
constant CURDESC_MSB_INDEX      : integer := 3;         -- CURDESC MSB Reg index
constant TAILDESC_LSB_INDEX     : integer := 4;         -- TAILDESC LSB Reg index
constant TAILDESC_MSB_INDEX     : integer := 5;         -- TAILDESC MSB Reg index
constant FRAME_STORE_INDEX      : integer := 6;         -- Frame Store Reg index
constant THRESHOLD_INDEX        : integer := 7;         -- Threshold Reg index
constant REG_IND        	: integer := 5;         --  Reg index
constant DMA_IRQ_MASK_IND  : integer := 3;         -- 



constant ZERO_VALUE             : std_logic_vector(31 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal reg_index_i              : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');

signal dma_irq_mask_i              : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');




signal dmacr_i              : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal dmasr_i              : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal curdesc_lsb_i        : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal curdesc_msb_i        : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal taildesc_lsb_i       : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal taildesc_msb_i       : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal num_frame_store_regmux_i    : std_logic_vector
                                (FRMSTORE_MSB_BIT downto 0)          := (others =>'0');
signal num_frame_store_i    : std_logic_vector
                                (FRMSTORE_MSB_BIT downto 0)          := (others =>'0');
signal linebuf_threshold_i  : std_logic_vector
                                (LINEBUFFER_THRESH_WIDTH-1 downto 0) := (others => '0');

-- DMASR Signals
signal halted               : std_logic := '0';
signal idle                 : std_logic := '0';
signal err                  : std_logic := '0';
signal err_p                  : std_logic := '0';
signal fsize_err            : std_logic := '0';
signal lsize_err            : std_logic := '0';
signal lsize_more_err       : std_logic := '0';
signal s2mm_fsize_more_or_sof_late_bit           : std_logic := '0';
signal dma_interr           : std_logic := '0';
signal dma_interr_minus_frame_errors           : std_logic := '0';
signal dma_slverr           : std_logic := '0';
signal dma_decerr           : std_logic := '0';
signal sg_slverr            : std_logic := '0';
signal sg_decerr            : std_logic := '0';
signal ioc_irq              : std_logic := '0';
signal dly_irq              : std_logic := '0';
signal err_d1               : std_logic := '0';
signal err_re               : std_logic := '0';
--signal err_fe               : std_logic := '0';
signal err_irq              : std_logic := '0';

signal sg_ftch_err          : std_logic := '0';
signal err_pointer_set      : std_logic := '0';
signal err_frmstore_set     : std_logic := '0';

-- Interrupt coalescing support signals
signal different_delay      : std_logic := '0';
signal different_thresh     : std_logic := '0';
signal threshold_is_zero    : std_logic := '0';

-- Soft reset support signals
signal soft_reset_i         : std_logic := '0';
signal run_stop_clr         : std_logic := '0';
signal reset_counts         : std_logic := '0';
signal irqdelay_wren_i      : std_logic := '0';
signal irqthresh_wren_i     : std_logic := '0';

-- Frame Store support signal
signal frmstore_is_zero     : std_logic := '0';
signal frm_store_i            : std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)  := (others => '0')   ;               --

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

frm_store               <= frm_store_i          ;
dmacr                   <= dmacr_i          ;
dmasr                   <= dmasr_i          ;
curdesc_lsb             <= curdesc_lsb_i    ;
curdesc_msb             <= curdesc_msb_i    ;
taildesc_lsb            <= taildesc_lsb_i   ;
dma_irq_mask            	<= dma_irq_mask_i   ;
reg_index            	<= reg_index_i   ;
taildesc_msb            <= taildesc_msb_i   ;
num_frame_store         <= num_frame_store_i;
num_frame_store_regmux  <= num_frame_store_regmux_i;
linebuf_threshold       <= linebuf_threshold_i;
---------------------------------------------------------------------------
-- DMA Control Register

---------------------------------------------------------------------------
-- DMACR - Interrupt Delay Value
-------------------------------------------------------------------------------

DISABLE_DMACR_DELAY_CNTR : if ((C_CHANNEL_IS_MM2S = 1 and (C_ENABLE_DEBUG_INFO_6 = 0 and C_ENABLE_DEBUG_ALL = 0) ) or (C_CHANNEL_IS_MM2S = 0 and (C_ENABLE_DEBUG_INFO_14 = 0 and C_ENABLE_DEBUG_ALL = 0) ))generate
begin

                irqdelay_wren <= '0';

                dmacr_i(DMACR_IRQDELAY_MSB_BIT
                 downto DMACR_IRQDELAY_LSB_BIT) <= (others => '0');

end generate DISABLE_DMACR_DELAY_CNTR;
  



ENABLE_DMACR_DELAY_CNTR : if ((C_CHANNEL_IS_MM2S = 1 and (C_ENABLE_DEBUG_INFO_6 = 1 or C_ENABLE_DEBUG_ALL = 1) ) or (C_CHANNEL_IS_MM2S = 0 and (C_ENABLE_DEBUG_INFO_14 = 1 or C_ENABLE_DEBUG_ALL = 1) ))generate
begin

DMACR_DELAY : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dmacr_i(DMACR_IRQDELAY_MSB_BIT
                 downto DMACR_IRQDELAY_LSB_BIT) <= (others => '0');
            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(DMACR_IRQDELAY_MSB_BIT
                 downto DMACR_IRQDELAY_LSB_BIT) <= axi2ip_wrdata(DMACR_IRQDELAY_MSB_BIT
                                                          downto DMACR_IRQDELAY_LSB_BIT);
            end if;
        end if;
    end process DMACR_DELAY;

-- If written delay is different than previous value then assert write enable
different_delay <= '1' when dmacr_i(DMACR_IRQDELAY_MSB_BIT downto DMACR_IRQDELAY_LSB_BIT)
                   /= axi2ip_wrdata(DMACR_IRQDELAY_MSB_BIT downto DMACR_IRQDELAY_LSB_BIT)
              else '0';

-- Delay value different, drive write of delay value to interrupt controller
NEW_DELAY_WRITE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                irqdelay_wren_i <= '0';
            -- If AXI Lite write to DMACR and delay different than current
            -- setting then update delay value
            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and different_delay = '1')then
                irqdelay_wren_i <= '1';
            else
                irqdelay_wren_i <= '0';
            end if;
        end if;
    end process NEW_DELAY_WRITE;

-- Reset delay irq counter on new delay write, or reset, or frame sync
irqdelay_wren <= irqdelay_wren_i or reset_counts or frame_sync;

end generate ENABLE_DMACR_DELAY_CNTR;



-------------------------------------------------------------------------------
-- DMACR - Interrupt Threshold Value
-------------------------------------------------------------------------------


DISABLE_DMACR_FRM_CNTR : if ((C_CHANNEL_IS_MM2S = 1 and (C_ENABLE_DEBUG_INFO_7 = 0 and C_ENABLE_DEBUG_ALL = 0) ) or (C_CHANNEL_IS_MM2S = 0 and (C_ENABLE_DEBUG_INFO_15 = 0 and C_ENABLE_DEBUG_ALL = 0) ))generate
begin

                irqthresh_wren <= '0';

                dmacr_i(DMACR_IRQTHRESH_MSB_BIT
                        downto DMACR_IRQTHRESH_LSB_BIT) <= ONE_THRESHOLD;

end generate DISABLE_DMACR_FRM_CNTR;
  






ENABLE_DMACR_FRM_CNTR : if ((C_CHANNEL_IS_MM2S = 1 and (C_ENABLE_DEBUG_INFO_7 = 1 or C_ENABLE_DEBUG_ALL = 1) ) or (C_CHANNEL_IS_MM2S = 0 and (C_ENABLE_DEBUG_INFO_15 = 1 or C_ENABLE_DEBUG_ALL = 1) ))generate
begin


threshold_is_zero <= '1' when axi2ip_wrdata(DMACR_IRQTHRESH_MSB_BIT
                                     downto DMACR_IRQTHRESH_LSB_BIT) = ZERO_THRESHOLD
                else '0';

DMACR_THRESH : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dmacr_i(DMACR_IRQTHRESH_MSB_BIT
                        downto DMACR_IRQTHRESH_LSB_BIT) <= ONE_THRESHOLD;
            -- On AXI Lite write
            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then

                -- If value is 0 then set threshold to 1
                if(threshold_is_zero='1')then
                    dmacr_i(DMACR_IRQTHRESH_MSB_BIT
                     downto DMACR_IRQTHRESH_LSB_BIT)    <= ONE_THRESHOLD;

                -- else set threshold to axi lite wrdata value
                else
                    dmacr_i(DMACR_IRQTHRESH_MSB_BIT
                     downto DMACR_IRQTHRESH_LSB_BIT)    <= axi2ip_wrdata(DMACR_IRQTHRESH_MSB_BIT
                                                                  downto DMACR_IRQTHRESH_LSB_BIT);
                end if;
            end if;
        end if;
    end process DMACR_THRESH;

-- If written threshold is different than previous value then assert write enable
different_thresh <= '1' when dmacr_i(DMACR_IRQTHRESH_MSB_BIT downto DMACR_IRQTHRESH_LSB_BIT)
                    /= axi2ip_wrdata(DMACR_IRQTHRESH_MSB_BIT downto DMACR_IRQTHRESH_LSB_BIT)
              else '0';

-- new treshold written therefore drive write of threshold out
NEW_THRESH_WRITE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                irqthresh_wren_i <= '0';
            -- If AXI Lite write to DMACR and threshold different than current
            -- setting then update threshold value
            -- If paused then hold frame counter from counting
            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and different_thresh = '1')then

                irqthresh_wren_i <= '1';
            else
                irqthresh_wren_i <= '0';
            end if;
        end if;
    end process NEW_THRESH_WRITE;


irqthresh_wren <= irqthresh_wren_i or reset_counts;


end generate ENABLE_DMACR_FRM_CNTR;



-- Due to seperate MM2S and S2MM resets the delay and frame count registers
-- is axi_sg must be reset with a physical write to axi_sg during a soft reset.
REG_RESET_IRQ_COUNTS : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(soft_reset_clr = '1')then
                reset_counts <= '0';
            elsif(prmry_resetn = '0' and dmacr_i(DMACR_RESET_BIT) = '1')then
                reset_counts <= '1';
            end if;
        end if;
    end process REG_RESET_IRQ_COUNTS;

-----------------------------------------------------------------------------------
------ DMACR - Remainder of DMA Control Register
-----------------------------------------------------------------------------------

GEN_NO_INTERNAL_GENLOCK : if C_INTERNAL_GENLOCK_ENABLE = 0 generate
begin


DS_GEN_DMACR_REGISTER : if C_GENLOCK_MODE = 3 generate
begin
DS_DMACR_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dmacr_i(DMACR_IRQTHRESH_LSB_BIT-2
                        downto DMACR_FRMCNTEN_BIT)   <= (others => '0');

            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(DMACR_IRQTHRESH_LSB_BIT-2
                        downto DMACR_FRMCNTEN_BIT)   <=   axi2ip_wrdata(DMACR_ERR_IRQEN_BIT)    -- bit  14
                                                        & axi2ip_wrdata(DMACR_DLY_IRQEN_BIT)    -- bit  13
                                                        & axi2ip_wrdata(DMACR_IOC_IRQEN_BIT)    -- bit  12
                                                        & axi2ip_wrdata(DMACR_PNTR_NUM_MSB
                                                                 downto DMACR_PNTR_NUM_LSB)     -- bits 11 downto 8
                                                        & ZERO_VALUE(DMACR_GENLOCK_SEL_BIT)  -- bit  7
                                                        & axi2ip_wrdata(DMACR_FSYNCSEL_MSB
                                                                 downto DMACR_FSYNCSEL_LSB)     -- bits 6 downto 5
                                                        & axi2ip_wrdata(DMACR_FRMCNTEN_BIT);    -- bit  4
            end if;
        end if;
    end process DS_DMACR_REGISTER;
end generate DS_GEN_DMACR_REGISTER;

DM_GEN_DMACR_REGISTER : if C_GENLOCK_MODE = 2 generate
begin
DM_DMACR_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dmacr_i(DMACR_IRQTHRESH_LSB_BIT-2
                        downto DMACR_FRMCNTEN_BIT)   <= (others => '0');

            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(DMACR_IRQTHRESH_LSB_BIT-2
                        downto DMACR_FRMCNTEN_BIT)   <=   axi2ip_wrdata(DMACR_ERR_IRQEN_BIT)    -- bit  14
                                                        & axi2ip_wrdata(DMACR_DLY_IRQEN_BIT)    -- bit  13
                                                        & axi2ip_wrdata(DMACR_IOC_IRQEN_BIT)    -- bit  12
                                                        & axi2ip_wrdata(DMACR_PNTR_NUM_MSB
                                                                 downto DMACR_PNTR_NUM_LSB)     -- bits 11 downto 8
                                                        & ZERO_VALUE(DMACR_GENLOCK_SEL_BIT)  -- bit  7
                                                        & axi2ip_wrdata(DMACR_FSYNCSEL_MSB
                                                                 downto DMACR_FSYNCSEL_LSB)     -- bits 6 downto 5
                                                        & axi2ip_wrdata(DMACR_FRMCNTEN_BIT);    -- bit  4
            end if;
        end if;
    end process DM_DMACR_REGISTER;
end generate DM_GEN_DMACR_REGISTER;


S_GEN_DMACR_REGISTER : if C_GENLOCK_MODE = 1 generate
begin
S_DMACR_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dmacr_i(DMACR_IRQTHRESH_LSB_BIT-2
                        downto DMACR_FRMCNTEN_BIT)   <= (others => '0');

            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(DMACR_IRQTHRESH_LSB_BIT-2
                        downto DMACR_FRMCNTEN_BIT)   <= axi2ip_wrdata(DMACR_ERR_IRQEN_BIT)    -- bit  14
                                                        & axi2ip_wrdata(DMACR_DLY_IRQEN_BIT)    -- bit  13
                                                        & axi2ip_wrdata(DMACR_IOC_IRQEN_BIT)    -- bit  12
                                                        & axi2ip_wrdata(DMACR_PNTR_NUM_MSB
                                                                 downto DMACR_PNTR_NUM_LSB)     -- bits 11 downto 8
                                                        & ZERO_VALUE(DMACR_GENLOCK_SEL_BIT)  -- bit  7
                                                        & axi2ip_wrdata(DMACR_FSYNCSEL_MSB
                                                                 downto DMACR_FSYNCSEL_LSB)     -- bits 6 downto 5
                                                        & axi2ip_wrdata(DMACR_FRMCNTEN_BIT);    -- bit  4
            end if;
        end if;
    end process S_DMACR_REGISTER;
end generate S_GEN_DMACR_REGISTER;

end generate GEN_NO_INTERNAL_GENLOCK;




-------------------------------------------------------------------------------
-- DMACR - Remainder of DMA Control Register
-------------------------------------------------------------------------------


GEN_FOR_INTERNAL_GENLOCK : if C_INTERNAL_GENLOCK_ENABLE = 1 generate
begin

DS_GEN_DMACR_REGISTER : if C_GENLOCK_MODE = 3 generate
begin
DS_DMACR_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then

		dmacr_i(14 downto 8) <= (others => '0');
		dmacr_i(7) 	     <= '1';
		dmacr_i(6 downto 4)  <= (others => '0');


            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(DMACR_IRQTHRESH_LSB_BIT-2
                        downto DMACR_FRMCNTEN_BIT)   <=   axi2ip_wrdata(DMACR_ERR_IRQEN_BIT)    -- bit  14
                                                        & axi2ip_wrdata(DMACR_DLY_IRQEN_BIT)    -- bit  13
                                                        & axi2ip_wrdata(DMACR_IOC_IRQEN_BIT)    -- bit  12
                                                        & axi2ip_wrdata(DMACR_PNTR_NUM_MSB
                                                                 downto DMACR_PNTR_NUM_LSB)     -- bits 11 downto 8
                                                        & axi2ip_wrdata(DMACR_GENLOCK_SEL_BIT)  -- bit  7
                                                        & axi2ip_wrdata(DMACR_FSYNCSEL_MSB
                                                                 downto DMACR_FSYNCSEL_LSB)     -- bits 6 downto 5
                                                        & axi2ip_wrdata(DMACR_FRMCNTEN_BIT);    -- bit  4
            end if;
        end if;
    end process DS_DMACR_REGISTER;
end generate DS_GEN_DMACR_REGISTER;

DM_GEN_DMACR_REGISTER : if C_GENLOCK_MODE = 2 generate
begin
DM_DMACR_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then

		dmacr_i(14 downto 8) <= (others => '0');
		dmacr_i(7) 	     <= '1';
		dmacr_i(6 downto 4)  <= (others => '0');



            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(DMACR_IRQTHRESH_LSB_BIT-2
                        downto DMACR_FRMCNTEN_BIT)   <=   axi2ip_wrdata(DMACR_ERR_IRQEN_BIT)    -- bit  14
                                                        & axi2ip_wrdata(DMACR_DLY_IRQEN_BIT)    -- bit  13
                                                        & axi2ip_wrdata(DMACR_IOC_IRQEN_BIT)    -- bit  12
                                                        & axi2ip_wrdata(DMACR_PNTR_NUM_MSB
                                                                 downto DMACR_PNTR_NUM_LSB)     -- bits 11 downto 8
                                                        & axi2ip_wrdata(DMACR_GENLOCK_SEL_BIT)  -- bit  7
                                                        & axi2ip_wrdata(DMACR_FSYNCSEL_MSB
                                                                 downto DMACR_FSYNCSEL_LSB)     -- bits 6 downto 5
                                                        & axi2ip_wrdata(DMACR_FRMCNTEN_BIT);    -- bit  4
            end if;
        end if;
    end process DM_DMACR_REGISTER;
end generate DM_GEN_DMACR_REGISTER;


S_GEN_DMACR_REGISTER : if C_GENLOCK_MODE = 1 generate
begin
S_DMACR_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then

		dmacr_i(14 downto 8) <= (others => '0');
		dmacr_i(7) 	     <= '1';
		dmacr_i(6 downto 4)  <= (others => '0');



            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(DMACR_IRQTHRESH_LSB_BIT-2
                        downto DMACR_FRMCNTEN_BIT)   <=  axi2ip_wrdata(DMACR_ERR_IRQEN_BIT)    -- bit  14
                                                        & axi2ip_wrdata(DMACR_DLY_IRQEN_BIT)    -- bit  13
                                                        & axi2ip_wrdata(DMACR_IOC_IRQEN_BIT)    -- bit  12
                                                        & axi2ip_wrdata(DMACR_PNTR_NUM_MSB
                                                                 downto DMACR_PNTR_NUM_LSB)     -- bits 11 downto 8
                                                        & axi2ip_wrdata(DMACR_GENLOCK_SEL_BIT)  -- bit  7
                                                        & axi2ip_wrdata(DMACR_FSYNCSEL_MSB
                                                                 downto DMACR_FSYNCSEL_LSB)     -- bits 6 downto 5
                                                        & axi2ip_wrdata(DMACR_FRMCNTEN_BIT);    -- bit  4
            end if;
        end if;
    end process S_DMACR_REGISTER;
end generate S_GEN_DMACR_REGISTER;
end generate GEN_FOR_INTERNAL_GENLOCK;



----M_GEN_DMACR_REGISTER : if C_GENLOCK_MODE = 0 generate
----begin
----M_DMACR_REGISTER : process(prmry_aclk)
----    begin
----        if(prmry_aclk'EVENT and prmry_aclk = '1')then
----            if(prmry_resetn = '0')then
----                dmacr_i(DMACR_IRQTHRESH_LSB_BIT-1
----                        downto DMACR_FRMCNTEN_BIT)   <= (others => '0');
----
----            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
----                dmacr_i(DMACR_IRQTHRESH_LSB_BIT-1
----                        downto DMACR_FRMCNTEN_BIT)   <= axi2ip_wrdata(DMACR_REPEAT_EN_BIT)        -- bit  15
----                                                        & axi2ip_wrdata(DMACR_ERR_IRQEN_BIT)    -- bit  14
----                                                        & axi2ip_wrdata(DMACR_DLY_IRQEN_BIT)    -- bit  13
----                                                        & axi2ip_wrdata(DMACR_IOC_IRQEN_BIT)    -- bit  12
----                                                        & ZERO_VALUE(DMACR_PNTR_NUM_MSB
----                                                                 downto DMACR_PNTR_NUM_LSB)     -- bits 11 downto 8
----                                                        & '0'  					-- bit  7
----                                                        & axi2ip_wrdata(DMACR_FSYNCSEL_MSB
----                                                                 downto DMACR_FSYNCSEL_LSB)     -- bits 6 downto 5
----                                                        & axi2ip_wrdata(DMACR_FRMCNTEN_BIT);    -- bit  4
----            end if;
----        end if;
----    end process M_DMACR_REGISTER;
----end generate M_GEN_DMACR_REGISTER;

M_GEN_DMACR_REGISTER : if C_GENLOCK_MODE = 0 generate
begin
M_DMACR_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dmacr_i(DMACR_IRQTHRESH_LSB_BIT-2
                        downto DMACR_FRMCNTEN_BIT)   <= (others => '0');

            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(DMACR_IRQTHRESH_LSB_BIT-2
                        downto DMACR_FRMCNTEN_BIT)   <=   axi2ip_wrdata(DMACR_ERR_IRQEN_BIT)    -- bit  14
                                                        & axi2ip_wrdata(DMACR_DLY_IRQEN_BIT)    -- bit  13
                                                        & axi2ip_wrdata(DMACR_IOC_IRQEN_BIT)    -- bit  12
                                                        & ZERO_VALUE(DMACR_PNTR_NUM_MSB
                                                                 downto DMACR_PNTR_NUM_LSB)     -- bits 11 downto 8
                                                        & '0'  					-- bit  7
                                                        & axi2ip_wrdata(DMACR_FSYNCSEL_MSB
                                                                 downto DMACR_FSYNCSEL_LSB)     -- bits 6 downto 5
                                                        & axi2ip_wrdata(DMACR_FRMCNTEN_BIT);    -- bit  4
            end if;
        end if;
    end process M_DMACR_REGISTER;
end generate M_GEN_DMACR_REGISTER;




-------------------------------------------------------------------------------
-- DMACR - GenLock Sync Enable Bit (
-------------------------------------------------------------------------------

-- Dynamic Genlock Slave mode therefore instantiate a register for sync enable.
DS_GEN_SYNCEN_BIT : if C_GENLOCK_MODE = 3 generate
begin
    DS_DMACR_SYNCEN : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' )then
                    dmacr_i(DMACR_SYNCEN_BIT)  <= '0';
                    dmacr_i(DMACR_REPEAT_EN_BIT)  <= '0';	--

                -- If DMACR Write then pass axi lite write bus to DMARC reset bit
                elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                    dmacr_i(DMACR_SYNCEN_BIT)  <= axi2ip_wrdata(DMACR_SYNCEN_BIT);

                end if;
            end if;
        end process DS_DMACR_SYNCEN;
end generate DS_GEN_SYNCEN_BIT;



-- Dynamic Genlock Master mode therefore instantiate a register for sync enable.
DM_GEN_SYNCEN_BIT : if C_GENLOCK_MODE = 2 generate
begin
    DM_DMACR_SYNCEN : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' )then
                    dmacr_i(DMACR_SYNCEN_BIT)  <= '0';
                    --dmacr_i(DMACR_REPEAT_EN_BIT)  <= '1';
                    dmacr_i(DMACR_REPEAT_EN_BIT)  <= '0';	--

                -- If DMACR Write then pass axi lite write bus to DMARC reset bit
                elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                    dmacr_i(DMACR_SYNCEN_BIT)  <= axi2ip_wrdata(DMACR_SYNCEN_BIT);
                    dmacr_i(DMACR_REPEAT_EN_BIT)  <= axi2ip_wrdata(DMACR_REPEAT_EN_BIT);

                end if;
            end if;
        end process DM_DMACR_SYNCEN;
end generate DM_GEN_SYNCEN_BIT;








-- Genlock Slave mode therefore instantiate a register for sync enable.
GEN_SYNCEN_BIT : if C_GENLOCK_MODE = 1 generate
begin
    DMACR_SYNCEN : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' )then
                    dmacr_i(DMACR_SYNCEN_BIT)  <= '0';
                    dmacr_i(DMACR_REPEAT_EN_BIT)  <= '0';	--

                -- If DMACR Write then pass axi lite write bus to DMARC reset bit
                elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                    dmacr_i(DMACR_SYNCEN_BIT)  <= axi2ip_wrdata(DMACR_SYNCEN_BIT);

                end if;
            end if;
        end process DMACR_SYNCEN;
end generate GEN_SYNCEN_BIT;

-- Genlock Master mode therefore make DMACR.SyncEn bit RO and set to zero
GEN_NOSYNCEN_BIT : if C_GENLOCK_MODE = 0 generate
begin
    dmacr_i(DMACR_SYNCEN_BIT)  <= '0';

    M_DMACR_REPEAT_EN : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' )then
                    --dmacr_i(DMACR_REPEAT_EN_BIT)  <= '1';
                    dmacr_i(DMACR_REPEAT_EN_BIT)  <= '0';	-- 

                -- If DMACR Write then pass axi lite write bus to DMACR bit
                elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                    dmacr_i(DMACR_REPEAT_EN_BIT)  <= axi2ip_wrdata(DMACR_REPEAT_EN_BIT);

                end if;
            end if;
        end process M_DMACR_REPEAT_EN;



end generate GEN_NOSYNCEN_BIT;



-------------------------------------------------------------------------------
-- DMACR - Reset Bit
-------------------------------------------------------------------------------
DMACR_RESET : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(soft_reset_clr = '1')then
                dmacr_i(DMACR_RESET_BIT)  <= '0';

            -- If DMACR Write then pass axi lite write bus to DMARC reset bit
            elsif(soft_reset_i = '0' and axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(DMACR_RESET_BIT)  <= axi2ip_wrdata(DMACR_RESET_BIT);

            end if;
        end if;
    end process DMACR_RESET;

soft_reset_i <= dmacr_i(DMACR_RESET_BIT);

-------------------------------------------------------------------------------
-- Circular Buffere/ Park Enable
-------------------------------------------------------------------------------
DMACR_TAILPTREN : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dmacr_i(DMACR_CRCLPRK_BIT)  <= '1';

            -- If DMACR Write then pass axi lite write bus to DMARC tailptr en bit
            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(DMACR_CRCLPRK_BIT)  <= axi2ip_wrdata(DMACR_CRCLPRK_BIT);

            end if;
        end if;
    end process DMACR_TAILPTREN;

-------------------------------------------------------------------------------
-- DMACR - Run/Stop Bit
-------------------------------------------------------------------------------
run_stop_clr   <= '1' when (stop_dma = '1')                     -- Stop due to error/rs clear
                        or (soft_reset_i = '1')                 -- Soft Reset
                        or (dmacr_i(DMACR_FRMCNTEN_BIT) = '1'   -- Frame Count Enable
                            and ioc_irq_set = '1')              -- and threshold met


             else '0';

DMACR_RUNSTOP : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dmacr_i(DMACR_RS_BIT)  <= '0';
            -- Clear on sg error (i.e. error) or dma error or soft reset
            elsif(run_stop_clr = '1')then
                dmacr_i(DMACR_RS_BIT)  <= '0';
            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(DMACR_RS_BIT)  <= axi2ip_wrdata(DMACR_RS_BIT);
            end if;
        end if;
    end process DMACR_RUNSTOP;

---------------------------------------------------------------------------
-- DMA Status Halted bit (BIT 0) - Set by dma controller indicating DMA
-- channel is halted.
---------------------------------------------------------------------------
DMASR_HALTED : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or halted_set = '1')then
                halted <= '1';
            elsif(halted_clr = '1')then
                halted <= '0';
            end if;
        end if;
    end process DMASR_HALTED;

---------------------------------------------------------------------------
-- DMA Status Idle bit (BIT 1) - Set by dma controller indicating DMA
-- channel is IDLE waiting at tail pointer.  Update of Tail Pointer
-- will cause engine to resume.  Note: Halted channels return to a
-- reset condition.
---------------------------------------------------------------------------
GEN_FOR_SG : if C_INCLUDE_SG = 1 generate
begin
    DMASR_IDLE : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0'
                or idle_clr = '1'
                or halted_set = '1')then
                    idle   <= '0';

                elsif(idle_set = '1')then
                    idle   <= '1';
                end if;
            end if;
        end process DMASR_IDLE;
end generate GEN_FOR_SG;
--  
GEN_NO_SG : if C_INCLUDE_SG = 0 generate
begin
    idle <= '0';
end generate GEN_NO_SG;

---------------------------------------------------------------------------
-- DMA Status Error bit (BIT 3)
-- Note: any error will cause entire engine to halt
---------------------------------------------------------------------------

MM2S_ERR_FOR_IRQ : if  C_CHANNEL_IS_MM2S = 1 generate
begin

err  <= dma_interr
            or lsize_err
            or lsize_more_err
            or dma_slverr
            or dma_decerr
            or sg_slverr
            or sg_decerr;


FRMSTR_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' )then
                    frm_store_i           <= (others => '0');
--            elsif(err = '1')then
--                    frm_store_i           <= frm_store_i;
            elsif(err = '0')then
                    frm_store_i           <= new_frmstr;
            end if;
        end if;
    end process FRMSTR_REGISTER;



end generate MM2S_ERR_FOR_IRQ;



S2MM_ERR_FOR_IRQ : if  C_CHANNEL_IS_MM2S = 0 generate
begin

err_p  <= dma_interr
            or lsize_err
            or lsize_more_err
            or dma_slverr
            or dma_decerr
            or sg_slverr
            or sg_decerr;



err  <= dma_interr_minus_frame_errors
            or (fsize_err                       and not dma_irq_mask_i(0))
            or (lsize_err                       and not dma_irq_mask_i(1))
            or (s2mm_fsize_more_or_sof_late_bit and not dma_irq_mask_i(2))
            or (lsize_more_err                  and not dma_irq_mask_i(3))
            or dma_slverr
            or dma_decerr
            or sg_slverr
            or sg_decerr;

FRMSTR_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' )then
                    frm_store_i           <= (others => '0');
--            elsif(err = '1')then
--                    frm_store_i           <= frm_store_i;
            elsif(err_p = '0')then
                    frm_store_i           <= new_frmstr;
            end if;
        end if;
    end process FRMSTR_REGISTER;


    DMAINTERR_MINUS_FRAME_ERRORS : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    dma_interr_minus_frame_errors <= '0';

                elsif(axi2ip_wrce(DMASR_INDEX) = '1' )then

                    dma_interr_minus_frame_errors <= (dma_interr_minus_frame_errors and not(axi2ip_wrdata(DMASR_DMAINTERR_BIT)))
                                 or dma_interr_set_minus_frame_errors;

                elsif(dma_interr_set_minus_frame_errors = '1' )then
                    dma_interr_minus_frame_errors <= '1';
                end if;
            end if;
        end process DMAINTERR_MINUS_FRAME_ERRORS;




end generate S2MM_ERR_FOR_IRQ;

-- Scatter Gather Error
sg_ftch_err <= ftch_slverr_set or ftch_decerr_set;

---------------------------------------------------------------------------
-- DMA Status DMA Internal Error bit (BIT 4)
---------------------------------------------------------------------------
-- If flush on frame sync disable then only reset will clear bit
GEN_FOR_NO_FLUSH : if C_ENABLE_FLUSH_ON_FSYNC = 0 generate
begin
                    s2mm_fsize_more_or_sof_late_bit <= '0';
    ----DMASR_DMAINTERR : process(prmry_aclk)
    ----    begin
    ----        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    ----            if(prmry_resetn = '0')then
    ----                dma_interr <= '0';
    ----            elsif(dma_interr_set = '1' )then
    ----                dma_interr <= '1';
    ----            end if;
    ----        end if;
    ----    end process DMASR_DMAINTERR;

    DMASR_FSIZEERR : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    fsize_err <= '0';
                elsif(fsize_mismatch_err = '1' )then
                    fsize_err <= '1';
                end if;
            end if;
        end process DMASR_FSIZEERR;


----    DMASR_LSIZE_ERR : process(prmry_aclk)
----        begin
----            if(prmry_aclk'EVENT and prmry_aclk = '1')then
----                if(prmry_resetn = '0')then
----                    lsize_err <= '0';
----                elsif(lsize_mismatch_err = '1' )then
----                    lsize_err <= '1';
----                end if;
----            end if;
----        end process DMASR_LSIZE_ERR;
----
----    DMASR_LSIZE_MORE_ERR : process(prmry_aclk)
----        begin
----            if(prmry_aclk'EVENT and prmry_aclk = '1')then
----                if(prmry_resetn = '0')then
----                    lsize_more_err <= '0';
----                elsif(lsize_more_mismatch_err = '1' )then
----                    lsize_more_err <= '1';
----                end if;
----            end if;
----        end process DMASR_LSIZE_MORE_ERR;

end generate GEN_FOR_NO_FLUSH;

-- Flush on frame sync enabled therefore can clear with a write of '1'
GEN_FOR_FLUSH : if C_ENABLE_FLUSH_ON_FSYNC = 1 generate
begin
   ---- DMASR_DMAINTERR : process(prmry_aclk)
   ----     begin
   ----         if(prmry_aclk'EVENT and prmry_aclk = '1')then
   ----             if(prmry_resetn = '0')then
   ----                 dma_interr <= '0';

   ----             -- CPU Writing a '1' to clear - OR'ed with setting to prevent
   ----             -- missing a 'set' during the write.
   ----             elsif(axi2ip_wrce(DMASR_INDEX) = '1' )then

   ----                 dma_interr <= (dma_interr and not(axi2ip_wrdata(DMASR_DMAINTERR_BIT)))
   ----                              or dma_interr_set;

   ----             elsif(dma_interr_set = '1' )then
   ----                 dma_interr <= '1';
   ----             end if;
   ----         end if;
   ----     end process DMASR_DMAINTERR;


    DMASR_FSIZEERR : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    fsize_err <= '0';

                -- CPU Writing a '1' to clear - OR'ed with setting to prevent
                -- missing a 'set' during the write.
                elsif(axi2ip_wrce(DMASR_INDEX) = '1' )then

                    fsize_err <= (fsize_err and not(axi2ip_wrdata(DMASR_FSIZEERR_BIT)))
                                 or fsize_mismatch_err;

                elsif(fsize_mismatch_err = '1' )then
                    fsize_err <= '1';
                end if;
            end if;
        end process DMASR_FSIZEERR;


    DMASR_FSIZE_MORE_OR_SOF_LATE_ERR : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    s2mm_fsize_more_or_sof_late_bit <= '0';

                -- CPU Writing a '1' to clear - OR'ed with setting to prevent
                -- missing a 'set' during the write.
                elsif(axi2ip_wrce(DMASR_INDEX) = '1' )then

                    s2mm_fsize_more_or_sof_late_bit <= (s2mm_fsize_more_or_sof_late_bit and not(axi2ip_wrdata(DMASR_FSIZE_MORE_OR_SOF_LATE_ERR_BIT)))
                                 or s2mm_fsize_more_or_sof_late;

                elsif(s2mm_fsize_more_or_sof_late = '1' )then
                    s2mm_fsize_more_or_sof_late_bit <= '1';
                end if;
            end if;
        end process DMASR_FSIZE_MORE_OR_SOF_LATE_ERR;

end generate GEN_FOR_FLUSH;


    DMASR_LSIZE_ERR : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    lsize_err <= '0';

                -- CPU Writing a '1' to clear - OR'ed with setting to prevent
                -- missing a 'set' during the write.
                elsif(axi2ip_wrce(DMASR_INDEX) = '1' )then

                    lsize_err <= (lsize_err and not(axi2ip_wrdata(DMASR_LSIZEERR_BIT)))
                                 or lsize_mismatch_err;

                elsif(lsize_mismatch_err = '1' )then
                    lsize_err <= '1';
                end if;
            end if;
        end process DMASR_LSIZE_ERR;

    DMASR_LSIZE_MORE_ERR : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    lsize_more_err <= '0';

                -- CPU Writing a '1' to clear - OR'ed with setting to prevent
                -- missing a 'set' during the write.
                elsif(axi2ip_wrce(DMASR_INDEX) = '1' )then

                    lsize_more_err <= (lsize_more_err and not(axi2ip_wrdata(DMASR_LSIZE_MORE_ERR_BIT)))
                                 or lsize_more_mismatch_err;

                elsif(lsize_more_mismatch_err = '1' )then
                    lsize_more_err <= '1';
                end if;
            end if;
        end process DMASR_LSIZE_MORE_ERR;

    DMASR_DMAINTERR : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    dma_interr <= '0';

                -- CPU Writing a '1' to clear - OR'ed with setting to prevent
                -- missing a 'set' during the write.
                elsif(axi2ip_wrce(DMASR_INDEX) = '1' )then

                    dma_interr <= (dma_interr and not(axi2ip_wrdata(DMASR_DMAINTERR_BIT)))
                                 or dma_interr_set;

                elsif(dma_interr_set = '1' )then
                    dma_interr <= '1';
                end if;
            end if;
        end process DMASR_DMAINTERR;



---------------------------------------------------------------------------
-- DMA Status DMA Slave Error bit (BIT 5)
---------------------------------------------------------------------------
DMASR_DMASLVERR : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dma_slverr <= '0';

            elsif(dma_slverr_set = '1' )then
                dma_slverr <= '1';

            end if;
        end if;
    end process DMASR_DMASLVERR;

---------------------------------------------------------------------------
-- DMA Status DMA Decode Error bit (BIT 6)
---------------------------------------------------------------------------
DMASR_DMADECERR : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dma_decerr <= '0';

            elsif(dma_decerr_set = '1' )then
                dma_decerr <= '1';

            end if;
        end if;
    end process DMASR_DMADECERR;


---------------------------------------------------------------------------
-- DMA Status IOC Interrupt status bit (BIT 11)
---------------------------------------------------------------------------
DMASR_IOCIRQ : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                ioc_irq <= '0';

            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
            -- missing a 'set' during the write.
            elsif(axi2ip_wrce(DMASR_INDEX) = '1' )then

                ioc_irq <= (ioc_irq and not(axi2ip_wrdata(DMASR_IOCIRQ_BIT)))
                             or ioc_irq_set;

            elsif(ioc_irq_set = '1')then
                ioc_irq <= '1';

            end if;
        end if;
    end process DMASR_IOCIRQ;

---------------------------------------------------------------------------
-- DMA Status Delay Interrupt status bit (BIT 12)
---------------------------------------------------------------------------
DMASR_DLYIRQ : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dly_irq <= '0';

            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
            -- missing a 'set' during the write.
            elsif(axi2ip_wrce(DMASR_INDEX) = '1' )then

                dly_irq <= (dly_irq and not(axi2ip_wrdata(DMASR_DLYIRQ_BIT)))
                             or dly_irq_set;

            elsif(dly_irq_set = '1')then
                dly_irq <= '1';

            end if;
        end if;
    end process DMASR_DLYIRQ;

-- Disable delay timer if halted or on delay irq set
dlyirq_dsble    <= dmasr_i(DMASR_HALTED_BIT) or dmasr_i(DMASR_DLYIRQ_BIT)
                   or fsync_mask;   -- 

---------------------------------------------------------------------------
-- DMA Status Error Interrupt status bit (BIT 12)
---------------------------------------------------------------------------
-- Delay error setting for generation of error strobe
GEN_ERR_RE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                err_d1 <= '0';
            else
                err_d1 <= err;
            end if;
        end if;
    end process GEN_ERR_RE;

-- Generate rising edge pulse on error
err_re   <= err and not err_d1;
--err_fe   <= not err and err_d1;

DMASR_ERRIRQ : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                err_irq <= '0';

            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
            -- missing a 'set' during the write.
            elsif(axi2ip_wrce(DMASR_INDEX) = '1' )then

                err_irq <= (err_irq and not(axi2ip_wrdata(DMASR_ERRIRQ_BIT)))
                             or err_re;

            elsif(err_re = '1')then
                err_irq <= '1';

            end if;
        end if;
    end process DMASR_ERRIRQ;

---------------------------------------------------------------------------
-- DMA Interrupt OUT
---------------------------------------------------------------------------
REG_INTR : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or soft_reset_i = '1')then
                introut <= '0';
            else
                introut <= (dly_irq and dmacr_i(DMACR_DLY_IRQEN_BIT))
                        or (ioc_irq and dmacr_i(DMACR_IOC_IRQEN_BIT))
                        or (err_irq and dmacr_i(DMACR_ERR_IRQEN_BIT));
            end if;
        end if;
    end process;

---------------------------------------------------------------------------
-- DMA Status Register
---------------------------------------------------------------------------
dmasr_i    <=  irqdelay_status    -- Bits 31 downto 24
                    & irqthresh_status -- Bits 23 downto 16
                    & lsize_more_err              -- Bit  15
                    & err_irq          -- Bit  14
                    & dly_irq          -- Bit  13
                    & ioc_irq          -- Bit  12
                    & s2mm_fsize_more_or_sof_late_bit              -- Bit  11
                    & sg_decerr        -- Bit  10
                    & sg_slverr        -- Bit  9
                    & lsize_err              -- Bit  8
                    & fsize_err              -- Bit  7
                    & dma_decerr       -- Bit  6
                    & dma_slverr       -- Bit  5
                    & dma_interr       -- Bit  4
                    & '0'              -- Bit  3
                    & '0'              -- Bit  2
                    & idle             -- Bit  1
                    & halted;          -- Bit  0




-------------------------------------------------------------------------------
-- Frame Store Pointer Field - Reference of current frame buffer pointer being
-- used.
-------------------------------------------------------------------------------
----FRMSTR_REGISTER : process(prmry_aclk)
----    begin
----        if(prmry_aclk'EVENT and prmry_aclk = '1')then
----            --if(prmry_resetn = '0' or err_fe = '1')then
----            if(prmry_resetn = '0' )then
----                frm_store           <= (others => '0');
----                err_frmstore_set  <= '0';
----            -- Detected error has NOT register a desc pointer
----            elsif(err_frmstore_set = '0')then
----
----                -- 
----                -- DMA Error Error
----                if(update_frmstore = '1' and err = '1')then
----                    frm_store           <= frmstr_err_addr;
----                    err_frmstore_set  <= '1';
----
----                -- 
----                -- Commanded to update frame store value - used for indicating
----                -- current frame begin processed by dma controller
----                elsif(update_frmstore = '1' and dmacr_i(DMACR_RS_BIT)  = '1')then
----                    frm_store           <= new_frmstr;
----                    err_frmstore_set  <= err_frmstore_set;
----
----                end if;
----            end if;
----        end if;
----    end process FRMSTR_REGISTER;

-- If SG engine is included then instantiate sg specific logic
GEN_SCATTER_GATHER_MODE : if C_INCLUDE_SG = 1 generate

    reg_index_i      <= (others => '0'); -- Not used in SCATTER GATHER mode


    ---------------------------------------------------------------------------
    -- DMA Status SG Slave Error bit (BIT 9)
    ---------------------------------------------------------------------------
    DMASR_SGSLVERR : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    sg_slverr <= '0';

                elsif(ftch_slverr_set = '1')then
                    sg_slverr <= '1';

                end if;
            end if;
        end process DMASR_SGSLVERR;

    ---------------------------------------------------------------------------
    -- DMA Status SG Decode Error bit (BIT 10)
    ---------------------------------------------------------------------------
    DMASR_SGDECERR : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    sg_decerr <= '0';

                elsif(ftch_decerr_set = '1')then
                    sg_decerr <= '1';

                end if;
            end if;
        end process DMASR_SGDECERR;

    ---------------------------------------------------------------------------
    -- Current Descriptor LSB Register
    ---------------------------------------------------------------------------
    CURDESC_LSB_REGISTER : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    curdesc_lsb_i   <= (others => '0');
                    err_pointer_set   <= '0';

                -- Detected error has NOT register a desc pointer
                elsif(err_pointer_set = '0')then

                    -- Scatter Gather Fetch Error
                    if(sg_ftch_err = '1')then
                        curdesc_lsb_i <= ftch_err_addr(CURDESC_LOWER_MSB_BIT -- Curdesc  bit 31 downto
                                                  downto CURDESC_LOWER_LSB_BIT)-- Curdesc  bit 5
                                       & "00000";                              -- Reserved bits 4 downto 0

                        err_pointer_set   <= '1';

                    -- Commanded to update descriptor value - used for indicating
                    -- current descriptor begin processed by dma controller
                    elsif(update_curdesc = '1' and dmacr_i(DMACR_RS_BIT)  = '1')then
                        curdesc_lsb_i   <= new_curdesc(CURDESC_LOWER_MSB_BIT  -- Curdesc  bit 31 downto
                                                downto CURDESC_LOWER_LSB_BIT)   -- Curdesc  bit 5
                                       & "00000";                               -- Reserved bit 4 downto 0

                        err_pointer_set <= err_pointer_set;

                    -- CPU update of current descriptor pointer.  CPU
                    -- only allowed to update when engine is halted.
                    elsif(axi2ip_wrce(CURDESC_LSB_INDEX) = '1' and dmasr_i(DMASR_HALTED_BIT) = '1')then
                        curdesc_lsb_i   <= axi2ip_wrdata(CURDESC_LOWER_MSB_BIT   -- Curdesc  bit 31 downto
                                                  downto CURDESC_LOWER_LSB_BIT)  -- Curdesc  bit 5
                                       & "00000";                                -- Reserved bit 4 downto 0

                        err_pointer_set <= err_pointer_set;

                    end if;
                end if;
            end if;
        end process CURDESC_LSB_REGISTER;


    ---------------------------------------------------------------------------
    -- Tail Descriptor LSB Register
    ---------------------------------------------------------------------------
    TAILDESC_LSB_REGISTER : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    taildesc_lsb_i  <= (others => '0');
                elsif(axi2ip_wrce(TAILDESC_LSB_INDEX) = '1')then
                    taildesc_lsb_i  <= axi2ip_wrdata(TAILDESC_LOWER_MSB_BIT
                                              downto TAILDESC_LOWER_LSB_BIT)
                                     & "00000";
                end if;
            end if;
        end process TAILDESC_LSB_REGISTER;

    ---------------------------------------------------------------------------
    -- Current Descriptor MSB Register
    ---------------------------------------------------------------------------
    -- Scatter Gather Interface configured for 64-Bit SG Addresses
    GEN_SG_ADDR_EQL64 :if C_M_AXI_SG_ADDR_WIDTH = 64 generate
    begin
        CURDESC_MSB_REGISTER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        curdesc_msb_i  <= (others => '0');

                    elsif(err_pointer_set = '0')then
                        -- Scatter Gather Fetch Error
                        if(sg_ftch_err = '1')then
                            curdesc_msb_i   <= ftch_err_addr((C_M_AXI_SG_ADDR_WIDTH
                                                - C_S_AXI_LITE_DATA_WIDTH)-1
                                                downto 0);

                        -- Commanded to update descriptor value - used for indicating
                        -- current descriptor begin processed by dma controller
                        elsif(update_curdesc = '1' and dmacr_i(DMACR_RS_BIT)  = '1')then
                            curdesc_msb_i <= new_curdesc
                                                ((C_M_AXI_SG_ADDR_WIDTH
                                                - C_S_AXI_LITE_DATA_WIDTH)-1
                                                downto 0);

                        -- CPU update of current descriptor pointer.  CPU
                        -- only allowed to update when engine is halted.
                        elsif(axi2ip_wrce(CURDESC_MSB_INDEX) = '1' and dmasr_i(DMASR_HALTED_BIT) = '1')then
                            curdesc_msb_i  <= axi2ip_wrdata;

                        end if;
                    end if;
                end if;
            end process CURDESC_MSB_REGISTER;

        ---------------------------------------------------------------------------
        -- Tail Descriptor MSB Register
        ---------------------------------------------------------------------------
        TAILDESC_MSB_REGISTER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        taildesc_msb_i  <= (others => '0');
                    elsif(axi2ip_wrce(TAILDESC_MSB_INDEX) = '1')then
                        taildesc_msb_i  <= axi2ip_wrdata;
                    end if;
                end if;
            end process TAILDESC_MSB_REGISTER;

        end generate GEN_SG_ADDR_EQL64;

    -- Scatter Gather Interface configured for 32-Bit SG Addresses
    GEN_SG_ADDR_EQL32 : if C_M_AXI_SG_ADDR_WIDTH = 32 generate
    begin
        curdesc_msb_i  <= (others => '0');
        taildesc_msb_i <= (others => '0');
    end generate GEN_SG_ADDR_EQL32;


    -- Scatter Gather Interface configured for 32-Bit SG Addresses
    GEN_TAILUPDATE_EQL32 : if C_M_AXI_SG_ADDR_WIDTH = 32 generate
    begin
        TAILPNTR_UPDT_PROCESS : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0' or dmacr_i(DMACR_RS_BIT)='0')then
                        tailpntr_updated    <= '0';
                    elsif(axi2ip_wrce(TAILDESC_LSB_INDEX) = '1')then
                        tailpntr_updated    <= '1';
                    else
                        tailpntr_updated    <= '0';
                    end if;
                end if;
            end process TAILPNTR_UPDT_PROCESS;


    end generate GEN_TAILUPDATE_EQL32;

    -- Scatter Gather Interface configured for 64-Bit SG Addresses
    GEN_TAILUPDATE_EQL64 : if C_M_AXI_SG_ADDR_WIDTH = 64 generate
    begin
        TAILPNTR_UPDT_PROCESS : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0' or dmacr_i(DMACR_RS_BIT)='0')then
                        tailpntr_updated    <= '0';
                    elsif(axi2ip_wrce(TAILDESC_MSB_INDEX) = '1')then
                        tailpntr_updated    <= '1';
                    else
                        tailpntr_updated    <= '0';
                    end if;
                end if;
            end process TAILPNTR_UPDT_PROCESS;

    end generate GEN_TAILUPDATE_EQL64;


end generate GEN_SCATTER_GATHER_MODE;

-- If SG engine is not included then instantiate register direct mode
GEN_NO_SCATTER_GATHER_MODE : if C_INCLUDE_SG = 0 generate
begin
    -- Tie off unused scatter gather specific signals
    sg_decerr           <= '0';             -- Not used in Register Direct Mode
    sg_slverr           <= '0';             -- Not used in Register Direct Mode
    curdesc_lsb_i       <= (others => '0'); -- Not used in Register Direct Mode
    curdesc_msb_i       <= (others => '0'); -- Not used in Register Direct Mode
    taildesc_lsb_i      <= (others => '0'); -- Not used in Register Direct Mode
    taildesc_msb_i      <= (others => '0'); -- Not used in Register Direct Mode
    tailpntr_updated    <= '0';             -- Not used in Register Direct Mode


 GEN_NO_REG_INDEX_REG : if C_NUM_FSTORES < 17 generate
 begin
    reg_index_i      <= (others => '0'); -- Not used if C_NUM_FSTORE =< 16

 end generate GEN_NO_REG_INDEX_REG;


 GEN_REG_INDEX_REG : if C_NUM_FSTORES > 16 generate
 begin
        ---------------------------------------------------------------------------
        --  Reg Index
        ---------------------------------------------------------------------------
        reg_index : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        reg_index_i  <= (others => '0');
                    elsif(axi2ip_wrce(REG_IND) = '1')then
                        reg_index_i(0)  <= axi2ip_wrdata(0);
                    end if;
                end if;
            end process reg_index;


 end generate GEN_REG_INDEX_REG;



end generate GEN_NO_SCATTER_GATHER_MODE;



---------------------------------------------------------------------------
-- Number of Frame Stores
---------------------------------------------------------------------------


ENABLE_NUM_FRMSTR_REGISTER : if ((C_CHANNEL_IS_MM2S = 1 and (C_ENABLE_DEBUG_INFO_5 = 1 or C_ENABLE_DEBUG_ALL = 1) ) or (C_CHANNEL_IS_MM2S = 0 and (C_ENABLE_DEBUG_INFO_13 = 1 or C_ENABLE_DEBUG_ALL = 1) ))generate
begin



NUM_FRMSTR_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                num_frame_store_i  <= std_logic_vector(to_unsigned(C_NUM_FSTORES_64,NUM_FRM_STORE_WIDTH));
            elsif(axi2ip_wrce(FRAME_STORE_INDEX) = '1')then

                -- If value is 0 then set frame store to 1
                if(frmstore_is_zero='1')then
                    num_frame_store_i   <= ONE_FRAMESTORE;
                else
                    num_frame_store_i   <= axi2ip_wrdata(FRMSTORE_MSB_BIT
                                                  downto FRMSTORE_LSB_BIT);
                end if;
            end if;
        end if;
    end process NUM_FRMSTR_REGISTER;

frmstore_is_zero <= '1' when axi2ip_wrdata(FRMSTORE_MSB_BIT
                                    downto FRMSTORE_LSB_BIT) = ZERO_FRAMESTORE
                else '0';

num_frame_store_regmux_i <= num_frame_store_i;

end generate ENABLE_NUM_FRMSTR_REGISTER;


DISABLE_NUM_FRMSTR_REGISTER : if ((C_CHANNEL_IS_MM2S = 1 and (C_ENABLE_DEBUG_INFO_5 = 0 and C_ENABLE_DEBUG_ALL = 0) ) or (C_CHANNEL_IS_MM2S = 0 and (C_ENABLE_DEBUG_INFO_13 = 0 and C_ENABLE_DEBUG_ALL = 0) ))generate
begin

                num_frame_store_i  <= std_logic_vector(to_unsigned(C_NUM_FSTORES_64,NUM_FRM_STORE_WIDTH));

		num_frame_store_regmux_i <= (others => '0');

end generate DISABLE_NUM_FRMSTR_REGISTER;



---------------------------------------------------------------------------
-- Line Buffer Threshold
---------------------------------------------------------------------------




ENABLE_LB_THRESH_REGISTER : if ((C_CHANNEL_IS_MM2S = 1 and (C_ENABLE_DEBUG_INFO_1 = 1 or C_ENABLE_DEBUG_ALL = 1) ) or (C_CHANNEL_IS_MM2S = 0 and (C_ENABLE_DEBUG_INFO_9 = 1 or C_ENABLE_DEBUG_ALL = 1) ))generate
begin

LB_THRESH_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                linebuf_threshold_i  <= std_logic_vector(to_unsigned(C_LINEBUFFER_THRESH,LINEBUFFER_THRESH_WIDTH));
            elsif(axi2ip_wrce(THRESHOLD_INDEX) = '1')then
                linebuf_threshold_i  <= axi2ip_wrdata(THRESH_MSB_BIT
                                              downto THRESH_LSB_BIT);
            end if;
        end if;
    end process LB_THRESH_REGISTER;

end generate ENABLE_LB_THRESH_REGISTER;
  

DISABLE_LB_THRESH_REGISTER : if ((C_CHANNEL_IS_MM2S = 1 and (C_ENABLE_DEBUG_INFO_1 = 0 and C_ENABLE_DEBUG_ALL = 0) ) or (C_CHANNEL_IS_MM2S = 0 and (C_ENABLE_DEBUG_INFO_9 = 0 and C_ENABLE_DEBUG_ALL = 0) ))generate
begin

             linebuf_threshold_i  <= (others => '0');

end generate DISABLE_LB_THRESH_REGISTER;
  

DMA_IRQ_MASK_GEN : if  C_CHANNEL_IS_MM2S = 0 generate
begin

        ---------------------------------------------------------------------------
        --  S2MM DMA IRQ MASK
        ---------------------------------------------------------------------------
        dma_irq_mask : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        dma_irq_mask_i  <= (others => '0');
                    elsif(axi2ip_wrce(DMA_IRQ_MASK_IND) = '1')then
                        dma_irq_mask_i(3 downto 0)  <= axi2ip_wrdata(3 downto 0);
                    end if;
                end if;
            end process dma_irq_mask;

end generate DMA_IRQ_MASK_GEN;

NO_DMA_IRQ_MASK_GEN : if  C_CHANNEL_IS_MM2S = 1 generate
begin

                        dma_irq_mask_i  <= (others => '0');

end generate NO_DMA_IRQ_MASK_GEN;



end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_regdirect
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_regdirect.vhd
--
-- Description:     This entity encompasses the channel register set.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_regdirect is
    generic(
        C_NUM_REGISTERS             : integer                   := 6        ;
        C_NUM_FSTORES               : integer range 1 to 32     := 1        ;
        C_NUM_FSTORES_64               : integer range 1 to 32     := 1        ;
        C_GENLOCK_MODE              : integer range 0 to 3      := 0        ;

        -----------------------------------------------------------------------
        C_DYNAMIC_RESOLUTION        : integer range 0 to 1      := 1	    ;
            -- Run time configuration of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 0 = Halt VDMA before writing new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 1 = Run time register configuration for new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE.
        -----------------------------------------------------------------------


        C_S_AXI_LITE_DATA_WIDTH     : integer range 32 to 32    := 32       ;
        C_M_AXI_ADDR_WIDTH          : integer range 32 to 32    := 32
    );
    port (
        prmry_aclk                  : in  std_logic                         ;           --
        prmry_resetn                : in  std_logic                         ;           --
                                                                                        --
        -- AXI Interface Control                                                        --
        axi2ip_wrce                 : in  std_logic_vector                              --
                                        (C_NUM_REGISTERS-1 downto 0)        ;           --
        axi2ip_wrdata               : in  std_logic_vector                              --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);           --
                                                                                        --
        run_stop                    : in  std_logic                         ;           --
        dmasr_halt                  : in  std_logic                         ;           --
        stop                        : in  std_logic                         ;           --
                                                                                        --

        reg_index                       : in  std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --

        -- Register Direct Support                                                      --
        prmtr_updt_complete         : out std_logic                         ;           --
        regdir_idle                 : out std_logic                         ;           --
                                                                                        --
        -- Register Direct Mode Video Parameter In                                      --
        reg_module_vsize            : out std_logic_vector                              --
                                        (VSIZE_DWIDTH-1 downto 0)           ;           --
        reg_module_hsize            : out std_logic_vector                              --
                                        (HSIZE_DWIDTH-1 downto 0)           ;           --
        reg_module_strid            : out std_logic_vector                              --
                                        (STRIDE_DWIDTH-1 downto 0)          ;           --
        reg_module_frmdly           : out std_logic_vector                              --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;           --
        reg_module_strt_addr        : out STARTADDR_ARRAY_TYPE                          --
                                        (0 to C_NUM_FSTORES - 1)            ;           --
        reg_module_start_address1   : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address2   : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address3   : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address4   : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address5   : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address6   : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address7   : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address8   : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address9   : out std_logic_vector                              --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address10  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address11  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address12  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address13  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address14  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address15  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address16  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address17  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address18  : out std_logic_vector                              --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address19  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address20  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address21  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address22  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address23  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address24  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address25  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address26  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address27  : out std_logic_vector                              --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address28  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address29  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address30  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address31  : out std_logic_vector                              --
                                         (C_M_AXI_ADDR_WIDTH - 1 downto 0);           --
        reg_module_start_address32  : out std_logic_vector                              --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)            --

    );
end axi_vdma_regdirect;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_regdirect is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant VSYNC_INDEX          : integer := 0;           -- VSYNC Register index
constant HSYNC_INDEX          : integer := 1;           -- HSYNC Register index
constant DLY_STRIDE_INDEX     : integer := 2;           -- STRIDE/DLY Reg index
--constant RESERVED_INDEX3      : integer := 3;           -- Reserved
constant STARTADDR1_INDEX       : integer := 3;           -- Start Address 1 Reg index
constant STARTADDR2_INDEX       : integer := 4;           -- Start Address 2 Reg index
constant STARTADDR3_INDEX       : integer := 5;           -- Start Address 3 Reg index
constant STARTADDR4_INDEX       : integer := 6;           -- Start Address 3 Reg index
constant STARTADDR5_INDEX       : integer := 7;           -- Start Address 3 Reg index
constant STARTADDR6_INDEX       : integer := 8;           -- Start Address 3 Reg index
constant STARTADDR7_INDEX       : integer := 9;           -- Start Address 3 Reg index
constant STARTADDR8_INDEX       : integer := 10;          -- Start Address 3 Reg index
constant STARTADDR9_INDEX       : integer := 11;          -- Start Address 3 Reg index
constant STARTADDR10_INDEX      : integer := 12;          -- Start Address 3 Reg index
constant STARTADDR11_INDEX      : integer := 13;          -- Start Address 3 Reg index
constant STARTADDR12_INDEX      : integer := 14;          -- Start Address 3 Reg index
constant STARTADDR13_INDEX      : integer := 15;          -- Start Address 3 Reg index
constant STARTADDR14_INDEX      : integer := 16;          -- Start Address 3 Reg index
constant STARTADDR15_INDEX      : integer := 17;          -- Start Address 3 Reg index
constant STARTADDR16_INDEX      : integer := 18;          -- Start Address 3 Reg index


-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal prmtr_updt_complete_i    : std_logic := '0';
signal reg_config_locked_i      : std_logic := '0';
signal regdir_idle_i            : std_logic := '0';
signal run_stop_d1              : std_logic := '0';
signal run_stop_re              : std_logic := '0';

--signal reg_module_strt_addr_i   : STARTADDR_ARRAY_TYPE(0 to MAX_FSTORES-1);
signal reg_module_start_address1_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address2_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address3_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address4_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address5_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address6_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address7_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address8_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address9_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address10_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address11_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address12_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address13_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address14_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address15_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address16_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address17_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address18_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address19_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address20_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address21_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address22_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address23_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address24_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address25_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address26_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address27_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address28_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address29_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address30_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address31_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address32_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin


-- Register DMACR RunStop bit to create a RE pulse
REG_RUN_RE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                run_stop_d1 <= '0';
            else
                run_stop_d1 <= run_stop;
            end if;
        end if;
    end process REG_RUN_RE;

run_stop_re    <= run_stop and not run_stop_d1;

-- Gen register direct idle flag to indicate when not idle.
-- Flag is asserted to NOT idle at start of run and to Idle
-- on reset, halt, or stop (i.e. error)
-- This is used to generate first fsync in free run mode.
REG_IDLE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or stop = '1')then
                regdir_idle_i <= '1';

            elsif(run_stop_re = '1')then
                regdir_idle_i <= '0';

            elsif(prmtr_updt_complete_i = '1')then
                regdir_idle_i <= '1';
            end if;
        end if;
    end process REG_IDLE;

regdir_idle <= regdir_idle_i;

-- Vertical Size Register
VSIZE_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                reg_module_vsize   <= (others => '0');
            elsif(axi2ip_wrce(VSYNC_INDEX) = '1' and reg_config_locked_i = '0')then
                reg_module_vsize   <= axi2ip_wrdata(VSIZE_DWIDTH-1 downto 0);
            end if;
        end if;
    end process VSIZE_REGISTER;

VIDEO_PRMTR_UPDATE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or run_stop = '0')then
                prmtr_updt_complete_i    <= '0';
            elsif(axi2ip_wrce(VSYNC_INDEX) = '1' and reg_config_locked_i = '0')then
                prmtr_updt_complete_i    <= '1';
            else
                prmtr_updt_complete_i    <= '0';
            end if;
        end if;
    end process VIDEO_PRMTR_UPDATE;

prmtr_updt_complete <= prmtr_updt_complete_i;

-- Horizontal Size Register
HSIZE_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                reg_module_hsize   <= (others => '0');
            elsif(axi2ip_wrce(HSYNC_INDEX) = '1' and reg_config_locked_i = '0')then
                reg_module_hsize   <= axi2ip_wrdata(HSIZE_DWIDTH-1 downto 0);
            end if;
        end if;
    end process HSIZE_REGISTER;

-- Delay/Stride Register
--Genlock Slave mode 
S_GEN_DLYSTRIDE_REGISTER : if C_GENLOCK_MODE = 1 generate
begin
S_DLYSTRIDE_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                --reg_module_frmdly   <= (others => '0');
                reg_module_frmdly   <= "00001";		--
                reg_module_strid    <= (others => '0');
            elsif(axi2ip_wrce(DLY_STRIDE_INDEX) = '1' and reg_config_locked_i = '0')then
                reg_module_frmdly   <= axi2ip_wrdata(FRMDLY_MSB downto FRMDLY_LSB);
                reg_module_strid    <= axi2ip_wrdata(STRIDE_DWIDTH-1 downto 0);
            end if;
        end if;
    end process S_DLYSTRIDE_REGISTER;
end generate S_GEN_DLYSTRIDE_REGISTER;

--Genlock Master mode 
M_GEN_DLYSTRIDE_REGISTER : if C_GENLOCK_MODE = 0 generate
begin
                reg_module_frmdly   <= (others => '0');
M_DLYSTRIDE_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                reg_module_strid    <= (others => '0');
            elsif(axi2ip_wrce(DLY_STRIDE_INDEX) = '1' and reg_config_locked_i = '0')then
                reg_module_strid    <= axi2ip_wrdata(STRIDE_DWIDTH-1 downto 0);
            end if;
        end if;
    end process M_DLYSTRIDE_REGISTER;
end generate M_GEN_DLYSTRIDE_REGISTER;


--Dynamic Genlock Master mode 
DM_GEN_DLYSTRIDE_REGISTER : if C_GENLOCK_MODE = 2 generate
begin
                reg_module_frmdly   <= (others => '0');
DM_DLYSTRIDE_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                reg_module_strid    <= (others => '0');
            elsif(axi2ip_wrce(DLY_STRIDE_INDEX) = '1' and reg_config_locked_i = '0')then
                reg_module_strid    <= axi2ip_wrdata(STRIDE_DWIDTH-1 downto 0);
            end if;
        end if;
    end process DM_DLYSTRIDE_REGISTER;
end generate DM_GEN_DLYSTRIDE_REGISTER;


--Dynamic Genlock Slave mode 
DS_GEN_DLYSTRIDE_REGISTER : if C_GENLOCK_MODE = 3 generate
begin
                reg_module_frmdly   <= (others => '0');
DS_DLYSTRIDE_REGISTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                reg_module_strid    <= (others => '0');
            elsif(axi2ip_wrce(DLY_STRIDE_INDEX) = '1' and reg_config_locked_i = '0')then
                reg_module_strid    <= axi2ip_wrdata(STRIDE_DWIDTH-1 downto 0);
            end if;
        end if;
    end process DS_DLYSTRIDE_REGISTER;
end generate DS_GEN_DLYSTRIDE_REGISTER;


--No Dynamic resolution 
GEN_REG_CONFIG_LOCK_BIT : if C_DYNAMIC_RESOLUTION = 0 generate
begin

REG_CONFIG_LOCKED : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or dmasr_halt = '1')then
                reg_config_locked_i    <= '0';
            elsif(axi2ip_wrce(VSYNC_INDEX) = '1')then
                reg_config_locked_i    <= '1';
            end if;
        end if;
    end process REG_CONFIG_LOCKED;



end generate GEN_REG_CONFIG_LOCK_BIT;

--Dynamic resolution 
GEN_NO_REG_CONFIG_LOCK_BIT : if C_DYNAMIC_RESOLUTION = 1 generate
begin

                reg_config_locked_i    <= '0';

end generate GEN_NO_REG_CONFIG_LOCK_BIT;


--*****************************************************************************
--** START ADDRESS REGISTERS
--*****************************************************************************

-- Generate C_NUM_FSTORE start address registeres
--GEN_START_ADDR_REG : for i in 1 to MAX_FSTORES generate
----signal j              		: integer := 1;
--
--begin
----j<= i;
--
--        -- Start Address Registers
--        START_ADDR : process(prmry_aclk)
--            begin
--                if(prmry_aclk'EVENT and prmry_aclk = '1')then
--                    if(prmry_resetn = '0')then
--                        reg_module_strt_addr_i(i-1)   <= (others => '0');
--                    -- Write to appropriate Start Address
--
--		    elsif(i>= C_NUM_FSTORES)then
--                        reg_module_strt_addr_i(i-1) <= (others => '0');
--
--
--                    elsif(i<C_NUM_FSTORES and axi2ip_wrce(i+2) = '1'and C_NUM_FSTORES <17)then
--			reg_module_strt_addr_i(i-1)   <= axi2ip_wrdata;
--		    elsif(i<C_NUM_FSTORES and C_NUM_FSTORES >=17 and j<17 and axi2ip_wrce(i+2) = '1' and reg_index(0) = '0')then	
--			--if(i<17 and axi2ip_wrce(i+2) = '1')then
--				--if(reg_index(0) = '0')then
--					reg_module_strt_addr_i(i-1)   <= axi2ip_wrdata;
--				--elsif(reg_index(0) = '1')then
--		    elsif(i<C_NUM_FSTORES and C_NUM_FSTORES >=17 and j<17 and axi2ip_wrce(i+2) = '1' and reg_index(0) = '1')then	
--					reg_module_strt_addr_i(i+15)   <= axi2ip_wrdata;
--				--end if;
--			--elsif(i>=17 and axi2ip_wrce(i-14) = '1')then
--		    elsif(i<C_NUM_FSTORES and C_NUM_FSTORES >=17 and j>=17 and axi2ip_wrce(i-14) = '1' and reg_index(0) = '0')then	
--				--if(reg_index(0) = '0')then
--					reg_module_strt_addr_i(i-17)   <= axi2ip_wrdata;
--				--elsif(reg_index(0) = '1')then
--		    elsif(i<C_NUM_FSTORES and C_NUM_FSTORES >=17 and j>=17 and axi2ip_wrce(i-14) = '1' and reg_index(0) = '1')then	
--					reg_module_strt_addr_i(i-1)   <= axi2ip_wrdata;
--				--end if;
--			--end if;
--	            -- For frames greater than fstores the vectors are reserved
--                    -- and set to zero
--                     end if;
--                end if;
--            end process START_ADDR;
--end generate GEN_START_ADDR_REG;

-- Map only C_NUM_FSTORE vectors to output port


-- Number of Fstores Generate
GEN_NUM_FSTORES_1   : if C_NUM_FSTORES = 1 generate

    -- Start Address Register
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    reg_module_start_address2_i   <= (others => '0');
    reg_module_start_address3_i   <= (others => '0');
    reg_module_start_address4_i   <= (others => '0');
    reg_module_start_address5_i   <= (others => '0');
    reg_module_start_address6_i   <= (others => '0');
    reg_module_start_address7_i   <= (others => '0');
    reg_module_start_address8_i   <= (others => '0');
    reg_module_start_address9_i   <= (others => '0');
    reg_module_start_address10_i  <= (others => '0');
    reg_module_start_address11_i  <= (others => '0');
    reg_module_start_address12_i  <= (others => '0');
    reg_module_start_address13_i  <= (others => '0');
    reg_module_start_address14_i  <= (others => '0');
    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_1;

-- Number of Fstores Generate
GEN_NUM_FSTORES_2   : if C_NUM_FSTORES = 2 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    reg_module_start_address3_i   <= (others => '0');
    reg_module_start_address4_i   <= (others => '0');
    reg_module_start_address5_i   <= (others => '0');
    reg_module_start_address6_i   <= (others => '0');
    reg_module_start_address7_i   <= (others => '0');
    reg_module_start_address8_i   <= (others => '0');
    reg_module_start_address9_i   <= (others => '0');
    reg_module_start_address10_i  <= (others => '0');
    reg_module_start_address11_i  <= (others => '0');
    reg_module_start_address12_i  <= (others => '0');
    reg_module_start_address13_i  <= (others => '0');
    reg_module_start_address14_i  <= (others => '0');
    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_2;


-- Number of Fstores Generate
GEN_NUM_FSTORES_3   : if C_NUM_FSTORES = 3 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;


    reg_module_start_address4_i   <= (others => '0');
    reg_module_start_address5_i   <= (others => '0');
    reg_module_start_address6_i   <= (others => '0');
    reg_module_start_address7_i   <= (others => '0');
    reg_module_start_address8_i   <= (others => '0');
    reg_module_start_address9_i   <= (others => '0');
    reg_module_start_address10_i  <= (others => '0');
    reg_module_start_address11_i  <= (others => '0');
    reg_module_start_address12_i  <= (others => '0');
    reg_module_start_address13_i  <= (others => '0');
    reg_module_start_address14_i  <= (others => '0');
    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_3;


-- Number of Fstores Generate
GEN_NUM_FSTORES_4   : if C_NUM_FSTORES = 4 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    reg_module_start_address5_i   <= (others => '0');
    reg_module_start_address6_i   <= (others => '0');
    reg_module_start_address7_i   <= (others => '0');
    reg_module_start_address8_i   <= (others => '0');
    reg_module_start_address9_i   <= (others => '0');
    reg_module_start_address10_i  <= (others => '0');
    reg_module_start_address11_i  <= (others => '0');
    reg_module_start_address12_i  <= (others => '0');
    reg_module_start_address13_i  <= (others => '0');
    reg_module_start_address14_i  <= (others => '0');
    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_4;


-- Number of Fstores Generate
GEN_NUM_FSTORES_5   : if C_NUM_FSTORES = 5 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    reg_module_start_address6_i   <= (others => '0');
    reg_module_start_address7_i   <= (others => '0');
    reg_module_start_address8_i   <= (others => '0');
    reg_module_start_address9_i   <= (others => '0');
    reg_module_start_address10_i  <= (others => '0');
    reg_module_start_address11_i  <= (others => '0');
    reg_module_start_address12_i  <= (others => '0');
    reg_module_start_address13_i  <= (others => '0');
    reg_module_start_address14_i  <= (others => '0');
    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_5;

-- Number of Fstores Generate
GEN_NUM_FSTORES_6   : if C_NUM_FSTORES = 6 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    reg_module_start_address7_i   <= (others => '0');
    reg_module_start_address8_i   <= (others => '0');
    reg_module_start_address9_i   <= (others => '0');
    reg_module_start_address10_i  <= (others => '0');
    reg_module_start_address11_i  <= (others => '0');
    reg_module_start_address12_i  <= (others => '0');
    reg_module_start_address13_i  <= (others => '0');
    reg_module_start_address14_i  <= (others => '0');
    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_6;

-- Number of Fstores Generate
GEN_NUM_FSTORES_7   : if C_NUM_FSTORES = 7 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    reg_module_start_address8_i   <= (others => '0');
    reg_module_start_address9_i   <= (others => '0');
    reg_module_start_address10_i  <= (others => '0');
    reg_module_start_address11_i  <= (others => '0');
    reg_module_start_address12_i  <= (others => '0');
    reg_module_start_address13_i  <= (others => '0');
    reg_module_start_address14_i  <= (others => '0');
    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_7;

-- Number of Fstores Generate
GEN_NUM_FSTORES_8   : if C_NUM_FSTORES = 8 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    reg_module_start_address9_i   <= (others => '0');
    reg_module_start_address10_i  <= (others => '0');
    reg_module_start_address11_i  <= (others => '0');
    reg_module_start_address12_i  <= (others => '0');
    reg_module_start_address13_i  <= (others => '0');
    reg_module_start_address14_i  <= (others => '0');
    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_8;



-- Number of Fstores Generate
GEN_NUM_FSTORES_9   : if C_NUM_FSTORES = 9 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    reg_module_start_address10_i  <= (others => '0');
    reg_module_start_address11_i  <= (others => '0');
    reg_module_start_address12_i  <= (others => '0');
    reg_module_start_address13_i  <= (others => '0');
    reg_module_start_address14_i  <= (others => '0');
    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_9;

-- Number of Fstores Generate
GEN_NUM_FSTORES_10   : if C_NUM_FSTORES = 10 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    reg_module_start_address11_i  <= (others => '0');
    reg_module_start_address12_i  <= (others => '0');
    reg_module_start_address13_i  <= (others => '0');
    reg_module_start_address14_i  <= (others => '0');
    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_10;

-- Number of Fstores Generate
GEN_NUM_FSTORES_11   : if C_NUM_FSTORES = 11 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    reg_module_start_address12_i  <= (others => '0');
    reg_module_start_address13_i  <= (others => '0');
    reg_module_start_address14_i  <= (others => '0');
    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_11;

-- Number of Fstores Generate
GEN_NUM_FSTORES_12   : if C_NUM_FSTORES = 12 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    reg_module_start_address13_i  <= (others => '0');
    reg_module_start_address14_i  <= (others => '0');
    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_12;

-- Number of Fstores Generate
GEN_NUM_FSTORES_13   : if C_NUM_FSTORES = 13 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    reg_module_start_address14_i  <= (others => '0');
    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_13;

-- Number of Fstores Generate
GEN_NUM_FSTORES_14   : if C_NUM_FSTORES = 14 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    reg_module_start_address15_i  <= (others => '0');
    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_14;

-- Number of Fstores Generate
GEN_NUM_FSTORES_15   : if C_NUM_FSTORES = 15 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    reg_module_start_address16_i  <= (others => '0');
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_15;


-- Number of Fstores Generate
GEN_NUM_FSTORES_16   : if C_NUM_FSTORES = 16 generate

    -- Start Address Register 1
    START_ADDR1 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0')then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;
    reg_module_start_address17_i  <= (others => '0');
    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_16;

-- Number of Fstores Generate
GEN_NUM_FSTORES_17   : if C_NUM_FSTORES = 17 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    START_ADDR2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;

    reg_module_start_address18_i  <= (others => '0');
    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_17;




-- Number of Fstores Generate
GEN_NUM_FSTORES_18   : if C_NUM_FSTORES = 18 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    START_ADDR3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;


    reg_module_start_address19_i  <= (others => '0');
    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_18;





-- Number of Fstores Generate
GEN_NUM_FSTORES_19   : if C_NUM_FSTORES = 19 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    START_ADDR4 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    reg_module_start_address20_i  <= (others => '0');
    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_19;





-- Number of Fstores Generate
GEN_NUM_FSTORES_20   : if C_NUM_FSTORES = 20 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    --START_ADDR4 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address4_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address4_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR4;

    -- Start Address Register 5
    START_ADDR5 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    START_ADDR20 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                    reg_module_start_address20_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address20_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR20;


    reg_module_start_address21_i  <= (others => '0');
    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_20;




-- Number of Fstores Generate
GEN_NUM_FSTORES_21   : if C_NUM_FSTORES = 21 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    --START_ADDR4 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address4_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address4_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR4;

    -- Start Address Register 5
    --START_ADDR5 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address5_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address5_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR5;

    -- Start Address Register 6
    START_ADDR6 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    START_ADDR20 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                    reg_module_start_address20_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address20_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR20;


    START_ADDR21 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                    reg_module_start_address21_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address21_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR21;



    reg_module_start_address22_i  <= (others => '0');
    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_21;




-- Number of Fstores Generate
GEN_NUM_FSTORES_22   : if C_NUM_FSTORES = 22 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    --START_ADDR4 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address4_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address4_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR4;

    -- Start Address Register 5
    --START_ADDR5 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address5_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address5_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR5;

    -- Start Address Register 6
    --START_ADDR6 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address6_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address6_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR6;

    -- Start Address Register 7
    START_ADDR7 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    START_ADDR20 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                    reg_module_start_address20_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address20_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR20;


    START_ADDR21 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                    reg_module_start_address21_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address21_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR21;


    START_ADDR22 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                    reg_module_start_address22_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address22_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR22;



    reg_module_start_address23_i  <= (others => '0');
    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_22;




-- Number of Fstores Generate
GEN_NUM_FSTORES_23   : if C_NUM_FSTORES = 23 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    --START_ADDR4 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address4_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address4_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR4;

    -- Start Address Register 5
    --START_ADDR5 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address5_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address5_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR5;

    -- Start Address Register 6
    --START_ADDR6 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address6_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address6_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR6;

    -- Start Address Register 7
    --START_ADDR7 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address7_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address7_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR7;

    -- Start Address Register 8
    START_ADDR8 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    START_ADDR20 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                    reg_module_start_address20_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address20_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR20;


    START_ADDR21 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                    reg_module_start_address21_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address21_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR21;


    START_ADDR22 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                    reg_module_start_address22_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address22_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR22;



    START_ADDR23 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                    reg_module_start_address23_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address23_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR23;



    reg_module_start_address24_i  <= (others => '0');
    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_23;




-- Number of Fstores Generate
GEN_NUM_FSTORES_24   : if C_NUM_FSTORES = 24 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    --START_ADDR4 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address4_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address4_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR4;

    -- Start Address Register 5
    --START_ADDR5 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address5_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address5_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR5;

    -- Start Address Register 6
    --START_ADDR6 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address6_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address6_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR6;

    -- Start Address Register 7
    --START_ADDR7 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address7_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address7_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR7;

    -- Start Address Register 8
   -- START_ADDR8 : process(prmry_aclk)
   --     begin
   --         if(prmry_aclk'EVENT and prmry_aclk = '1')then
   --             if(prmry_resetn = '0')then
   --                 reg_module_start_address8_i   <= (others => '0');
   --             elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
   --                 reg_module_start_address8_i   <= axi2ip_wrdata;
   --             end if;
   --         end if;
   --     end process START_ADDR8;

    -- Start Address Register 9
    START_ADDR9 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    START_ADDR20 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                    reg_module_start_address20_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address20_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR20;


    START_ADDR21 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                    reg_module_start_address21_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address21_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR21;


    START_ADDR22 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                    reg_module_start_address22_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address22_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR22;

    START_ADDR23 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                    reg_module_start_address23_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address23_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR23;





    START_ADDR24 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                    reg_module_start_address24_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address24_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR24;



    reg_module_start_address25_i  <= (others => '0');
    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_24;



-- Number of Fstores Generate
GEN_NUM_FSTORES_25   : if C_NUM_FSTORES = 25 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    --START_ADDR4 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address4_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address4_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR4;

    -- Start Address Register 5
    --START_ADDR5 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address5_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address5_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR5;

    -- Start Address Register 6
    --START_ADDR6 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address6_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address6_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR6;

    -- Start Address Register 7
    --START_ADDR7 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address7_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address7_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR7;

    -- Start Address Register 8
   -- START_ADDR8 : process(prmry_aclk)
   --     begin
   --         if(prmry_aclk'EVENT and prmry_aclk = '1')then
   --             if(prmry_resetn = '0')then
   --                 reg_module_start_address8_i   <= (others => '0');
   --             elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
   --                 reg_module_start_address8_i   <= axi2ip_wrdata;
   --             end if;
   --         end if;
   --     end process START_ADDR8;

    -- Start Address Register 9
    --START_ADDR9 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address9_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address9_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR9;

    -- Start Address Register 10
    START_ADDR10 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    START_ADDR20 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                    reg_module_start_address20_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address20_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR20;


    START_ADDR21 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                    reg_module_start_address21_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address21_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR21;


    START_ADDR22 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                    reg_module_start_address22_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address22_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR22;

    START_ADDR23 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                    reg_module_start_address23_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address23_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR23;





    START_ADDR24 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                    reg_module_start_address24_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address24_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR24;



    START_ADDR25 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                    reg_module_start_address25_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address25_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR25;



    reg_module_start_address26_i  <= (others => '0');
    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_25;




-- Number of Fstores Generate
GEN_NUM_FSTORES_26   : if C_NUM_FSTORES = 26 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    --START_ADDR4 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address4_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address4_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR4;

    -- Start Address Register 5
    --START_ADDR5 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address5_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address5_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR5;

    -- Start Address Register 6
    --START_ADDR6 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address6_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address6_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR6;

    -- Start Address Register 7
    --START_ADDR7 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address7_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address7_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR7;

    -- Start Address Register 8
   -- START_ADDR8 : process(prmry_aclk)
   --     begin
   --         if(prmry_aclk'EVENT and prmry_aclk = '1')then
   --             if(prmry_resetn = '0')then
   --                 reg_module_start_address8_i   <= (others => '0');
   --             elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
   --                 reg_module_start_address8_i   <= axi2ip_wrdata;
   --             end if;
   --         end if;
   --     end process START_ADDR8;

    -- Start Address Register 9
    --START_ADDR9 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address9_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address9_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR9;

    -- Start Address Register 10
    --START_ADDR10 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address10_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address10_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR10;

    -- Start Address Register 11
    START_ADDR11 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    START_ADDR20 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                    reg_module_start_address20_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address20_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR20;

    START_ADDR21 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                    reg_module_start_address21_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address21_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR21;



    START_ADDR22 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                    reg_module_start_address22_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address22_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR22;


    START_ADDR23 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                    reg_module_start_address23_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address23_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR23;




    START_ADDR24 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                    reg_module_start_address24_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address24_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR24;



    START_ADDR25 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                    reg_module_start_address25_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address25_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR25;


    START_ADDR26 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                    reg_module_start_address26_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address26_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR26;



    reg_module_start_address27_i  <= (others => '0');
    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_26;






-- Number of Fstores Generate
GEN_NUM_FSTORES_27   : if C_NUM_FSTORES = 27 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    --START_ADDR4 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address4_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address4_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR4;

    -- Start Address Register 5
    --START_ADDR5 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address5_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address5_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR5;

    -- Start Address Register 6
    --START_ADDR6 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address6_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address6_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR6;

    -- Start Address Register 7
    --START_ADDR7 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address7_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address7_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR7;

    -- Start Address Register 8
   -- START_ADDR8 : process(prmry_aclk)
   --     begin
   --         if(prmry_aclk'EVENT and prmry_aclk = '1')then
   --             if(prmry_resetn = '0')then
   --                 reg_module_start_address8_i   <= (others => '0');
   --             elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
   --                 reg_module_start_address8_i   <= axi2ip_wrdata;
   --             end if;
   --         end if;
   --     end process START_ADDR8;

    -- Start Address Register 9
    --START_ADDR9 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address9_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address9_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR9;

    -- Start Address Register 10
    --START_ADDR10 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address10_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address10_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR10;

    -- Start Address Register 11
    --START_ADDR11 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address11_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address11_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR11;

    -- Start Address Register 12
    START_ADDR12 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    START_ADDR20 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                    reg_module_start_address20_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address20_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR20;

    START_ADDR21 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                    reg_module_start_address21_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address21_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR21;



    START_ADDR22 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                    reg_module_start_address22_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address22_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR22;


    START_ADDR23 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                    reg_module_start_address23_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address23_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR23;




    START_ADDR24 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                    reg_module_start_address24_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address24_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR24;



    START_ADDR25 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                    reg_module_start_address25_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address25_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR25;


    START_ADDR26 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                    reg_module_start_address26_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address26_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR26;


    START_ADDR27 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                    reg_module_start_address27_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address27_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR27;



    reg_module_start_address28_i  <= (others => '0');
    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_27;




-- Number of Fstores Generate
GEN_NUM_FSTORES_28   : if C_NUM_FSTORES = 28 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    --START_ADDR4 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address4_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address4_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR4;

    -- Start Address Register 5
    --START_ADDR5 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address5_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address5_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR5;

    -- Start Address Register 6
    --START_ADDR6 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address6_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address6_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR6;

    -- Start Address Register 7
    --START_ADDR7 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address7_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address7_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR7;

    -- Start Address Register 8
   -- START_ADDR8 : process(prmry_aclk)
   --     begin
   --         if(prmry_aclk'EVENT and prmry_aclk = '1')then
   --             if(prmry_resetn = '0')then
   --                 reg_module_start_address8_i   <= (others => '0');
   --             elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
   --                 reg_module_start_address8_i   <= axi2ip_wrdata;
   --             end if;
   --         end if;
   --     end process START_ADDR8;

    -- Start Address Register 9
    --START_ADDR9 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address9_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address9_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR9;

    -- Start Address Register 10
    --START_ADDR10 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address10_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address10_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR10;

    -- Start Address Register 11
    --START_ADDR11 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address11_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address11_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR11;

    -- Start Address Register 12
    --START_ADDR12 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address12_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address12_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR12;

    -- Start Address Register 13
    START_ADDR13 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    START_ADDR20 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                    reg_module_start_address20_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address20_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR20;

    START_ADDR21 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                    reg_module_start_address21_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address21_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR21;



    START_ADDR22 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                    reg_module_start_address22_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address22_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR22;


    START_ADDR23 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                    reg_module_start_address23_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address23_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR23;




    START_ADDR24 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                    reg_module_start_address24_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address24_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR24;



    START_ADDR25 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                    reg_module_start_address25_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address25_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR25;


    START_ADDR26 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                    reg_module_start_address26_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address26_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR26;


    START_ADDR27 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                    reg_module_start_address27_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address27_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR27;


    START_ADDR28 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                    reg_module_start_address28_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address28_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR28;



    reg_module_start_address29_i  <= (others => '0');
    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_28;




-- Number of Fstores Generate
GEN_NUM_FSTORES_29   : if C_NUM_FSTORES = 29 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    --START_ADDR4 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address4_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address4_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR4;

    -- Start Address Register 5
    --START_ADDR5 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address5_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address5_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR5;

    -- Start Address Register 6
    --START_ADDR6 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address6_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address6_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR6;

    -- Start Address Register 7
    --START_ADDR7 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address7_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address7_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR7;

    -- Start Address Register 8
   -- START_ADDR8 : process(prmry_aclk)
   --     begin
   --         if(prmry_aclk'EVENT and prmry_aclk = '1')then
   --             if(prmry_resetn = '0')then
   --                 reg_module_start_address8_i   <= (others => '0');
   --             elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
   --                 reg_module_start_address8_i   <= axi2ip_wrdata;
   --             end if;
   --         end if;
   --     end process START_ADDR8;

    -- Start Address Register 9
    --START_ADDR9 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address9_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address9_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR9;

    -- Start Address Register 10
    --START_ADDR10 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address10_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address10_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR10;

    -- Start Address Register 11
    --START_ADDR11 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address11_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address11_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR11;

    -- Start Address Register 12
    --START_ADDR12 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address12_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address12_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR12;

    -- Start Address Register 13
    --START_ADDR13 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address13_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address13_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR13;

    -- Start Address Register 14
    START_ADDR14 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    START_ADDR20 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                    reg_module_start_address20_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address20_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR20;

    START_ADDR21 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                    reg_module_start_address21_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address21_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR21;



    START_ADDR22 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                    reg_module_start_address22_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address22_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR22;


    START_ADDR23 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                    reg_module_start_address23_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address23_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR23;




    START_ADDR24 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                    reg_module_start_address24_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address24_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR24;



    START_ADDR25 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                    reg_module_start_address25_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address25_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR25;


    START_ADDR26 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                    reg_module_start_address26_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address26_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR26;


    START_ADDR27 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                    reg_module_start_address27_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address27_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR27;


    START_ADDR28 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                    reg_module_start_address28_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address28_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR28;


    START_ADDR29 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                    reg_module_start_address29_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address29_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR29;



    reg_module_start_address30_i  <= (others => '0');
    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_29;



-- Number of Fstores Generate
GEN_NUM_FSTORES_30   : if C_NUM_FSTORES = 30 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    --START_ADDR4 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address4_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address4_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR4;

    -- Start Address Register 5
    --START_ADDR5 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address5_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address5_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR5;

    -- Start Address Register 6
    --START_ADDR6 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address6_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address6_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR6;

    -- Start Address Register 7
    --START_ADDR7 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address7_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address7_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR7;

    -- Start Address Register 8
   -- START_ADDR8 : process(prmry_aclk)
   --     begin
   --         if(prmry_aclk'EVENT and prmry_aclk = '1')then
   --             if(prmry_resetn = '0')then
   --                 reg_module_start_address8_i   <= (others => '0');
   --             elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
   --                 reg_module_start_address8_i   <= axi2ip_wrdata;
   --             end if;
   --         end if;
   --     end process START_ADDR8;

    -- Start Address Register 9
    --START_ADDR9 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address9_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address9_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR9;

    -- Start Address Register 10
    --START_ADDR10 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address10_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address10_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR10;

    -- Start Address Register 11
    --START_ADDR11 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address11_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address11_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR11;

    -- Start Address Register 12
    --START_ADDR12 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address12_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address12_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR12;

    -- Start Address Register 13
    --START_ADDR13 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address13_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address13_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR13;

    -- Start Address Register 14
    --START_ADDR14 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address14_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address14_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR14;

    -- Start Address Register 15
    START_ADDR15 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    START_ADDR20 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                    reg_module_start_address20_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address20_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR20;

    START_ADDR21 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                    reg_module_start_address21_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address21_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR21;



    START_ADDR22 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                    reg_module_start_address22_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address22_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR22;


    START_ADDR23 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                    reg_module_start_address23_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address23_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR23;




    START_ADDR24 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                    reg_module_start_address24_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address24_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR24;



    START_ADDR25 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                    reg_module_start_address25_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address25_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR25;


    START_ADDR26 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                    reg_module_start_address26_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address26_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR26;


    START_ADDR27 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                    reg_module_start_address27_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address27_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR27;


    START_ADDR28 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                    reg_module_start_address28_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address28_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR28;


    START_ADDR29 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                    reg_module_start_address29_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address29_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR29;


    START_ADDR30 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                    reg_module_start_address30_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address30_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR30;




    reg_module_start_address31_i  <= (others => '0');
    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_30;




-- Number of Fstores Generate
GEN_NUM_FSTORES_31   : if C_NUM_FSTORES = 31 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    --START_ADDR4 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address4_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address4_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR4;

    -- Start Address Register 5
    --START_ADDR5 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address5_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address5_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR5;

    -- Start Address Register 6
    --START_ADDR6 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address6_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address6_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR6;

    -- Start Address Register 7
    --START_ADDR7 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address7_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address7_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR7;

    -- Start Address Register 8
   -- START_ADDR8 : process(prmry_aclk)
   --     begin
   --         if(prmry_aclk'EVENT and prmry_aclk = '1')then
   --             if(prmry_resetn = '0')then
   --                 reg_module_start_address8_i   <= (others => '0');
   --             elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
   --                 reg_module_start_address8_i   <= axi2ip_wrdata;
   --             end if;
   --         end if;
   --     end process START_ADDR8;

    -- Start Address Register 9
    --START_ADDR9 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address9_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address9_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR9;

    -- Start Address Register 10
    --START_ADDR10 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address10_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address10_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR10;

    -- Start Address Register 11
    --START_ADDR11 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address11_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address11_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR11;

    -- Start Address Register 12
    --START_ADDR12 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address12_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address12_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR12;

    -- Start Address Register 13
    --START_ADDR13 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address13_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address13_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR13;

    -- Start Address Register 14
    --START_ADDR14 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address14_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address14_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR14;

    -- Start Address Register 15
    --START_ADDR15 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address15_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address15_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR15;

    -- Start Address Register 16
    START_ADDR16 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    START_ADDR20 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                    reg_module_start_address20_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address20_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR20;

    START_ADDR21 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                    reg_module_start_address21_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address21_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR21;



    START_ADDR22 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                    reg_module_start_address22_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address22_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR22;


    START_ADDR23 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                    reg_module_start_address23_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address23_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR23;




    START_ADDR24 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                    reg_module_start_address24_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address24_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR24;



    START_ADDR25 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                    reg_module_start_address25_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address25_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR25;


    START_ADDR26 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                    reg_module_start_address26_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address26_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR26;


    START_ADDR27 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                    reg_module_start_address27_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address27_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR27;


    START_ADDR28 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                    reg_module_start_address28_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address28_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR28;


    START_ADDR29 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                    reg_module_start_address29_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address29_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR29;


    START_ADDR30 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                    reg_module_start_address30_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address30_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR30;


    START_ADDR31 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                    reg_module_start_address31_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address31_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR31;





    reg_module_start_address32_i  <= (others => '0');

end generate GEN_NUM_FSTORES_31;




-- Number of Fstores Generate
GEN_NUM_FSTORES_32   : if C_NUM_FSTORES = 32 generate

    -- Start Address Register 1
    --START_ADDR1 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address1_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address1_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR1;

    -- Start Address Register 2
    --START_ADDR2 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address2_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address2_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR2;

    -- Start Address Register 3
    --START_ADDR3 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address3_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address3_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR3;

    -- Start Address Register 4
    --START_ADDR4 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address4_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address4_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR4;

    -- Start Address Register 5
    --START_ADDR5 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address5_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address5_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR5;

    -- Start Address Register 6
    --START_ADDR6 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address6_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address6_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR6;

    -- Start Address Register 7
    --START_ADDR7 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address7_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address7_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR7;

    -- Start Address Register 8
   -- START_ADDR8 : process(prmry_aclk)
   --     begin
   --         if(prmry_aclk'EVENT and prmry_aclk = '1')then
   --             if(prmry_resetn = '0')then
   --                 reg_module_start_address8_i   <= (others => '0');
   --             elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
   --                 reg_module_start_address8_i   <= axi2ip_wrdata;
   --             end if;
   --         end if;
   --     end process START_ADDR8;

    -- Start Address Register 9
    --START_ADDR9 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address9_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address9_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR9;

    -- Start Address Register 10
    --START_ADDR10 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address10_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address10_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR10;

    -- Start Address Register 11
    --START_ADDR11 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address11_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address11_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR11;

    -- Start Address Register 12
    --START_ADDR12 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address12_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address12_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR12;

    -- Start Address Register 13
    --START_ADDR13 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address13_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address13_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR13;

    -- Start Address Register 14
    --START_ADDR14 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address14_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address14_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR14;

    -- Start Address Register 15
    --START_ADDR15 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address15_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address15_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR15;

    -- Start Address Register 16
    --START_ADDR16 : process(prmry_aclk)
    --    begin
    --        if(prmry_aclk'EVENT and prmry_aclk = '1')then
    --            if(prmry_resetn = '0')then
    --                reg_module_start_address16_i   <= (others => '0');
    --            elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0' and reg_index(0) = '0'  )then
    --                reg_module_start_address16_i   <= axi2ip_wrdata;
    --            end if;
    --        end if;
    --    end process START_ADDR16;

    -- Start Address Register 17
    START_ADDR17 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address1_i   <= (others => '0');
                    reg_module_start_address17_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address1_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR1_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address17_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR17;
    -- Start Address Register 17
    START_ADDR18 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address2_i   <= (others => '0');
                    reg_module_start_address18_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address2_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR2_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address18_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR18;

    START_ADDR19 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address3_i   <= (others => '0');
                    reg_module_start_address19_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address3_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR3_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address19_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR19;


    START_ADDR20 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address4_i   <= (others => '0');
                    reg_module_start_address20_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address4_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR4_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address20_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR20;

    START_ADDR21 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address5_i   <= (others => '0');
                    reg_module_start_address21_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address5_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR5_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address21_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR21;



    START_ADDR22 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address6_i   <= (others => '0');
                    reg_module_start_address22_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address6_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR6_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address22_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR22;


    START_ADDR23 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address7_i   <= (others => '0');
                    reg_module_start_address23_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address7_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR7_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address23_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR23;




    START_ADDR24 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address8_i   <= (others => '0');
                    reg_module_start_address24_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address8_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR8_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address24_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR24;



    START_ADDR25 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address9_i   <= (others => '0');
                    reg_module_start_address25_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address9_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR9_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address25_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR25;


    START_ADDR26 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address10_i   <= (others => '0');
                    reg_module_start_address26_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address10_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR10_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address26_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR26;


    START_ADDR27 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address11_i   <= (others => '0');
                    reg_module_start_address27_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address11_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR11_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address27_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR27;


    START_ADDR28 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address12_i   <= (others => '0');
                    reg_module_start_address28_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address12_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR12_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address28_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR28;


    START_ADDR29 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address13_i   <= (others => '0');
                    reg_module_start_address29_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address13_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR13_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address29_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR29;


    START_ADDR30 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address14_i   <= (others => '0');
                    reg_module_start_address30_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address14_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR14_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address30_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR30;


    START_ADDR31 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address15_i   <= (others => '0');
                    reg_module_start_address31_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address15_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR15_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address31_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR31;



    START_ADDR32 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    reg_module_start_address16_i   <= (others => '0');
                    reg_module_start_address32_i   <= (others => '0');
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '0')then
                    reg_module_start_address16_i   <= axi2ip_wrdata;
                elsif(  axi2ip_wrce(STARTADDR16_INDEX) = '1' and  reg_config_locked_i = '0'  and reg_index(0) = '1')then
                    reg_module_start_address32_i   <= axi2ip_wrdata;
                end if;
            end if;
        end process START_ADDR32;






end generate GEN_NUM_FSTORES_32;




-- Number of Fstores Generate
GEN_1   : if C_NUM_FSTORES = 1 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 

end generate GEN_1;


-- Number of Fstores Generate
GEN_2   : if C_NUM_FSTORES = 2 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 

end generate GEN_2;


-- Number of Fstores Generate
GEN_3   : if C_NUM_FSTORES = 3 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 

end generate GEN_3;


-- Number of Fstores Generate
GEN_4   : if C_NUM_FSTORES = 4 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 

end generate GEN_4;

-- Number of Fstores Generate
GEN_5   : if C_NUM_FSTORES = 5 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 

end generate GEN_5;

-- Number of Fstores Generate
GEN_6   : if C_NUM_FSTORES = 6 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 

end generate GEN_6;


-- Number of Fstores Generate
GEN_7   : if C_NUM_FSTORES = 7 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 

end generate GEN_7;


-- Number of Fstores Generate
GEN_8   : if C_NUM_FSTORES = 8 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 

end generate GEN_8;



-- Number of Fstores Generate
GEN_9   : if C_NUM_FSTORES = 9 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 

end generate GEN_9;



-- Number of Fstores Generate
GEN_10   : if C_NUM_FSTORES = 10 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 

end generate GEN_10;

-- Number of Fstores Generate
GEN_11   : if C_NUM_FSTORES = 11 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 

end generate GEN_11;


-- Number of Fstores Generate
GEN_12   : if C_NUM_FSTORES = 12 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 

end generate GEN_12;


-- Number of Fstores Generate
GEN_13   : if C_NUM_FSTORES = 13 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 

end generate GEN_13;


-- Number of Fstores Generate
GEN_14   : if C_NUM_FSTORES = 14 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 

end generate GEN_14;

-- Number of Fstores Generate
GEN_15   : if C_NUM_FSTORES = 15 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 

end generate GEN_15;

-- Number of Fstores Generate
GEN_16   : if C_NUM_FSTORES = 16 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 


end generate GEN_16;


-- Number of Fstores Generate
GEN_17   : if C_NUM_FSTORES = 17 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 

end generate GEN_17;


-- Number of Fstores Generate
GEN_18   : if C_NUM_FSTORES = 18 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 

end generate GEN_18;



-- Number of Fstores Generate
GEN_19   : if C_NUM_FSTORES = 19 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 

end generate GEN_19;

-- Number of Fstores Generate
GEN_20   : if C_NUM_FSTORES = 20 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 

end generate GEN_20;


-- Number of Fstores Generate
GEN_21   : if C_NUM_FSTORES = 21 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 
 reg_module_strt_addr(20) 	<=   reg_module_start_address21_i ; 

end generate GEN_21;


-- Number of Fstores Generate
GEN_22   : if C_NUM_FSTORES = 22 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 
 reg_module_strt_addr(20) 	<=   reg_module_start_address21_i ; 
 reg_module_strt_addr(21) 	<=   reg_module_start_address22_i ; 


end generate GEN_22;


-- Number of Fstores Generate
GEN_23   : if C_NUM_FSTORES = 23 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 
 reg_module_strt_addr(20) 	<=   reg_module_start_address21_i ; 
 reg_module_strt_addr(21) 	<=   reg_module_start_address22_i ; 
 reg_module_strt_addr(22) 	<=   reg_module_start_address23_i ; 

end generate GEN_23;


-- Number of Fstores Generate
GEN_24   : if C_NUM_FSTORES = 24 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 
 reg_module_strt_addr(20) 	<=   reg_module_start_address21_i ; 
 reg_module_strt_addr(21) 	<=   reg_module_start_address22_i ; 
 reg_module_strt_addr(22) 	<=   reg_module_start_address23_i ; 
 reg_module_strt_addr(23) 	<=   reg_module_start_address24_i ; 

end generate GEN_24;

-- Number of Fstores Generate
GEN_25   : if C_NUM_FSTORES = 25 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 
 reg_module_strt_addr(20) 	<=   reg_module_start_address21_i ; 
 reg_module_strt_addr(21) 	<=   reg_module_start_address22_i ; 
 reg_module_strt_addr(22) 	<=   reg_module_start_address23_i ; 
 reg_module_strt_addr(23) 	<=   reg_module_start_address24_i ; 
 reg_module_strt_addr(24) 	<=   reg_module_start_address25_i ; 

end generate GEN_25;

-- Number of Fstores Generate
GEN_26   : if C_NUM_FSTORES = 26 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 
 reg_module_strt_addr(20) 	<=   reg_module_start_address21_i ; 
 reg_module_strt_addr(21) 	<=   reg_module_start_address22_i ; 
 reg_module_strt_addr(22) 	<=   reg_module_start_address23_i ; 
 reg_module_strt_addr(23) 	<=   reg_module_start_address24_i ; 
 reg_module_strt_addr(24) 	<=   reg_module_start_address25_i ; 
 reg_module_strt_addr(25) 	<=   reg_module_start_address26_i ; 

end generate GEN_26;


-- Number of Fstores Generate
GEN_27   : if C_NUM_FSTORES = 27 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 
 reg_module_strt_addr(20) 	<=   reg_module_start_address21_i ; 
 reg_module_strt_addr(21) 	<=   reg_module_start_address22_i ; 
 reg_module_strt_addr(22) 	<=   reg_module_start_address23_i ; 
 reg_module_strt_addr(23) 	<=   reg_module_start_address24_i ; 
 reg_module_strt_addr(24) 	<=   reg_module_start_address25_i ; 
 reg_module_strt_addr(25) 	<=   reg_module_start_address26_i ; 
 reg_module_strt_addr(26) 	<=   reg_module_start_address27_i ; 

end generate GEN_27;


-- Number of Fstores Generate
GEN_28   : if C_NUM_FSTORES = 28 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 
 reg_module_strt_addr(20) 	<=   reg_module_start_address21_i ; 
 reg_module_strt_addr(21) 	<=   reg_module_start_address22_i ; 
 reg_module_strt_addr(22) 	<=   reg_module_start_address23_i ; 
 reg_module_strt_addr(23) 	<=   reg_module_start_address24_i ; 
 reg_module_strt_addr(24) 	<=   reg_module_start_address25_i ; 
 reg_module_strt_addr(25) 	<=   reg_module_start_address26_i ; 
 reg_module_strt_addr(26) 	<=   reg_module_start_address27_i ; 
 reg_module_strt_addr(27) 	<=   reg_module_start_address28_i ; 

end generate GEN_28;



-- Number of Fstores Generate
GEN_29   : if C_NUM_FSTORES = 29 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 
 reg_module_strt_addr(20) 	<=   reg_module_start_address21_i ; 
 reg_module_strt_addr(21) 	<=   reg_module_start_address22_i ; 
 reg_module_strt_addr(22) 	<=   reg_module_start_address23_i ; 
 reg_module_strt_addr(23) 	<=   reg_module_start_address24_i ; 
 reg_module_strt_addr(24) 	<=   reg_module_start_address25_i ; 
 reg_module_strt_addr(25) 	<=   reg_module_start_address26_i ; 
 reg_module_strt_addr(26) 	<=   reg_module_start_address27_i ; 
 reg_module_strt_addr(27) 	<=   reg_module_start_address28_i ; 
 reg_module_strt_addr(28) 	<=   reg_module_start_address29_i ; 

end generate GEN_29;



-- Number of Fstores Generate
GEN_30   : if C_NUM_FSTORES = 30 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 
 reg_module_strt_addr(20) 	<=   reg_module_start_address21_i ; 
 reg_module_strt_addr(21) 	<=   reg_module_start_address22_i ; 
 reg_module_strt_addr(22) 	<=   reg_module_start_address23_i ; 
 reg_module_strt_addr(23) 	<=   reg_module_start_address24_i ; 
 reg_module_strt_addr(24) 	<=   reg_module_start_address25_i ; 
 reg_module_strt_addr(25) 	<=   reg_module_start_address26_i ; 
 reg_module_strt_addr(26) 	<=   reg_module_start_address27_i ; 
 reg_module_strt_addr(27) 	<=   reg_module_start_address28_i ; 
 reg_module_strt_addr(28) 	<=   reg_module_start_address29_i ; 
 reg_module_strt_addr(29) 	<=   reg_module_start_address30_i ; 

end generate GEN_30;


-- Number of Fstores Generate
GEN_31   : if C_NUM_FSTORES = 31 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 
 reg_module_strt_addr(20) 	<=   reg_module_start_address21_i ; 
 reg_module_strt_addr(21) 	<=   reg_module_start_address22_i ; 
 reg_module_strt_addr(22) 	<=   reg_module_start_address23_i ; 
 reg_module_strt_addr(23) 	<=   reg_module_start_address24_i ; 
 reg_module_strt_addr(24) 	<=   reg_module_start_address25_i ; 
 reg_module_strt_addr(25) 	<=   reg_module_start_address26_i ; 
 reg_module_strt_addr(26) 	<=   reg_module_start_address27_i ; 
 reg_module_strt_addr(27) 	<=   reg_module_start_address28_i ; 
 reg_module_strt_addr(28) 	<=   reg_module_start_address29_i ; 
 reg_module_strt_addr(29) 	<=   reg_module_start_address30_i ; 
 reg_module_strt_addr(30) 	<=   reg_module_start_address31_i ; 

end generate GEN_31;


-- Number of Fstores Generate
GEN_32   : if C_NUM_FSTORES = 32 generate

 reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
 reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 
 reg_module_strt_addr(20) 	<=   reg_module_start_address21_i ; 
 reg_module_strt_addr(21) 	<=   reg_module_start_address22_i ; 
 reg_module_strt_addr(22) 	<=   reg_module_start_address23_i ; 
 reg_module_strt_addr(23) 	<=   reg_module_start_address24_i ; 
 reg_module_strt_addr(24) 	<=   reg_module_start_address25_i ; 
 reg_module_strt_addr(25) 	<=   reg_module_start_address26_i ; 
 reg_module_strt_addr(26) 	<=   reg_module_start_address27_i ; 
 reg_module_strt_addr(27) 	<=   reg_module_start_address28_i ; 
 reg_module_strt_addr(28) 	<=   reg_module_start_address29_i ; 
 reg_module_strt_addr(29) 	<=   reg_module_start_address30_i ; 
 reg_module_strt_addr(30) 	<=   reg_module_start_address31_i ; 
 reg_module_strt_addr(31) 	<=   reg_module_start_address32_i ; 

end generate GEN_32;








--GEN_START_ADDR_MAP : for i in 0 to C_NUM_FSTORES-1 generate
--begin
--
--    reg_module_strt_addr(i) <= reg_module_strt_addr_i(i);
--
--end generate GEN_START_ADDR_MAP;




 --reg_module_strt_addr(0) 	<=   reg_module_start_address1_i  ; 
 --reg_module_strt_addr(1) 	<=   reg_module_start_address2_i  ; 
 --reg_module_strt_addr(2) 	<=   reg_module_start_address3_i  ; 
 --reg_module_strt_addr(3) 	<=   reg_module_start_address4_i  ; 
 --reg_module_strt_addr(4) 	<=   reg_module_start_address5_i  ; 
 --reg_module_strt_addr(5) 	<=   reg_module_start_address6_i  ; 
 --reg_module_strt_addr(6) 	<=   reg_module_start_address7_i  ; 
 --reg_module_strt_addr(7) 	<=   reg_module_start_address8_i  ; 
 --reg_module_strt_addr(8) 	<=   reg_module_start_address9_i  ; 
 --reg_module_strt_addr(9) 	<=   reg_module_start_address10_i ; 
 --reg_module_strt_addr(10) 	<=   reg_module_start_address11_i ; 
 --reg_module_strt_addr(11) 	<=   reg_module_start_address12_i ; 
 --reg_module_strt_addr(12) 	<=   reg_module_start_address13_i ; 
 --reg_module_strt_addr(13) 	<=   reg_module_start_address14_i ; 
 --reg_module_strt_addr(14) 	<=   reg_module_start_address15_i ; 
 --reg_module_strt_addr(15) 	<=   reg_module_start_address16_i ; 
 --reg_module_strt_addr(16) 	<=   reg_module_start_address17_i ; 
 --reg_module_strt_addr(17) 	<=   reg_module_start_address18_i ; 
 --reg_module_strt_addr(18) 	<=   reg_module_start_address19_i ; 
 --reg_module_strt_addr(19) 	<=   reg_module_start_address20_i ; 
 --reg_module_strt_addr(20) 	<=   reg_module_start_address21_i ; 
 --reg_module_strt_addr(21) 	<=   reg_module_start_address22_i ; 
 --reg_module_strt_addr(22) 	<=   reg_module_start_address23_i ; 
 --reg_module_strt_addr(23) 	<=   reg_module_start_address24_i ; 
 --reg_module_strt_addr(24) 	<=   reg_module_start_address25_i ; 
 --reg_module_strt_addr(25) 	<=   reg_module_start_address26_i ; 
 --reg_module_strt_addr(26) 	<=   reg_module_start_address27_i ; 
 --reg_module_strt_addr(27) 	<=   reg_module_start_address28_i ; 
 --reg_module_strt_addr(28) 	<=   reg_module_start_address29_i ; 
 --reg_module_strt_addr(29) 	<=   reg_module_start_address30_i ; 
 --reg_module_strt_addr(30) 	<=   reg_module_start_address31_i ; 
 --reg_module_strt_addr(31) 	<=   reg_module_start_address32_i ; 























---- Map for use in read mux.
reg_module_start_address1  <=    reg_module_start_address1_i  ;
reg_module_start_address2  <=    reg_module_start_address2_i  ;
reg_module_start_address3  <=    reg_module_start_address3_i  ;
reg_module_start_address4  <=    reg_module_start_address4_i  ;
reg_module_start_address5  <=    reg_module_start_address5_i  ;
reg_module_start_address6  <=    reg_module_start_address6_i  ;
reg_module_start_address7  <=    reg_module_start_address7_i  ;
reg_module_start_address8  <=    reg_module_start_address8_i  ;
reg_module_start_address9  <=    reg_module_start_address9_i  ;
reg_module_start_address10 <=    reg_module_start_address10_i ;
reg_module_start_address11 <=    reg_module_start_address11_i ;
reg_module_start_address12 <=    reg_module_start_address12_i ;
reg_module_start_address13 <=    reg_module_start_address13_i ;
reg_module_start_address14 <=    reg_module_start_address14_i ;
reg_module_start_address15 <=    reg_module_start_address15_i ;
reg_module_start_address16 <=    reg_module_start_address16_i ;
reg_module_start_address17 <=    reg_module_start_address17_i ;
reg_module_start_address18 <=    reg_module_start_address18_i ;
reg_module_start_address19 <=    reg_module_start_address19_i ;
reg_module_start_address20 <=    reg_module_start_address20_i ;
reg_module_start_address21 <=    reg_module_start_address21_i ;
reg_module_start_address22 <=    reg_module_start_address22_i ;
reg_module_start_address23 <=    reg_module_start_address23_i ;
reg_module_start_address24 <=    reg_module_start_address24_i ;
reg_module_start_address25 <=    reg_module_start_address25_i ;
reg_module_start_address26 <=    reg_module_start_address26_i ;
reg_module_start_address27 <=    reg_module_start_address27_i ;
reg_module_start_address28 <=    reg_module_start_address28_i ;
reg_module_start_address29 <=    reg_module_start_address29_i ;
reg_module_start_address30 <=    reg_module_start_address30_i ;
reg_module_start_address31 <=    reg_module_start_address31_i ;
reg_module_start_address32 <=    reg_module_start_address32_i ;


--------*****************************************************************************
--------** START ADDRESS REGISTERS
--------*****************************************************************************
------
-------- Generate C_NUM_FSTORE start address registeres
------GEN_START_ADDR_REG : for i in 0 to MAX_FSTORES-1 generate
------begin
------
------        -- Start Address Registers
------        START_ADDR : process(prmry_aclk)
------            begin
------                if(prmry_aclk'EVENT and prmry_aclk = '1')then
------                    if(prmry_resetn = '0')then
------                        reg_module_strt_addr_i(i)   <= (others => '0');
------                    -- Write to appropriate Start Address
------                    -- Index based on [(i+1)*2]+2.  This gives an index increment
------                    -- starting at 4 then going 6,8,10,12, etc. skipping each
------                    -- reserved space between 32-bit start addresses.  For
------                    -- 64bit addressing this index calculation will need to be
------                    -- modified.
------                    elsif(i<C_NUM_FSTORES and axi2ip_wrce(((i+1)*2)+2) = '1')then
------                        reg_module_strt_addr_i(i)   <= axi2ip_wrdata;
------
------                    -- For frames greater than fstores the vectors are reserved
------                    -- and set to zero
------                    elsif(i>= C_NUM_FSTORES)then
------                        reg_module_strt_addr_i(i) <= (others => '0');
------
------                    end if;
------                end if;
------            end process START_ADDR;
------end generate GEN_START_ADDR_REG;
------
-------- Map only C_NUM_FSTORE vectors to output port
------GEN_START_ADDR_MAP : for i in 0 to C_NUM_FSTORES-1 generate
------begin
------
------    reg_module_strt_addr(i) <= reg_module_strt_addr_i(i);
------
------end generate GEN_START_ADDR_MAP;
------
------
-------- Map for use in read mux.
------reg_module_start_address1_i  <= reg_module_strt_addr_i(0);
------reg_module_start_address2_i  <= reg_module_strt_addr_i(1);
------reg_module_start_address3_i  <= reg_module_strt_addr_i(2);
------reg_module_start_address4_i  <= reg_module_strt_addr_i(3);
------reg_module_start_address5_i  <= reg_module_strt_addr_i(4);
------reg_module_start_address6_i  <= reg_module_strt_addr_i(5);
------reg_module_start_address7_i  <= reg_module_strt_addr_i(6);
------reg_module_start_address8_i  <= reg_module_strt_addr_i(7);
------reg_module_start_address9_i  <= reg_module_strt_addr_i(8);
------reg_module_start_address10_i <= reg_module_strt_addr_i(9);
------reg_module_start_address11_i <= reg_module_strt_addr_i(10);
------reg_module_start_address12_i <= reg_module_strt_addr_i(11);
------reg_module_start_address13_i <= reg_module_strt_addr_i(12);
------reg_module_start_address14_i <= reg_module_strt_addr_i(13);
------reg_module_start_address15_i <= reg_module_strt_addr_i(14);
------reg_module_start_address16_i <= reg_module_strt_addr_i(15);
------reg_module_start_address17_i <= reg_module_strt_addr_i(16);
------reg_module_start_address18_i <= reg_module_strt_addr_i(17);
------reg_module_start_address19_i <= reg_module_strt_addr_i(18);
------reg_module_start_address20_i <= reg_module_strt_addr_i(19);
------reg_module_start_address21_i <= reg_module_strt_addr_i(20);
------reg_module_start_address22_i <= reg_module_strt_addr_i(21);
------reg_module_start_address23_i <= reg_module_strt_addr_i(22);
------reg_module_start_address24_i <= reg_module_strt_addr_i(23);
------reg_module_start_address25_i <= reg_module_strt_addr_i(24);
------reg_module_start_address26_i <= reg_module_strt_addr_i(25);
------reg_module_start_address27_i <= reg_module_strt_addr_i(26);
------reg_module_start_address28_i <= reg_module_strt_addr_i(27);
------reg_module_start_address29_i <= reg_module_strt_addr_i(28);
------reg_module_start_address30_i <= reg_module_strt_addr_i(29);
------reg_module_start_address31_i <= reg_module_strt_addr_i(30);
------reg_module_start_address32_i <= reg_module_strt_addr_i(31);




end implementation;




-------------------------------------------------------------------------------
-- axi_vdma_reg_mux
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_reg_mux.vhd
-- Description: This entity is AXI VDMA Register Module Top Level
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdmantrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_regf.vhd
--                   |   |- axi_vdma_litef.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sgf.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdstsf.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sgf.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdstsf.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_reg_mux is
    generic (
        C_TOTAL_NUM_REGISTER            	: integer                	:= 8       ;
            -- Total number of defined registers for AXI VDMA.  Used
            -- to determine wrce and rdce vector widths.

        C_INCLUDE_SG                    	: integer range 0 to 1   	:= 1       ;
            -- Include or Exclude Scatter Gather Engine
            -- 0 = Exclude Scatter Gather Engine (Enables Register Direct Mode)
            -- 1 = Include Scatter Gather Engine

        C_CHANNEL_IS_MM2S               	: integer range 0 to 1   	:= 1       ;
            -- Channel type for Read Mux
            -- 0 = Channel is S2MM
            -- 1 = Channel is MM2S

        C_NUM_FSTORES                   	: integer range 1 to 32 	:= 3        ;
            -- Number of Frame Stores
        C_NUM_FSTORES_64                   	: integer range 1 to 32 	:= 3        ;
            -- Number of Frame Stores

        C_ENABLE_VIDPRMTR_READS     		: integer range 0 to 1       	:= 1       ;
            -- Specifies whether video parameters are readable by axi_lite interface
            -- when configure for Register Direct Mode
            -- 0 = Disable Video Parameter Reads
            -- 1 = Enable Video Parameter Reads

        C_S_AXI_LITE_ADDR_WIDTH     		: integer range 9 to 9    	:= 9       ;
            -- AXI Lite interface address width

        C_S_AXI_LITE_DATA_WIDTH     		: integer range 32 to 32   	:= 32       ;
            -- AXI Lite interface data width

        C_M_AXI_SG_ADDR_WIDTH       		: integer range 32 to 64    	:= 32       ;
            -- Scatter Gather engine Address Width

        C_M_AXI_ADDR_WIDTH          		: integer range 32 to 32    	:= 32
            -- Master AXI Memory Map Address Width for MM2S Write Port
    );
    port (
        -----------------------------------------------------------------------
        -- AXI Lite Control Interface
        -----------------------------------------------------------------------
        axi2ip_rdaddr               : in  std_logic_vector                                  --
                                           (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0)     ;       --
        axi2ip_rden                 : in  std_logic                                 ;       --
        ip2axi_rddata               : out std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --
        ip2axi_rddata_valid         : out std_logic                                 ;       --


        reg_index                   : in  std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --


        dmacr                       : in  std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --
        dmasr                       : in  std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --
        dma_irq_mask                       : in  std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --
        curdesc_lsb                 : in  std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --
        curdesc_msb                 : in  std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --
        taildesc_lsb                : in  std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --
        taildesc_msb                : in  std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --
        num_frame_store             : in  std_logic_vector                                  --
                                           (NUM_FRM_STORE_WIDTH-1 downto 0)         ;       --
        linebuf_threshold           : in  std_logic_vector                                  --
                                           (THRESH_MSB_BIT downto 0)                ;       --
        -- Register Direct Support                                                          --
        reg_vflip_regmux            : in  std_logic                         ;           --
        reg_module_vsize            : in  std_logic_vector                                  --
                                           (VSIZE_DWIDTH-1 downto 0)                ;       --
        reg_module_hsize            : in  std_logic_vector                                  --
                                           (HSIZE_DWIDTH-1 downto 0)                ;       --
        reg_module_stride           : in  std_logic_vector                                  --
                                           (STRIDE_DWIDTH-1 downto 0)               ;       --
        reg_module_frmdly           : in  std_logic_vector                                  --
                                           (FRMDLY_DWIDTH-1 downto 0)               ;       --
        reg_module_start_address1   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address2   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address3   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address4   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address5   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address6   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address7   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address8   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address9   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address10  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address11  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address12  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address13  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address14  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address15  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address16  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address17   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address18   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address19   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address20   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address21   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address22   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address23   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address24   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address25   : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address26  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address27  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address28  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address29  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address30  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address31  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)        ;       --
        reg_module_start_address32  : in  std_logic_vector                                  --
                                           (C_M_AXI_ADDR_WIDTH - 1 downto 0)                --

    );
end axi_vdma_reg_mux;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_reg_mux is

attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";
ATTRIBUTE DONT_TOUCH                           : STRING;

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

constant VSIZE_PAD_WIDTH    : integer := C_S_AXI_LITE_DATA_WIDTH-VSIZE_DWIDTH;
constant VSIZE_PAD          : std_logic_vector(VSIZE_PAD_WIDTH-1 downto 0) 	:= (others => '0');
constant HSIZE_PAD_WIDTH    : integer := C_S_AXI_LITE_DATA_WIDTH-HSIZE_DWIDTH;
constant HSIZE_PAD          : std_logic_vector(HSIZE_PAD_WIDTH-1 downto 0) 	:= (others => '0');

constant FRMSTORE_ZERO_PAD  : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH - 1
                                downto FRMSTORE_MSB_BIT+1) 			:= (others => '0');
constant THRESH_ZERO_PAD    : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH - 1
                                downto THRESH_MSB_BIT+1) 			:= (others => '0');

constant VFLIP_PAD          : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-2 downto 0) 	:= (others => '0');

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal read_addr_ri         : std_logic_vector(8 downto 0) 			:= (others => '0');
signal read_addr            : std_logic_vector(7 downto 0) 			:= (others => '0');
signal read_addr_sg_1       : std_logic_vector(7 downto 0) 			:= (others => '0');
signal ip2axi_rddata_int    : std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --


  ATTRIBUTE DONT_TOUCH OF ip2axi_rddata_int               : SIGNAL IS "true";
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

ip2axi_rddata <= ip2axi_rddata_int;
--*****************************************************************************
-- AXI LITE READ MUX
--*****************************************************************************
-- Register module is for MM2S Channel therefore look at
-- MM2S Register offsets
GEN_READ_MUX_FOR_MM2S : if C_CHANNEL_IS_MM2S = 1 generate
begin
    -- Scatter Gather Mode Read MUX
    GEN_READ_MUX_SG : if C_INCLUDE_SG = 1 generate
    begin
        --read_addr <= axi2ip_rdaddr(9 downto 0);
        read_addr_sg_1 <= axi2ip_rdaddr(7 downto 0);

        AXI_LITE_READ_MUX : process(read_addr_sg_1       ,
                                    axi2ip_rden     ,
                                    dmacr         ,
                                    dmasr         ,
                                    curdesc_lsb   ,
                                    curdesc_msb   ,
                                    taildesc_lsb  ,
                                    taildesc_msb  ,
                                    num_frame_store,
                                    linebuf_threshold)
            begin
                case read_addr_sg_1 is
                    when MM2S_DMACR_OFFSET_SG        =>
                        ip2axi_rddata_int       <= dmacr;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when MM2S_DMASR_OFFSET_SG        =>
                        ip2axi_rddata_int       <= dmasr;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when MM2S_CURDESC_LSB_OFFSET_SG  =>
                        ip2axi_rddata_int       <= curdesc_lsb;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when MM2S_CURDESC_MSB_OFFSET_SG  =>
                        ip2axi_rddata_int       <= curdesc_msb;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when MM2S_TAILDESC_LSB_OFFSET_SG =>
                        ip2axi_rddata_int       <= taildesc_lsb;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when MM2S_TAILDESC_MSB_OFFSET_SG =>
                        ip2axi_rddata_int       <= taildesc_msb;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when MM2S_FRAME_STORE_OFFSET_SG =>
                        ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                             & num_frame_store;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when MM2S_THRESHOLD_OFFSET_SG =>
                        ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                            & linebuf_threshold;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when others =>
                        ip2axi_rddata_int       <= (others => '0');
                        ip2axi_rddata_valid <= '0';
                end case;
            end process AXI_LITE_READ_MUX;
    end generate GEN_READ_MUX_SG;



    -- Register Direct Mode Read MUX
    GEN_READ_MUX_REG_DIRECT : if C_INCLUDE_SG = 0  and C_ENABLE_VIDPRMTR_READS = 1 generate
    begin

        read_addr <= axi2ip_rdaddr(7 downto 0);
        read_addr_ri <= reg_index(0) & axi2ip_rdaddr(7 downto 0);



        -- 1 start addresses
        GEN_FSTORES_1  : if C_NUM_FSTORES = 1 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1)
                begin
                    case read_addr is
                        when  MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_1;

        -- 2 start addresses
        GEN_FSTORES_2  : if C_NUM_FSTORES = 2 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_2;

        -- 3 start addresses
        GEN_FSTORES_3  : if C_NUM_FSTORES = 3 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_3;

        -- 4 start addresses
        GEN_FSTORES_4  : if C_NUM_FSTORES = 4 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_4;

        -- 5 start addresses
        GEN_FSTORES_5  : if C_NUM_FSTORES = 5 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_5;

        -- 6 start addresses
        GEN_FSTORES_6  : if C_NUM_FSTORES = 6 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_6;

        -- 7 start addresses
        GEN_FSTORES_7  : if C_NUM_FSTORES = 7 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_7;

        -- 8 start addresses
        GEN_FSTORES_8  : if C_NUM_FSTORES = 8 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_8;

        -- 9 start addresses
        GEN_FSTORES_9  : if C_NUM_FSTORES = 9 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_9;

        -- 10 start addresses
        GEN_FSTORES_10  : if C_NUM_FSTORES = 10 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_10;

        -- 11 start addresses
        GEN_FSTORES_11  : if C_NUM_FSTORES = 11 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_11;

        -- 12 start addresses
        GEN_FSTORES_12  : if C_NUM_FSTORES = 12 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_12;

        -- 13 start addresses
        GEN_FSTORES_13  : if C_NUM_FSTORES = 13 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_13;

        -- 14 start addresses
        GEN_FSTORES_14  : if C_NUM_FSTORES = 14 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_14;

        -- 15 start addresses
        GEN_FSTORES_15  : if C_NUM_FSTORES = 15 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_15;

        -- 16 start addresses
        GEN_FSTORES_16  : if C_NUM_FSTORES = 16 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16)
                begin
                    case read_addr is
                        when MM2S_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_16;

        -- 17 start addresses
        GEN_FSTORES_17  : if C_NUM_FSTORES = 17 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_17;

        -- 18 start addresses
        GEN_FSTORES_18  : if C_NUM_FSTORES = 18 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_18;

        -- 19 start addresses
        GEN_FSTORES_19  : if C_NUM_FSTORES = 19 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_19;

        -- 20 start addresses
        GEN_FSTORES_20  : if C_NUM_FSTORES = 20 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_20;

        -- 21 start addresses
        GEN_FSTORES_21  : if C_NUM_FSTORES = 21 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_21;

        -- 22 start addresses
        GEN_FSTORES_22  : if C_NUM_FSTORES = 22 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_22;

        -- 23 start addresses
        GEN_FSTORES_23  : if C_NUM_FSTORES = 23 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_23;

        -- 24 start addresses
        GEN_FSTORES_24  : if C_NUM_FSTORES = 24 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_24;

        -- 25 start addresses
        GEN_FSTORES_25  : if C_NUM_FSTORES = 25 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_25;

        -- 26 start addresses
        GEN_FSTORES_26  : if C_NUM_FSTORES = 26 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_26;

        -- 27 start addresses
        GEN_FSTORES_27  : if C_NUM_FSTORES = 27 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26    ,
                                        reg_module_start_address27)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR27_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address27;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_27;

        -- 28 start addresses
        GEN_FSTORES_28  : if C_NUM_FSTORES = 28 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26    ,
                                        reg_module_start_address27    ,
                                        reg_module_start_address28)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR27_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address27;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR28_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address28;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_28;

        -- 29 start addresses
        GEN_FSTORES_29  : if C_NUM_FSTORES = 29 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26    ,
                                        reg_module_start_address27    ,
                                        reg_module_start_address28    ,
                                        reg_module_start_address29)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR27_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address27;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR28_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address28;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR29_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address29;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_29;

        -- 30 start addresses
        GEN_FSTORES_30  : if C_NUM_FSTORES = 30 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26    ,
                                        reg_module_start_address27    ,
                                        reg_module_start_address28    ,
                                        reg_module_start_address29    ,
                                        reg_module_start_address30)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR27_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address27;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR28_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address28;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR29_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address29;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR30_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address30;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_30;

        -- 31 start addresses
        GEN_FSTORES_31  : if C_NUM_FSTORES = 31 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26    ,
                                        reg_module_start_address27    ,
                                        reg_module_start_address28    ,
                                        reg_module_start_address29    ,
                                        reg_module_start_address30    ,
                                        reg_module_start_address31)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR27_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address27;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR28_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address28;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR29_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address29;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR30_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address30;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR31_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address31;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_31;

        -- 32 start addresses
        GEN_FSTORES_32  : if C_NUM_FSTORES = 32 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26    ,
                                        reg_module_start_address27    ,
                                        reg_module_start_address28    ,
                                        reg_module_start_address29    ,
                                        reg_module_start_address30    ,
                                        reg_module_start_address31    ,
                                        reg_module_start_address32)
                begin
                    case read_addr_ri is
                        when MM2S_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;

                        when MM2S_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR27_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address27;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR28_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address28;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR29_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address29;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR30_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address30;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR31_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address31;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_STARTADDR32_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address32;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_32;



    end generate GEN_READ_MUX_REG_DIRECT;

    -- Register Direct Mode Read MUX
    GEN_READ_MUX_LITE_REG_DIRECT : if C_INCLUDE_SG = 0  and C_ENABLE_VIDPRMTR_READS = 0 generate
    begin
        read_addr <= axi2ip_rdaddr(7 downto 0);

        AXI_LITE_READ_MUX : process(read_addr                           ,
                                    axi2ip_rden                         ,
                                    dmacr                             ,
                                    reg_index                             ,
                                    dmasr                             ,
                                    num_frame_store                   ,
                                    linebuf_threshold)
            begin
                case read_addr is
                    when MM2S_DMACR_OFFSET_8          =>
                        ip2axi_rddata_int       <= dmacr;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when MM2S_DMASR_OFFSET_8          =>
                        ip2axi_rddata_int       <= dmasr;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when MM2S_REG_INDEX_OFFSET_8          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when MM2S_FRAME_STORE_OFFSET_8 =>
                        ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                             & num_frame_store;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when MM2S_THRESHOLD_OFFSET_8 =>
                        ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                            & linebuf_threshold;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when others =>
                        ip2axi_rddata_int       <= (others => '0');
                        ip2axi_rddata_valid <= '0';
                end case;
            end process AXI_LITE_READ_MUX;
    end generate GEN_READ_MUX_LITE_REG_DIRECT;

end generate GEN_READ_MUX_FOR_MM2S;


-- Register module is for S2MM Channel therefore look at
-- S2MM Register offsets
GEN_READ_MUX_FOR_S2MM : if C_CHANNEL_IS_MM2S = 0 generate
begin
    -- Scatter Gather Mode Read MUX
    GEN_READ_MUX_SG : if C_INCLUDE_SG = 1 generate
    begin
        --read_addr <= axi2ip_rdaddr(9 downto 0);
        read_addr_sg_1 <= axi2ip_rdaddr(7 downto 0);

        AXI_LITE_READ_MUX : process(read_addr_sg_1       ,
                                    axi2ip_rden     ,
                                    dmacr         ,
                                    dmasr         ,
                                    curdesc_lsb   ,
                                    dma_irq_mask   ,
                                    taildesc_lsb  ,
                                    taildesc_msb  ,
                                    num_frame_store,
                                    reg_vflip_regmux,
                                    linebuf_threshold)
            begin
                case read_addr_sg_1 is
                    when S2MM_DMACR_OFFSET_SG        =>
                        ip2axi_rddata_int       <= dmacr;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMASR_OFFSET_SG        =>
                        ip2axi_rddata_int       <= dmasr;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_CURDESC_LSB_OFFSET_SG  =>
                        ip2axi_rddata_int       <= curdesc_lsb;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_SG  =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_TAILDESC_LSB_OFFSET_SG =>
                        ip2axi_rddata_int       <= taildesc_lsb;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_TAILDESC_MSB_OFFSET_SG =>
                        ip2axi_rddata_int       <= taildesc_msb;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_FRAME_STORE_OFFSET_SG =>
                        ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                             & num_frame_store;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_THRESHOLD_OFFSET_SG =>
                        ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                            & linebuf_threshold;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when VFLIP_OFFSET_8 =>
                        ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when others =>
                        ip2axi_rddata_int       <= (others => '0');
                        ip2axi_rddata_valid <= '0';
                end case;
            end process AXI_LITE_READ_MUX;
    end generate GEN_READ_MUX_SG;



    -- Register Direct Mode Read MUX
    GEN_READ_MUX_REG_DIRECT : if C_INCLUDE_SG = 0  and C_ENABLE_VIDPRMTR_READS = 1 generate
    begin

        read_addr <= axi2ip_rdaddr(7 downto 0);
        read_addr_ri <= reg_index(0) & axi2ip_rdaddr(7 downto 0);
        -- 17 start addresses


        -- 1 start addresses
        GEN_FSTORES_1  : if C_NUM_FSTORES = 1 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_1;

        -- 2 start addresses
        GEN_FSTORES_2  : if C_NUM_FSTORES = 2 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_2;

        -- 3 start addresses
        GEN_FSTORES_3  : if C_NUM_FSTORES = 3 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_3;

        -- 4 start addresses
        GEN_FSTORES_4  : if C_NUM_FSTORES = 4 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_4;

        -- 5 start addresses
        GEN_FSTORES_5  : if C_NUM_FSTORES = 5 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_5;

        -- 6 start addresses
        GEN_FSTORES_6  : if C_NUM_FSTORES = 6 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_6;

        -- 7 start addresses
        GEN_FSTORES_7  : if C_NUM_FSTORES = 7 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_7;

        -- 8 start addresses
        GEN_FSTORES_8  : if C_NUM_FSTORES = 8 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_8;

        -- 9 start addresses
        GEN_FSTORES_9  : if C_NUM_FSTORES = 9 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_9;

        -- 10 start addresses
        GEN_FSTORES_10  : if C_NUM_FSTORES = 10 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_10;

        -- 11 start addresses
        GEN_FSTORES_11  : if C_NUM_FSTORES = 11 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_11;

        -- 12 start addresses
        GEN_FSTORES_12  : if C_NUM_FSTORES = 12 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_12;

        -- 13 start addresses
        GEN_FSTORES_13  : if C_NUM_FSTORES = 13 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_13;

        -- 14 start addresses
        GEN_FSTORES_14  : if C_NUM_FSTORES = 14 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_14;

        -- 15 start addresses
        GEN_FSTORES_15  : if C_NUM_FSTORES = 15 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_15;

        -- 16 start addresses
        GEN_FSTORES_16  : if C_NUM_FSTORES = 16 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                          ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16)
                begin
                    case read_addr is
                        when S2MM_DMACR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_8          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_8 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_8 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_8           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_8 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_8         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR1_OFFSET_8 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_8      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_8     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_16;

        -- 17 start addresses
        GEN_FSTORES_17  : if C_NUM_FSTORES = 17 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_17;


        -- 18 start addresses
        GEN_FSTORES_18  : if C_NUM_FSTORES = 18 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_18;

        -- 19 start addresses
        GEN_FSTORES_19  : if C_NUM_FSTORES = 19 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_19;

        -- 20 start addresses
        GEN_FSTORES_20  : if C_NUM_FSTORES = 20 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_20;

        -- 21 start addresses
        GEN_FSTORES_21  : if C_NUM_FSTORES = 21 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_21;

        -- 22 start addresses
        GEN_FSTORES_22  : if C_NUM_FSTORES = 22 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_22;

        -- 23 start addresses
        GEN_FSTORES_23  : if C_NUM_FSTORES = 23 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_23;

        -- 24 start addresses
        GEN_FSTORES_24  : if C_NUM_FSTORES = 24 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_24;

        -- 25 start addresses
        GEN_FSTORES_25  : if C_NUM_FSTORES = 25 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_25;

        -- 26 start addresses
        GEN_FSTORES_26  : if C_NUM_FSTORES = 26 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_26;

        -- 27 start addresses
        GEN_FSTORES_27  : if C_NUM_FSTORES = 27 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26    ,
                                        reg_module_start_address27)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR27_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address27;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_27;

        -- 28 start addresses
        GEN_FSTORES_28  : if C_NUM_FSTORES = 28 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26    ,
                                        reg_module_start_address27    ,
                                        reg_module_start_address28)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR27_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address27;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR28_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address28;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_28;

        -- 29 start addresses
        GEN_FSTORES_29  : if C_NUM_FSTORES = 29 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26    ,
                                        reg_module_start_address27    ,
                                        reg_module_start_address28    ,
                                        reg_module_start_address29)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR27_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address27;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR28_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address28;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR29_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address29;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_29;

        -- 30 start addresses
        GEN_FSTORES_30  : if C_NUM_FSTORES = 30 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26    ,
                                        reg_module_start_address27    ,
                                        reg_module_start_address28    ,
                                        reg_module_start_address29    ,
                                        reg_module_start_address30)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR27_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address27;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR28_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address28;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR29_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address29;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR30_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address30;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_30;

        -- 31 start addresses
        GEN_FSTORES_31  : if C_NUM_FSTORES = 31 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26    ,
                                        reg_module_start_address27    ,
                                        reg_module_start_address28    ,
                                        reg_module_start_address29    ,
                                        reg_module_start_address30    ,
                                        reg_module_start_address31)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR27_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address27;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR28_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address28;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR29_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address29;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR30_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address30;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR31_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address31;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_31;

        -- 32 start addresses
        GEN_FSTORES_32  : if C_NUM_FSTORES = 32 generate
        begin
            AXI_LITE_READ_MUX : process(read_addr_ri                       ,
                                        axi2ip_rden                     ,
                                        dmacr                         ,
                                        dmasr                         , reg_index ,
                                    dma_irq_mask   ,
                                        num_frame_store               ,
                                        linebuf_threshold             ,
                                        reg_module_vsize              ,
                                        reg_module_hsize              ,
                                        reg_module_stride             ,
                                        reg_module_frmdly             ,
                                        reg_vflip_regmux             ,
                                        reg_module_start_address1     ,
                                        reg_module_start_address2     ,
                                        reg_module_start_address3     ,
                                        reg_module_start_address4     ,
                                        reg_module_start_address5     ,
                                        reg_module_start_address6     ,
                                        reg_module_start_address7     ,
                                        reg_module_start_address8     ,
                                        reg_module_start_address9     ,
                                        reg_module_start_address10    ,
                                        reg_module_start_address11    ,
                                        reg_module_start_address12    ,
                                        reg_module_start_address13    ,
                                        reg_module_start_address14    ,
                                        reg_module_start_address15    ,
                                        reg_module_start_address16    ,
                                        reg_module_start_address17    ,
                                        reg_module_start_address18    ,
                                        reg_module_start_address19    ,
                                        reg_module_start_address20    ,
                                        reg_module_start_address21    ,
                                        reg_module_start_address22    ,
                                        reg_module_start_address23    ,
                                        reg_module_start_address24    ,
                                        reg_module_start_address25    ,
                                        reg_module_start_address26    ,
                                        reg_module_start_address27    ,
                                        reg_module_start_address28    ,
                                        reg_module_start_address29    ,
                                        reg_module_start_address30    ,
                                        reg_module_start_address31    ,
                                        reg_module_start_address32)
                begin
                    case read_addr_ri is
                        when S2MM_DMACR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_90          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_90          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_90          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_90 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_90 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_90           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_90 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_90         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_DMACR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmacr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMASR_OFFSET_91          =>
                            ip2axi_rddata_int       <= dmasr;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DMA_IRQ_MASK_OFFSET_91          =>
                            ip2axi_rddata_int       <= dma_irq_mask;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_91          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_FRAME_STORE_OFFSET_91 =>
                            ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                                 & num_frame_store;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_THRESHOLD_OFFSET_91 =>
                            ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                                & linebuf_threshold;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_VSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= VSIZE_PAD & reg_module_vsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_HSIZE_OFFSET_91           =>
                            ip2axi_rddata_int       <= HSIZE_PAD & reg_module_hsize;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when VFLIP_OFFSET_91 =>
                            ip2axi_rddata_int       <= VFLIP_PAD
                                             & reg_vflip_regmux;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_DLYSTRD_OFFSET_91         =>
                            ip2axi_rddata_int       <= RSVD_BITS_31TO29
                                                & reg_module_frmdly
                                                & RSVD_BITS_23TO16
                                                & reg_module_stride;
                            ip2axi_rddata_valid <= axi2ip_rden;



                        when S2MM_STARTADDR1_OFFSET_90 =>
                            ip2axi_rddata_int       <= reg_module_start_address1;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR2_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address2;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR3_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address3;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR4_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address4;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR5_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address5;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR6_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address6;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR7_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address7;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR8_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address8;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR9_OFFSET_90      =>
                            ip2axi_rddata_int       <= reg_module_start_address9;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR10_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address10;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR11_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address11;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR12_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address12;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR13_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address13;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR14_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address14;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR15_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address15;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR16_OFFSET_90     =>
                            ip2axi_rddata_int       <= reg_module_start_address16;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR17_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address17;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR18_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address18;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR19_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address19;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR20_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address20;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR21_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address21;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR22_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address22;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR23_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address23;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR24_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address24;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR25_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address25;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR26_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address26;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR27_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address27;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR28_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address28;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR29_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address29;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR30_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address30;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR31_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address31;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_STARTADDR32_OFFSET_91     =>
                            ip2axi_rddata_int       <= reg_module_start_address32;
                            ip2axi_rddata_valid <= axi2ip_rden;
                        when others =>
                            ip2axi_rddata_int       <= (others => '0');
                            ip2axi_rddata_valid <= '0';
                    end case;
                end process AXI_LITE_READ_MUX;
        end generate GEN_FSTORES_32;




    end generate GEN_READ_MUX_REG_DIRECT;

    -- Register Direct Mode Read MUX
    GEN_READ_MUX_LITE_REG_DIRECT : if C_INCLUDE_SG = 0  and C_ENABLE_VIDPRMTR_READS = 0 generate
    begin
        read_addr <= axi2ip_rdaddr(7 downto 0);

        AXI_LITE_READ_MUX : process(read_addr                           ,
                                    axi2ip_rden                         ,
                                    dmacr                             ,
                                    reg_index                             ,
                                    dmasr                             ,
                                    dma_irq_mask   ,
                                    num_frame_store                   ,
                                    reg_vflip_regmux             ,
                                    linebuf_threshold)
            begin
                case read_addr is
                    when S2MM_DMACR_OFFSET_8          =>
                        ip2axi_rddata_int       <= dmacr;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMASR_OFFSET_8          =>
                        ip2axi_rddata_int       <= dmasr;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_DMA_IRQ_MASK_8          =>
                        ip2axi_rddata_int       <= dma_irq_mask;
                        ip2axi_rddata_valid <= axi2ip_rden;
                        when S2MM_REG_INDEX_OFFSET_8          =>
                            ip2axi_rddata_int       <= reg_index;
                            ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_FRAME_STORE_OFFSET_8 =>
                        ip2axi_rddata_int       <= FRMSTORE_ZERO_PAD
                                             & num_frame_store;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when VFLIP_OFFSET_8 =>
                        ip2axi_rddata_int       <= VFLIP_PAD
                                         & reg_vflip_regmux;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when S2MM_THRESHOLD_OFFSET_8 =>
                        ip2axi_rddata_int       <= THRESH_ZERO_PAD
                                            & linebuf_threshold;
                        ip2axi_rddata_valid <= axi2ip_rden;
                    when others =>
                        ip2axi_rddata_int       <= (others => '0');
                        ip2axi_rddata_valid <= '0';
                end case;
            end process AXI_LITE_READ_MUX;
    end generate GEN_READ_MUX_LITE_REG_DIRECT;

end generate GEN_READ_MUX_FOR_S2MM;

end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_reg_module
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_reg_module.vhd
-- Description: This entity is AXI VDMA Register Module Top Level
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_reg_module is
    generic (
        C_TOTAL_NUM_REGISTER            : integer                := 8       ;
            -- Total number of defined registers for AXI VDMA.  Used
            -- to determine wrce and rdce vector widths.

        C_INCLUDE_SG                    : integer range 0 to 1   := 1       ;
            -- Include or Exclude Scatter Gather Engine
            -- 0 = Exclude Scatter Gather Engine (Enables Register Direct Mode)
            -- 1 = Include Scatter Gather Engine

        C_CHANNEL_IS_MM2S               : integer range 0 to 1   := 1       ;
            -- Channel type for Read Mux
            -- 0 = Channel is S2MM
            -- 1 = Channel is MM2S

        C_ENABLE_FLUSH_ON_FSYNC     	: integer range 0 to 1       := 0       ;  -- 
            -- Specifies VDMA Flush on Frame sync enabled
            -- 0 = Disabled
            -- 1 = Enabled

        C_ENABLE_VIDPRMTR_READS     	: integer range 0 to 1       := 1       ;
            -- Specifies whether video parameters are readable by axi_lite interface
            -- when configure for Register Direct Mode
            -- 0 = Disable Video Parameter Reads
            -- 1 = Enable Video Parameter Reads

        C_INTERNAL_GENLOCK_ENABLE   	: integer range 0 to 1          := 0;

        -----------------------------------------------------------------------
        C_DYNAMIC_RESOLUTION           : integer range 0 to 1        := 1	;
            -- Run time configuration of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 0 = Halt VDMA before writing new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 1 = Run time register configuration for new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE.
        -----------------------------------------------------------------------

        --C_ENABLE_DEBUG_INFO             : string := "1111111111111111";		-- 1 to 16 -- 
        --C_ENABLE_DEBUG_INFO             : bit_vector(15 downto 0) 	:= (others => '1');		--15 downto 0  -- 

        C_ENABLE_DEBUG_ALL       : integer range 0 to 1      	:= 1;
            -- Setting this make core backward compatible to 2012.4 version in terms of ports and registers
        C_ENABLE_DEBUG_INFO_0       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 0
        C_ENABLE_DEBUG_INFO_1       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 1
        C_ENABLE_DEBUG_INFO_2       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 2
        C_ENABLE_DEBUG_INFO_3       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 3
        C_ENABLE_DEBUG_INFO_4       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 4
        C_ENABLE_DEBUG_INFO_5       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 5
        C_ENABLE_DEBUG_INFO_6       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 6
        C_ENABLE_DEBUG_INFO_7       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 7
        C_ENABLE_DEBUG_INFO_8       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 8
        C_ENABLE_DEBUG_INFO_9       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 9
        C_ENABLE_DEBUG_INFO_10      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 10
        C_ENABLE_DEBUG_INFO_11      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 11
        C_ENABLE_DEBUG_INFO_12      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 12
        C_ENABLE_DEBUG_INFO_13      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 13
        C_ENABLE_DEBUG_INFO_14      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 14
        C_ENABLE_DEBUG_INFO_15      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 15

        C_ENABLE_VERT_FLIP              : integer range 0 to 1          := 0;            

        C_NUM_FSTORES                   : integer range 1 to 32 := 3        ;
            -- Number of Frame Stores
        C_NUM_FSTORES_64                   : integer range 1 to 32 := 3        ;
            -- Number of Frame Stores

        C_LINEBUFFER_THRESH         	: integer range 1 to 65536  := 1        ;
            -- Linebuffer Threshold Default setting

        C_GENLOCK_MODE                  : integer range 0 to 3  := 0        ;
            -- Specifies the Gen-Lock mode for the MM2S Channel
            -- 0 = Master Mode
            -- 1 = Slave Mode

        C_S_AXI_LITE_ADDR_WIDTH     	: integer range 9 to 9    := 9       ;
            -- AXI Lite interface address width

        C_S_AXI_LITE_DATA_WIDTH     	: integer range 32 to 32    := 32       ;
            -- AXI Lite interface data width

        C_M_AXI_SG_ADDR_WIDTH       	: integer range 32 to 64    := 32       ;
            -- Scatter Gather engine Address Width

        C_M_AXI_ADDR_WIDTH          	: integer range 32 to 32    := 32
            -- Master AXI Memory Map Address Width for MM2S Write Port
    );
    port (
        -----------------------------------------------------------------------
        -- AXI Lite Control Interface
        -----------------------------------------------------------------------
        prmry_aclk                  : in  std_logic                                 ;       --
        prmry_resetn                : in  std_logic                                 ;       --
                                                                                            --
        -- Register to AXI Lite Interface                                                   --
        axi2ip_wrce                 : in  std_logic_vector                                  --
                                           (C_TOTAL_NUM_REGISTER-1 downto 0)        ;       --
        axi2ip_wrdata               : in  std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --
        axi2ip_rdaddr               : in  std_logic_vector                                  --
                                           (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0)     ;       --
        axi2ip_rden                 : in  std_logic                                 ;       --
        ip2axi_rddata               : out std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --
        ip2axi_rddata_valid         : out std_logic                                 ;       --
        ip2axi_frame_ptr_ref        : out std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)             ;       --
        ip2axi_frame_store          : out std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)             ;       --
        ip2axi_introut              : out std_logic                                 ;       --
                                                                                            --
        -- Soft Reset                                                                       --
        soft_reset                  : out std_logic                                 ;       --
        soft_reset_clr              : in  std_logic                                 ;       --
                                                                                            --
        -- DMA Control / Status Register Signals                                            --
        stop                        : in  std_logic                                 ;       --
        halted_clr                  : in  std_logic                                 ;       --
        halted_set                  : in  std_logic                                 ;       --
        idle_set                    : in  std_logic                                 ;       --
        idle_clr                    : in  std_logic                                 ;       --
        dma_interr_set              : in  std_logic                                 ;       --
        dma_interr_set_minus_frame_errors              : in  std_logic                                 ;       --
        dma_slverr_set              : in  std_logic                                 ;       --
        dma_decerr_set              : in  std_logic                                 ;       --

        fsize_mismatch_err          : in  std_logic                                 ;       --
        lsize_mismatch_err          : in  std_logic                                 ;       --
        lsize_more_mismatch_err     : in  std_logic                                 ;       --
        s2mm_fsize_more_or_sof_late : in  std_logic                                 ;       --

        ioc_irq_set                 : in  std_logic                                 ;       --
        dly_irq_set                 : in  std_logic                                 ;       --
        irqdelay_status             : in  std_logic_vector(7 downto 0)              ;       --
        irqthresh_status            : in  std_logic_vector(7 downto 0)              ;       --
        frame_sync                  : in  std_logic                                 ;       --
        fsync_mask                  : in  std_logic                                 ;       --
                                                                                            --
        ftch_slverr_set             : in  std_logic                                 ;       --
        ftch_decerr_set             : in  std_logic                                 ;       --
        new_curdesc_wren            : in  std_logic                                 ;       --
        new_curdesc                 : in  std_logic_vector                                  --
                                           (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)       ;       --
        update_frmstore             : in  std_logic                                 ;       --
        new_frmstr                  : in  std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)             ;       --
        tstvect_fsync               : in  std_logic                                 ;       --
        valid_frame_sync            : in  std_logic                                 ;       --
        irqthresh_rstdsbl           : out std_logic                                 ;       --
        dlyirq_dsble                : out std_logic                                 ;       --
        irqthresh_wren              : out std_logic                                 ;       --
        irqdelay_wren               : out std_logic                                 ;       --
        tailpntr_updated            : out std_logic                                 ;       --

        reg_index                   : out std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --


        dmacr                       : out std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --
        dmasr                       : out std_logic_vector                                  --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)     ;       --
        curdesc                     : out std_logic_vector                                  --
                                           (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)       ;       --
        taildesc                    : out std_logic_vector                                  --
                                           (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)       ;       --
        num_frame_store             : out std_logic_vector                                  --
                                        (NUM_FRM_STORE_WIDTH-1 downto 0)            ;       --
        linebuf_threshold           : out std_logic_vector                                  --
                                        (THRESH_MSB_BIT downto 0)                   ;       --
        -- Register Direct Support                                                          --
        regdir_idle                 : out std_logic                                 ;       --
        prmtr_updt_complete         : out std_logic                                 ;       --
        reg_module_vsize            : out std_logic_vector                                  --
                                           (VSIZE_DWIDTH-1 downto 0)                ;       --
        reg_module_hsize            : out std_logic_vector                                  --
                                           (HSIZE_DWIDTH-1 downto 0)                ;       --
        reg_module_stride           : out std_logic_vector                                  --
                                           (STRIDE_DWIDTH-1 downto 0)               ;       --
        reg_module_frmdly           : out std_logic_vector                                  --
                                           (FRMDLY_DWIDTH-1 downto 0)               ;       --
        reg_module_strt_addr        : out STARTADDR_ARRAY_TYPE                              --
                                           (0 to C_NUM_FSTORES - 1)                 ;       --
        vflip                       : out std_logic                                 ;       --
                                                                                            --
        -- Fetch/Update error addresses                                                     --
        frmstr_err_addr             : in std_logic_vector
                                        (FRAME_NUMBER_WIDTH-1 downto 0)               ;     --
        ftch_err_addr               : in  std_logic_vector                                  --
                                           (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)               --


    );
end axi_vdma_reg_module;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_reg_module is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

constant VSIZE_PAD_WIDTH    : integer := C_S_AXI_LITE_DATA_WIDTH-VSIZE_DWIDTH;
constant VSIZE_PAD          : std_logic_vector(VSIZE_PAD_WIDTH-1 downto 0) 	:= (others => '0');
constant HSIZE_PAD_WIDTH    : integer := C_S_AXI_LITE_DATA_WIDTH-HSIZE_DWIDTH;
constant HSIZE_PAD          : std_logic_vector(HSIZE_PAD_WIDTH-1 downto 0) 	:= (others => '0');

constant FRMSTORE_ZERO_PAD  : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH - 1
                                downto FRMSTORE_MSB_BIT+1) 			:= (others => '0');
constant THRESH_ZERO_PAD    : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH - 1
                                downto THRESH_MSB_BIT+1) 			:= (others => '0');

-- Convert registeSTARTADDRr ce index depending on channel
constant DMACR_INDEX            : integer := convert_base_index(C_CHANNEL_IS_MM2S,MM2S_DMACR_INDEX);
constant THRESHOLD_INDEX      	: integer := convert_base_index(C_CHANNEL_IS_MM2S,MM2S_THRESHOLD_INDEX);
constant STARTADDR16_INDEX      : integer := convert_regdir_index(C_CHANNEL_IS_MM2S,MM2S_STARTADDR16_INDEX);
--constant STARTADDR32_INDEX    : integer := convert_regdir_index(C_CHANNEL_IS_MM2S,MM2S_STARTADDR32_INDEX);
constant VSIZE_INDEX            : integer := convert_regdir_index(C_CHANNEL_IS_MM2S,MM2S_VSIZE_INDEX);

-- Convert msb/lsb bit index depending on channel
constant PARKPTR_FRMPTR_MSB_BIT : integer := PARKPTR_FRMPTR_S2MM_MSB_BIT - (C_CHANNEL_IS_MM2S*8);
constant PARKPTR_FRMPTR_LSB_BIT : integer := PARKPTR_FRMPTR_S2MM_LSB_BIT - (C_CHANNEL_IS_MM2S*8);




-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal dmacr_i                      : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal dmasr_i                      : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal dma_irq_mask_i                      : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal curdesc_lsb_i                : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal curdesc_msb_i                : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal taildesc_lsb_i               : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal reg_index_i                  : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal taildesc_msb_i               : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal num_frame_store_i            : std_logic_vector(FRMSTORE_MSB_BIT downto 0)           := (others => '0');
signal num_frame_store_regmux_i     : std_logic_vector(FRMSTORE_MSB_BIT downto 0)           := (others => '0');
signal linebuf_threshold_i          : std_logic_vector(THRESH_MSB_BIT downto 0)             := (others => '0');
signal irqthresh_wren_i             : std_logic 					    := '0';
signal frm_store                    : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)       := (others => '0');
signal ptr_ref_i                    : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)       := (others => '0');

signal regdir_wrack                 : std_logic := '0'; -- 
signal vflip_i                      : std_logic := '1'; 



-- Register Direct signals
signal reg_module_vsize_i           : std_logic_vector(VSIZE_DWIDTH-1 downto 0)         := (others => '0');
signal reg_module_hsize_i           : std_logic_vector(HSIZE_DWIDTH-1 downto 0)         := (others => '0');
signal reg_module_stride_i          : std_logic_vector(STRIDE_DWIDTH-1 downto 0)        := (others => '0');
signal reg_module_frmdly_i          : std_logic_vector(FRMDLY_DWIDTH-1 downto 0)        := (others => '0');
signal reg_module_start_address1_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address2_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address3_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address4_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address5_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address6_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address7_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address8_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address9_i  : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address10_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address11_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address12_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address13_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address14_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address15_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address16_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address17_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address18_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address19_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address20_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address21_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address22_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address23_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address24_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address25_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address26_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address27_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address28_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address29_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address30_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address31_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');
signal reg_module_start_address32_i : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0) := (others => '0');

signal reg_module_strt_addr_i       : STARTADDR_ARRAY_TYPE(0 to C_NUM_FSTORES - 1);




-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin


-- Pass register data out to top level for other module use
reg_index               <= reg_index_i;             -- REG INDEX 
dmacr                   <= dmacr_i;             -- DMA Control Register
dmasr                   <= dmasr_i;             -- DMA Status Register
num_frame_store         <= num_frame_store_i;   -- Number of Frame Stores
linebuf_threshold       <= linebuf_threshold_i; -- Line Buffer Threshold
ip2axi_frame_ptr_ref    <= ptr_ref_i;           -- Park Pointer Reference
ip2axi_frame_store      <= frm_store;           -- Current Frame Store
vflip                   <= vflip_i;             -- Vertical Flip Register


-- For 32 bit address map only lsb registers out
GEN_DESC_ADDR_EQL32 : if C_M_AXI_SG_ADDR_WIDTH = 32 generate
begin
    curdesc    <= curdesc_lsb_i;
    taildesc   <= taildesc_lsb_i;
end generate GEN_DESC_ADDR_EQL32;

-- For 64 bit address map lsb and msb registers out
GEN_DESC_ADDR_EQL64 : if C_M_AXI_SG_ADDR_WIDTH = 64 generate
begin
    curdesc    <= curdesc_msb_i & curdesc_lsb_i;
    taildesc   <= taildesc_msb_i & taildesc_lsb_i;
end generate GEN_DESC_ADDR_EQL64;

-- Pass MM2S register direct signals out
reg_module_vsize               <= reg_module_vsize_i             ;
reg_module_hsize               <= reg_module_hsize_i             ;
reg_module_stride              <= reg_module_stride_i            ;
reg_module_frmdly              <= reg_module_frmdly_i            ;
reg_module_strt_addr           <= reg_module_strt_addr_i         ;


I_DMA_REGISTER : entity axi_vdma_v6_3_10.axi_vdma_register
generic map (
    C_NUM_REGISTERS             => NUM_REG_PER_CHANNEL      ,
    C_NUM_FSTORES               => C_NUM_FSTORES            ,
    C_NUM_FSTORES_64               => C_NUM_FSTORES_64            ,
    C_ENABLE_FLUSH_ON_FSYNC     => C_ENABLE_FLUSH_ON_FSYNC  , -- 
    --C_ENABLE_DEBUG_INFO         => C_ENABLE_DEBUG_INFO             ,
        C_ENABLE_DEBUG_ALL      => C_ENABLE_DEBUG_ALL             ,
        C_ENABLE_DEBUG_INFO_0        => C_ENABLE_DEBUG_INFO_0             ,
        C_ENABLE_DEBUG_INFO_1        => C_ENABLE_DEBUG_INFO_1             ,
        C_ENABLE_DEBUG_INFO_2        => C_ENABLE_DEBUG_INFO_2             ,
        C_ENABLE_DEBUG_INFO_3        => C_ENABLE_DEBUG_INFO_3             ,
        C_ENABLE_DEBUG_INFO_4        => C_ENABLE_DEBUG_INFO_4             ,
        C_ENABLE_DEBUG_INFO_5        => C_ENABLE_DEBUG_INFO_5             ,
        C_ENABLE_DEBUG_INFO_6        => C_ENABLE_DEBUG_INFO_6             ,
        C_ENABLE_DEBUG_INFO_7        => C_ENABLE_DEBUG_INFO_7             ,
        C_ENABLE_DEBUG_INFO_8        => C_ENABLE_DEBUG_INFO_8             ,
        C_ENABLE_DEBUG_INFO_9        => C_ENABLE_DEBUG_INFO_9             ,
        C_ENABLE_DEBUG_INFO_10       => C_ENABLE_DEBUG_INFO_10             ,
        C_ENABLE_DEBUG_INFO_11       => C_ENABLE_DEBUG_INFO_11             ,
        C_ENABLE_DEBUG_INFO_12       => C_ENABLE_DEBUG_INFO_12             ,
        C_ENABLE_DEBUG_INFO_13       => C_ENABLE_DEBUG_INFO_13             ,
        C_ENABLE_DEBUG_INFO_14       => C_ENABLE_DEBUG_INFO_14             ,
        C_ENABLE_DEBUG_INFO_15       => C_ENABLE_DEBUG_INFO_15             ,


    C_CHANNEL_IS_MM2S           => C_CHANNEL_IS_MM2S                      ,
    C_INTERNAL_GENLOCK_ENABLE   => C_INTERNAL_GENLOCK_ENABLE          ,

    C_LINEBUFFER_THRESH         => C_LINEBUFFER_THRESH      ,
    C_INCLUDE_SG                => C_INCLUDE_SG             ,
    C_GENLOCK_MODE              => C_GENLOCK_MODE           ,
    C_S_AXI_LITE_DATA_WIDTH     => C_S_AXI_LITE_DATA_WIDTH  ,
    C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH
)
port map(
    -- Secondary Clock / Reset
    prmry_aclk                  => prmry_aclk               ,
    prmry_resetn                => prmry_resetn             ,

    -- CPU Write Control (via AXI Lite)
    axi2ip_wrdata               => axi2ip_wrdata            ,
    axi2ip_wrce                 => axi2ip_wrce
                                    (THRESHOLD_INDEX
                                    downto DMACR_INDEX)     ,
    -- DMASR Register bit control/status
    stop_dma                    => stop                     ,
    halted_clr                  => halted_clr               ,
    halted_set                  => halted_set               ,
    idle_set                    => idle_set                 ,
    idle_clr                    => idle_clr                 ,
    ioc_irq_set                 => ioc_irq_set              ,
    dly_irq_set                 => dly_irq_set              ,
    irqdelay_status             => irqdelay_status          ,
    irqthresh_status            => irqthresh_status         ,
    dlyirq_dsble                => dlyirq_dsble             ,
    frame_sync                  => frame_sync               ,
    fsync_mask                  => fsync_mask               ,

    -- SG Error Control
    ftch_slverr_set             => ftch_slverr_set          ,
    ftch_decerr_set             => ftch_decerr_set          ,
    ftch_err_addr               => ftch_err_addr          ,
    frmstr_err_addr             => frmstr_err_addr        ,

    fsize_mismatch_err          => fsize_mismatch_err         ,   -- 
    lsize_mismatch_err          => lsize_mismatch_err           ,   -- 
    lsize_more_mismatch_err     => lsize_more_mismatch_err           ,   -- 
    s2mm_fsize_more_or_sof_late => s2mm_fsize_more_or_sof_late           ,   -- 

    dma_interr_set_minus_frame_errors              => dma_interr_set_minus_frame_errors           ,
    dma_interr_set              => dma_interr_set           ,
    dma_slverr_set              => dma_slverr_set           ,
    dma_decerr_set              => dma_decerr_set           ,
    irqthresh_wren              => irqthresh_wren_i         ,
    irqdelay_wren               => irqdelay_wren            ,
    introut                     => ip2axi_introut           ,
    soft_reset_clr              => soft_reset_clr           ,

    -- CURDESC Update
    update_curdesc              => new_curdesc_wren         ,
    new_curdesc                 => new_curdesc              ,
    update_frmstore             => update_frmstore          ,
    new_frmstr                  => new_frmstr               ,
    frm_store                   => frm_store                ,

    -- TAILDESC Update
    tailpntr_updated            => tailpntr_updated         ,

    -- Channel Registers
    dmacr                       => dmacr_i                  ,
    dmasr                       => dmasr_i                  ,
    dma_irq_mask                       => dma_irq_mask_i                  ,
    curdesc_lsb                 => curdesc_lsb_i            ,
    curdesc_msb                 => curdesc_msb_i            ,
    taildesc_lsb                => taildesc_lsb_i           ,
    reg_index                	=> reg_index_i           ,
    taildesc_msb                => taildesc_msb_i           ,
    num_frame_store_regmux      => num_frame_store_regmux_i        ,
    num_frame_store             => num_frame_store_i        ,
    linebuf_threshold           => linebuf_threshold_i
);


-- Mask off first fsync by asserting irqthresh wren.  This is to prevent decrementing
-- frame count before first frame transfers. Note: implemented this way to prevent
-- having to modify axi_sg helper core
irqthresh_wren <= irqthresh_wren_i or (tstvect_fsync and not valid_frame_sync);

-- If delay interrupt disabled then do not reset irq threshold on delay timeout
irqthresh_rstdsbl  <= not dmacr_i(DMACR_DLY_IRQEN_BIT);

-- Soft reset set in mm2s DMACR or s2MM DMACR
soft_reset <= dmacr_i(DMACR_RESET_BIT);


-- Park Pointer Reference Register Field
PARK_REF_REG : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                ptr_ref_i   <= (others => '0');

            -- CPU Write
            elsif(axi2ip_wrce(VDMA_PARKPTR_INDEX) = '1')then
                ptr_ref_i  <= axi2ip_wrdata(PARKPTR_FRMPTR_MSB_BIT
                                     downto PARKPTR_FRMPTR_LSB_BIT);

            else
                ptr_ref_i   <= ptr_ref_i;

            end if;
        end if;
    end process PARK_REF_REG;



VFLIP_FOR_S2MM : if C_ENABLE_VERT_FLIP = 1 and C_CHANNEL_IS_MM2S = 0 generate
begin

-- Vertical Flip Register Bit
VER_FLIP_REG : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                vflip_i   <= '1';

            -- CPU Write
            elsif(axi2ip_wrce(VERTICAL_FLIP_INDEX) = '1')then
                vflip_i  <= axi2ip_wrdata(0);

            else
                vflip_i   <= vflip_i;

            end if;
        end if;
    end process VER_FLIP_REG;

end generate VFLIP_FOR_S2MM;





-- In scatter gather mode, tie off register direct signals
GEN_SG_MODE : if C_INCLUDE_SG = 1 generate
begin
    reg_module_vsize_i             <= (others => '0');
    reg_module_hsize_i             <= (others => '0');
    reg_module_stride_i            <= (others => '0');
    reg_module_frmdly_i            <= (others => '0');

    -- Must zero each element of an array of vectors to zero
    -- all vectors.
    GEN_ZERO_STRT : for i in 0 to C_NUM_FSTORES-1 generate
        begin
            reg_module_strt_addr_i(i)   <= (others => '0');
    end generate GEN_ZERO_STRT;


    reg_module_start_address1_i    <= (others => '0');
    reg_module_start_address2_i    <= (others => '0');
    reg_module_start_address3_i    <= (others => '0');
    reg_module_start_address4_i    <= (others => '0');
    reg_module_start_address5_i    <= (others => '0');
    reg_module_start_address6_i    <= (others => '0');
    reg_module_start_address7_i    <= (others => '0');
    reg_module_start_address8_i    <= (others => '0');
    reg_module_start_address9_i    <= (others => '0');
    reg_module_start_address10_i   <= (others => '0');
    reg_module_start_address11_i   <= (others => '0');
    reg_module_start_address12_i   <= (others => '0');
    reg_module_start_address13_i   <= (others => '0');
    reg_module_start_address14_i   <= (others => '0');
    reg_module_start_address15_i   <= (others => '0');
    reg_module_start_address16_i   <= (others => '0');
    reg_module_start_address17_i   <= (others => '0');
    reg_module_start_address18_i   <= (others => '0');
    reg_module_start_address19_i   <= (others => '0');
    reg_module_start_address20_i   <= (others => '0');
    reg_module_start_address21_i   <= (others => '0');
    reg_module_start_address22_i   <= (others => '0');
    reg_module_start_address23_i   <= (others => '0');
    reg_module_start_address24_i   <= (others => '0');
    reg_module_start_address25_i   <= (others => '0');
    reg_module_start_address26_i   <= (others => '0');
    reg_module_start_address27_i   <= (others => '0');
    reg_module_start_address28_i   <= (others => '0');
    reg_module_start_address29_i   <= (others => '0');
    reg_module_start_address30_i   <= (others => '0');
    reg_module_start_address31_i   <= (others => '0');
    reg_module_start_address32_i   <= (others => '0');
    regdir_idle                    <= '1';
    regdir_wrack                   <= '0';   -- 
    prmtr_updt_complete            <= '0';
end generate GEN_SG_MODE;


-- In register direct mode instantiate register direct register block
GEN_REG_DIRECT_MODE : if C_INCLUDE_SG = 0 generate
begin
    REGDIRECT_I : entity  axi_vdma_v6_3_10.axi_vdma_regdirect
        generic map(
            C_NUM_REGISTERS             => NUM_DIRECT_REG_PER_CHANNEL           ,
            C_NUM_FSTORES               => C_NUM_FSTORES                        ,
            C_NUM_FSTORES_64               => C_NUM_FSTORES_64                        ,
    	    C_GENLOCK_MODE              => C_GENLOCK_MODE           ,
    	    C_DYNAMIC_RESOLUTION        => C_DYNAMIC_RESOLUTION           ,
            C_S_AXI_LITE_DATA_WIDTH     => C_S_AXI_LITE_DATA_WIDTH              ,
            C_M_AXI_ADDR_WIDTH          => C_M_AXI_ADDR_WIDTH
        )
        port map(
            prmry_aclk                  => prmry_aclk                           ,
            prmry_resetn                => prmry_resetn                         ,

            -- AXI Interface Control
            axi2ip_wrce                 => axi2ip_wrce(STARTADDR16_INDEX
                                            downto VSIZE_INDEX)                 ,
            --axi2ip_wrce                 => axi2ip_wrce(STARTADDR32_INDEX
            --                                downto VSIZE_INDEX)                 ,
            axi2ip_wrdata               => axi2ip_wrdata                        ,

            run_stop                    => dmacr_i(DMACR_RS_BIT)                ,
            dmasr_halt                  => dmasr_i(DMASR_HALTED_BIT)            ,
            stop                        => stop                                 ,
            regdir_idle                 => regdir_idle                          ,

            -- Register Direct Support
        reg_index                   => reg_index_i                           ,
            prmtr_updt_complete         => prmtr_updt_complete                  ,
            reg_module_vsize            => reg_module_vsize_i                   ,
            reg_module_hsize            => reg_module_hsize_i                   ,
            reg_module_strid            => reg_module_stride_i                  ,
            reg_module_frmdly           => reg_module_frmdly_i                  ,
            reg_module_strt_addr        => reg_module_strt_addr_i               ,

            -- Start address mapped for ReadMux
            reg_module_start_address1   => reg_module_start_address1_i          ,
            reg_module_start_address2   => reg_module_start_address2_i          ,
            reg_module_start_address3   => reg_module_start_address3_i          ,
            reg_module_start_address4   => reg_module_start_address4_i          ,
            reg_module_start_address5   => reg_module_start_address5_i          ,
            reg_module_start_address6   => reg_module_start_address6_i          ,
            reg_module_start_address7   => reg_module_start_address7_i          ,
            reg_module_start_address8   => reg_module_start_address8_i          ,
            reg_module_start_address9   => reg_module_start_address9_i          ,
            reg_module_start_address10  => reg_module_start_address10_i         ,
            reg_module_start_address11  => reg_module_start_address11_i         ,
            reg_module_start_address12  => reg_module_start_address12_i         ,
            reg_module_start_address13  => reg_module_start_address13_i         ,
            reg_module_start_address14  => reg_module_start_address14_i         ,
            reg_module_start_address15  => reg_module_start_address15_i         ,
            reg_module_start_address16  => reg_module_start_address16_i         ,
            reg_module_start_address17  => reg_module_start_address17_i         ,
            reg_module_start_address18  => reg_module_start_address18_i         ,
            reg_module_start_address19  => reg_module_start_address19_i         ,
            reg_module_start_address20  => reg_module_start_address20_i         ,
            reg_module_start_address21  => reg_module_start_address21_i         ,
            reg_module_start_address22  => reg_module_start_address22_i         ,
            reg_module_start_address23  => reg_module_start_address23_i         ,
            reg_module_start_address24  => reg_module_start_address24_i         ,
            reg_module_start_address25  => reg_module_start_address25_i         ,
            reg_module_start_address26  => reg_module_start_address26_i         ,
            reg_module_start_address27  => reg_module_start_address27_i         ,
            reg_module_start_address28  => reg_module_start_address28_i         ,
            reg_module_start_address29  => reg_module_start_address29_i         ,
            reg_module_start_address30  => reg_module_start_address30_i         ,
            reg_module_start_address31  => reg_module_start_address31_i         ,
            reg_module_start_address32  => reg_module_start_address32_i
        );
end generate GEN_REG_DIRECT_MODE;



--*****************************************************************************
-- AXI LITE READ MUX
--*****************************************************************************
LITE_READ_MUX_I : entity  axi_vdma_v6_3_10.axi_vdma_reg_mux
    generic map(
        C_TOTAL_NUM_REGISTER        => C_TOTAL_NUM_REGISTER                     ,
        C_INCLUDE_SG                => C_INCLUDE_SG                             ,
        C_CHANNEL_IS_MM2S           => C_CHANNEL_IS_MM2S                        ,
        C_NUM_FSTORES               => C_NUM_FSTORES                            ,
        C_NUM_FSTORES_64               => C_NUM_FSTORES_64                            ,
        C_ENABLE_VIDPRMTR_READS     => C_ENABLE_VIDPRMTR_READS                  ,
        C_S_AXI_LITE_ADDR_WIDTH     => C_S_AXI_LITE_ADDR_WIDTH                  ,
        C_S_AXI_LITE_DATA_WIDTH     => C_S_AXI_LITE_DATA_WIDTH                  ,
        C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH                    ,
        C_M_AXI_ADDR_WIDTH          => C_M_AXI_ADDR_WIDTH
    )
    port map (
        -----------------------------------------------------------------------
        -- AXI Lite Control Interface
        -----------------------------------------------------------------------
        axi2ip_rdaddr               => axi2ip_rdaddr                            ,
        axi2ip_rden                 => axi2ip_rden                              ,
        ip2axi_rddata               => ip2axi_rddata                            ,
        ip2axi_rddata_valid         => ip2axi_rddata_valid                      ,

        dmacr                       => dmacr_i                                  ,
        dmasr                       => dmasr_i                                  ,
        dma_irq_mask                       => dma_irq_mask_i                                  ,
        curdesc_lsb                 => curdesc_lsb_i                            ,
        curdesc_msb                 => curdesc_msb_i                            ,
        taildesc_lsb                => taildesc_lsb_i                           ,
        reg_index                   => reg_index_i                           ,
        taildesc_msb                => taildesc_msb_i                           ,
        num_frame_store             => num_frame_store_regmux_i                        ,
        linebuf_threshold           => linebuf_threshold_i                      ,
        reg_vflip_regmux            => vflip_i                              ,

        -- Register Direct Support
        reg_module_vsize            => reg_module_vsize_i                       ,
        reg_module_hsize            => reg_module_hsize_i                       ,
        reg_module_stride           => reg_module_stride_i                      ,
        reg_module_frmdly           => reg_module_frmdly_i                      ,
        reg_module_start_address1   => reg_module_start_address1_i              ,
        reg_module_start_address2   => reg_module_start_address2_i              ,
        reg_module_start_address3   => reg_module_start_address3_i              ,
        reg_module_start_address4   => reg_module_start_address4_i              ,
        reg_module_start_address5   => reg_module_start_address5_i              ,
        reg_module_start_address6   => reg_module_start_address6_i              ,
        reg_module_start_address7   => reg_module_start_address7_i              ,
        reg_module_start_address8   => reg_module_start_address8_i              ,
        reg_module_start_address9   => reg_module_start_address9_i              ,
        reg_module_start_address10  => reg_module_start_address10_i             ,
        reg_module_start_address11  => reg_module_start_address11_i             ,
        reg_module_start_address12  => reg_module_start_address12_i             ,
        reg_module_start_address13  => reg_module_start_address13_i             ,
        reg_module_start_address14  => reg_module_start_address14_i             ,
        reg_module_start_address15  => reg_module_start_address15_i             ,
        reg_module_start_address16  => reg_module_start_address16_i             ,
        reg_module_start_address17  => reg_module_start_address17_i             ,
        reg_module_start_address18  => reg_module_start_address18_i             ,
        reg_module_start_address19  => reg_module_start_address19_i             ,
        reg_module_start_address20  => reg_module_start_address20_i             ,
        reg_module_start_address21  => reg_module_start_address21_i             ,
        reg_module_start_address22  => reg_module_start_address22_i             ,
        reg_module_start_address23  => reg_module_start_address23_i             ,
        reg_module_start_address24  => reg_module_start_address24_i             ,
        reg_module_start_address25  => reg_module_start_address25_i             ,
        reg_module_start_address26  => reg_module_start_address26_i             ,
        reg_module_start_address27  => reg_module_start_address27_i             ,
        reg_module_start_address28  => reg_module_start_address28_i             ,
        reg_module_start_address29  => reg_module_start_address29_i             ,
        reg_module_start_address30  => reg_module_start_address30_i             ,
        reg_module_start_address31  => reg_module_start_address31_i             ,
        reg_module_start_address32  => reg_module_start_address32_i
    );

end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_reg_if
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_reg_if.vhd
-- Description: This entity is AXI VDMA Register Interface Top Level
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

library lib_cdc_v1_0_2;
-------------------------------------------------------------------------------
entity  axi_vdma_reg_if is
    generic(
        C_INCLUDE_MM2S              	: integer range 0 to 1      	:= 1;
            -- Include or exclude MM2S channel
            -- 0 = exclude mm2s channel
            -- 1 = include mm2s channel

        C_INCLUDE_S2MM              	: integer range 0 to 1      	:= 1;
            -- Include or exclude S2MM channel
            -- 0 = exclude s2mm channel
            -- 1 = include s2mm channel
        C_ENABLE_DEBUG_ALL       : integer range 0 to 1      	:= 1;
            -- Setting this make core backward compatible to 2012.4 version in terms of ports and registers
        C_ENABLE_DEBUG_INFO_0       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 0
        C_ENABLE_DEBUG_INFO_1       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 1
        C_ENABLE_DEBUG_INFO_2       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 2
        C_ENABLE_DEBUG_INFO_3       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 3
        C_ENABLE_DEBUG_INFO_4       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 4
        C_ENABLE_DEBUG_INFO_5       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 5
        C_ENABLE_DEBUG_INFO_6       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 6
        C_ENABLE_DEBUG_INFO_7       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 7
        C_ENABLE_DEBUG_INFO_8       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 8
        C_ENABLE_DEBUG_INFO_9       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 9
        C_ENABLE_DEBUG_INFO_10      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 10
        C_ENABLE_DEBUG_INFO_11      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 11
        C_ENABLE_DEBUG_INFO_12      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 12
        C_ENABLE_DEBUG_INFO_13      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 13
        C_ENABLE_DEBUG_INFO_14      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 14
        C_ENABLE_DEBUG_INFO_15      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 15






        C_INCLUDE_SG                    : integer range 0 to 1   	:= 1;
            -- Include or Exclude Scatter Gather Engine
            -- 0 = Exclude Scatter Gather Engine (Enables Register Direct Mode)
            -- 1 = Include Scatter Gather Engine

        C_ENABLE_VIDPRMTR_READS         : integer range 0 to 1   	:= 1;
            -- Specifies whether video parameters are readable by axi_lite interface
            -- when configure for Register Direct Mode
            -- 0 = Disable Video Parameter Reads (Saves FPGA Resources)
            -- 1 = Enable Video Parameter Reads

        C_TOTAL_NUM_REGISTER            : integer                	:= 8;
            -- Number of register CE's

        C_PRMRY_IS_ACLK_ASYNC         	: integer range 0 to 1     	:= 0;
            -- Specifies the AXI Lite clock is asynchronous
            -- 0 = AXI Clocks are Synchronous
            -- 1 = AXI Clocks are Asynchronous

        C_S_AXI_LITE_ADDR_WIDTH     	: integer range 9 to 9    	:= 9;
            -- AXI Lite interface address width

        C_S_AXI_LITE_DATA_WIDTH     	: integer range 32 to 32    	:= 32;
            -- AXI Lite interface data width

        C_VERSION_MAJOR             	: std_logic_vector (3 downto 0) := X"1" ;
            -- Major Version number 0, 1, 2, 3 etc.

        C_VERSION_MINOR             	: std_logic_vector (7 downto 0) := X"00";
            -- Minor Version Number 00, 01, 02, etc.

        C_VERSION_REVISION          	: std_logic_vector (3 downto 0) := X"a" ;
            -- Version Revision character (EDK) a,b,c,etc

        C_REVISION_NUMBER           	: string 			:= "Build Number: 0000"
            -- Internal build number
    );
    port (
        -----------------------------------------------------------------------
        -- AXI Lite Control Interface
        -----------------------------------------------------------------------
        s_axi_lite_aclk             : in  std_logic                                 ;       --
        s_axi_lite_reset_n          : in  std_logic                                 ;       --
                                                                                            --
        -- AXI Lite Write Address Channel                                                   --
        s_axi_lite_awvalid          : in  std_logic                                 ;       --
        s_axi_lite_awready          : out std_logic                                 ;       --
        s_axi_lite_awaddr           : in  std_logic_vector                                  --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0)        ;       --
                                                                                            --
        -- AXI Lite Write Data Channel                                                      --
        s_axi_lite_wvalid           : in  std_logic                                 ;       --
        s_axi_lite_wready           : out std_logic                                 ;       --
        s_axi_lite_wdata            : in  std_logic_vector                                  --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)        ;       --
                                                                                            --
        -- AXI Lite Write Response Channel                                                  --
        s_axi_lite_bresp            : out std_logic_vector(1 downto 0)              ;       --
        s_axi_lite_bvalid           : out std_logic                                 ;       --
        s_axi_lite_bready           : in  std_logic                                 ;       --
                                                                                            --
        -- AXI Lite Read Address Channel                                                    --
        s_axi_lite_arvalid          : in  std_logic                                 ;       --
        s_axi_lite_arready          : out std_logic                                 ;       --
        s_axi_lite_araddr           : in  std_logic_vector                                  --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0)        ;       --
        s_axi_lite_rvalid           : out std_logic                                 ;       --
        s_axi_lite_rready           : in  std_logic                                 ;       --
        s_axi_lite_rdata            : out std_logic_vector                                  --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)        ;       --
        s_axi_lite_rresp            : out std_logic_vector(1 downto 0)              ;       --
                                                                                            --
                                                                                            --
        -- MM2S Register Interface                                                          --
        m_axi_mm2s_aclk             : in  std_logic                                 ;       --
        mm2s_hrd_resetn             : in  std_logic                                 ;       --
        mm2s_axi2ip_wrce            : out  std_logic_vector                                 --
                                        (C_TOTAL_NUM_REGISTER-1 downto 0)           ;       --
        mm2s_axi2ip_wrdata          : out  std_logic_vector                                 --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)        ;       --
        mm2s_axi2ip_rdaddr          : out std_logic_vector                                  --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0)        ;       --
        mm2s_ip2axi_rddata          : in std_logic_vector                               --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  ;          --
        mm2s_ip2axi_frame_ptr_ref   : in  std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)             ;       --
        mm2s_ip2axi_frame_store     : in  std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)             ;       --
        mm2s_ip2axi_introut         : in  std_logic                                 ;       --
                                                                                            --
                                                                                            --
        -- S2MM Register Interface                                                          --

        m_axi_s2mm_aclk             : in  std_logic                                 ;       --
        s2mm_hrd_resetn             : in  std_logic                                 ;       --



        s2mm_axi2ip_wrce            : out std_logic_vector                                  --
                                        (C_TOTAL_NUM_REGISTER-1 downto 0)           ;       --
        s2mm_axi2ip_wrdata          : out std_logic_vector                                  --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)        ;       --
                                                                                            --
        s2mm_ip2axi_rddata          : in std_logic_vector                               --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  ;          --
        s2mm_axi2ip_rdaddr          : out std_logic_vector                                  --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0)        ;       --
        s2mm_ip2axi_frame_ptr_ref   : in  std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)             ;       --
        s2mm_ip2axi_frame_store     : in  std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)             ;       --
        s2mm_ip2axi_introut         : in  std_logic                                 ;       --


s2mm_capture_dm_done_vsize_counter  :  in std_logic_vector(12 downto 0) ;
s2mm_capture_hsize_at_uf_err        :  in std_logic_vector(15 downto 0) ;

        mm2s_chnl_current_frame     : in std_logic_vector
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        mm2s_genlock_pair_frame     : in std_logic_vector
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --

        s2mm_chnl_current_frame     : in std_logic_vector
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        s2mm_genlock_pair_frame     : in std_logic_vector
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --

        -- Interrupt Out                                                                    --
        mm2s_introut                : out std_logic                                 ;       --
        s2mm_introut                : out std_logic                                         --


    );
end axi_vdma_reg_if;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_reg_if is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant AXI_LITE_SYNC      : integer := 0;

constant ZERO_VALUE_VECT    : std_logic_vector(128 downto 0) := (others => '0');

-- PARK_PTR_REF Register constants
constant PARK_PAD_WIDTH     : integer := (C_S_AXI_LITE_DATA_WIDTH - (FRAME_NUMBER_WIDTH * 4))/4;
constant PARK_REG_PAD       : std_logic_vector(PARK_PAD_WIDTH-1 downto 0) := (others => '0');




-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
--signal axi2ip_rden                  			: std_logic := '0';
signal ip2axi_rddata_common_region  			: std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');

-- version signals
signal rev_num                      			: integer := string2int(C_REVISION_NUMBER);
signal vdma_version_i               			: std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) 	:= (others => '0');
signal park_ptr_ref_i               			: std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) 	:= (others => '0');
signal genlock_frm_ptr_i            			: std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) 	:= (others => '0');
signal s2mm_hsize_at_lsize_less_err 			: std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) 	:= (others => '0');
signal s2mm_vsize_at_fsize_less_err 			: std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) 	:= (others => '0');

signal mm2s_frame_ptr_ref           			: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal mm2s_frame_store             			: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal mm2s_chnl_current_frame_i    			: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal mm2s_genlock_pair_frame_i    			: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');

signal s2mm_frame_ptr_ref           			: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal s2mm_frame_store             			: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal s2mm_chnl_current_frame_i    			: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal s2mm_genlock_pair_frame_i    			: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');

signal sig_axi2ip_common_region_1_rden                  : std_logic 						:= '0';
signal sig_axi2ip_common_region_2_rden                  : std_logic 						:= '0';
signal read_region_mux_select              		: std_logic_vector(3 downto 0) 				:= (others => '0');
signal sig_axi2ip_lite_rdaddr          			: std_logic_vector(C_S_AXI_LITE_ADDR_WIDTH-1 downto 0)	:= (others => '0');           --


signal mm2s_ip2axi_frame_ptr_ref_cdc_tig           	: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal mm2s_ip2axi_frame_store_cdc_tig             	: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal mm2s_chnl_current_frame_cdc_tig    		: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal mm2s_genlock_pair_frame_cdc_tig    		: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal s2mm_ip2axi_frame_ptr_ref_cdc_tig		: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal s2mm_ip2axi_frame_store_cdc_tig 			: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal s2mm_chnl_current_frame_cdc_tig 			: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal s2mm_genlock_pair_frame_cdc_tig 			: std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal s2mm_capture_hsize_at_uf_err_cdc_tig		: std_logic_vector(15 downto 0) 			:= (others => '0');
signal s2mm_capture_dm_done_vsize_counter_cdc_tig	: std_logic_vector(12 downto 0) 			:= (others => '0');


  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF mm2s_ip2axi_frame_ptr_ref_cdc_tig         : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF mm2s_ip2axi_frame_store_cdc_tig           : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF mm2s_chnl_current_frame_cdc_tig    	   : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF mm2s_genlock_pair_frame_cdc_tig    	   : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s2mm_ip2axi_frame_ptr_ref_cdc_tig	   : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s2mm_ip2axi_frame_store_cdc_tig 	   : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s2mm_chnl_current_frame_cdc_tig 	   : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s2mm_genlock_pair_frame_cdc_tig 	   : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s2mm_capture_hsize_at_uf_err_cdc_tig	   : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF s2mm_capture_dm_done_vsize_counter_cdc_tig  : SIGNAL IS "true"; 

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin





read_region_mux_select(3) 		<= sig_axi2ip_common_region_2_rden ;
read_region_mux_select(2) 		<= sig_axi2ip_common_region_1_rden ;
read_region_mux_select(1 downto 0) 	<= sig_axi2ip_lite_rdaddr(3 downto 2);





-------------------------------------------------------------------------------
-- Generate AXI Lite Inteface
-------------------------------------------------------------------------------
GEN_AXI_LITE_IF : if C_INCLUDE_MM2S = 1 or C_INCLUDE_S2MM = 1 generate
begin
    AXI_LITE_IF_I : entity axi_vdma_v6_3_10.axi_vdma_lite_if
        generic map(
            C_NUM_CE                    => C_TOTAL_NUM_REGISTER     ,
            C_MM2S_IS                   => C_INCLUDE_MM2S           ,
            C_S2MM_IS                   => C_INCLUDE_S2MM           ,
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC    ,
            C_S_AXI_LITE_ADDR_WIDTH     => C_S_AXI_LITE_ADDR_WIDTH  ,
            C_S_AXI_LITE_DATA_WIDTH     => C_S_AXI_LITE_DATA_WIDTH
        )
        port map(
            s_axi_lite_aclk             => s_axi_lite_aclk          ,
            s_axi_lite_aresetn          => s_axi_lite_reset_n       ,

            m_axi_mm2s_aclk             => m_axi_mm2s_aclk                      ,
            mm2s_hrd_resetn             => mm2s_hrd_resetn                      ,

            m_axi_s2mm_aclk             => m_axi_s2mm_aclk                      ,
            s2mm_hrd_resetn             => s2mm_hrd_resetn                      ,

            -- AXI Lite Write Address Channel
            s_axi_lite_awvalid          => s_axi_lite_awvalid       ,
            s_axi_lite_awready          => s_axi_lite_awready       ,
            s_axi_lite_awaddr           => s_axi_lite_awaddr        ,

            -- AXI Lite Write Data Channel
            s_axi_lite_wvalid           => s_axi_lite_wvalid        ,
            s_axi_lite_wready           => s_axi_lite_wready        ,
            s_axi_lite_wdata            => s_axi_lite_wdata         ,

            -- AXI Lite Write Response Channel
            s_axi_lite_bresp            => s_axi_lite_bresp         ,
            s_axi_lite_bvalid           => s_axi_lite_bvalid        ,
            s_axi_lite_bready           => s_axi_lite_bready        ,

            -- AXI Lite Read Address Channel
            s_axi_lite_arvalid          => s_axi_lite_arvalid       ,
            s_axi_lite_arready          => s_axi_lite_arready       ,
            s_axi_lite_araddr           => s_axi_lite_araddr        ,
            s_axi_lite_rvalid           => s_axi_lite_rvalid        ,
            s_axi_lite_rready           => s_axi_lite_rready        ,
            s_axi_lite_rdata            => s_axi_lite_rdata         ,
            s_axi_lite_rresp            => s_axi_lite_rresp         ,

            axi2ip_common_region_1_rden => sig_axi2ip_common_region_1_rden              ,
            axi2ip_common_region_2_rden => sig_axi2ip_common_region_2_rden              ,
            axi2ip_lite_rdaddr          => sig_axi2ip_lite_rdaddr            ,

            mm2s_axi2ip_wrce            => mm2s_axi2ip_wrce              ,
            mm2s_axi2ip_wrdata          => mm2s_axi2ip_wrdata            ,
            mm2s_ip2axi_rddata          => mm2s_ip2axi_rddata              ,
            mm2s_axi2ip_rdaddr          => mm2s_axi2ip_rdaddr            ,
            s2mm_axi2ip_wrce            => s2mm_axi2ip_wrce              ,
            s2mm_axi2ip_wrdata          => s2mm_axi2ip_wrdata            ,
            s2mm_ip2axi_rddata          => s2mm_ip2axi_rddata              ,
            s2mm_axi2ip_rdaddr          => s2mm_axi2ip_rdaddr            ,
            ip2axi_rddata_common_region => ip2axi_rddata_common_region

        );
end generate GEN_AXI_LITE_IF;

-------------------------------------------------------------------------------
-- No channels therefore do not generate an AXI Lite interface
-------------------------------------------------------------------------------
GEN_NO_AXI_LITE_IF : if C_INCLUDE_MM2S = 0 and C_INCLUDE_S2MM = 0 generate
begin
    s_axi_lite_awready          <= '0';
    s_axi_lite_wready           <= '0';
    s_axi_lite_bresp            <= (others => '0');
    s_axi_lite_bvalid           <= '0';
    s_axi_lite_arready          <= '0';
    s_axi_lite_rvalid           <= '0';
    s_axi_lite_rdata            <= (others => '0');
    s_axi_lite_rresp            <= (others => '0');

end generate GEN_NO_AXI_LITE_IF;

-------------------------------------------------------------------------------
-- Generate MM2S Registers if included
-------------------------------------------------------------------------------
GEN_MM2S_LITE_CROSSINGS : if C_INCLUDE_MM2S = 1 generate
begin

  GEN_MM2S_CROSSINGS_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
  

        mm2s_frame_ptr_ref  		<= mm2s_ip2axi_frame_ptr_ref;
        mm2s_frame_store    		<= mm2s_ip2axi_frame_store;
        mm2s_chnl_current_frame_i    	<= mm2s_chnl_current_frame;
        mm2s_genlock_pair_frame_i    	<= mm2s_genlock_pair_frame;
        mm2s_introut            	<= mm2s_ip2axi_introut;


  end generate GEN_MM2S_CROSSINGS_SYNC;

  GEN_MM2S_CROSSINGS_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
  

        mm2s_frame_ptr_ref  			<= mm2s_ip2axi_frame_ptr_ref_cdc_tig;
        mm2s_frame_store    			<= mm2s_ip2axi_frame_store_cdc_tig;
        mm2s_chnl_current_frame_i    		<= mm2s_chnl_current_frame_cdc_tig;
        mm2s_genlock_pair_frame_i    		<= mm2s_genlock_pair_frame_cdc_tig;


GEN_LITE_MM2S_MISC_CROSSING : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then


        mm2s_ip2axi_frame_ptr_ref_cdc_tig  	<= mm2s_ip2axi_frame_ptr_ref;
        mm2s_ip2axi_frame_store_cdc_tig    	<= mm2s_ip2axi_frame_store;
        mm2s_chnl_current_frame_cdc_tig    	<= mm2s_chnl_current_frame;
        mm2s_genlock_pair_frame_cdc_tig    	<= mm2s_genlock_pair_frame;


        end if;
    end process GEN_LITE_MM2S_MISC_CROSSING;


MM2S_INTRPT_CROSSING_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES_LITE
    )
    port map (
        prmry_aclk                 => m_axi_mm2s_aclk,
        prmry_resetn               => mm2s_hrd_resetn, 
        prmry_in                   => mm2s_ip2axi_introut, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axi_lite_aclk, 
        scndry_resetn              => s_axi_lite_reset_n,
        scndry_out                 => mm2s_introut,
        scndry_vect_out            => open
    );



  end generate GEN_MM2S_CROSSINGS_ASYNC;





end generate GEN_MM2S_LITE_CROSSINGS;

-------------------------------------------------------------------------------
-- Tie MM2S Register outputs to zero if excluded
-------------------------------------------------------------------------------
GEN_NO_MM2S_CROSSINGS : if C_INCLUDE_MM2S = 0 generate
begin
    mm2s_introut                <= '0';
    mm2s_frame_ptr_ref  	<= (others => '0');
    mm2s_frame_store    	<= (others => '0');
    mm2s_chnl_current_frame_i   <= (others => '0');
    mm2s_genlock_pair_frame_i   <= (others => '0');

end generate GEN_NO_MM2S_CROSSINGS;


-------------------------------------------------------------------------------
-- Generate S2MM Registers if included
-------------------------------------------------------------------------------
GEN_S2MM_LITE_CROSSINGS : if C_INCLUDE_S2MM = 1 generate
begin

  GEN_S2MM_CROSSINGS_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate

        s2mm_frame_ptr_ref  				<= s2mm_ip2axi_frame_ptr_ref;
        s2mm_frame_store    				<= s2mm_ip2axi_frame_store;
        s2mm_chnl_current_frame_i    			<= s2mm_chnl_current_frame;
        s2mm_genlock_pair_frame_i    			<= s2mm_genlock_pair_frame;
        s2mm_introut        				<= s2mm_ip2axi_introut;
	s2mm_hsize_at_lsize_less_err(15 downto 0)	<= s2mm_capture_hsize_at_uf_err(15 downto 0);
	s2mm_vsize_at_fsize_less_err(12 downto 0)	<= s2mm_capture_dm_done_vsize_counter(12 downto 0);

  end generate GEN_S2MM_CROSSINGS_SYNC;

  GEN_S2MM_CROSSINGS_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate

        s2mm_frame_ptr_ref  				<= s2mm_ip2axi_frame_ptr_ref_cdc_tig;
        s2mm_frame_store    				<= s2mm_ip2axi_frame_store_cdc_tig;
        s2mm_chnl_current_frame_i    			<= s2mm_chnl_current_frame_cdc_tig;
        s2mm_genlock_pair_frame_i    			<= s2mm_genlock_pair_frame_cdc_tig;
	s2mm_hsize_at_lsize_less_err(15 downto 0)	<= s2mm_capture_hsize_at_uf_err_cdc_tig(15 downto 0);
	s2mm_vsize_at_fsize_less_err(12 downto 0)	<= s2mm_capture_dm_done_vsize_counter_cdc_tig(12 downto 0);


GEN_LITE_S2MM_MISC_CROSSING : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then


        s2mm_ip2axi_frame_ptr_ref_cdc_tig  			<= s2mm_ip2axi_frame_ptr_ref;
        s2mm_ip2axi_frame_store_cdc_tig    			<= s2mm_ip2axi_frame_store;
        s2mm_chnl_current_frame_cdc_tig    			<= s2mm_chnl_current_frame;
        s2mm_genlock_pair_frame_cdc_tig    			<= s2mm_genlock_pair_frame;
	s2mm_capture_hsize_at_uf_err_cdc_tig(15 downto 0)	<= s2mm_capture_hsize_at_uf_err(15 downto 0);
	s2mm_capture_dm_done_vsize_counter_cdc_tig(12 downto 0)	<= s2mm_capture_dm_done_vsize_counter(12 downto 0);


        end if;
    end process GEN_LITE_S2MM_MISC_CROSSING;




S2MM_INTRPT_CROSSING_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES_LITE
    )
    port map (
        prmry_aclk                 => m_axi_s2mm_aclk,
        prmry_resetn               => s2mm_hrd_resetn, 
        prmry_in                   => s2mm_ip2axi_introut, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axi_lite_aclk, 
        scndry_resetn              => s_axi_lite_reset_n,
        scndry_out                 => s2mm_introut,
        scndry_vect_out            => open
    );




  end generate GEN_S2MM_CROSSINGS_ASYNC;



end generate GEN_S2MM_LITE_CROSSINGS;

-------------------------------------------------------------------------------
-- Tie S2MM Register outputs to zero if excluded
-------------------------------------------------------------------------------
GEN_NO_S2MM_CROSSINGS : if C_INCLUDE_S2MM = 0 generate
begin

    	s2mm_introut                			<= '0';
        s2mm_frame_ptr_ref  				<= (others => '0');
        s2mm_frame_store    				<= (others => '0');
        s2mm_chnl_current_frame_i    			<= (others => '0');
        s2mm_genlock_pair_frame_i    			<= (others => '0');
	s2mm_hsize_at_lsize_less_err(15 downto 0)	<= (others => '0');
	s2mm_vsize_at_fsize_less_err(12 downto 0)	<= (others => '0');


end generate GEN_NO_S2MM_CROSSINGS;


s2mm_hsize_at_lsize_less_err(31 downto 16)		<= (others => '0');
s2mm_vsize_at_fsize_less_err(31 downto 13)		<= (others => '0');


--*****************************************************************************
-- GenLock frame number Reference Register (located here because mm2s and s2mm are
-- combined into this one register)
--*****************************************************************************

genlock_frm_ptr_i(31 downto 29)  <= (others => '0');
genlock_frm_ptr_i(28 downto 24)  <= s2mm_genlock_pair_frame_i;
genlock_frm_ptr_i(23 downto 21)  <= (others => '0');
genlock_frm_ptr_i(20 downto 16)  <= s2mm_chnl_current_frame_i;
genlock_frm_ptr_i(15 downto 13)  <= (others => '0');
genlock_frm_ptr_i(12 downto 8)   <= mm2s_genlock_pair_frame_i;
genlock_frm_ptr_i(7 downto 5)    <= (others => '0');
genlock_frm_ptr_i(4 downto 0)    <= mm2s_chnl_current_frame_i;

--*****************************************************************************
-- Park Pointer Reference Register (located here because mm2s and s2mm are
-- combined into this one register)
--*****************************************************************************
park_ptr_ref_i <= PARK_REG_PAD
                & s2mm_frame_store
                & PARK_REG_PAD
                & mm2s_frame_store
                & PARK_REG_PAD
                & s2mm_frame_ptr_ref
                & PARK_REG_PAD
                & mm2s_frame_ptr_ref;

--*****************************************************************************
-- VDMA Version (located here because it is not unique to one particular
-- channel)
--*****************************************************************************
vdma_version_i(31 downto 16) <= (C_VERSION_MAJOR & C_VERSION_MINOR & C_VERSION_REVISION);
vdma_version_i(15 downto 0)  <= std_logic_vector(to_unsigned(rev_num,16));


--*****************************************************************************
-- Read access to common_Region_1 (0x20 to 0x2C) or common_Region_2 (0xF0 to 0xFC)
--*****************************************************************************

GEN_COMMON_REGION_READ_MUX_STS_REG : if (C_ENABLE_DEBUG_INFO_12 = 1 or C_ENABLE_DEBUG_ALL = 1) generate
begin



COMMON_REGION_READ_MUX : process(read_region_mux_select,
                         park_ptr_ref_i,genlock_frm_ptr_i,s2mm_hsize_at_lsize_less_err, s2mm_vsize_at_fsize_less_err,
                         vdma_version_i
                         )
    begin
        case read_region_mux_select is

            when "0101" => -- GenLock Frame ptr capture 	0x24
                ip2axi_rddata_common_region       <= genlock_frm_ptr_i;
            when "0110" => -- Park ptr 				0x28
                ip2axi_rddata_common_region       <= park_ptr_ref_i;
            when "0111" => -- VDMA version			0x2C
                ip2axi_rddata_common_region       <= vdma_version_i;
            when "1000" => -- S2MM HSIZE STS 			0xF0
                ip2axi_rddata_common_region       <= s2mm_hsize_at_lsize_less_err;
            when "1001" => -- S2MM VSIZE STS			0xF4
                ip2axi_rddata_common_region       <= s2mm_vsize_at_fsize_less_err;
            when others => -- RESERVED				0x20, 0xF8, 0xFC
                ip2axi_rddata_common_region       <= (others => '0');

        end case;
    end process COMMON_REGION_READ_MUX;

end generate GEN_COMMON_REGION_READ_MUX_STS_REG;

GEN_COMMON_REGION_READ_MUX_NO_STS_REG : if (C_ENABLE_DEBUG_INFO_12 = 0 and C_ENABLE_DEBUG_ALL = 0) generate
begin



COMMON_REGION_READ_MUX : process(read_region_mux_select,
                         park_ptr_ref_i,
                         vdma_version_i
                         )
    begin
        case read_region_mux_select is

            --when "0101" => -- GenLock Frame ptr capture 	0x24
            --    ip2axi_rddata_common_region       <= genlock_frm_ptr_i;
            when "0110" => -- Park ptr 				0x28
                ip2axi_rddata_common_region       <= park_ptr_ref_i;
            when "0111" => -- VDMA version			0x2C
                ip2axi_rddata_common_region       <= vdma_version_i;
            --when "1000" => -- S2MM HSIZE STS 			0xF0
            --    ip2axi_rddata_common_region       <= s2mm_hsize_at_lsize_less_err;
            --when "1001" => -- S2MM VSIZE STS			0xF4
            --    ip2axi_rddata_common_region       <= s2mm_vsize_at_fsize_less_err;
            when others => -- RESERVED				0x20, 0x24, 0xF0, 0xF4, 0xF8, 0xFC
                ip2axi_rddata_common_region       <= (others => '0');

        end case;
    end process COMMON_REGION_READ_MUX;

end generate GEN_COMMON_REGION_READ_MUX_NO_STS_REG;






end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_intrpt
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_intrpt.vhd
-- Description: This entity handles interrupt coalescing
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;
use lib_pkg_v1_0_2.lib_pkg.max2;

-------------------------------------------------------------------------------
entity  axi_vdma_intrpt is
    generic(

        C_INCLUDE_CH1                  	: integer range 0 to 1       := 1    ;
            -- Include or exclude MM2S primary data path
            -- 0 = Exclude MM2S primary data path
            -- 1 = Include MM2S primary data path
        --C_ENABLE_DEBUG_INFO             : string := "1111111111111111";		-- 1 to 16 -- 
        --C_ENABLE_DEBUG_INFO             : bit_vector(15 downto 0) 	:= (others => '1');		--15 downto 0  -- 
        C_ENABLE_DEBUG_ALL       : integer range 0 to 1      	:= 1;
            -- Setting this make core backward compatible to 2012.4 version in terms of ports and registers
        C_ENABLE_DEBUG_INFO_0       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 0
        C_ENABLE_DEBUG_INFO_1       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 1
        C_ENABLE_DEBUG_INFO_2       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 2
        C_ENABLE_DEBUG_INFO_3       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 3
        C_ENABLE_DEBUG_INFO_4       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 4
        C_ENABLE_DEBUG_INFO_5       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 5
        C_ENABLE_DEBUG_INFO_6       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 6
        C_ENABLE_DEBUG_INFO_7       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 7
        C_ENABLE_DEBUG_INFO_8       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 8
        C_ENABLE_DEBUG_INFO_9       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 9
        C_ENABLE_DEBUG_INFO_10      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 10
        C_ENABLE_DEBUG_INFO_11      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 11
        C_ENABLE_DEBUG_INFO_12      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 12
        C_ENABLE_DEBUG_INFO_13      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 13
        C_ENABLE_DEBUG_INFO_14      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 14
        C_ENABLE_DEBUG_INFO_15      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 15





        C_INCLUDE_CH2                  	: integer range 0 to 1       := 1    ;
            -- Include or exclude S2MM primary data path
            -- 0 = Exclude S2MM primary data path
            -- 1 = Include S2MM primary data path

        C_INCLUDE_DLYTMR            	: integer range 0 to 1       := 1    ;
            -- Include/Exclude interrupt delay timer
            -- 0 = Exclude Delay timer
            -- 1 = Include Delay timer

        C_DLYTMR_RESOLUTION         	: integer range 1 to 100000  := 125
            -- Interrupt Delay Timer resolution in usec

    );
    port (

        -- Secondary Clock and Reset
        m_axi_ch1_aclk              : in  std_logic                         ;              --
        m_axi_ch1_aresetn           : in  std_logic                         ;              --
                                                                                           --
        m_axi_ch2_aclk              : in  std_logic                         ;              --
        m_axi_ch2_aresetn           : in  std_logic                         ;              --
                                                                                           --
        ch1_irqthresh_decr          : in  std_logic                         ;-- 
        ch1_irqthresh_decr_mask     : in  std_logic                         ;-- 
        ch1_irqthresh_rstdsbl       : in  std_logic                         ;-- 
        ch1_dlyirq_dsble            : in  std_logic                         ;              --
        ch1_irqdelay_wren           : in  std_logic                         ;              --
        ch1_irqdelay                : in  std_logic_vector(7 downto 0)      ;              --
        ch1_irqthresh_wren          : in  std_logic                         ;              --
        ch1_irqthresh               : in  std_logic_vector(7 downto 0)      ;              --
        ch1_packet_sof              : in  std_logic                         ;              --
        ch1_packet_eof              : in  std_logic                         ;              --
        ch1_packet_eof_mask         : in  std_logic                         ;              --
        ch1_ioc_irq_set             : out std_logic                         ;              --
        ch1_dly_irq_set             : out std_logic                         ;              --
        ch1_irqdelay_status         : out std_logic_vector(7 downto 0)      ;              --
        ch1_irqthresh_status        : out std_logic_vector(7 downto 0)      ;              --
                                                                                           --
        ch2_irqthresh_decr          : in  std_logic                         ;-- 
        ch2_irqthresh_decr_mask     : in  std_logic                         ;-- 
        ch2_irqthresh_rstdsbl       : in  std_logic                         ;-- 
        ch2_dlyirq_dsble            : in  std_logic                         ;              --
        ch2_irqdelay_wren           : in  std_logic                         ;              --
        ch2_irqdelay                : in  std_logic_vector(7 downto 0)      ;              --
        ch2_irqthresh_wren          : in  std_logic                         ;              --
        ch2_irqthresh               : in  std_logic_vector(7 downto 0)      ;              --
        ch2_packet_sof              : in  std_logic                         ;              --
        ch2_packet_eof              : in  std_logic                         ;              --
        ch2_packet_eof_mask         : in  std_logic                         ;              --
        ch2_ioc_irq_set             : out std_logic                         ;              --
        ch2_dly_irq_set             : out std_logic                         ;              --
        ch2_irqdelay_status         : out std_logic_vector(7 downto 0)      ;              --
        ch2_irqthresh_status        : out std_logic_vector(7 downto 0)                     --

    );

end axi_vdma_intrpt;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_intrpt is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- Delay interrupt fast counter width
constant FAST_COUNT_WIDTH   : integer := clog2(C_DLYTMR_RESOLUTION+1);
-- Delay interrupt fast counter terminal count
constant FAST_COUNT_TC      : std_logic_vector(FAST_COUNT_WIDTH-1 downto 0)
                                := std_logic_vector(to_unsigned(
                                (C_DLYTMR_RESOLUTION-1),FAST_COUNT_WIDTH));




-- Delay interrupt fast counter zero value
constant ZERO_FAST_COUNT    : std_logic_vector(FAST_COUNT_WIDTH-1 downto 0)
                                := (others => '0');

constant ZERO_VALUE         : std_logic_vector(7 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal ch1_thresh_count    : std_logic_vector(7 downto 0) := ONE_THRESHOLD;
signal ch1_dly_irq_set_i   : std_logic := '0';
signal ch1_ioc_irq_set_i   : std_logic := '0';

signal ch1_delay_count     : std_logic_vector(7 downto 0) := (others => '0');
signal ch1_delay_cnt_en    : std_logic := '0';
signal ch1_dly_fast_cnt    : std_logic_vector(FAST_COUNT_WIDTH-1 downto 0) := (others => '0');
signal ch1_dly_fast_incr   : std_logic := '0';
signal ch1_delay_zero      : std_logic := '0';
signal ch1_delay_tc        : std_logic := '0';
signal ch1_disable_delay   : std_logic := '0';

signal ch2_thresh_count    : std_logic_vector(7 downto 0) := ONE_THRESHOLD;
signal ch2_dly_irq_set_i   : std_logic := '0';
signal ch2_ioc_irq_set_i   : std_logic := '0';

signal ch2_delay_count     : std_logic_vector(7 downto 0) := (others => '0');
signal ch2_delay_cnt_en    : std_logic := '0';
signal ch2_dly_fast_cnt    : std_logic_vector(FAST_COUNT_WIDTH-1 downto 0) := (others => '0');
signal ch2_dly_fast_incr   : std_logic := '0';
signal ch2_delay_zero      : std_logic := '0';
signal ch2_delay_tc        : std_logic := '0';
signal ch2_disable_delay   : std_logic := '0';
signal ch1_irqthresh_decr_mask_sig   : std_logic := '0';
signal ch2_irqthresh_decr_mask_sig   : std_logic := '0';


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

-- Transmit channel included therefore generate transmit interrupt logic
GEN_INCLUDE_MM2S : if C_INCLUDE_CH1 = 1 generate
begin


GEN_CH1_FRM_CNTR : if (C_ENABLE_DEBUG_INFO_7 = 1 or C_ENABLE_DEBUG_ALL = 1) generate
begin
    REG_THRESH_COUNT : process(m_axi_ch1_aclk)
        begin
            if(m_axi_ch1_aclk'EVENT and m_axi_ch1_aclk = '1')then
                if(m_axi_ch1_aresetn = '0')then
                    ch1_thresh_count   <= ONE_THRESHOLD;
                    ch1_ioc_irq_set_i  <= '0';

                -- New Threshold set by CPU OR delay interrupt event occured.
                elsif( (ch1_irqthresh_wren = '1')
                    or (ch1_dly_irq_set_i = '1' and ch1_irqthresh_rstdsbl = '0')) then
                    ch1_thresh_count   <= ch1_irqthresh;
                    ch1_ioc_irq_set_i  <= '0';

                -- IOC event then...
                elsif(ch1_irqthresh_decr = '1' and ch1_irqthresh_decr_mask_sig = '0')then --
                    -- Threshold at zero, reload threshold and drive ioc
                    -- interrupt.
                    if(ch1_thresh_count = ONE_THRESHOLD)then
                        ch1_thresh_count    <= ch1_irqthresh;
                        ch1_ioc_irq_set_i  <= '1';
                    else
                        ch1_thresh_count   <= std_logic_vector(unsigned(ch1_thresh_count(7 downto 0)) - 1);
                        ch1_ioc_irq_set_i  <= '0';
                    end if;
                else
                    ch1_thresh_count   <= ch1_thresh_count;
                    ch1_ioc_irq_set_i  <= '0';
                end if;
            end if;
        end process REG_THRESH_COUNT;


    CH1_FRMCNT_MASK : process(m_axi_ch1_aclk)
        begin
            if(m_axi_ch1_aclk'EVENT and m_axi_ch1_aclk = '1')then
                if(m_axi_ch1_aresetn = '0')then
                    ch1_irqthresh_decr_mask_sig  <= '0';
                elsif (ch1_irqthresh_decr_mask = '1' and ch1_irqthresh_decr = '1') then
                    ch1_irqthresh_decr_mask_sig  <= '1';
                elsif (ch1_irqthresh_decr = '1') then
                    ch1_irqthresh_decr_mask_sig  <= '0';
                end if;
            end if;
        end process CH1_FRMCNT_MASK;




    -- Pass current threshold count out to DMASR
    ch1_irqthresh_status <= ch1_thresh_count;
    ch1_ioc_irq_set      <= ch1_ioc_irq_set_i;

end generate GEN_CH1_FRM_CNTR;
    ---------------------------------------------------------------------------
    -- Generate Delay Interrupt Timers
    ---------------------------------------------------------------------------
    GEN_CH1_DELAY_INTERRUPT : if (C_ENABLE_DEBUG_INFO_6 = 1 or C_ENABLE_DEBUG_ALL = 1) generate
    begin
        GEN_CH1_FAST_COUNTER : if C_DLYTMR_RESOLUTION /= 1 generate
        begin
            ---------------------------------------------------------------------------
            -- Delay interrupt high resolution timer
            ---------------------------------------------------------------------------
            REG_DLY_FAST_CNT : process(m_axi_ch1_aclk)
                begin
                    if(m_axi_ch1_aclk'EVENT and m_axi_ch1_aclk = '1')then
                        if(m_axi_ch1_aresetn = '0' or ch1_delay_cnt_en = '0' or ch1_disable_delay = '1'
                        or ch1_packet_sof = '1' or ch1_irqdelay_wren = '1')then
                            ch1_dly_fast_cnt   <= FAST_COUNT_TC;
                            ch1_dly_fast_incr  <= '0';
                        elsif(ch1_dly_fast_cnt = ZERO_FAST_COUNT)then
                            ch1_dly_fast_cnt   <= FAST_COUNT_TC;
                            ch1_dly_fast_incr  <= '1';
                        else
                            ch1_dly_fast_cnt   <= std_logic_vector(unsigned(ch1_dly_fast_cnt(FAST_COUNT_WIDTH-1 downto 0)) - 1);
                            ch1_dly_fast_incr  <= '0';
                        end if;
                    end if;
                end process REG_DLY_FAST_CNT;
        end generate GEN_CH1_FAST_COUNTER;

        GEN_CH1_NO_FAST_COUNTER :  if C_DLYTMR_RESOLUTION = 1 generate
            REG_DLY_FAST_CNT : process(m_axi_ch1_aclk)
                begin
                    if(m_axi_ch1_aclk'EVENT and m_axi_ch1_aclk = '1')then
                        if(m_axi_ch1_aresetn = '0' or ch1_delay_cnt_en = '0' or ch1_disable_delay = '1'
                        or ch1_packet_sof = '1' or ch1_irqdelay_wren = '1')then
                            ch1_dly_fast_incr <= '0';
                        else
                            ch1_dly_fast_incr <= '1';
                        end if;
                    end if;
                end process REG_DLY_FAST_CNT;
        end generate GEN_CH1_NO_FAST_COUNTER;

        -- DMACR Delay value set to zero - disable delay interrupt
        ch1_delay_zero <= '1' when ch1_irqdelay = ZERO_DELAY
                      else '0';

        -- Delay Terminal Count reached (i.e. Delay count = DMACR delay value)
        ch1_delay_tc <= '1' when ch1_delay_count = ch1_irqdelay
                             and ch1_delay_zero = '0'
                             and ch1_packet_sof = '0'
                    else '0';

        -- 1 clock earlier delay counter disable to prevent count
        -- increment on TC hit.
        ch1_disable_delay <= '1' when ch1_delay_zero = '1'
                                   or ch1_dlyirq_dsble = '1'
                                   or ch1_dly_irq_set_i = '1'
                        else '0';

        ---------------------------------------------------------------------------
        -- Delay interrupt low resolution timer
        ---------------------------------------------------------------------------
        REG_DELAY_COUNT : process(m_axi_ch1_aclk)
            begin
                if(m_axi_ch1_aclk'EVENT and m_axi_ch1_aclk = '1')then
                    if(m_axi_ch1_aresetn = '0' or ch1_delay_cnt_en = '0' or ch1_disable_delay = '1'
                    or ch1_packet_sof = '1' or ch1_irqdelay_wren = '1')then
                        ch1_delay_count    <= (others => '0');
                        ch1_dly_irq_set_i  <= '0';
                    elsif(ch1_dly_fast_incr = '1' and ch1_delay_tc = '1')then
                        ch1_delay_count    <= (others => '0');
                        ch1_dly_irq_set_i  <= '1';
                    elsif(ch1_dly_fast_incr = '1')then
                        ch1_delay_count    <= std_logic_vector(unsigned(ch1_delay_count(7 downto 0)) + 1);
                        ch1_dly_irq_set_i  <= '0';
                    else
                        ch1_delay_count    <= ch1_delay_count;
                        ch1_dly_irq_set_i  <= '0';
                    end if;
                end if;
            end process REG_DELAY_COUNT;

        -- Pass current delay count to DMASR
        ch1_irqdelay_status    <= ch1_delay_count;
        ch1_dly_irq_set        <= ch1_dly_irq_set_i;

        -- Enable control for delay counter
        REG_DELAY_CNT_ENABLE : process(m_axi_ch1_aclk)
            begin
                if(m_axi_ch1_aclk'EVENT and m_axi_ch1_aclk = '1')then
                    if(m_axi_ch1_aresetn = '0' or ch1_disable_delay = '1')then
                        ch1_delay_cnt_en   <= '0';

                    -- stop counting if already counting and receive an sof and
                    -- not end of another packet
                    elsif(ch1_delay_cnt_en = '1' and ch1_packet_sof = '1'
                    and ch1_packet_eof = '0')then
                        ch1_delay_cnt_en   <= '0';
                    elsif(ch1_packet_eof = '1' and ch1_packet_eof_mask = '0')then
                        ch1_delay_cnt_en   <= '1';
                    end if;
                end if;
            end process REG_DELAY_CNT_ENABLE;
    end generate GEN_CH1_DELAY_INTERRUPT;

end generate GEN_INCLUDE_MM2S;

-- Receive channel included therefore generate receive interrupt logic
GEN_INCLUDE_S2MM : if C_INCLUDE_CH2 = 1 generate
begin

GEN_CH2_FRM_CNTR : if (C_ENABLE_DEBUG_INFO_15 = 1 or C_ENABLE_DEBUG_ALL = 1) generate
begin


    REG_THRESH_COUNT : process(m_axi_ch2_aclk)
        begin
            if(m_axi_ch2_aclk'EVENT and m_axi_ch2_aclk = '1')then
                if(m_axi_ch2_aresetn = '0')then
                    ch2_thresh_count   <= ONE_THRESHOLD;
                    ch2_ioc_irq_set_i  <= '0';

                -- New Threshold set by CPU OR delay interrupt event occured.
                elsif( (ch2_irqthresh_wren = '1')
                    or (ch2_dly_irq_set_i = '1' and ch2_irqthresh_rstdsbl = '0')) then
                    ch2_thresh_count   <= ch2_irqthresh;
                    ch2_ioc_irq_set_i  <= '0';

                -- IOC event then...
                elsif(ch2_irqthresh_decr = '1' and ch2_irqthresh_decr_mask_sig = '0')then --
                    -- Threshold at zero, reload threshold and drive ioc
                    -- interrupt.
                    if(ch2_thresh_count = ONE_THRESHOLD)then
                        ch2_thresh_count   <= ch2_irqthresh;
                        ch2_ioc_irq_set_i  <= '1';
                    else
                        ch2_thresh_count   <= std_logic_vector(unsigned(ch2_thresh_count(7 downto 0)) - 1);
                        ch2_ioc_irq_set_i  <= '0';
                    end if;
                else
                    ch2_thresh_count   <= ch2_thresh_count;
                    ch2_ioc_irq_set_i  <= '0';
                end if;
            end if;
        end process REG_THRESH_COUNT;


    CH2_FRMCNT_MASK : process(m_axi_ch2_aclk)
        begin
            if(m_axi_ch2_aclk'EVENT and m_axi_ch2_aclk = '1')then
                if(m_axi_ch2_aresetn = '0')then
                    ch2_irqthresh_decr_mask_sig  <= '0';
                elsif (ch2_irqthresh_decr_mask = '1' and ch2_irqthresh_decr = '1') then
                    ch2_irqthresh_decr_mask_sig  <= '1';
                elsif (ch2_irqthresh_decr = '1') then
                    ch2_irqthresh_decr_mask_sig  <= '0';
                end if;
            end if;
        end process CH2_FRMCNT_MASK;







    -- Pass current threshold count out to DMASR
    ch2_irqthresh_status   <= ch2_thresh_count;
    ch2_ioc_irq_set        <= ch2_ioc_irq_set_i;

end generate GEN_CH2_FRM_CNTR;
    ---------------------------------------------------------------------------
    -- Generate Delay Interrupt Timers
    ---------------------------------------------------------------------------
    GEN_CH2_DELAY_INTERRUPT : if (C_ENABLE_DEBUG_INFO_14 = 1 or C_ENABLE_DEBUG_ALL = 1)  generate
    begin
        ---------------------------------------------------------------------------
        -- Delay interrupt high resolution timer
        ---------------------------------------------------------------------------
        GEN_CH2_FAST_COUNTER : if C_DLYTMR_RESOLUTION /= 1 generate
        begin
            REG_DLY_FAST_CNT : process(m_axi_ch2_aclk)
                begin
                    if(m_axi_ch2_aclk'EVENT and m_axi_ch2_aclk = '1')then
                        if(m_axi_ch2_aresetn = '0' or ch2_delay_cnt_en = '0' or ch2_disable_delay = '1'
                        or ch2_packet_sof = '1' or ch2_irqdelay_wren = '1')then
                            ch2_dly_fast_cnt   <= FAST_COUNT_TC;
                            ch2_dly_fast_incr  <= '0';
                        elsif(ch2_dly_fast_cnt = ZERO_FAST_COUNT)then
                            ch2_dly_fast_cnt   <= FAST_COUNT_TC;
                            ch2_dly_fast_incr  <= '1';
                        else
                            ch2_dly_fast_cnt   <= std_logic_vector(unsigned(ch2_dly_fast_cnt(FAST_COUNT_WIDTH-1 downto 0)) - 1);
                            ch2_dly_fast_incr  <= '0';
                        end if;
                    end if;
                end process REG_DLY_FAST_CNT;
        end generate GEN_CH2_FAST_COUNTER;

        GEN_CH2_NO_FAST_COUNTER :  if C_DLYTMR_RESOLUTION = 1 generate
            REG_DLY_FAST_CNT : process(m_axi_ch2_aclk)
                begin
                    if(m_axi_ch2_aclk'EVENT and m_axi_ch2_aclk = '1')then
                        if(m_axi_ch2_aresetn = '0' or ch2_delay_cnt_en = '0' or ch2_disable_delay = '1'
                        or ch2_packet_sof = '1' or ch2_irqdelay_wren = '1')then
                            ch2_dly_fast_incr <= '0';
                        else
                            ch2_dly_fast_incr <= '1';
                        end if;
                    end if;
                end process REG_DLY_FAST_CNT;
        end generate GEN_CH2_NO_FAST_COUNTER;

        -- DMACR Delay value set to zero - disable delay interrupt
        ch2_delay_zero <= '1' when ch2_irqdelay = ZERO_DELAY
                      else '0';

        -- Delay Terminal Count reached (i.e. Delay count = DMACR delay value)
        ch2_delay_tc <= '1' when ch2_delay_count = ch2_irqdelay
                             and ch2_delay_zero = '0'
                             and ch2_packet_sof = '0'
                      else '0';

        -- 1 clock earlier delay counter disable to prevent count
        -- increment on TC hit.
        ch2_disable_delay <= '1' when ch2_delay_zero = '1'
                                   or ch2_dlyirq_dsble = '1'
                                   or ch2_dly_irq_set_i = '1'
                        else '0';

        ---------------------------------------------------------------------------
        -- Delay interrupt low resolution timer
        ---------------------------------------------------------------------------
        REG_DELAY_COUNT : process(m_axi_ch2_aclk)
            begin
                if(m_axi_ch2_aclk'EVENT and m_axi_ch2_aclk = '1')then
                    if(m_axi_ch2_aresetn = '0' or ch2_delay_cnt_en = '0' or ch2_disable_delay = '1'
                    or ch2_packet_sof = '1' or ch2_irqdelay_wren = '1')then
                        ch2_delay_count    <= (others => '0');
                        ch2_dly_irq_set_i  <= '0';
                    elsif(ch2_dly_fast_incr = '1' and ch2_delay_tc = '1')then
                        ch2_delay_count    <= (others => '0');
                        ch2_dly_irq_set_i  <= '1';
                    elsif(ch2_dly_fast_incr = '1')then
                        ch2_delay_count    <= std_logic_vector(unsigned(ch2_delay_count(7 downto 0)) + 1);
                        ch2_dly_irq_set_i  <= '0';
                    else
                        ch2_delay_count    <= ch2_delay_count;
                        ch2_dly_irq_set_i  <= '0';
                    end if;
                end if;
            end process REG_DELAY_COUNT;

        -- Pass current delay count to DMASR
        ch2_irqdelay_status <= ch2_delay_count;
        ch2_dly_irq_set     <= ch2_dly_irq_set_i;

        -- Enable control for delay counter
        REG_DELAY_CNT_ENABLE : process(m_axi_ch2_aclk)
            begin
                if(m_axi_ch2_aclk'EVENT and m_axi_ch2_aclk = '1')then
                    if(m_axi_ch2_aresetn = '0' or ch2_disable_delay = '1')then
                        ch2_delay_cnt_en   <= '0';
                    -- stop counting if already counting and receive an sof and
                    -- not end of another packet
                    elsif(ch2_delay_cnt_en = '1' and ch2_packet_sof = '1'
                    and ch2_packet_eof = '0')then
                        ch2_delay_cnt_en   <= '0';
                    elsif(ch2_packet_eof = '1' and ch2_packet_eof_mask = '0')then
                        ch2_delay_cnt_en   <= '1';
                    end if;
                end if;
            end process REG_DELAY_CNT_ENABLE;
    end generate GEN_CH2_DELAY_INTERRUPT;


end generate GEN_INCLUDE_S2MM;




-- Transmit channel not included therefore associated outputs to zero
GEN_NO_CH1_FRM_CNTR : if C_INCLUDE_CH1 = 0 or (C_ENABLE_DEBUG_INFO_7 = 0 and C_ENABLE_DEBUG_ALL = 0) generate
begin
    ch1_ioc_irq_set        <= '0';
    ch1_irqthresh_status   <= (others => '0');
end generate GEN_NO_CH1_FRM_CNTR;


    ---------------------------------------------------------------------------
    -- MM2S Delay interrupt NOT included
    ---------------------------------------------------------------------------
    GEN_NO_CH1_DELAY_INTR : if C_INCLUDE_CH1 = 0 or (C_ENABLE_DEBUG_INFO_6 = 0 and C_ENABLE_DEBUG_ALL = 0) generate
    begin
        ch1_dly_irq_set     <= '0';
        ch1_dly_irq_set_i   <= '0';
        ch1_irqdelay_status <= (others => '0');
    end generate GEN_NO_CH1_DELAY_INTR;







-- Receive channel not included therefore associated outputs to zero
GEN_NO_CH2_FRM_CNTR : if C_INCLUDE_CH2 = 0 or (C_ENABLE_DEBUG_INFO_15 = 0 and C_ENABLE_DEBUG_ALL = 0) generate
begin
    ch2_ioc_irq_set        <= '0';
    ch2_irqthresh_status   <= (others => '0');
end generate GEN_NO_CH2_FRM_CNTR;


    ---------------------------------------------------------------------------
    -- S2MM Delay interrupt NOT included
    ---------------------------------------------------------------------------
    GEN_NO_CH2_DELAY_INTR : if C_INCLUDE_CH2 = 0 or (C_ENABLE_DEBUG_INFO_14 = 0 and C_ENABLE_DEBUG_ALL = 0)  generate
    begin
        ch2_dly_irq_set     <= '0';
        ch2_dly_irq_set_i   <= '0';
        ch2_irqdelay_status <= (others => '0');
    end generate GEN_NO_CH2_DELAY_INTR;



end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_sofeof_mngr
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_vdma_sof_gen.vhd
-- Description: This entity manages SOF detection, EOF detection not used for
--              axi_vdma.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

-------------------------------------------------------------------------------
entity  axi_vdma_sof_gen is
    port (
        -----------------------------------------------------------------------
        -- AXI System Signals
        -----------------------------------------------------------------------
        scndry_aclk                 : in  std_logic                         ;           --
        scndry_resetn               : in  std_logic                         ;           --
                                                                                        --
        -- AXI Stream                                                                   --
        axis_tready                 : in  std_logic                         ;           --
        axis_tvalid                 : in  std_logic                         ;           --
                                                                                        --
        fsync                       : in  std_logic                         ;           -- 
        -- Detected SOF                                                                 --
        packet_sof                  : out std_logic                                     --
    );

end axi_vdma_sof_gen;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_sof_gen is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal s_valid              : std_logic := '0';
signal s_valid_d1           : std_logic := '0';

signal packet_sof_i         : std_logic := '0';
signal hold_sof             : std_logic := '0';


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

---------------------------------------------------------------------------
-- Generate Packet EOF and SOF
---------------------------------------------------------------------------
packet_sof <= packet_sof_i;

-- Generate rising edge pulse on valid to use for
-- smaple and hold register
REG_FOR_RE : process(scndry_aclk)
    begin
        if(scndry_aclk'EVENT and scndry_aclk = '1')then
            if(scndry_resetn = '0')then
                s_valid     <= '0';
                s_valid_d1  <= '0';
            else
                -- 
                --s_valid     <= axis_tvalid;
                s_valid     <= axis_tvalid and axis_tready;
                s_valid_d1  <= s_valid;
            end if;
        end if;
    end process REG_FOR_RE;

packet_sof_i  <= s_valid and not s_valid_d1 and not hold_sof; -- 

-- 
-- Generate only 1 SOF (all that is needed) to prevent lockups
-- on CDC module with sof pulses being too close together.
SOF_HOLD_REG : process(scndry_aclk)
    begin
        if(scndry_aclk'EVENT and scndry_aclk = '1')then
            if(scndry_resetn = '0' or fsync = '1')then
                hold_sof <= '0';
            elsif(packet_sof_i = '1')then
                hold_sof <= '1';
            end if;
        end if;
    end process SOF_HOLD_REG;


end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_skid_buf.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_skid_buf.vhd
--
-- Description:
--  Implements the AXi Skid Buffer in the Option 2 (Registerd outputs) mode.
--
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;



-------------------------------------------------------------------------------

entity axi_vdma_skid_buf is
  generic (
    C_WDATA_WIDTH : INTEGER range 8 to 1024 := 32;
       --  Width of the Stream Data bus (in bits)
    C_TUSER_WIDTH : INTEGER range 1 to 128  := 1
       -- Width of tuser bus (in bits)

    );
  port (
  -- System Ports
     ACLK         : In  std_logic ;                                         --
     ARST         : In  std_logic ;                                         --
                                                                            --
   -- Shutdown control (assert for 1 clk pulse)                             --
     skid_stop    : In std_logic  ;                                         --
   -- Slave Side (Stream Data Input)                                        --
     S_VALID      : In  std_logic ;                                         --
     S_READY      : Out std_logic ;                                         --
     S_Data       : In  std_logic_vector(C_WDATA_WIDTH-1 downto 0);         --
     S_STRB       : In  std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0);     --
     S_Last       : In  std_logic ;                                         --
     S_User       : In  std_logic_vector(C_TUSER_WIDTH-1 downto 0);         --
   -- Master Side (Stream Data Output                                       --
     M_VALID      : Out std_logic ;                                         --
     M_READY      : In  std_logic ;                                         --
     M_Data       : Out std_logic_vector(C_WDATA_WIDTH-1 downto 0);         --
     M_STRB       : Out std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0);     --
     M_Last       : Out std_logic;                                          --
     M_User       : Out std_logic_vector(C_TUSER_WIDTH-1 downto 0)          --
    );

end entity axi_vdma_skid_buf;


architecture implementation of axi_vdma_skid_buf is

attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-- Signals decalrations -------------------------

  Signal sig_reset_reg         : std_logic := '0';
  signal sig_spcl_s_ready_set  : std_logic := '0';

  signal sig_data_skid_reg     : std_logic_vector(C_WDATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_skid_reg     : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_last_skid_reg     : std_logic := '0';
  signal sig_skid_reg_en       : std_logic := '0';

  signal sig_data_skid_mux_out : std_logic_vector(C_WDATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_skid_mux_out : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_last_skid_mux_out : std_logic := '0';
  signal sig_skid_mux_sel      : std_logic := '0';

  signal sig_data_reg_out      : std_logic_vector(C_WDATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_reg_out      : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_last_reg_out      : std_logic := '0';
  signal sig_data_reg_out_en   : std_logic := '0';

  signal sig_m_valid_out       : std_logic := '0';
  signal sig_m_valid_dup       : std_logic := '0';
  signal sig_m_valid_comb      : std_logic := '0';

  signal sig_s_ready_out       : std_logic := '0';
  signal sig_s_ready_dup       : std_logic := '0';
  signal sig_s_ready_comb      : std_logic := '0';

  signal sig_stop_request      : std_logic := '0';
--  signal sig_stopped           : std_logic := '0';
  signal sig_sready_stop       : std_logic := '0';
  signal sig_sready_stop_reg   : std_logic := '0';
  signal sig_s_last_xfered     : std_logic := '0';

  signal sig_m_last_xfered     : std_logic := '0';
  signal sig_mvalid_stop_reg   : std_logic := '0';
  signal sig_mvalid_stop       : std_logic := '0';

  signal sig_slast_with_stop   : std_logic := '0';
  signal sig_sstrb_stop_mask   : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_sstrb_with_stop   : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');


  signal sig_user_skid_mux_out : std_logic_vector(C_TUSER_WIDTH-1 downto 0) := (others => '0');
  signal sig_user_skid_reg     : std_logic_vector(C_TUSER_WIDTH-1 downto 0) := (others => '0');
  signal sig_user_reg_out      : std_logic_vector(C_TUSER_WIDTH-1 downto 0) := (others => '0');


-- Register duplication attribute assignments to control fanout
-- on handshake output signals

  Attribute KEEP : string; -- declaration
  Attribute EQUIVALENT_REGISTER_REMOVAL : string; -- declaration

  Attribute KEEP of sig_m_valid_out : signal is "TRUE"; -- definition
  Attribute KEEP of sig_m_valid_dup : signal is "TRUE"; -- definition
  Attribute KEEP of sig_s_ready_out : signal is "TRUE"; -- definition
  Attribute KEEP of sig_s_ready_dup : signal is "TRUE"; -- definition

  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_m_valid_out : signal is "no";
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_m_valid_dup : signal is "no";
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s_ready_out : signal is "no";
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s_ready_dup : signal is "no";


begin --(architecture implementation)

   M_VALID <= sig_m_valid_out;
   S_READY <= sig_s_ready_out;

   M_STRB  <= sig_strb_reg_out;
   M_Last  <= sig_last_reg_out;
   M_Data  <= sig_data_reg_out;
   M_User  <= sig_user_reg_out;

  -- Special shutdown logic version od Slast.
  -- A halt request forces a tlast through the skig buffer
  sig_slast_with_stop <= s_last or sig_stop_request;
  sig_sstrb_with_stop <= s_strb or sig_sstrb_stop_mask;
  -- Assign the special S_READY FLOP set signal
  sig_spcl_s_ready_set <= sig_reset_reg;


  -- Generate the ouput register load enable control
   sig_data_reg_out_en <= M_READY or not(sig_m_valid_dup);

  -- Generate the skid input register load enable control
   sig_skid_reg_en     <= sig_s_ready_dup;

  -- Generate the skid mux select control
   sig_skid_mux_sel    <= not(sig_s_ready_dup);


 -- Skid Mux
   sig_data_skid_mux_out <=  sig_data_skid_reg
     When (sig_skid_mux_sel = '1')
     Else  S_Data;

   sig_user_skid_mux_out <= sig_user_skid_reg
     When (sig_skid_mux_sel = '1')
     Else  S_User;


   sig_strb_skid_mux_out <=  sig_strb_skid_reg
     When (sig_skid_mux_sel = '1')
     Else  sig_sstrb_with_stop;

   sig_last_skid_mux_out <=  sig_last_skid_reg
     When (sig_skid_mux_sel = '1')
     Else  sig_slast_with_stop;


   -- m_valid combinational logic
   sig_m_valid_comb <= S_VALID or
                      (sig_m_valid_dup and
                      (not(sig_s_ready_dup) or
                       not(M_READY)));



   -- s_ready combinational logic
   sig_s_ready_comb <= M_READY or
                      (sig_s_ready_dup and
                      (not(sig_m_valid_dup) or
                       not(S_VALID)));



   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: REG_THE_RST
   --
   -- Process Description:
   -- Register input reset
   --
   -------------------------------------------------------------
   REG_THE_RST : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then

            sig_reset_reg <= ARST;

        end if;
      end process REG_THE_RST;




   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: S_READY_FLOP
   --
   -- Process Description:
   -- Registers S_READY handshake signals per Skid Buffer
   -- Option 2 scheme
   --
   -------------------------------------------------------------
   S_READY_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST            = '1' or
               sig_sready_stop = '1') then  -- Special stop condition

             sig_s_ready_out  <= '0';
             sig_s_ready_dup  <= '0';

           Elsif (sig_spcl_s_ready_set = '1') Then

             sig_s_ready_out  <= '1';
             sig_s_ready_dup  <= '1';

           else

             sig_s_ready_out  <= sig_s_ready_comb;
             sig_s_ready_dup  <= sig_s_ready_comb;

           end if;
        end if;
      end process S_READY_FLOP;






   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: M_VALID_FLOP
   --
   -- Process Description:
   -- Registers M_VALID handshake signals per Skid Buffer
   -- Option 2 scheme
   --
   -------------------------------------------------------------
   M_VALID_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST                 = '1' or
               sig_spcl_s_ready_set = '1' or    -- Fix from AXI DMA
               sig_mvalid_stop      = '1') then -- Special stop condition
             sig_m_valid_out  <= '0';
             sig_m_valid_dup  <= '0';

           else

             sig_m_valid_out  <= sig_m_valid_comb;
             sig_m_valid_dup  <= sig_m_valid_comb;

           end if;
        end if;
      end process M_VALID_FLOP;






   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: SKID_REG
   --
   -- Process Description:
   -- This process implements the output registers for the
   -- Skid Buffer Data signals
   --
   -------------------------------------------------------------
   SKID_REG : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then

             sig_data_skid_reg <= (others => '0');
             sig_strb_skid_reg <= (others => '0');
             sig_last_skid_reg <= '0';
             sig_user_skid_reg <= (others => '0');

           elsif (sig_skid_reg_en = '1') then

             sig_data_skid_reg <= S_Data;
             sig_strb_skid_reg <= sig_sstrb_with_stop;
             sig_last_skid_reg <= sig_slast_with_stop;
             sig_user_skid_reg <= S_User;
           else
             null;  -- hold current state
           end if;
        end if;
      end process SKID_REG;





   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: OUTPUT_REG
   --
   -- Process Description:
   -- This process implements the output registers for the
   -- Skid Buffer Data signals
   --
   -------------------------------------------------------------
   OUTPUT_REG : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST                = '1' or
               sig_mvalid_stop_reg = '1') then

             sig_data_reg_out <= (others => '0');
             sig_strb_reg_out <= (others => '0');
             sig_last_reg_out <= '0';
             sig_user_reg_out <= (others => '0');

           elsif (sig_data_reg_out_en = '1') then

             sig_data_reg_out <= sig_data_skid_mux_out;
             sig_strb_reg_out <= sig_strb_skid_mux_out;
             sig_last_reg_out <= sig_last_skid_mux_out;
             sig_user_reg_out <= sig_user_skid_mux_out;

           else
             null;  -- hold current state
           end if;
        end if;
      end process OUTPUT_REG;




   -------- Special Stop Logic --------------------------------------


   sig_s_last_xfered  <=  sig_s_ready_dup and
                          s_valid         and
                          sig_slast_with_stop;


   sig_sready_stop    <=  (sig_s_last_xfered and
                          sig_stop_request) or
                          sig_sready_stop_reg;






   sig_m_last_xfered  <=  sig_m_valid_dup and
                          m_ready         and
                          sig_last_reg_out;


   sig_mvalid_stop    <=  (sig_m_last_xfered and
                          sig_stop_request)  or
                          sig_mvalid_stop_reg;




   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_STOP_REQ_FLOP
   --
   -- Process Description:
   -- This process implements the Stop request flop. It is a
   -- sample and hold register that can only be cleared by reset.
   --
   -------------------------------------------------------------
   IMP_STOP_REQ_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then

             sig_stop_request <= '0';
             sig_sstrb_stop_mask <= (others => '0');

           elsif (skid_stop = '1') then

             sig_stop_request <= '1';
             sig_sstrb_stop_mask <= (others => '1');

           else
             null;  -- hold current state
           end if;
        end if;
      end process IMP_STOP_REQ_FLOP;









   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_CLR_SREADY_FLOP
   --
   -- Process Description:
   -- This process implements the flag to clear the s_ready
   -- flop at a stop condition.
   --
   -------------------------------------------------------------
   IMP_CLR_SREADY_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then

             sig_sready_stop_reg <= '0';

           elsif (sig_s_last_xfered = '1' and
                  sig_stop_request  = '1') then

             sig_sready_stop_reg <= '1';

           else
             null;  -- hold current state
           end if;
        end if;
      end process IMP_CLR_SREADY_FLOP;





   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_CLR_MREADY_FLOP
   --
   -- Process Description:
   -- This process implements the flag to clear the m_ready
   -- flop at a stop condition.
   --
   -------------------------------------------------------------
   IMP_CLR_MVALID_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then

             sig_mvalid_stop_reg <= '0';

           elsif (sig_m_last_xfered = '1' and
                  sig_stop_request  = '1') then

             sig_mvalid_stop_reg <= '1';

           else
             null;  -- hold current state
           end if;
        end if;
      end process IMP_CLR_MVALID_FLOP;



end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_sfifo.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_sfifo.vhd
-- Version:         initial
-- Description:
--    This file contains the logic to generate a CoreGen call to create a
-- synchronous FIFO as part of the synthesis process of XST. This eliminates
-- the need for multiple fixed netlists for various sizes and widths of FIFOs.
--
--
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
library fifo_generator_v13_2_5;
use fifo_generator_v13_2_5.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.all;
--use proc_common_v4_0.coregen_comp_defs.all;
--use proc_common_v4_0.family_support.all;

-- synopsys translate_off
--library XilinxCoreLib;
--use XilinxCoreLib.all;
-- synopsys translate_on


library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;
Library xpm;
use xpm.vcomponents.all;



-------------------------------------------------------------------------------

ENTITY axi_vdma_sfifo IS
  GENERIC (
    -------------------------------------------------------------------------
    -- Generic Declarations
    -------------------------------------------------------------------------
    C_FAMILY       	  : STRING  := "virtex7";   --
    C_FULL_FLAGS_RST_VAL  : INTEGER := 1;          -- 0,1 ; Default 1
    UW_DATA_WIDTH         : INTEGER := 16;          -- 1 - 1024; Default 16
    UW_FIFO_DEPTH         : INTEGER := 1024         -- 16 - 256K; Default 1K
    );
  PORT (

    -- Common signal
    rst              : in  std_logic := '0';

    sleep            : in  std_logic := '0';
    wr_rst_busy      : out std_logic := '0';
    rd_rst_busy      : out std_logic := '0';
    -- Write Domain signals
    clk           : in  std_logic := '0';
    din              : in  std_logic_vector(UW_DATA_WIDTH-1 downto 0) := (others => '0');
    wr_en            : in  std_logic := '0';
    full             : out std_logic := '0';
    data_count    : out std_logic_vector(clog2(uw_fifo_depth)-1 downto 0) := (others => '0');

    -- Read Domain signals
    rd_en            : in  std_logic := '0';
    dout             : out std_logic_vector(UW_DATA_WIDTH-1 downto 0) := (others => '0');
    empty            : out std_logic := '1'

    );
END ENTITY axi_vdma_sfifo;

-----------------------------------------------------------------------------
-- Architecture section
-----------------------------------------------------------------------------
ARCHITECTURE xilinx OF axi_vdma_sfifo IS
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of xilinx : architecture is "yes";

  --CONSTANT GND : std_logic := '0';
  CONSTANT VCC : std_logic := '1';
  CONSTANT clog2_uw_fifo_depth   : integer := clog2(uw_fifo_depth);
  CONSTANT clog2_uw_fifo_depth_plus_1   : integer := clog2(uw_fifo_depth) + 1;
  --Signals added to fix MTI and XSIM issues caused by fix for VCS issues not to use "LIBRARY_SCAN = TRUE"
  signal ZERO_pntr : std_logic_vector(clog2_uw_fifo_depth-1 downto 0) := (others => '0');
  signal GND : std_logic := '0';
   signal ALMOST_FULL           : std_logic;                 
   signal WR_ACK           : std_logic;                 
   signal OVERFLOW           : std_logic;                 
   signal ALMOST_EMPTY           : std_logic;                 
   signal VALID           : std_logic;                 
   signal UNDERFLOW           : std_logic;                 
   signal PROG_FULL           : std_logic;                 
   signal PROG_EMPTY          : std_logic;                 
   signal SBITERR             : std_logic;                 
   signal DBITERR             : std_logic;                  
   signal S_AXI_AWREADY       : std_logic;
   signal S_AXI_WREADY        : std_logic;
   signal S_AXI_BID           : std_logic_vector(3 DOWNTO 0);
   signal S_AXI_BRESP         : std_logic_vector(2-1 DOWNTO 0);
   signal S_AXI_BUSER         : std_logic_vector(0 downto 0);
   signal S_AXI_BVALID        : std_logic;

--   -- AXI Full/Lite Master Write Channel (Read side)
--   signal M_AXI_AWID          : std_logic_vector(3 DOWNTO 0);
--   signal M_AXI_AWADDR        : std_logic_vector(31 DOWNTO 0);
--   signal M_AXI_AWLEN         : std_logic_vector(8-1 DOWNTO 0);
--   signal M_AXI_AWSIZE        : std_logic_vector(3-1 DOWNTO 0);
--   signal M_AXI_AWBURST       : std_logic_vector(2-1 DOWNTO 0);
--   signal M_AXI_AWLOCK        : std_logic_vector(2-1 DOWNTO 0);
--   signal M_AXI_AWCACHE       : std_logic_vector(4-1 DOWNTO 0);
--   signal M_AXI_AWPROT        : std_logic_vector(3-1 DOWNTO 0);
--   signal M_AXI_AWQOS         : std_logic_vector(4-1 DOWNTO 0);
--   signal M_AXI_AWREGION      : std_logic_vector(4-1 DOWNTO 0);
--   signal M_AXI_AWUSER        : std_logic_vector(0 downto 0);
--   signal M_AXI_AWVALID       : std_logic;
--   signal M_AXI_WID           : std_logic_vector(3 DOWNTO 0);
--   signal M_AXI_WDATA         : std_logic_vector(63 DOWNTO 0);
--   signal M_AXI_WSTRB         : std_logic_vector(7 DOWNTO 0);
--   signal M_AXI_WLAST         : std_logic;
--   signal M_AXI_WUSER         : std_logic_vector(0 downto 0);
--   signal M_AXI_WVALID        : std_logic;
--   signal M_AXI_BREADY        : std_logic;
--
--   -- AXI Full/Lite Slave Read Channel (Write side)
--   signal S_AXI_ARREADY       : std_logic;
--   signal S_AXI_RID           : std_logic_vector(3 DOWNTO 0);       
--   signal S_AXI_RDATA         : std_logic_vector(63 DOWNTO 0); 
--   signal S_AXI_RRESP         : std_logic_vector(2-1 DOWNTO 0);
--   signal S_AXI_RLAST         : std_logic;
--   signal S_AXI_RUSER         : std_logic_vector(0 downto 0);
--   signal S_AXI_RVALID        : std_logic;
--
--   -- AXI Full/Lite Master Read Channel (Read side)
--   signal M_AXI_ARID          : std_logic_vector(3 DOWNTO 0);        
--   signal M_AXI_ARADDR        : std_logic_vector(31 DOWNTO 0);  
--   signal M_AXI_ARLEN         : std_logic_vector(8-1 DOWNTO 0);
--   signal M_AXI_ARSIZE        : std_logic_vector(3-1 DOWNTO 0);
--   signal M_AXI_ARBURST       : std_logic_vector(2-1 DOWNTO 0);
--   signal M_AXI_ARLOCK        : std_logic_vector(2-1 DOWNTO 0);
--   signal M_AXI_ARCACHE       : std_logic_vector(4-1 DOWNTO 0);
--   signal M_AXI_ARPROT        : std_logic_vector(3-1 DOWNTO 0);
--   signal M_AXI_ARQOS         : std_logic_vector(4-1 DOWNTO 0);
--   signal M_AXI_ARREGION      : std_logic_vector(4-1 DOWNTO 0);
--   signal M_AXI_ARUSER        : std_logic_vector(0 downto 0);
--   signal M_AXI_ARVALID       : std_logic;
--   signal M_AXI_RREADY        : std_logic;
--
--   -- AXI Streaming Slave Signals (Write side)
--   signal S_AXIS_TREADY       : std_logic;
--
--   -- AXI Streaming Master Signals (Read side)
--   signal M_AXIS_TVALID       : std_logic;
--   signal M_AXIS_TDATA        : std_logic_vector(63 DOWNTO 0);
--   signal M_AXIS_TSTRB        : std_logic_vector(3 DOWNTO 0);
--   signal M_AXIS_TKEEP        : std_logic_vector(3 DOWNTO 0);
--   signal M_AXIS_TLAST        : std_logic;
--   signal M_AXIS_TID          : std_logic_vector(7 DOWNTO 0);
--   signal M_AXIS_TDEST        : std_logic_vector(3 DOWNTO 0);
--   signal M_AXIS_TUSER        : std_logic_vector(3 DOWNTO 0);
--
--   -- AXI Full/Lite Write Address Channel Signals
--   signal AXI_AW_DATA_COUNT    : std_logic_vector(4 DOWNTO 0);
--   signal AXI_AW_WR_DATA_COUNT : std_logic_vector(4 DOWNTO 0);
--   signal AXI_AW_RD_DATA_COUNT : std_logic_vector(4 DOWNTO 0);
--   signal AXI_AW_SBITERR       : std_logic;
--   signal AXI_AW_DBITERR       : std_logic;
--   signal AXI_AW_OVERFLOW      : std_logic;
--   signal AXI_AW_UNDERFLOW     : std_logic;
--   signal AXI_AW_PROG_FULL     : STD_LOGIC;
--   signal AXI_AW_PROG_EMPTY    : STD_LOGIC;
--
--
--   -- AXI Full/Lite Write Data Channel Signals
--   signal AXI_W_DATA_COUNT     : std_logic_vector(10 DOWNTO 0);
--   signal AXI_W_WR_DATA_COUNT  : std_logic_vector(10 DOWNTO 0);
--   signal AXI_W_RD_DATA_COUNT  : std_logic_vector(10 DOWNTO 0);
--   signal AXI_W_SBITERR        : std_logic;
--   signal AXI_W_DBITERR        : std_logic;
--   signal AXI_W_OVERFLOW       : std_logic;
--   signal AXI_W_UNDERFLOW      : std_logic;
--   signal AXI_W_PROG_FULL      : STD_LOGIC;
--   signal AXI_W_PROG_EMPTY     : STD_LOGIC;
--
--   -- AXI Full/Lite Write Response Channel Signals
--   signal AXI_B_DATA_COUNT     : std_logic_vector(4 DOWNTO 0);
--   signal AXI_B_WR_DATA_COUNT  : std_logic_vector(4 DOWNTO 0);
--   signal AXI_B_RD_DATA_COUNT  : std_logic_vector(4 DOWNTO 0);
--   signal AXI_B_SBITERR        : std_logic;
--   signal AXI_B_DBITERR        : std_logic;
--   signal AXI_B_OVERFLOW       : std_logic;
--   signal AXI_B_UNDERFLOW      : std_logic;
--   signal AXI_B_PROG_FULL      : STD_LOGIC;
--   signal AXI_B_PROG_EMPTY     : STD_LOGIC;
--
--   -- AXI Full/Lite Read Address Channel Signals
--   signal AXI_AR_DATA_COUNT    : std_logic_vector(4 DOWNTO 0);
--   signal AXI_AR_WR_DATA_COUNT : std_logic_vector(4 DOWNTO 0);
--   signal AXI_AR_RD_DATA_COUNT : std_logic_vector(4 DOWNTO 0);
--   signal AXI_AR_SBITERR       : std_logic;
--   signal AXI_AR_DBITERR       : std_logic;
--   signal AXI_AR_OVERFLOW      : std_logic;
--   signal AXI_AR_UNDERFLOW     : std_logic;
--   signal AXI_AR_PROG_FULL     : STD_LOGIC;
--   signal AXI_AR_PROG_EMPTY    : STD_LOGIC;
--
--   -- AXI Full/Lite Read Data Channel Signals
--   signal AXI_R_DATA_COUNT     : std_logic_vector(10 DOWNTO 0);
--   signal AXI_R_WR_DATA_COUNT  : std_logic_vector(10 DOWNTO 0);
--   signal AXI_R_RD_DATA_COUNT  : std_logic_vector(10 DOWNTO 0);
--   signal AXI_R_SBITERR        : std_logic;
--   signal AXI_R_DBITERR        : std_logic;
--   signal AXI_R_OVERFLOW       : std_logic;
--   signal AXI_R_UNDERFLOW      : std_logic;
--   signal AXI_R_PROG_FULL      : STD_LOGIC;
--   signal AXI_R_PROG_EMPTY     : STD_LOGIC;
--
--   -- AXI Streaming FIFO Related Signals
--   signal AXIS_DATA_COUNT      : std_logic_vector(10 DOWNTO 0);
--   signal AXIS_WR_DATA_COUNT   : std_logic_vector(10 DOWNTO 0);
--   signal AXIS_RD_DATA_COUNT   : std_logic_vector(10 DOWNTO 0);
--   signal AXIS_SBITERR         : std_logic;
--   signal AXIS_DBITERR         : std_logic;
--   signal AXIS_OVERFLOW        : std_logic;
--   signal AXIS_UNDERFLOW       : std_logic;
--   signal AXIS_PROG_FULL       : STD_LOGIC;
--   signal AXIS_PROG_EMPTY      : STD_LOGIC;
--  --Signals added to fix MTI and XSIM issues caused by fix for VCS issues not to use "LIBRARY_SCAN = TRUE"
--   signal RD_DATA_COUNT          : std_logic_vector(clog2_uw_fifo_depth-1 DOWNTO 0);                 
   signal WR_DATA_COUNT          : std_logic_vector(clog2_uw_fifo_depth DOWNTO 0);                 
--

signal wr_rst_busy_sig              : std_logic := '0';
signal rd_rst_busy_sig              : std_logic := '0';                  


  signal  sig_data_count    : std_logic_vector(clog2(uw_fifo_depth) downto 0) := (others => '0');
begin
--FAMILY_8 : if ((C_FAMILY = "kintexu") or (C_FAMILY = "virtexu") or (C_FAMILY = "artixu"))   generate
--begin
--
--wr_rst_busy <= wr_rst_busy_sig;
--rd_rst_busy <= rd_rst_busy_sig;
--
--
--end generate FAMILY_8;
--
--FAMILY_NOT_8 : if   ((C_FAMILY /= "kintexu") and (C_FAMILY /= "virtexu") and (C_FAMILY /= "artixu")) generate
--begin
--
--wr_rst_busy <= '0';
--rd_rst_busy <= '0';
--
--
--end generate FAMILY_NOT_8;

FAMILY_NOT_7 : if ((C_FAMILY /= "kintex7") and (C_FAMILY /= "virtex7") and (C_FAMILY /= "artix7") and (C_FAMILY /= "zynq") and (C_FAMILY /= "spartan7"))   generate

begin

wr_rst_busy <= wr_rst_busy_sig;
rd_rst_busy <= rd_rst_busy_sig;


end generate FAMILY_NOT_7;

FAMILY_7 : if   ((C_FAMILY = "kintex7") or (C_FAMILY = "virtex7") or (C_FAMILY = "artix7") or (C_FAMILY = "zynq") or (C_FAMILY = "spartan7")) generate

begin

wr_rst_busy <= '0';
rd_rst_busy <= '0';


end generate FAMILY_7;



data_count <= sig_data_count(clog2(uw_fifo_depth)-1 downto 0);
ZERO_pntr <= (others => '0');
GND <= '0';

   xpm_fifo_sync_inst : xpm_fifo_sync
   generic map (
      DOUT_RESET_VALUE => "0",   
      ECC_MODE => "no_ecc",      
      FIFO_MEMORY_TYPE => "auto",
      FIFO_READ_LATENCY => 0,    
      FIFO_WRITE_DEPTH => uw_fifo_depth,  
      FULL_RESET_VALUE => 0,     
      PROG_EMPTY_THRESH => 10,    
      PROG_FULL_THRESH => 10,     
      RD_DATA_COUNT_WIDTH => clog2_uw_fifo_depth_plus_1,  
      READ_DATA_WIDTH => uw_data_width,     
      READ_MODE => "fwft",         
      USE_ADV_FEATURES => "1717", 
      WAKEUP_TIME => 0,           
      WRITE_DATA_WIDTH => uw_data_width,     
      WR_DATA_COUNT_WIDTH => clog2_uw_fifo_depth_plus_1    
   )
   port map (
      wr_clk => clk,               
      rst => rst,                     
      din => din,                     
      wr_en => wr_en,                  
      rd_en => rd_en,                 
      sleep => sleep,                 
      rd_rst_busy => rd_rst_busy_sig,     
      wr_rst_busy => wr_rst_busy_sig,     
      injectdbiterr => GND, 
      injectsbiterr => GND, 
      dout => dout,                   
      full => full,                   
      empty => empty,                 
      almost_full => ALMOST_FULL,     
      wr_ack => WR_ACK,               
      data_valid => VALID,       
      underflow => UNDERFLOW,         
      overflow => OVERFLOW,           
      almost_empty => ALMOST_EMPTY,   
      dbiterr => DBITERR,             
      sbiterr => SBITERR,             
      rd_data_count => WR_DATA_COUNT, 
      wr_data_count => sig_data_count, 
      prog_empty => PROG_EMPTY,       
      prog_full => PROG_FULL         
   );
--    backup                              => GND,
--    backup_marker                       => GND,
--    clk                                 => clk,
--    rst                                 => GND,
--    srst                                => rst,
--    wr_clk                              => GND,
--    wr_rst                              => GND,
--    rd_clk                              => GND,
--    rd_rst                              => GND,
--    din                                 => din,
--    wr_en                               => wr_en,
--    rd_en                               => rd_en,
--    sleep                     		=> sleep,
--    wr_rst_busy                     	=> wr_rst_busy_sig,
--    rd_rst_busy                     	=> rd_rst_busy_sig,
--
--    int_clk                             => GND,
--    injectdbiterr                       => GND,
--    injectsbiterr                       => GND,
--    dout                                => dout,
--    full                                => full,
--    empty                               => empty,
--    almost_full                         => ALMOST_FULL,
--    wr_ack                              => WR_ACK,
--    overflow                            => OVERFLOW,
--    almost_empty                        => ALMOST_EMPTY,
--    valid                               => VALID,
--    underflow                           => UNDERFLOW,
--    data_count                          => sig_data_count,
--    rd_data_count                       => RD_DATA_COUNT,
--    wr_data_count                       => WR_DATA_COUNT,
--    prog_full                           => PROG_FULL,
--    prog_empty                          => PROG_EMPTY,
--    sbiterr                             => SBITERR,
--    dbiterr                             => DBITERR,
--

--  fg_inst : entity fifo_generator_v13_2_5.fifo_generator_v13_2_5
--  GENERIC MAP (
--    C_COMMON_CLOCK                      => 1,
----    C_COUNT_TYPE                        => C_COUNT_TYPE,
--    C_COUNT_TYPE                        => 0,					--my
----    C_DATA_COUNT_WIDTH                  => C_DATA_COUNT_WIDTH,
--    C_DATA_COUNT_WIDTH                  => clog2_uw_fifo_depth_plus_1,		--my
----    C_DEFAULT_VALUE                     => C_DEFAULT_VALUE,
--    C_DIN_WIDTH                         => uw_data_width,
----    C_DOUT_RST_VAL                      => C_DOUT_RST_VAL,
--    C_DOUT_WIDTH                        => uw_data_width,
----    C_ENABLE_RLOCS                      => C_ENABLE_RLOCS,
--    --C_FAMILY                            => "virtex7",
--    C_FAMILY                            => C_FAMILY,				--my
--    --C_FULL_FLAGS_RST_VAL                => uw_full_flags_rst_val,
--    C_FULL_FLAGS_RST_VAL                => C_FULL_FLAGS_RST_VAL,					--my
----    C_HAS_ALMOST_EMPTY                  => C_HAS_ALMOST_EMPTY,
----    C_HAS_ALMOST_FULL                   => C_HAS_ALMOST_FULL,
----    C_HAS_BACKUP                        => C_HAS_BACKUP,
--    C_HAS_DATA_COUNT                    => 1,					--my
----    C_HAS_DATA_COUNT                    => C_HAS_DATA_COUNT,
----    C_HAS_INT_CLK                       => C_HAS_INT_CLK,
----    C_HAS_MEMINIT_FILE                  => C_HAS_MEMINIT_FILE,
----    C_HAS_OVERFLOW                      => C_HAS_OVERFLOW,
--    C_HAS_RD_DATA_COUNT                 => 0,					--my
----    C_HAS_RD_DATA_COUNT                 => C_HAS_RD_DATA_COUNT,
----    C_HAS_RD_RST                        => C_HAS_RD_RST,
--    C_EN_SAFETY_CKT                     => 0,
--    C_HAS_RST                           => 0,
--    C_HAS_SRST                          => 1,
----    C_HAS_UNDERFLOW                     => C_HAS_UNDERFLOW,
----    C_HAS_VALID                         => C_HAS_VALID,
----    C_HAS_WR_ACK                        => C_HAS_WR_ACK,
--    C_HAS_WR_DATA_COUNT                 => 0,					--my
----    C_HAS_WR_DATA_COUNT                 => C_HAS_WR_DATA_COUNT,
----    C_HAS_WR_RST                        => C_HAS_WR_RST,
--    --C_IMPLEMENTATION_TYPE               => C_IMPLEMENTATION_TYPE,
--    C_IMPLEMENTATION_TYPE               => 0,					--my --Block RAM
----    C_INIT_WR_PNTR_VAL                  => C_INIT_WR_PNTR_VAL,
--    --C_MEMORY_TYPE                       => C_MEMORY_TYPE,		
--    C_MEMORY_TYPE                       => 1,					--my --Block RAM
----    C_MIF_FILE_NAME                     => C_MIF_FILE_NAME,
----    C_OPTIMIZATION_MODE                 => C_OPTIMIZATION_MODE,
----    C_OVERFLOW_LOW                      => C_OVERFLOW_LOW,
--    --C_PRELOAD_LATENCY                   => C_PRELOAD_LATENCY,
--    --C_PRELOAD_REGS                      => C_PRELOAD_REGS,
--    C_PRELOAD_LATENCY                   => 0,					--my
--    C_PRELOAD_REGS                      => 1,					--my	
--    --C_PRIM_FIFO_TYPE                    => C_PRIM_FIFO_TYPE,
--      C_PRIM_FIFO_TYPE               =>  "512x36",  -- only used for V5 Hard FIFO        
--
--
--
--
--
--
--    C_PROG_EMPTY_THRESH_ASSERT_VAL      => 10,
--    C_PROG_EMPTY_THRESH_NEGATE_VAL      => 9,
--    C_PROG_EMPTY_TYPE                   => 0,
--    --C_PROG_FULL_THRESH_ASSERT_VAL       => if_then_else((UW_FIFO_TYPE = "BUILT_IN"), UW_FIFO_DEPTH-150, 14),		--my
--    --C_PROG_FULL_THRESH_NEGATE_VAL       => if_then_else((UW_FIFO_TYPE = "BUILT_IN"), UW_FIFO_DEPTH-160, 12),		--my
--    C_PROG_FULL_TYPE                    => 0,
--    C_RD_DATA_COUNT_WIDTH               => clog2_uw_fifo_depth,		--my
----    C_RD_DATA_COUNT_WIDTH               => C_RD_DATA_COUNT_WIDTH,
--    C_RD_DEPTH                          => uw_fifo_depth,
--    --C_RD_FREQ                           => C_RD_FREQ,
--    C_RD_FREQ                           => 1,					--my
--    C_RD_PNTR_WIDTH                     => clog2_uw_fifo_depth,
----    C_UNDERFLOW_LOW                     => C_UNDERFLOW_LOW,
----    C_USE_DOUT_RST                      => C_USE_DOUT_RST,
----    C_USE_ECC                           => C_USE_ECC,
--    C_USE_EMBEDDED_REG                  => 1,					--my
----    C_USE_EMBEDDED_REG                  => C_USE_EMBEDDED_REG,
----    C_USE_FIFO16_FLAGS                  => C_USE_FIFO16_FLAGS,
--    C_USE_FWFT_DATA_COUNT               => 1,					--my
----    C_USE_FWFT_DATA_COUNT               => C_USE_FWFT_DATA_COUNT,
----    C_VALID_LOW                         => C_VALID_LOW,
----    C_WR_ACK_LOW                        => C_WR_ACK_LOW,
--    C_WR_DATA_COUNT_WIDTH               => clog2_uw_fifo_depth,		--my
----    C_WR_DATA_COUNT_WIDTH               => C_WR_DATA_COUNT_WIDTH,
--    C_WR_DEPTH                          => uw_fifo_depth,
--    --C_WR_FREQ                           => C_WR_FREQ,
--    C_WR_FREQ                           => 1,					--my
--    C_WR_PNTR_WIDTH                     => clog2_uw_fifo_depth,
----    C_WR_RESPONSE_LATENCY               => C_WR_RESPONSE_LATENCY,
----    C_MSGON_VAL                         => C_MSGON_VAL,
----    C_ENABLE_RST_SYNC                   => C_ENABLE_RST_SYNC,
----    C_ERROR_INJECTION_TYPE              => C_ERROR_INJECTION_TYPE,
--    C_SYNCHRONIZER_STAGE                => MTBF_STAGES,
--
--              -- AXI Interface related parameters start here
--              C_INTERFACE_TYPE               =>  0,    --           : integer := 0; -- 0: Native Interface; 1: AXI Interface
--              C_AXI_TYPE                     =>  0,    --           : integer := 0; -- 0: AXI Stream; 1: AXI Full; 2: AXI Lite
--              C_HAS_AXI_WR_CHANNEL           =>  0,    --           : integer := 0;
--              C_HAS_AXI_RD_CHANNEL           =>  0,    --           : integer := 0;
--              C_HAS_SLAVE_CE                 =>  0,    --           : integer := 0;
--              C_HAS_MASTER_CE                =>  0,    --           : integer := 0;
--              C_ADD_NGC_CONSTRAINT           =>  0,    --           : integer := 0;
--              C_USE_COMMON_OVERFLOW          =>  0,    --           : integer := 0;
--              C_USE_COMMON_UNDERFLOW         =>  0,    --           : integer := 0;
--              C_USE_DEFAULT_SETTINGS         =>  0,    --           : integer := 0;
--
--              -- AXI Full/Lite
--              C_AXI_ID_WIDTH                 =>  4 ,    --           : integer := 0;
--              C_AXI_ADDR_WIDTH               =>  32,    --           : integer := 0;
--              C_AXI_DATA_WIDTH               =>  64,    --           : integer := 0;
--              C_AXI_LEN_WIDTH                =>  8,     --           : integer := 8;
--              C_AXI_LOCK_WIDTH               =>  2,     --           : integer := 2;
--              C_HAS_AXI_ID                   =>  0,     --           : integer := 0;
--              C_HAS_AXI_AWUSER               =>  0 ,    --           : integer := 0;
--              C_HAS_AXI_WUSER                =>  0 ,    --           : integer := 0;
--              C_HAS_AXI_BUSER                =>  0 ,    --           : integer := 0;
--              C_HAS_AXI_ARUSER               =>  0 ,    --           : integer := 0;
--              C_HAS_AXI_RUSER                =>  0 ,    --           : integer := 0;
--              C_AXI_ARUSER_WIDTH             =>  1 ,    --           : integer := 0;
--              C_AXI_AWUSER_WIDTH             =>  1 ,    --           : integer := 0;
--              C_AXI_WUSER_WIDTH              =>  1 ,    --           : integer := 0;
--              C_AXI_BUSER_WIDTH              =>  1 ,    --           : integer := 0;
--              C_AXI_RUSER_WIDTH              =>  1 ,    --           : integer := 0;
--                                                 
--              -- AXI Streaming
--              C_HAS_AXIS_TDATA               =>  0 ,    --           : integer := 0;
--              C_HAS_AXIS_TID                 =>  0 ,    --           : integer := 0;
--              C_HAS_AXIS_TDEST               =>  0 ,    --           : integer := 0;
--              C_HAS_AXIS_TUSER               =>  0 ,    --           : integer := 0;
--              C_HAS_AXIS_TREADY              =>  1 ,    --           : integer := 0;
--              C_HAS_AXIS_TLAST               =>  0 ,    --           : integer := 0;
--              C_HAS_AXIS_TSTRB               =>  0 ,    --           : integer := 0;
--              C_HAS_AXIS_TKEEP               =>  0 ,    --           : integer := 0;
--              C_AXIS_TDATA_WIDTH             =>  64,    --           : integer := 1;
--              C_AXIS_TID_WIDTH               =>  8 ,    --           : integer := 1;
--              C_AXIS_TDEST_WIDTH             =>  4 ,    --           : integer := 1;
--              C_AXIS_TUSER_WIDTH             =>  4 ,    --           : integer := 1;
--              C_AXIS_TSTRB_WIDTH             =>  4 ,    --           : integer := 1;
--              C_AXIS_TKEEP_WIDTH             =>  4 ,    --           : integer := 1;
--
--              -- AXI Channel Type
--              -- WACH --> Write Address Channel
--              -- WDCH --> Write Data Channel
--              -- WRCH --> Write Response Channel
--              -- RACH --> Read Address Channel
--              -- RDCH --> Read Data Channel
--              -- AXIS --> AXI Streaming
--              C_WACH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logic
--              C_WDCH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
--              C_WRCH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
--              C_RACH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
--              C_RDCH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
--              C_AXIS_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
--
--              -- AXI Implementation Type
--              -- 1 = Common Clock Block RAM FIFO
--              -- 2 = Common Clock Distributed RAM FIFO
--              -- 11 = Independent Clock Block RAM FIFO
--              -- 12 = Independent Clock Distributed RAM FIFO
--              C_IMPLEMENTATION_TYPE_WACH    =>  1,    --            : integer := 0;
--              C_IMPLEMENTATION_TYPE_WDCH    =>  1,    --            : integer := 0;
--              C_IMPLEMENTATION_TYPE_WRCH    =>  1,    --            : integer := 0;
--              C_IMPLEMENTATION_TYPE_RACH    =>  1,    --            : integer := 0;
--              C_IMPLEMENTATION_TYPE_RDCH    =>  1,    --            : integer := 0;
--              C_IMPLEMENTATION_TYPE_AXIS    =>  1,    --            : integer := 0;
--
--              -- AXI FIFO Type
--              -- 0 = Data FIFO
--              -- 1 = Packet FIFO
--              -- 2 = Low Latency Data FIFO
--              C_APPLICATION_TYPE_WACH      =>  0,    --             : integer := 0;
--              C_APPLICATION_TYPE_WDCH      =>  0,    --             : integer := 0;
--              C_APPLICATION_TYPE_WRCH      =>  0,    --             : integer := 0;
--              C_APPLICATION_TYPE_RACH      =>  0,    --             : integer := 0;
--              C_APPLICATION_TYPE_RDCH      =>  0,    --             : integer := 0;
--              C_APPLICATION_TYPE_AXIS      =>  0,    --             : integer := 0;
--
--              -- Enable ECC
--              -- 0 = ECC disabled
--              -- 1 = ECC enabled
--              C_USE_ECC_WACH               =>  0,    --             : integer := 0;
--              C_USE_ECC_WDCH               =>  0,    --             : integer := 0;
--              C_USE_ECC_WRCH               =>  0,    --             : integer := 0;
--              C_USE_ECC_RACH               =>  0,    --             : integer := 0;
--              C_USE_ECC_RDCH               =>  0,    --             : integer := 0;
--              C_USE_ECC_AXIS               =>  0,    --             : integer := 0;
--
--              -- ECC Error Injection Type
--              -- 0 = No Error Injection
--              -- 1 = Single Bit Error Injection
--              -- 2 = Double Bit Error Injection
--              -- 3 = Single Bit and Double Bit Error Injection
--              C_ERROR_INJECTION_TYPE_WACH  =>  0,    --             : integer := 0;
--              C_ERROR_INJECTION_TYPE_WDCH  =>  0,    --             : integer := 0;
--              C_ERROR_INJECTION_TYPE_WRCH  =>  0,    --             : integer := 0;
--              C_ERROR_INJECTION_TYPE_RACH  =>  0,    --             : integer := 0;
--              C_ERROR_INJECTION_TYPE_RDCH  =>  0,    --             : integer := 0;
--              C_ERROR_INJECTION_TYPE_AXIS  =>  0,    --             : integer := 0;
--
--              -- Input Data Width
--              -- Accumulation of all AXI input signal's width
--              C_DIN_WIDTH_WACH                    =>  32,    --      : integer := 1;
--              C_DIN_WIDTH_WDCH                    =>  64,    --      : integer := 1;
--              C_DIN_WIDTH_WRCH                    =>  2 ,    --      : integer := 1;
--              C_DIN_WIDTH_RACH                    =>  32,    --      : integer := 1;
--              C_DIN_WIDTH_RDCH                    =>  64,    --      : integer := 1;
--              C_DIN_WIDTH_AXIS                    =>  1 ,    --      : integer := 1;
--
--              C_WR_DEPTH_WACH                     =>  16  ,   --      : integer := 16;
--              C_WR_DEPTH_WDCH                     =>  1024,   --      : integer := 16;
--              C_WR_DEPTH_WRCH                     =>  16  ,   --      : integer := 16;
--              C_WR_DEPTH_RACH                     =>  16  ,   --      : integer := 16;
--              C_WR_DEPTH_RDCH                     =>  1024,   --      : integer := 16;
--              C_WR_DEPTH_AXIS                     =>  1024,   --      : integer := 16;
--
--              C_WR_PNTR_WIDTH_WACH                =>  4 ,    --      : integer := 4;
--              C_WR_PNTR_WIDTH_WDCH                =>  10,    --      : integer := 4;
--              C_WR_PNTR_WIDTH_WRCH                =>  4 ,    --      : integer := 4;
--              C_WR_PNTR_WIDTH_RACH                =>  4 ,    --      : integer := 4;
--              C_WR_PNTR_WIDTH_RDCH                =>  10,    --      : integer := 4;
--              C_WR_PNTR_WIDTH_AXIS                =>  10,    --      : integer := 4;
--
--              C_HAS_DATA_COUNTS_WACH              =>  0,    --      : integer := 0;
--              C_HAS_DATA_COUNTS_WDCH              =>  0,    --      : integer := 0;
--              C_HAS_DATA_COUNTS_WRCH              =>  0,    --      : integer := 0;
--              C_HAS_DATA_COUNTS_RACH              =>  0,    --      : integer := 0;
--              C_HAS_DATA_COUNTS_RDCH              =>  0,    --      : integer := 0;
--              C_HAS_DATA_COUNTS_AXIS              =>  0,    --      : integer := 0;
--
--              C_HAS_PROG_FLAGS_WACH               =>  0,    --      : integer := 0;
--              C_HAS_PROG_FLAGS_WDCH               =>  0,    --      : integer := 0;
--              C_HAS_PROG_FLAGS_WRCH               =>  0,    --      : integer := 0;
--              C_HAS_PROG_FLAGS_RACH               =>  0,    --      : integer := 0;
--              C_HAS_PROG_FLAGS_RDCH               =>  0,    --      : integer := 0;
--              C_HAS_PROG_FLAGS_AXIS               =>  0,    --      : integer := 0;
--
--              C_PROG_FULL_TYPE_WACH               =>  5   ,    --      : integer := 0;
--              C_PROG_FULL_TYPE_WDCH               =>  5   ,    --      : integer := 0;
--              C_PROG_FULL_TYPE_WRCH               =>  5   ,    --      : integer := 0;
--              C_PROG_FULL_TYPE_RACH               =>  5   ,    --      : integer := 0;
--              C_PROG_FULL_TYPE_RDCH               =>  5   ,    --      : integer := 0;
--              C_PROG_FULL_TYPE_AXIS               =>  5   ,    --      : integer := 0;
--              C_PROG_FULL_THRESH_ASSERT_VAL_WACH  =>  1023,    --      : integer := 0;
--              C_PROG_FULL_THRESH_ASSERT_VAL_WDCH  =>  1023,    --      : integer := 0;
--              C_PROG_FULL_THRESH_ASSERT_VAL_WRCH  =>  1023,    --      : integer := 0;
--              C_PROG_FULL_THRESH_ASSERT_VAL_RACH  =>  1023,    --      : integer := 0;
--              C_PROG_FULL_THRESH_ASSERT_VAL_RDCH  =>  1023,    --      : integer := 0;
--              C_PROG_FULL_THRESH_ASSERT_VAL_AXIS  =>  1023,    --      : integer := 0;
--
--              C_PROG_EMPTY_TYPE_WACH              =>  5   ,    --      : integer := 0;
--              C_PROG_EMPTY_TYPE_WDCH              =>  5   ,    --      : integer := 0;
--              C_PROG_EMPTY_TYPE_WRCH              =>  5   ,    --      : integer := 0;
--              C_PROG_EMPTY_TYPE_RACH              =>  5   ,    --      : integer := 0;
--              C_PROG_EMPTY_TYPE_RDCH              =>  5   ,    --      : integer := 0;
--              C_PROG_EMPTY_TYPE_AXIS              =>  5   ,    --      : integer := 0;
--              C_PROG_EMPTY_THRESH_ASSERT_VAL_WACH =>  1022,    --      : integer := 0;
--              C_PROG_EMPTY_THRESH_ASSERT_VAL_WDCH =>  1022,    --      : integer := 0;
--              C_PROG_EMPTY_THRESH_ASSERT_VAL_WRCH =>  1022,    --      : integer := 0;
--              C_PROG_EMPTY_THRESH_ASSERT_VAL_RACH =>  1022,    --      : integer := 0;
--              C_PROG_EMPTY_THRESH_ASSERT_VAL_RDCH =>  1022,    --      : integer := 0;
--              C_PROG_EMPTY_THRESH_ASSERT_VAL_AXIS =>  1022,    --      : integer := 0;
--
--              C_REG_SLICE_MODE_WACH               =>  0,    --      : integer := 0;
--              C_REG_SLICE_MODE_WDCH               =>  0,    --      : integer := 0;
--              C_REG_SLICE_MODE_WRCH               =>  0,    --      : integer := 0;
--              C_REG_SLICE_MODE_RACH               =>  0,    --      : integer := 0;
--              C_REG_SLICE_MODE_RDCH               =>  0,    --      : integer := 0;
--              C_REG_SLICE_MODE_AXIS               =>  0     --      : integer := 0
--
--
--  )
--  PORT MAP (
--    backup                              => GND,
--    backup_marker                       => GND,
--    clk                                 => clk,
--    rst                                 => GND,
--    srst                                => rst,
--    wr_clk                              => GND,
--    wr_rst                              => GND,
--    rd_clk                              => GND,
--    rd_rst                              => GND,
--    din                                 => din,
--    wr_en                               => wr_en,
--    rd_en                               => rd_en,
--    sleep                     		=> sleep,
--    wr_rst_busy                     	=> wr_rst_busy_sig,
--    rd_rst_busy                     	=> rd_rst_busy_sig,
--
--    prog_empty_thresh                   => ZERO_pntr,
--    prog_empty_thresh_assert            => ZERO_pntr,
--    prog_empty_thresh_negate            => ZERO_pntr,
--    prog_full_thresh                    => ZERO_pntr,
--    prog_full_thresh_assert             => ZERO_pntr,
--    prog_full_thresh_negate             => ZERO_pntr,
--
--
--    int_clk                             => GND,
--    injectdbiterr                       => GND,
--    injectsbiterr                       => GND,
--    dout                                => dout,
--    full                                => full,
--    empty                               => empty,
--    almost_full                         => ALMOST_FULL,
--    wr_ack                              => WR_ACK,
--    overflow                            => OVERFLOW,
--    almost_empty                        => ALMOST_EMPTY,
--    valid                               => VALID,
--    underflow                           => UNDERFLOW,
--    data_count                          => sig_data_count,
--    rd_data_count                       => RD_DATA_COUNT,
--    wr_data_count                       => WR_DATA_COUNT,
--    prog_full                           => PROG_FULL,
--    prog_empty                          => PROG_EMPTY,
--    sbiterr                             => SBITERR,
--    dbiterr                             => DBITERR,
--
--              m_aclk                    =>  '0',                   --       : IN  std_logic := '0';
--              s_aclk                    =>  '0',                   --       : IN  std_logic := '0';
--              s_aresetn                 =>  '0',                   --       : IN  std_logic := '0';
--              m_aclk_en                 =>  '0',                   --       : IN  std_logic := '0';
--              s_aclk_en                 =>  '0',                   --       : IN  std_logic := '0';
--
--              -- AXI Full/Lite Slave Write Channel (write side)
--              s_axi_awid                =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awaddr              =>  "00000000000000000000000000000000",   --(others => '0'),      --      : IN  std_logic_vector(C_AXI_ADDR_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awlen               =>  "00000000",          --(others => '0'),      --      : IN  std_logic_vector(8-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awsize              =>  "000",          --(others => '0'),      --      : IN  std_logic_vector(3-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awburst             =>  "00",           --(others => '0'),      --      : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awlock              =>  "00",           --(others => '0'),      --      : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awcache             =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awprot              =>  "000",          --(others => '0'),      --      : IN  std_logic_vector(3-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awqos               =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awregion            =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awuser              =>  "0",            --(others => '0'),      --      : IN  std_logic_vector(C_AXI_AWUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awvalid             =>  '0',                  --      : IN  std_logic := '0';
--              s_axi_awready             =>  S_AXI_AWREADY,        --      : OUT std_logic;
--              s_axi_wid                 =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_wdata               =>  "0000000000000000000000000000000000000000000000000000000000000000", --(others => '0'),      --      : IN  std_logic_vector(C_AXI_DATA_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_wstrb               =>  "00000000",          --(others => '0'),      --      : IN  std_logic_vector(C_AXI_DATA_WIDTH/8-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_wlast               =>  '0',                  --      : IN  std_logic := '0';
--              s_axi_wuser               =>  "0",            --(others => '0'),      --      : IN  std_logic_vector(C_AXI_WUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_wvalid              =>  '0',                  --      : IN  std_logic := '0';
--              s_axi_wready              =>  S_AXI_WREADY,         --      : OUT std_logic;
--              s_axi_bid                 =>  S_AXI_BID,            --      : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_bresp               =>  S_AXI_BRESP,          --      : OUT std_logic_vector(2-1 DOWNTO 0);
--              s_axi_buser               =>  S_AXI_BUSER,          --      : OUT std_logic_vector(C_AXI_BUSER_WIDTH-1 DOWNTO 0);
--              s_axi_bvalid              =>  S_AXI_BVALID,          --      : OUT std_logic;
--              s_axi_bready              =>  '0',                  --      : IN  std_logic := '0';
--
--              -- AXI Full/Lite Master Write Channel (Read side)
--              m_axi_awid                =>  M_AXI_AWID,           --       : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0);
--              m_axi_awaddr              =>  M_AXI_AWADDR,         --       : OUT std_logic_vector(C_AXI_ADDR_WIDTH-1 DOWNTO 0);
--              m_axi_awlen               =>  M_AXI_AWLEN,          --       : OUT std_logic_vector(8-1 DOWNTO 0);
--              m_axi_awsize              =>  M_AXI_AWSIZE,         --       : OUT std_logic_vector(3-1 DOWNTO 0);
--              m_axi_awburst             =>  M_AXI_AWBURST,        --       : OUT std_logic_vector(2-1 DOWNTO 0);
--              m_axi_awlock              =>  M_AXI_AWLOCK,         --       : OUT std_logic_vector(2-1 DOWNTO 0);
--              m_axi_awcache             =>  M_AXI_AWCACHE,        --       : OUT std_logic_vector(4-1 DOWNTO 0);
--              m_axi_awprot              =>  M_AXI_AWPROT,         --       : OUT std_logic_vector(3-1 DOWNTO 0);
--              m_axi_awqos               =>  M_AXI_AWQOS,          --       : OUT std_logic_vector(4-1 DOWNTO 0);
--              m_axi_awregion            =>  M_AXI_AWREGION,       --       : OUT std_logic_vector(4-1 DOWNTO 0);
--              m_axi_awuser              =>  M_AXI_AWUSER,         --       : OUT std_logic_vector(C_AXI_AWUSER_WIDTH-1 DOWNTO 0);
--              m_axi_awvalid             =>  M_AXI_AWVALID,        --       : OUT std_logic;
--              m_axi_awready             =>  '0',                  --       : IN  std_logic := '0';
--              m_axi_wid                 =>  M_AXI_WID,            --       : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0);
--              m_axi_wdata               =>  M_AXI_WDATA,          --       : OUT std_logic_vector(C_AXI_DATA_WIDTH-1 DOWNTO 0);
--              m_axi_wstrb               =>  M_AXI_WSTRB,          --       : OUT std_logic_vector(C_AXI_DATA_WIDTH/8-1 DOWNTO 0);
--              m_axi_wlast               =>  M_AXI_WLAST,          --       : OUT std_logic;
--              m_axi_wuser               =>  M_AXI_WUSER,          --       : OUT std_logic_vector(C_AXI_WUSER_WIDTH-1 DOWNTO 0);
--              m_axi_wvalid              =>  M_AXI_WVALID,         --       : OUT std_logic;
--              m_axi_wready              =>  '0',                  --       : IN  std_logic := '0';
--              m_axi_bid                 =>  "0000",               --(others => '0'),      --       : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              m_axi_bresp               =>  "00",                 --(others => '0'),      --       : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
--              m_axi_buser               =>  "0",                  --(others => '0'),      --       : IN  std_logic_vector(C_AXI_BUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              m_axi_bvalid              =>  '0',                  --       : IN  std_logic := '0';
--              m_axi_bready              =>  M_AXI_BREADY,         --       : OUT std_logic;
--
--              -- AXI Full/Lite Slave Read Channel (Write side)
--              s_axi_arid               =>  "0000",         --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_araddr             =>  "00000000000000000000000000000000",   --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(C_AXI_ADDR_WIDTH-1 DOWNTO 0) := (OTHERS => '0'); 
--              s_axi_arlen              =>  "00000000",          --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(8-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arsize             =>  "000",          --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(3-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arburst            =>  "00",           --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arlock             =>  "00",           --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arcache            =>  "0000",         --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arprot             =>  "000",          --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(3-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arqos              =>  "0000",         --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arregion           =>  "0000",         --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_aruser             =>  "0",            --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(C_AXI_ARUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arvalid            =>  '0',                   --       : IN  std_logic := '0';
--              s_axi_arready            =>  S_AXI_ARREADY,         --       : OUT std_logic;
--              s_axi_rid                =>  S_AXI_RID,             --       : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0);       
--              s_axi_rdata              =>  S_AXI_RDATA,           --       : OUT std_logic_vector(C_AXI_DATA_WIDTH-1 DOWNTO 0); 
--              s_axi_rresp              =>  S_AXI_RRESP,           --       : OUT std_logic_vector(2-1 DOWNTO 0);
--              s_axi_rlast              =>  S_AXI_RLAST,           --       : OUT std_logic;
--              s_axi_ruser              =>  S_AXI_RUSER,           --       : OUT std_logic_vector(C_AXI_RUSER_WIDTH-1 DOWNTO 0);
--              s_axi_rvalid             =>  S_AXI_RVALID,          --       : OUT std_logic;
--              s_axi_rready             =>  '0',                   --       : IN  std_logic := '0';
--
--              -- AXI Full/Lite Master Read Channel (Read side)
--              m_axi_arid               =>  M_AXI_ARID,           --        : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0);        
--              m_axi_araddr             =>  M_AXI_ARADDR,         --        : OUT std_logic_vector(C_AXI_ADDR_WIDTH-1 DOWNTO 0);  
--              m_axi_arlen              =>  M_AXI_ARLEN,          --        : OUT std_logic_vector(8-1 DOWNTO 0);
--              m_axi_arsize             =>  M_AXI_ARSIZE,         --        : OUT std_logic_vector(3-1 DOWNTO 0);
--              m_axi_arburst            =>  M_AXI_ARBURST,        --        : OUT std_logic_vector(2-1 DOWNTO 0);
--              m_axi_arlock             =>  M_AXI_ARLOCK,         --        : OUT std_logic_vector(2-1 DOWNTO 0);
--              m_axi_arcache            =>  M_AXI_ARCACHE,        --        : OUT std_logic_vector(4-1 DOWNTO 0);
--              m_axi_arprot             =>  M_AXI_ARPROT,         --        : OUT std_logic_vector(3-1 DOWNTO 0);
--              m_axi_arqos              =>  M_AXI_ARQOS,          --        : OUT std_logic_vector(4-1 DOWNTO 0);
--              m_axi_arregion           =>  M_AXI_ARREGION,       --        : OUT std_logic_vector(4-1 DOWNTO 0);
--              m_axi_aruser             =>  M_AXI_ARUSER,         --        : OUT std_logic_vector(C_AXI_ARUSER_WIDTH-1 DOWNTO 0);
--              m_axi_arvalid            =>  M_AXI_ARVALID,        --        : OUT std_logic;
--              m_axi_arready            =>  '0',                  --        : IN  std_logic := '0';
--              m_axi_rid                =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');        
--              m_axi_rdata              =>  "0000000000000000000000000000000000000000000000000000000000000000", --(others => '0'),      --        : IN  std_logic_vector(C_AXI_DATA_WIDTH-1 DOWNTO 0) := (OTHERS => '0');  
--              m_axi_rresp              =>  "00",                 --(others => '0'),      --        : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
--              m_axi_rlast              =>  '0',                  --        : IN  std_logic := '0';
--              m_axi_ruser              =>  "0",                  --(others => '0'),      --        : IN  std_logic_vector(C_AXI_RUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              m_axi_rvalid             =>  '0',                  --        : IN  std_logic := '0';
--              m_axi_rready             =>  M_AXI_RREADY,         --        : OUT std_logic;
--
--              -- AXI Streaming Slave Signals (Write side)
--              s_axis_tvalid            =>  '0',                  --        : IN  std_logic := '0';
--              s_axis_tready            =>  S_AXIS_TREADY,        --        : OUT std_logic;
--              s_axis_tdata             =>  "0000000000000000000000000000000000000000000000000000000000000000", --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TDATA_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axis_tstrb             =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TSTRB_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axis_tkeep             =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TKEEP_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axis_tlast             =>  '0',                  --        : IN  std_logic := '0';
--              s_axis_tid               =>  "00000000",                 --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axis_tdest             =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TDEST_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axis_tuser             =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--
--              -- AXI Streaming Master Signals (Read side)
--              m_axis_tvalid            =>  M_AXIS_TVALID,        --        : OUT std_logic;
--              m_axis_tready            =>  '0',                  --        : IN  std_logic := '0';
--              m_axis_tdata             =>  M_AXIS_TDATA,         --        : OUT std_logic_vector(C_AXIS_TDATA_WIDTH-1 DOWNTO 0);
--              m_axis_tstrb             =>  M_AXIS_TSTRB,         --        : OUT std_logic_vector(C_AXIS_TSTRB_WIDTH-1 DOWNTO 0);
--              m_axis_tkeep             =>  M_AXIS_TKEEP,         --        : OUT std_logic_vector(C_AXIS_TKEEP_WIDTH-1 DOWNTO 0);
--              m_axis_tlast             =>  M_AXIS_TLAST,         --        : OUT std_logic;
--              m_axis_tid               =>  M_AXIS_TID,           --        : OUT std_logic_vector(C_AXIS_TID_WIDTH-1 DOWNTO 0);
--              m_axis_tdest             =>  M_AXIS_TDEST,         --        : OUT std_logic_vector(C_AXIS_TDEST_WIDTH-1 DOWNTO 0);
--              m_axis_tuser             =>  M_AXIS_TUSER,         --        : OUT std_logic_vector(C_AXIS_TUSER_WIDTH-1 DOWNTO 0);
--
--              -- AXI Full/Lite Write Address Channel Signals
--              axi_aw_injectsbiterr     =>  '0',                  --        : IN  std_logic := '0';
--              axi_aw_injectdbiterr     =>  '0',                  --        : IN  std_logic := '0';
--              axi_aw_prog_full_thresh  =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WACH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_aw_prog_empty_thresh =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WACH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_aw_data_count        =>  AXI_AW_DATA_COUNT,    --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WACH DOWNTO 0);
--              axi_aw_wr_data_count     =>  AXI_AW_WR_DATA_COUNT, --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WACH DOWNTO 0);
--              axi_aw_rd_data_count     =>  AXI_AW_RD_DATA_COUNT, --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WACH DOWNTO 0);
--              axi_aw_sbiterr           =>  AXI_AW_SBITERR,       --        : OUT std_logic;
--              axi_aw_dbiterr           =>  AXI_AW_DBITERR,       --        : OUT std_logic;
--              axi_aw_overflow          =>  AXI_AW_OVERFLOW,      --        : OUT std_logic;
--              axi_aw_underflow         =>  AXI_AW_UNDERFLOW,     --        : OUT std_logic;
--              axi_aw_prog_full         =>  AXI_AW_PROG_FULL,     --        : OUT STD_LOGIC := '0';
--              axi_aw_prog_empty        =>  AXI_AW_PROG_EMPTY,    --        : OUT STD_LOGIC := '1';
--
--
--              -- AXI Full/Lite Write Data Channel Signals
--              axi_w_injectsbiterr      =>  '0',                  --        : IN  std_logic := '0';
--              axi_w_injectdbiterr      =>  '0',                  --        : IN  std_logic := '0';
--              axi_w_prog_full_thresh   =>  "0000000000",         --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WDCH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_w_prog_empty_thresh  =>  "0000000000",         --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WDCH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_w_data_count         =>  AXI_W_DATA_COUNT,     --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WDCH DOWNTO 0);
--              axi_w_wr_data_count      =>  AXI_W_WR_DATA_COUNT,  --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WDCH DOWNTO 0);
--              axi_w_rd_data_count      =>  AXI_W_RD_DATA_COUNT,  --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WDCH DOWNTO 0);
--              axi_w_sbiterr            =>  AXI_W_SBITERR,        --        : OUT std_logic;
--              axi_w_dbiterr            =>  AXI_W_DBITERR,        --        : OUT std_logic;
--              axi_w_overflow           =>  AXI_W_OVERFLOW,       --        : OUT std_logic;
--              axi_w_underflow          =>  AXI_W_UNDERFLOW,      --        : OUT std_logic;
--              axi_w_prog_full          =>  AXI_W_PROG_FULL,      --        : OUT STD_LOGIC := '0';
--              axi_w_prog_empty         =>  AXI_W_PROG_EMPTY,     --        : OUT STD_LOGIC := '1';
--
--              -- AXI Full/Lite Write Response Channel Signals
--              axi_b_injectsbiterr      =>  '0',                  --        : IN  std_logic := '0';
--              axi_b_injectdbiterr      =>  '0',                  --        : IN  std_logic := '0';
--              axi_b_prog_full_thresh   =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WRCH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_b_prog_empty_thresh  =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WRCH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_b_data_count         =>  AXI_B_DATA_COUNT,     --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WRCH DOWNTO 0);
--              axi_b_wr_data_count      =>  AXI_B_WR_DATA_COUNT,  --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WRCH DOWNTO 0);
--              axi_b_rd_data_count      =>  AXI_B_RD_DATA_COUNT,  --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WRCH DOWNTO 0);
--              axi_b_sbiterr            =>  AXI_B_SBITERR,        --        : OUT std_logic;
--              axi_b_dbiterr            =>  AXI_B_DBITERR,        --        : OUT std_logic;
--              axi_b_overflow           =>  AXI_B_OVERFLOW,       --        : OUT std_logic;
--              axi_b_underflow          =>  AXI_B_UNDERFLOW,      --        : OUT std_logic;
--              axi_b_prog_full          =>  AXI_B_PROG_FULL,      --        : OUT STD_LOGIC := '0';
--              axi_b_prog_empty         =>  AXI_B_PROG_EMPTY,     --        : OUT STD_LOGIC := '1';
--
--              -- AXI Full/Lite Read Address Channel Signals
--              axi_ar_injectsbiterr     =>  '0',                  --        : IN  std_logic := '0';
--              axi_ar_injectdbiterr     =>  '0',                  --        : IN  std_logic := '0';
--              axi_ar_prog_full_thresh  =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_RACH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_ar_prog_empty_thresh =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_RACH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_ar_data_count        =>  AXI_AR_DATA_COUNT,    --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_RACH DOWNTO 0);
--              axi_ar_wr_data_count     =>  AXI_AR_WR_DATA_COUNT, --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_RACH DOWNTO 0);
--              axi_ar_rd_data_count     =>  AXI_AR_RD_DATA_COUNT, --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_RACH DOWNTO 0);
--              axi_ar_sbiterr           =>  AXI_AR_SBITERR,       --        : OUT std_logic;
--              axi_ar_dbiterr           =>  AXI_AR_DBITERR,       --        : OUT std_logic;
--              axi_ar_overflow          =>  AXI_AR_OVERFLOW,      --        : OUT std_logic;
--              axi_ar_underflow         =>  AXI_AR_UNDERFLOW,     --        : OUT std_logic;
--              axi_ar_prog_full         =>  AXI_AR_PROG_FULL,     --        : OUT STD_LOGIC := '0';
--              axi_ar_prog_empty        =>  AXI_AR_PROG_EMPTY,    --        : OUT STD_LOGIC := '1';
--
--              -- AXI Full/Lite Read Data Channel Signals
--              axi_r_injectsbiterr     =>  '0',                  --         : IN  std_logic := '0';
--              axi_r_injectdbiterr     =>  '0',                  --         : IN  std_logic := '0';
--              axi_r_prog_full_thresh  =>  "0000000000",         --(others => '0'),      --         : IN  std_logic_vector(C_WR_PNTR_WIDTH_RDCH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_r_prog_empty_thresh =>  "0000000000",         --(others => '0'),      --         : IN  std_logic_vector(C_WR_PNTR_WIDTH_RDCH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_r_data_count        =>  AXI_R_DATA_COUNT,     --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_RDCH DOWNTO 0);
--              axi_r_wr_data_count     =>  AXI_R_WR_DATA_COUNT,  --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_RDCH DOWNTO 0);
--              axi_r_rd_data_count     =>  AXI_R_RD_DATA_COUNT,  --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_RDCH DOWNTO 0);
--              axi_r_sbiterr           =>  AXI_R_SBITERR,        --         : OUT std_logic;
--              axi_r_dbiterr           =>  AXI_R_DBITERR,        --         : OUT std_logic;
--              axi_r_overflow          =>  AXI_R_OVERFLOW,       --         : OUT std_logic;
--              axi_r_underflow         =>  AXI_R_UNDERFLOW,      --         : OUT std_logic;
--              axi_r_prog_full         =>  AXI_R_PROG_FULL,      --         : OUT STD_LOGIC := '0';
--              axi_r_prog_empty        =>  AXI_R_PROG_EMPTY,     --         : OUT STD_LOGIC := '1';
--
--              -- AXI Streaming FIFO Related Signals
--              axis_injectsbiterr      =>  '0',                  --         : IN  std_logic := '0';
--              axis_injectdbiterr      =>  '0',                  --         : IN  std_logic := '0';
--              axis_prog_full_thresh   =>  "0000000000",         --(others => '0'),      --         : IN  std_logic_vector(C_WR_PNTR_WIDTH_AXIS-1 DOWNTO 0) := (OTHERS => '0');
--              axis_prog_empty_thresh  =>  "0000000000",         --(others => '0'),      --         : IN  std_logic_vector(C_WR_PNTR_WIDTH_AXIS-1 DOWNTO 0) := (OTHERS => '0');
--              axis_data_count         =>  AXIS_DATA_COUNT,      --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_AXIS DOWNTO 0);
--              axis_wr_data_count      =>  AXIS_WR_DATA_COUNT,   --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_AXIS DOWNTO 0);
--              axis_rd_data_count      =>  AXIS_RD_DATA_COUNT,   --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_AXIS DOWNTO 0);
--              axis_sbiterr            =>  AXIS_SBITERR,         --         : OUT std_logic;
--              axis_dbiterr            =>  AXIS_DBITERR,         --         : OUT std_logic;
--              axis_overflow           =>  AXIS_OVERFLOW,        --         : OUT std_logic;
--              axis_underflow          =>  AXIS_UNDERFLOW,       --         : OUT std_logic
--              axis_prog_full          =>  AXIS_PROG_FULL,       --         : OUT STD_LOGIC := '0';
--              axis_prog_empty         =>  AXIS_PROG_EMPTY       --         : OUT STD_LOGIC := '1';
--  );
--
--
END ARCHITECTURE xilinx;




-------------------------------------------------------------------------------
-- axi_vdma_sfifo_autord.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_sfifo_autord.vhd
-- Version:         initial
-- Description:
--    This file contains the logic to generate a CoreGen call to create a
-- synchronous FIFO as part of the synthesis process of XST. This eliminates
-- the need for multiple fixed netlists for various sizes and widths of FIFOs.
--
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;

library lib_fifo_v1_0_14;
use lib_fifo_v1_0_14.sync_fifo_fg;


library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;


-------------------------------------------------------------------------------

entity axi_vdma_sfifo_autord is
  generic (
     C_DWIDTH                : integer := 32;
       -- Sets the width of the FIFO Data

     C_DEPTH                 : integer := 128;
       -- Sets the depth of the FIFO

     C_DATA_CNT_WIDTH        : integer := 8;
       -- Sets the width of the FIFO Data Count output

     C_NEED_ALMOST_EMPTY     : Integer range 0 to 1 := 0;
       -- Indicates the need for an almost empty flag from the internal FIFO

     C_NEED_ALMOST_FULL      : Integer range 0 to 1 := 0;
       -- Indicates the need for an almost full flag from the internal FIFO

     C_USE_BLKMEM            : Integer range 0 to 1 := 1;
       -- Sets the type of memory to use for the FIFO
       -- 0 = Distributed Logic
       -- 1 = Block Ram

     C_FAMILY                : String  := "virtex7"
       -- Specifies the target FPGA Family

    );
  port (

    -- FIFO Inputs ------------------------------------------------------------------
     SFIFO_Sinit             : In  std_logic;                                      --
     SFIFO_Clk               : In  std_logic;                                      --
     SFIFO_Wr_en             : In  std_logic;                                      --
     SFIFO_Din               : In  std_logic_vector(C_DWIDTH-1 downto 0);          --
     SFIFO_Rd_en             : In  std_logic;                                      --
     SFIFO_Clr_Rd_Data_Valid : In  std_logic;                                      --
     --------------------------------------------------------------------------------

    -- FIFO Outputs -----------------------------------------------------------------
     SFIFO_DValid            : Out std_logic;                                      --
     SFIFO_Dout              : Out std_logic_vector(C_DWIDTH-1 downto 0);          --
     SFIFO_Full              : Out std_logic;                                      --
     SFIFO_Empty             : Out std_logic;                                      --
     SFIFO_Almost_full       : Out std_logic;                                      --
     SFIFO_Almost_empty      : Out std_logic;                                      --
     SFIFO_Rd_count          : Out std_logic_vector(C_DATA_CNT_WIDTH-1 downto 0);  --
     SFIFO_Rd_count_minus1   : Out std_logic_vector(C_DATA_CNT_WIDTH-1 downto 0);  --
     SFIFO_Wr_count          : Out std_logic_vector(C_DATA_CNT_WIDTH-1 downto 0);  --
     SFIFO_Rd_ack            : Out std_logic                                       --
     --------------------------------------------------------------------------------

    );
end entity axi_vdma_sfifo_autord;

-----------------------------------------------------------------------------
-- Architecture section
-----------------------------------------------------------------------------

architecture imp of axi_vdma_sfifo_autord is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";


-- Constant declarations

   -- none

-- Signal declarations

   signal write_data_lil_end         : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
   signal read_data_lil_end          : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
   signal raw_data_cnt_lil_end       : std_logic_vector(C_DATA_CNT_WIDTH-1 downto 0) := (others => '0');
   signal raw_data_count_int         : natural := 0;
   signal raw_data_count_corr        : std_logic_vector(C_DATA_CNT_WIDTH-1 downto 0) := (others => '0');
   signal raw_data_count_corr_minus1 : std_logic_vector(C_DATA_CNT_WIDTH-1 downto 0) := (others => '0');
   Signal corrected_empty            : std_logic := '0';
   Signal corrected_almost_empty     : std_logic := '0';
   Signal sig_SFIFO_empty            : std_logic := '0';

   -- backend fifo read ack sample and hold
   Signal sig_rddata_valid           : std_logic := '0';
   Signal hold_ff_q                  : std_logic := '0';
   Signal ored_ack_ff_reset          : std_logic := '0';
   Signal autoread                   : std_logic := '0';
   Signal sig_sfifo_rdack            : std_logic := '0';
   Signal fifo_read_enable           : std_logic := '0';



begin

 -- Bit ordering translations

    write_data_lil_end    <=  SFIFO_Din;  -- translate from Big Endian to little
                                          -- endian.

    SFIFO_Dout            <= read_data_lil_end;  -- translate from Little Endian to
                                                 -- Big endian.


 -- Other port usages and assignments
    SFIFO_Rd_ack          <= sig_sfifo_rdack;

    SFIFO_Almost_empty    <= corrected_almost_empty;

    SFIFO_Empty           <= corrected_empty;

    SFIFO_Wr_count        <= raw_data_cnt_lil_end;


    SFIFO_Rd_count        <= raw_data_count_corr;


    SFIFO_Rd_count_minus1 <= raw_data_count_corr_minus1;



    SFIFO_DValid          <= sig_rddata_valid; -- Output data valid indicator


    fifo_read_enable      <= SFIFO_Rd_en or autoread;








    ------------------------------------------------------------
    -- Instance: I_SYNC_FIFOGEN_FIFO
    --
    -- Description:
    --  Instance for the synchronous fifo from proc common.
    --
    ------------------------------------------------------------
    I_SYNC_FIFOGEN_FIFO : entity lib_fifo_v1_0_14.sync_fifo_fg
      generic map(
	 C_XPM_FIFO	      =>  1,
         C_FAMILY             =>  C_FAMILY,        -- requred for FIFO Gen
         C_DCOUNT_WIDTH       =>  C_DATA_CNT_WIDTH,
         C_ENABLE_RLOCS       =>  0,
         C_HAS_DCOUNT         =>  1,
          C_SYNCHRONIZER_STAGE          =>  MTBF_STAGES,
         C_HAS_RD_ACK         =>  1,
         C_HAS_RD_ERR         =>  0,
         C_HAS_WR_ACK         =>  1,
         C_HAS_WR_ERR         =>  0,
         C_MEMORY_TYPE        =>  C_USE_BLKMEM,
         C_PORTS_DIFFER       =>  0,
         C_RD_ACK_LOW         =>  0,
         C_READ_DATA_WIDTH    =>  C_DWIDTH,
         C_READ_DEPTH         =>  C_DEPTH,
         C_RD_ERR_LOW         =>  0,
         C_WR_ACK_LOW         =>  0,
         C_WR_ERR_LOW         =>  0,
         C_WRITE_DATA_WIDTH   =>  C_DWIDTH,
         C_WRITE_DEPTH        =>  C_DEPTH
         --C_WRITE_DEPTH        =>  C_DEPTH,
         --C_PRELOAD_REGS       =>  1, -- 1 = first word fall through
         --C_PRELOAD_LATENCY    =>  0, -- 0 = first word fall through
         --C_USE_EMBEDDED_REG   =>  1  -- 0 ;
         )
      port map(
         Clk                  =>  SFIFO_Clk,
         Sinit                =>  SFIFO_Sinit,
         Din                  =>  write_data_lil_end,
         Wr_en                =>  SFIFO_Wr_en,
         Rd_en                =>  fifo_read_enable,
         Dout                 =>  read_data_lil_end,
         Full                 =>  SFIFO_Full,
         Empty                =>  sig_SFIFO_empty,
         Rd_ack               =>  sig_sfifo_rdack,
         Wr_ack               =>  open,
         Rd_err               =>  open,
         Wr_err               =>  open,
         Data_count           =>  raw_data_cnt_lil_end
        );

   -------------------------------------------------------------------------------






   -------------------------------------------------------------------------------
   -- Read Ack assert & hold logic Needed because....
   -------------------------------------------------------------------------------
   --     1) The CoreGen Sync FIFO has to be read once to get valid
   --        data to the read data port.
   --     2) The Read ack from the fifo is only asserted for 1 clock.
   --     3) A signal is needed that indicates valid data is at the read
   --        port of the FIFO and has not yet been used. This signal needs
   --        to be held until the next read operation occurs or a clear
   --        signal is received.


    ored_ack_ff_reset  <=  fifo_read_enable or
                           SFIFO_Sinit or
                           SFIFO_Clr_Rd_Data_Valid;

    sig_rddata_valid   <=  hold_ff_q or
                           sig_sfifo_rdack;




    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_ACK_HOLD_FLOP
    --
    -- Process Description:
    --  Flop for registering the hold flag
    --
    -------------------------------------------------------------
    IMP_ACK_HOLD_FLOP : process (SFIFO_Clk)
       begin
         if (SFIFO_Clk'event and SFIFO_Clk = '1') then
           if (ored_ack_ff_reset = '1') then
             hold_ff_q  <= '0';
           else
             hold_ff_q  <= sig_rddata_valid;
           end if;
         end if;
       end process IMP_ACK_HOLD_FLOP;



    -- generate auto-read enable. This keeps fresh data at the output
    -- of the FIFO whenever it is available.
    autoread <= '1'                     -- create a read strobe when the
      when (sig_rddata_valid = '0' and  -- output data is NOT valid
            sig_SFIFO_empty = '0')      -- and the FIFO is not empty
      Else '0';


    raw_data_count_int <=  CONV_INTEGER(raw_data_cnt_lil_end);




    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: INCLUDE_ALMOST_EMPTY
    --
    -- If Generate Description:
    --  This IFGen corrects the FIFO Read Count output for the
    --  auto read function and includes the generation of the
    --  Almost_Empty flag.
    --
    ------------------------------------------------------------
    INCLUDE_ALMOST_EMPTY : if (C_NEED_ALMOST_EMPTY = 1) generate

       -- local signals

          Signal raw_data_count_int_corr        : integer := 0;
          Signal raw_data_count_int_corr_minus1 : integer := 0;

       begin


         -------------------------------------------------------------
         -- Combinational Process
         --
         -- Label: CORRECT_RD_CNT_IAE
         --
         -- Process Description:
         --  This process corrects the FIFO Read Count output for the
         --  auto read function and includes the generation of the
         --  Almost_Empty flag.
         --
         -------------------------------------------------------------
         CORRECT_RD_CNT_IAE : process (sig_rddata_valid,
                                       sig_SFIFO_empty,
                                       raw_data_count_int)
            begin


               if (sig_rddata_valid = '0') then

                  raw_data_count_int_corr        <= 0;
                  raw_data_count_int_corr_minus1 <= 0;
                  corrected_empty                <= '1';
                  corrected_almost_empty         <= '0';

               elsif (sig_SFIFO_empty = '1') then   -- rddata valid and fifo empty

                  raw_data_count_int_corr        <= 1;
                  raw_data_count_int_corr_minus1 <= 0;
                  corrected_empty                <= '0';
                  corrected_almost_empty         <= '1';

               Elsif (raw_data_count_int = 1) Then  -- rddata valid and fifo almost empty

                  raw_data_count_int_corr        <= 2;
                  raw_data_count_int_corr_minus1 <= 1;
                  corrected_empty                <= '0';
                  corrected_almost_empty         <= '0';

               else                                 -- rddata valid and modify rd count from FIFO

                  raw_data_count_int_corr        <= raw_data_count_int+1;
                  raw_data_count_int_corr_minus1 <= raw_data_count_int;
                  corrected_empty                <= '0';
                  corrected_almost_empty         <= '0';

               end if;

            end process CORRECT_RD_CNT_IAE;


            raw_data_count_corr <= CONV_STD_LOGIC_VECTOR(raw_data_count_int_corr,
                                                         C_DATA_CNT_WIDTH);

            raw_data_count_corr_minus1 <= CONV_STD_LOGIC_VECTOR(raw_data_count_int_corr_minus1,
                                                                 C_DATA_CNT_WIDTH);

       end generate INCLUDE_ALMOST_EMPTY;



    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: OMIT_ALMOST_EMPTY
    --
    -- If Generate Description:
    --    This process corrects the FIFO Read Count output for the
    -- auto read function and omits the generation of the
    -- Almost_Empty flag.
    --
    ------------------------------------------------------------
    OMIT_ALMOST_EMPTY : if (C_NEED_ALMOST_EMPTY = 0) generate

       -- local signals

          Signal raw_data_count_int_corr : integer := 0;

       begin

          corrected_almost_empty  <= '0'; -- always low


          -------------------------------------------------------------
          -- Combinational Process
          --
          -- Label: CORRECT_RD_CNT
          --
          -- Process Description:
          --    This process corrects the FIFO Read Count output for the
          -- auto read function and omits the generation of the
          -- Almost_Empty flag.
          --
          -------------------------------------------------------------
          CORRECT_RD_CNT : process (sig_rddata_valid,
                                    sig_SFIFO_empty,
                                    raw_data_count_int)
             begin


                if (sig_rddata_valid = '0') then

                   raw_data_count_int_corr <= 0;
                   corrected_empty         <= '1';

                elsif (sig_SFIFO_empty = '1') then   -- rddata valid and fifo empty

                   raw_data_count_int_corr <= 1;
                   corrected_empty         <= '0';

                Elsif (raw_data_count_int = 1) Then  -- rddata valid and fifo almost empty

                   raw_data_count_int_corr <= 2;
                   corrected_empty         <= '0';

                else                                 -- rddata valid and modify rd count from FIFO

                   raw_data_count_int_corr <= raw_data_count_int+1;
                   corrected_empty         <= '0';

                end if;

             end process CORRECT_RD_CNT;


             raw_data_count_corr <= CONV_STD_LOGIC_VECTOR(raw_data_count_int_corr,
                                                          C_DATA_CNT_WIDTH);



       end generate OMIT_ALMOST_EMPTY;




    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: INCLUDE_ALMOST_FULL
    --
    -- If Generate Description:
    --  This IfGen Includes the generation of the Amost_Full flag.
    --
    --
    ------------------------------------------------------------
    INCLUDE_ALMOST_FULL : if (C_NEED_ALMOST_FULL = 1) generate

       -- Local Constants

         Constant ALMOST_FULL_VALUE : integer := 2**(C_DATA_CNT_WIDTH-1)-1;

       begin

          SFIFO_Almost_full <= '1'
             When raw_data_count_int = ALMOST_FULL_VALUE
             Else '0';


       end generate INCLUDE_ALMOST_FULL;




    ------------------------------------------------------------
    -- If Generate
    --
    -- Label: OMIT_ALMOST_FULL
    --
    -- If Generate Description:
    --  This IfGen Omits the generation of the Amost_Full flag.
    --
    --
    ------------------------------------------------------------
    OMIT_ALMOST_FULL : if (C_NEED_ALMOST_FULL = 0) generate

       begin

           SFIFO_Almost_full <= '0';  -- always low

       end generate OMIT_ALMOST_FULL;



end imp;


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- axi_vdma_afifo_builtin.vhd - entity/architecture pair
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010, 2012-2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--



LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
library fifo_generator_v13_2_5;
use fifo_generator_v13_2_5.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.all;
--use proc_common_v4_0.coregen_comp_defs.all;
--use proc_common_v4_0.family_support.all;


library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;


-- synopsys translate_off
--library XilinxCoreLib;
--use XilinxCoreLib.all;
-- synopsys translate_on


ENTITY axi_vdma_afifo_builtin IS
  GENERIC (
    -------------------------------------------------------------------------
    -- Generic Declarations
    -------------------------------------------------------------------------
    PL_FIFO_TYPE          : STRING  := "BLOCK_RAM"; -- BLOCK_RAM, LUTRAM, BUILT_IN; Default: BLOCK_RAM
    PL_READ_MODE          : STRING  := "STANDARD";  -- STANDARD, FWFT; Default: STANDARD
    PL_FASTER_CLOCK       : STRING  := "WR_CLK";    -- WR_CLK, RD_CLK; Default: WR_CLK
    PL_FULL_FLAGS_RST_VAL : INTEGER := 1;           -- 1, 0; Default: 1
    PL_DATA_WIDTH         : INTEGER := 16;          -- 1 - 1024; Default 16
    C_FAMILY              : string  := "virtex7";
    PL_FIFO_DEPTH         : INTEGER := 1024         -- 16 - 256K; Default 1K
    );
  PORT (

    -- Common signal
    rst              : in  std_logic := '0';

    sleep            : in  std_logic := '0';
    wr_rst_busy      : out std_logic := '0';
    rd_rst_busy      : out std_logic := '0';
    -- Write Domain signals
    wr_clk           : in  std_logic := '0';
    din              : in  std_logic_vector(PL_DATA_WIDTH-1 downto 0) := (others => '0');
    wr_en            : in  std_logic := '0';
    full             : out std_logic := '0';

    -- Write Domain signals
    rd_clk           : in  std_logic := '0';
    rd_en            : in  std_logic := '0';
    dout             : out std_logic_vector(PL_DATA_WIDTH-1 downto 0) := (others => '0');
    empty            : out std_logic := '1'

    );
END ENTITY axi_vdma_afifo_builtin;

ARCHITECTURE xilinx OF axi_vdma_afifo_builtin IS
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of xilinx : architecture is "yes";


  ---------------------------------------------------------------------------
  -- FUNCTION : log2roundup
  ---------------------------------------------------------------------------
  FUNCTION log2roundup (
      data_value : integer)
  	RETURN integer IS
  	
  	VARIABLE width       : integer := 0;
  	VARIABLE cnt         : integer := 1;
  	CONSTANT lower_limit : integer := 1;
  	CONSTANT upper_limit : integer := 8;
  	
  BEGIN
  	IF (data_value <= 1) THEN
      width   := 0;
  	ELSE
  	  WHILE (cnt < data_value) LOOP
  	    width := width + 1;
  	    cnt   := cnt *2;
  	  END LOOP;
  	END IF;
  	
  	RETURN width;
  END log2roundup;

  ------------------------------------------------------------------------------
  -- This function is used to implement an IF..THEN when such a statement is not
  --  allowed. 
  ------------------------------------------------------------------------------
  FUNCTION if_then_else (
    condition : boolean; 
    true_case : integer; 
    false_case : integer) 
  RETURN integer IS
    VARIABLE retval : integer := 0;
  BEGIN
    IF NOT condition THEN
      retval:=false_case;
    ELSE
      retval:=true_case;
    END IF;
    RETURN retval;
  END if_then_else;

  ------------------------------------------------------------------------------
   -- This function is used to implement an IF..THEN when such a statement is not
   --  allowed and returns string. 
   ------------------------------------------------------------------------------
   function if_then_else (
     condition : boolean; 
     true_case : string;
     false_case : string) 
   return string is
   begin
     if not condition then
       return false_case;
     else
       return true_case;
     end if;
   end if_then_else;
  
    -----------------------------------------------------------------------------
    -- FUNCTION: to_lower_case_char
    -- Returns the lower case form of char IF char is an upper case letter.
    -- Otherwise char is returned.
    -----------------------------------------------------------------------------
    FUNCTION to_lower_case_char(
      char : character )
    RETURN character IS
    BEGIN
      -------------------------------------------------------------------------
      -- If char is not an upper case letter THEN return char
      --
      -- Otherwise map char to its corresponding lower case character and
      -- return that
      -------------------------------------------------------------------------
      IF char<'A' OR char>'Z' THEN
        RETURN char;
      END IF;
  
      CASE char IS
        WHEN 'A' => RETURN 'a';
        WHEN 'B' => RETURN 'b';
        WHEN 'C' => RETURN 'c';
        WHEN 'D' => RETURN 'd';
        WHEN 'E' => RETURN 'e';
        WHEN 'F' => RETURN 'f';
        WHEN 'G' => RETURN 'g';
        WHEN 'H' => RETURN 'h';
        WHEN 'I' => RETURN 'i';
        WHEN 'J' => RETURN 'j';
        WHEN 'K' => RETURN 'k';
        WHEN 'L' => RETURN 'l';
        WHEN 'M' => RETURN 'm';
        WHEN 'N' => RETURN 'n';
        WHEN 'O' => RETURN 'o';
        WHEN 'P' => RETURN 'p';
        WHEN 'Q' => RETURN 'q';
        WHEN 'R' => RETURN 'r';
        WHEN 'S' => RETURN 's';
        WHEN 'T' => RETURN 't';
        WHEN 'U' => RETURN 'u';
        WHEN 'V' => RETURN 'v';
        WHEN 'W' => RETURN 'w';
        WHEN 'X' => RETURN 'x';
        WHEN 'Y' => RETURN 'y';
        WHEN 'Z' => RETURN 'z';
        WHEN OTHERS => RETURN char;
      END CASE;
    END to_lower_case_char;
  
    -----------------------------------------------------------------------------
    -- Returns true IF case insensitive string comparison determines that
    -- str1 and str2 are equal
    -----------------------------------------------------------------------------
    FUNCTION equal_ignore_case(
      str1 : string;
      str2 : string )
    RETURN boolean IS
      CONSTANT len1 : integer := str1'length;
      CONSTANT len2 : integer := str2'length;
      VARIABLE equal : boolean := TRUE;
    BEGIN
      IF NOT (len1=len2) THEN
        equal := FALSE;
      ELSE
        FOR i IN str2'left TO str1'right LOOP
          IF NOT (to_lower_case_char(str1(i)) = to_lower_case_char(str2(i))) THEN
            equal := FALSE;
          END IF;
        END LOOP;
      END IF;
  
      RETURN equal;
    END equal_ignore_case;

  --#############################################################
  --#
  --# Get the Primitive fifo type
  --# Description: Algorithm for Built-In FIFO implementation
  --# to determine which primitive is most optimal to use 
  --#
  --#############################################################

  function get_Prim_Fifo_Type (
    width    : integer;
    depth    : integer;
    use_ecc  : integer)
  return string is

    variable prim_4kx4_used   : integer :=  (((width-1)/4 +1)*((depth-1)/4096 +1));
    variable prim_2kx9_used   : integer :=  (((width-1)/9 +1)*((depth-1)/2048 +1));
    variable prim_1kx18_used  : integer :=  (((width-1)/18+1)*((depth-1)/1024 +1));
    variable prim_512x36_used : integer :=  (((width-1)/36+1)*((depth-1)/512  +1));
    variable prim_8kx4_used   : integer :=  (((width-1)/4 +1)*((depth-1)/8192 +1));
    variable prim_4kx9_used   : integer :=  (((width-1)/9 +1)*((depth-1)/4096 +1));
    variable prim_2kx18_used  : integer :=  (((width-1)/18+1)*((depth-1)/2048 +1));
    variable prim_1kx36_used  : integer :=  (((width-1)/36+1)*((depth-1)/1024 +1));
    variable prim_512x72_used : integer :=  (((width-1)/72+1)*((depth-1)/512  +1));
     
    variable min_used    : integer := prim_4kx4_used;
    variable min_type    : string (1 to 6) := "4kx4  ";
  begin
     
     if (use_ecc = 0) then      

       --##########################################################
       --# Rules: Primitive used should
       --# - generate correct full flags if depth >= 512
       --# - use min number of primitives
       --# - use primitive that reduces latency when possible
       --# This creates 3 cases:
       --# 1) depth <= 512
       --# 2) depth = 1k 
       --# 3) depth = 2k 
       --# 4) depth >= 4k
       --##########################################################
       if (depth <= 512) then

         if (min_used > prim_512x72_used) then
           min_used := prim_512x72_used;
           min_type := "512x72";     
         else
           min_used := prim_512x36_used;
           min_type := "512x36";     
         end if;

       elsif (depth = 1024) then
           min_used := prim_1kx18_used;
           min_type := "1kx18 ";     

         if (min_used > prim_512x36_used) then
           min_used := prim_512x36_used;
           min_type := "512x36";     
         end if;

         if (min_used > prim_1kx36_used) then
           min_used := prim_1kx36_used;
           min_type := "1kx36 ";     
         end if;

         if (min_used > prim_512x72_used) then
           min_used := prim_512x72_used;
           min_type := "512x72";     
         end if;

       elsif (depth = 2048) then
           min_used := prim_2kx9_used;
           min_type := "2kx9  ";     

         if (min_used > prim_1kx18_used) then
           min_used := prim_1kx18_used;
           min_type := "1kx18 ";     
         end if;

         if (min_used > prim_512x36_used) then
           min_used := prim_512x36_used;
           min_type := "512x36";     
         end if;

         if (min_used > prim_2kx18_used) then
           min_used := prim_2kx18_used;
           min_type := "2kx18 ";     
         end if;

         if (min_used > prim_1kx36_used) then
           min_used := prim_1kx36_used;
           min_type := "1kx36 ";     
         end if;

         if (min_used > prim_512x72_used) then
           min_used := prim_512x72_used;
           min_type := "512x72";     
         end if;

       else
           min_used := prim_4kx4_used;
           min_type := "4kx4  ";     

         if (min_used > prim_2kx9_used) then
           min_used := prim_2kx9_used;
           min_type := "2kx9  ";     
         end if;

         if (min_used > prim_1kx18_used) then
           min_used := prim_1kx18_used;
           min_type := "1kx18 ";     
         end if;

         if (min_used > prim_512x36_used) then
           min_used := prim_512x36_used;
           min_type := "512x36";     
         end if;

         if (min_used > prim_8kx4_used) then
           min_used := prim_8kx4_used;
           min_type := "8kx4  ";     
         end if;

         if (min_used > prim_4kx9_used) then
           min_used := prim_4kx9_used;
           min_type := "4kx9  ";     
         end if;

         if (min_used > prim_2kx18_used) then
           min_used := prim_2kx18_used;
           min_type := "2kx18 ";     
         end if;

         if (min_used > prim_1kx36_used) then
           min_used := prim_1kx36_used;
           min_type := "1kx36 ";     
         end if;

         if (min_used > prim_512x72_used) then
           min_used := prim_512x72_used;
           min_type := "512x72";     
         end if;
       end if;
    else
      
      -- if ecc is used, always use the 512x72 primitive
      min_used := prim_512x72_used;
      min_type := "512x72";     
 
    end if;
      
     return min_type;
  end get_Prim_Fifo_Type;

  --CONSTANT GND : std_logic := '0';
  CONSTANT VCC : std_logic := '1';

  CONSTANT ZERO1 : std_logic_vector(0 downto 0) := (others => '0');
  CONSTANT ZERO2 : std_logic_vector(1 downto 0) := (others => '0');
  CONSTANT ZERO3 : std_logic_vector(2 downto 0) := (others => '0');
  CONSTANT ZERO4 : std_logic_vector(3 downto 0) := (others => '0');
  CONSTANT ZERO8 : std_logic_vector(7 downto 0) := (others => '0');
  CONSTANT ZERO16 : std_logic_vector(15 downto 0) := (others => '0');
  CONSTANT ZERO32 : std_logic_vector(31 downto 0) := (others => '0');
  CONSTANT ZERO64 : std_logic_vector(63 downto 0) := (others => '0');
  --CONSTANT ZERO_pntr : std_logic_vector(log2roundup(pl_fifo_depth)-1 downto 0) := (others => '0');

  CONSTANT C_PRELOAD_LATENCY : integer := if_then_else((PL_READ_MODE = "FWFT"), 0, 1);
  CONSTANT C_PRELOAD_REGS    : integer := if_then_else((PL_READ_MODE = "FWFT"), 1, 0);
  CONSTANT C_WR_FREQ         : integer := if_then_else((PL_FASTER_CLOCK = "WR_CLK"), 10, 1);
  CONSTANT C_RD_FREQ         : integer := if_then_else((PL_FASTER_CLOCK = "RD_CLK"), 10, 1);

  CONSTANT C_MEMORY_TYPE     : integer := if_then_else((PL_FIFO_TYPE = "BLOCK_RAM"), 1,
                                          if_then_else((PL_FIFO_TYPE = "LUTRAM"), 2,
                                          if_then_else((PL_FIFO_TYPE = "BUILT_IN"), 4, 0)));

  CONSTANT C_IMPLEMENTATION_TYPE : integer := if_then_else((PL_FIFO_TYPE = "BLOCK_RAM"), 0,
                                              if_then_else((PL_FIFO_TYPE = "LUTRAM"), 0,
                                              if_then_else((PL_FIFO_TYPE = "BUILT_IN"), 6, 8)));

  CONSTANT PRIM_FIFO_TYPE    : string := get_Prim_Fifo_Type(pl_data_width,pl_fifo_depth,0);
  CONSTANT C_PRIM_FIFO_TYPE  : string := if_then_else(PRIM_FIFO_TYPE = "8kx4  ", "8kx4",
                                         if_then_else(PRIM_FIFO_TYPE = "4kx9  ", "4kx9",
                                         if_then_else(PRIM_FIFO_TYPE = "4kx4  ", "4kx4",
                                         if_then_else(PRIM_FIFO_TYPE = "2kx18 ", "2kx18",
                                         if_then_else(PRIM_FIFO_TYPE = "2kx9  ", "2kx9",
                                         if_then_else(PRIM_FIFO_TYPE = "1kx36 ", "1kx36",
                                         if_then_else(PRIM_FIFO_TYPE = "1kx18 ", "1kx18",
                                         if_then_else(PRIM_FIFO_TYPE = "512x72", "512x72",
                                         if_then_else(PRIM_FIFO_TYPE = "512x36", "512x36","")))))))));

  CONSTANT IS_FIFO_TYPE_VLD  : integer := if_then_else((PL_FIFO_TYPE = "BLOCK_RAM") or 
                                                       (PL_FIFO_TYPE = "LUTRAM") or 
                                                       (PL_FIFO_TYPE = "BUILT_IN"), 1, 0);
  CONSTANT IS_READ_MODE_VLD  : integer := if_then_else((PL_READ_MODE = "STANDARD") or 
                                                       (PL_READ_MODE = "FWFT"), 1, 0);
  CONSTANT IS_DATA_WIDTH_VLD : integer := if_then_else(PL_DATA_WIDTH > 0 and PL_DATA_WIDTH <= 1024, 1, 0);
  CONSTANT IS_FIFO_DEPTH_VLD : integer := if_then_else((PL_FIFO_DEPTH = 16 or PL_FIFO_DEPTH = 32 or PL_FIFO_DEPTH = 64 or
                                                       PL_FIFO_DEPTH = 128 or PL_FIFO_DEPTH = 256 or PL_FIFO_DEPTH = 512 or
                                                       PL_FIFO_DEPTH = 1024 or PL_FIFO_DEPTH = 2048 or PL_FIFO_DEPTH = 4096 or
                                                       PL_FIFO_DEPTH = 8192 or PL_FIFO_DEPTH = 16384 or PL_FIFO_DEPTH = 32768 or
                                                       PL_FIFO_DEPTH = 65536 or PL_FIFO_DEPTH = 131072 or PL_FIFO_DEPTH = 262144),1,0);
  CONSTANT VLD_BI_DEPTH      : integer := if_then_else((PL_FIFO_DEPTH = 512 or PL_FIFO_DEPTH = 1024 or PL_FIFO_DEPTH = 2048 or PL_FIFO_DEPTH = 4096 or
                                                       PL_FIFO_DEPTH = 8192 or PL_FIFO_DEPTH = 16384 or PL_FIFO_DEPTH = 32768 or
                                                       PL_FIFO_DEPTH = 65536 or PL_FIFO_DEPTH = 131072 or PL_FIFO_DEPTH = 262144),1,0);
--  CONSTANT IS_BI_DEPTH_VLD   : integer := if_then_else((VLD_BI_DEPTH = 1 and PL_FIFO_TYPE = "BUILT_IN"), 1, 0);
  CONSTANT IS_BI_DEPTH_VLD   : integer := if_then_else((VLD_BI_DEPTH = 1), 1, 0);
  CONSTANT log2roundup_pl_fifo_depth   : integer := log2roundup(pl_fifo_depth);
  CONSTANT PROG_FULL_THRESH_ASSERT_VAL_1   : integer := if_then_else((PL_FIFO_TYPE = "BUILT_IN"), PL_FIFO_DEPTH-150, 14);
  CONSTANT PROG_FULL_THRESH_NEGATE_VAL_1   : integer := if_then_else((PL_FIFO_TYPE = "BUILT_IN"), PL_FIFO_DEPTH-160, 12);

  --CONSTANT SYNC_RST_PORT    : integer := if_then_else(((C_FAMILY = "kintexu") or (C_FAMILY = "virtexu") or (C_FAMILY = "artixu")), 1, 0);		-- ultra-scale
  --CONSTANT ASYNC_RST_PORT   : integer := if_then_else(((C_FAMILY /= "kintexu") and (C_FAMILY /= "virtexu") and (C_FAMILY /= "artixu")), 1, 0);		-- 7-series (not ultrascale)

  CONSTANT SYNC_RST_PORT   : integer := if_then_else(((C_FAMILY /= "kintex7") and (C_FAMILY /= "virtex7") and (C_FAMILY /= "artix7") and (C_FAMILY /= "zynq") and (C_FAMILY /= "spartan7")), 1, 0);		--not 7-series 
  CONSTANT ASYNC_RST_PORT    : integer := if_then_else(((C_FAMILY = "kintex7") or (C_FAMILY = "virtex7") or (C_FAMILY = "artix7") or (C_FAMILY = "zynq") or (C_FAMILY = "spartan7")), 1, 0);		-- 7-series
  --Signals added to fix MTI and XSIM issues caused by fix for VCS issues not to use "LIBRARY_SCAN = TRUE"
  signal ZERO_pntr : std_logic_vector(log2roundup_pl_fifo_depth-1 downto 0) := (others => '0');
  signal GND : std_logic := '0';
   signal ALMOST_FULL           : std_logic;                 
   signal WR_ACK           : std_logic;                 
   signal OVERFLOW           : std_logic;                 
   signal ALMOST_EMPTY           : std_logic;                 
   signal VALID           : std_logic;                 
   signal UNDERFLOW           : std_logic;                 
   signal PROG_FULL           : std_logic;                 
   signal PROG_EMPTY          : std_logic;                 
   signal SBITERR             : std_logic;                 
   signal DBITERR             : std_logic;                  
   signal S_AXI_AWREADY       : std_logic;
   signal S_AXI_WREADY        : std_logic;
   signal S_AXI_BID           : std_logic_vector(3 DOWNTO 0);
   signal S_AXI_BRESP         : std_logic_vector(2-1 DOWNTO 0);
   signal S_AXI_BUSER         : std_logic_vector(0 downto 0);
   signal S_AXI_BVALID        : std_logic;

   -- AXI Full/Lite Master Write Channel (Read side)
   signal M_AXI_AWID          : std_logic_vector(3 DOWNTO 0);
   signal M_AXI_AWADDR        : std_logic_vector(31 DOWNTO 0);
   signal M_AXI_AWLEN         : std_logic_vector(8-1 DOWNTO 0);
   signal M_AXI_AWSIZE        : std_logic_vector(3-1 DOWNTO 0);
   signal M_AXI_AWBURST       : std_logic_vector(2-1 DOWNTO 0);
   signal M_AXI_AWLOCK        : std_logic_vector(2-1 DOWNTO 0);
   signal M_AXI_AWCACHE       : std_logic_vector(4-1 DOWNTO 0);
   signal M_AXI_AWPROT        : std_logic_vector(3-1 DOWNTO 0);
   signal M_AXI_AWQOS         : std_logic_vector(4-1 DOWNTO 0);
   signal M_AXI_AWREGION      : std_logic_vector(4-1 DOWNTO 0);
   signal M_AXI_AWUSER        : std_logic_vector(0 downto 0);
   signal M_AXI_AWVALID       : std_logic;
   signal M_AXI_WID           : std_logic_vector(3 DOWNTO 0);
   signal M_AXI_WDATA         : std_logic_vector(63 DOWNTO 0);
   signal M_AXI_WSTRB         : std_logic_vector(7 DOWNTO 0);
   signal M_AXI_WLAST         : std_logic;
   signal M_AXI_WUSER         : std_logic_vector(0 downto 0);
   signal M_AXI_WVALID        : std_logic;
   signal M_AXI_BREADY        : std_logic;

   -- AXI Full/Lite Slave Read Channel (Write side)
   signal S_AXI_ARREADY       : std_logic;
   signal S_AXI_RID           : std_logic_vector(3 DOWNTO 0);       
   signal S_AXI_RDATA         : std_logic_vector(63 DOWNTO 0); 
   signal S_AXI_RRESP         : std_logic_vector(2-1 DOWNTO 0);
   signal S_AXI_RLAST         : std_logic;
   signal S_AXI_RUSER         : std_logic_vector(0 downto 0);
   signal S_AXI_RVALID        : std_logic;

   -- AXI Full/Lite Master Read Channel (Read side)
   signal M_AXI_ARID          : std_logic_vector(3 DOWNTO 0);        
   signal M_AXI_ARADDR        : std_logic_vector(31 DOWNTO 0);  
   signal M_AXI_ARLEN         : std_logic_vector(8-1 DOWNTO 0);
   signal M_AXI_ARSIZE        : std_logic_vector(3-1 DOWNTO 0);
   signal M_AXI_ARBURST       : std_logic_vector(2-1 DOWNTO 0);
   signal M_AXI_ARLOCK        : std_logic_vector(2-1 DOWNTO 0);
   signal M_AXI_ARCACHE       : std_logic_vector(4-1 DOWNTO 0);
   signal M_AXI_ARPROT        : std_logic_vector(3-1 DOWNTO 0);
   signal M_AXI_ARQOS         : std_logic_vector(4-1 DOWNTO 0);
   signal M_AXI_ARREGION      : std_logic_vector(4-1 DOWNTO 0);
   signal M_AXI_ARUSER        : std_logic_vector(0 downto 0);
   signal M_AXI_ARVALID       : std_logic;
   signal M_AXI_RREADY        : std_logic;

   -- AXI Streaming Slave Signals (Write side)
   signal S_AXIS_TREADY       : std_logic;

   -- AXI Streaming Master Signals (Read side)
   signal M_AXIS_TVALID       : std_logic;
   signal M_AXIS_TDATA        : std_logic_vector(63 DOWNTO 0);
   signal M_AXIS_TSTRB        : std_logic_vector(3 DOWNTO 0);
   signal M_AXIS_TKEEP        : std_logic_vector(3 DOWNTO 0);
   signal M_AXIS_TLAST        : std_logic;
   signal M_AXIS_TID          : std_logic_vector(7 DOWNTO 0);
   signal M_AXIS_TDEST        : std_logic_vector(3 DOWNTO 0);
   signal M_AXIS_TUSER        : std_logic_vector(3 DOWNTO 0);

   -- AXI Full/Lite Write Address Channel Signals
   signal AXI_AW_DATA_COUNT    : std_logic_vector(4 DOWNTO 0);
   signal AXI_AW_WR_DATA_COUNT : std_logic_vector(4 DOWNTO 0);
   signal AXI_AW_RD_DATA_COUNT : std_logic_vector(4 DOWNTO 0);
   signal AXI_AW_SBITERR       : std_logic;
   signal AXI_AW_DBITERR       : std_logic;
   signal AXI_AW_OVERFLOW      : std_logic;
   signal AXI_AW_UNDERFLOW     : std_logic;
   signal AXI_AW_PROG_FULL     : STD_LOGIC;
   signal AXI_AW_PROG_EMPTY    : STD_LOGIC;


   -- AXI Full/Lite Write Data Channel Signals
   signal AXI_W_DATA_COUNT     : std_logic_vector(10 DOWNTO 0);
   signal AXI_W_WR_DATA_COUNT  : std_logic_vector(10 DOWNTO 0);
   signal AXI_W_RD_DATA_COUNT  : std_logic_vector(10 DOWNTO 0);
   signal AXI_W_SBITERR        : std_logic;
   signal AXI_W_DBITERR        : std_logic;
   signal AXI_W_OVERFLOW       : std_logic;
   signal AXI_W_UNDERFLOW      : std_logic;
   signal AXI_W_PROG_FULL      : STD_LOGIC;
   signal AXI_W_PROG_EMPTY     : STD_LOGIC;

   -- AXI Full/Lite Write Response Channel Signals
   signal AXI_B_DATA_COUNT     : std_logic_vector(4 DOWNTO 0);
   signal AXI_B_WR_DATA_COUNT  : std_logic_vector(4 DOWNTO 0);
   signal AXI_B_RD_DATA_COUNT  : std_logic_vector(4 DOWNTO 0);
   signal AXI_B_SBITERR        : std_logic;
   signal AXI_B_DBITERR        : std_logic;
   signal AXI_B_OVERFLOW       : std_logic;
   signal AXI_B_UNDERFLOW      : std_logic;
   signal AXI_B_PROG_FULL      : STD_LOGIC;
   signal AXI_B_PROG_EMPTY     : STD_LOGIC;

   -- AXI Full/Lite Read Address Channel Signals
   signal AXI_AR_DATA_COUNT    : std_logic_vector(4 DOWNTO 0);
   signal AXI_AR_WR_DATA_COUNT : std_logic_vector(4 DOWNTO 0);
   signal AXI_AR_RD_DATA_COUNT : std_logic_vector(4 DOWNTO 0);
   signal AXI_AR_SBITERR       : std_logic;
   signal AXI_AR_DBITERR       : std_logic;
   signal AXI_AR_OVERFLOW      : std_logic;
   signal AXI_AR_UNDERFLOW     : std_logic;
   signal AXI_AR_PROG_FULL     : STD_LOGIC;
   signal AXI_AR_PROG_EMPTY    : STD_LOGIC;

   -- AXI Full/Lite Read Data Channel Signals
   signal AXI_R_DATA_COUNT     : std_logic_vector(10 DOWNTO 0);
   signal AXI_R_WR_DATA_COUNT  : std_logic_vector(10 DOWNTO 0);
   signal AXI_R_RD_DATA_COUNT  : std_logic_vector(10 DOWNTO 0);
   signal AXI_R_SBITERR        : std_logic;
   signal AXI_R_DBITERR        : std_logic;
   signal AXI_R_OVERFLOW       : std_logic;
   signal AXI_R_UNDERFLOW      : std_logic;
   signal AXI_R_PROG_FULL      : STD_LOGIC;
   signal AXI_R_PROG_EMPTY     : STD_LOGIC;

   -- AXI Streaming FIFO Related Signals
   signal AXIS_DATA_COUNT      : std_logic_vector(10 DOWNTO 0);
   signal AXIS_WR_DATA_COUNT   : std_logic_vector(10 DOWNTO 0);
   signal AXIS_RD_DATA_COUNT   : std_logic_vector(10 DOWNTO 0);
   signal AXIS_SBITERR         : std_logic;
   signal AXIS_DBITERR         : std_logic;
   signal AXIS_OVERFLOW        : std_logic;
   signal AXIS_UNDERFLOW       : std_logic;
   signal AXIS_PROG_FULL       : STD_LOGIC;
   signal AXIS_PROG_EMPTY      : STD_LOGIC;
  --Signals added to fix MTI and XSIM issues caused by fix for VCS issues not to use "LIBRARY_SCAN = TRUE"
   signal DATA_COUNT          : std_logic_vector(log2roundup_pl_fifo_depth-1 DOWNTO 0);                 
   signal RD_DATA_COUNT          : std_logic_vector(log2roundup_pl_fifo_depth-1 DOWNTO 0);                 
   signal WR_DATA_COUNT          : std_logic_vector(log2roundup_pl_fifo_depth-1 DOWNTO 0);                 

signal wr_rst_busy_sig              : std_logic := '0';
signal rd_rst_busy_sig              : std_logic := '0';                  
signal rst_i               : std_logic := '0';                  
signal srst_i              : std_logic := '0';                  




BEGIN

--FAMILY_8 : if ((C_FAMILY = "kintexu") or (C_FAMILY = "virtexu") or (C_FAMILY = "artixu"))   generate
--begin
--
--wr_rst_busy <= wr_rst_busy_sig;
--rd_rst_busy <= rd_rst_busy_sig;
--
--srst_i <= rst;
--rst_i  <= '0';
--
--end generate FAMILY_8;
--
--FAMILY_NOT_8 : if   ((C_FAMILY /= "kintexu") and (C_FAMILY /= "virtexu") and (C_FAMILY /= "artixu")) generate
--begin
--
--wr_rst_busy <= '0';
--rd_rst_busy <= '0';
--
--srst_i <= '0';
--rst_i  <= rst;
--
--end generate FAMILY_NOT_8;

--8 series
FAMILY_NOT_7 : if ((C_FAMILY /= "kintex7") and (C_FAMILY /= "virtex7") and (C_FAMILY /= "artix7") and (C_FAMILY /= "zynq") and (C_FAMILY /= "spartan7"))   generate
begin

wr_rst_busy <= wr_rst_busy_sig;
rd_rst_busy <= rd_rst_busy_sig;

srst_i <= rst;
rst_i  <= '0';

end generate FAMILY_NOT_7;
--7 series
FAMILY_7 : if   ((C_FAMILY = "kintex7") or (C_FAMILY = "virtex7") or (C_FAMILY = "artix7") or (C_FAMILY = "zynq") or (C_FAMILY = "spartan7")) generate
begin

wr_rst_busy <= '0';
rd_rst_busy <= '0';

srst_i <= '0';
rst_i  <= rst;

end generate FAMILY_7;





ZERO_pntr <= (others => '0');
GND <= '0';

  fg_builtin_fifo_inst : entity fifo_generator_v13_2_5.fifo_generator_v13_2_5
  GENERIC MAP (
    C_COMMON_CLOCK                      => 0,
--    C_COUNT_TYPE                        => C_COUNT_TYPE,
    C_DATA_COUNT_WIDTH                  => log2roundup_pl_fifo_depth,
--    C_DEFAULT_VALUE                     => C_DEFAULT_VALUE,
    C_DIN_WIDTH                         => pl_data_width,
--    C_DOUT_RST_VAL                      => C_DOUT_RST_VAL,
    C_DOUT_WIDTH                        => pl_data_width,
--    C_ENABLE_RLOCS                      => C_ENABLE_RLOCS,
    --C_FAMILY                            => "virtex7",
    C_FAMILY                            => C_FAMILY,
    C_FULL_FLAGS_RST_VAL                => pl_full_flags_rst_val,
--    C_HAS_ALMOST_EMPTY                  => C_HAS_ALMOST_EMPTY,
--    C_HAS_ALMOST_FULL                   => C_HAS_ALMOST_FULL,
--    C_HAS_BACKUP                        => C_HAS_BACKUP,
--    C_HAS_DATA_COUNT                    => C_HAS_DATA_COUNT,
--    C_HAS_INT_CLK                       => C_HAS_INT_CLK,
--    C_HAS_MEMINIT_FILE                  => C_HAS_MEMINIT_FILE,
--    C_HAS_OVERFLOW                      => C_HAS_OVERFLOW,
--    C_HAS_RD_DATA_COUNT                 => C_HAS_RD_DATA_COUNT,
--    C_HAS_RD_RST                        => C_HAS_RD_RST,

    C_EN_SAFETY_CKT                     => 1,
    C_HAS_RST                           => ASYNC_RST_PORT,
    C_HAS_SRST                          => SYNC_RST_PORT,

--    C_HAS_UNDERFLOW                     => C_HAS_UNDERFLOW,
--    C_HAS_VALID                         => C_HAS_VALID,
--    C_HAS_WR_ACK                        => C_HAS_WR_ACK,
--    C_HAS_WR_DATA_COUNT                 => C_HAS_WR_DATA_COUNT,
--    C_HAS_WR_RST                        => C_HAS_WR_RST,
    C_IMPLEMENTATION_TYPE               => C_IMPLEMENTATION_TYPE,
--    C_INIT_WR_PNTR_VAL                  => C_INIT_WR_PNTR_VAL,
    C_MEMORY_TYPE                       => C_MEMORY_TYPE,
--    C_MIF_FILE_NAME                     => C_MIF_FILE_NAME,
--    C_OPTIMIZATION_MODE                 => C_OPTIMIZATION_MODE,
--    C_OVERFLOW_LOW                      => C_OVERFLOW_LOW,
    C_PRELOAD_LATENCY                   => C_PRELOAD_LATENCY,
    C_PRELOAD_REGS                      => C_PRELOAD_REGS,
    C_PRIM_FIFO_TYPE                    => C_PRIM_FIFO_TYPE,
    C_PROG_EMPTY_THRESH_ASSERT_VAL      => 10,
    C_PROG_EMPTY_THRESH_NEGATE_VAL      => 9,
    C_PROG_EMPTY_TYPE                   => 0,
    C_PROG_FULL_THRESH_ASSERT_VAL       => PROG_FULL_THRESH_ASSERT_VAL_1,
    C_PROG_FULL_THRESH_NEGATE_VAL       => PROG_FULL_THRESH_NEGATE_VAL_1,
    C_PROG_FULL_TYPE                    => 0,
    C_RD_DATA_COUNT_WIDTH               => log2roundup_pl_fifo_depth,
    C_RD_DEPTH                          => pl_fifo_depth,
    C_RD_FREQ                           => C_RD_FREQ,
    C_RD_PNTR_WIDTH                     => log2roundup_pl_fifo_depth,
--    C_UNDERFLOW_LOW                     => C_UNDERFLOW_LOW,
--    C_USE_DOUT_RST                      => C_USE_DOUT_RST,
--    C_USE_ECC                           => C_USE_ECC,
--    C_USE_EMBEDDED_REG                  => C_USE_EMBEDDED_REG,
--    C_USE_FIFO16_FLAGS                  => C_USE_FIFO16_FLAGS,
--    C_USE_FWFT_DATA_COUNT               => C_USE_FWFT_DATA_COUNT,
--    C_VALID_LOW                         => C_VALID_LOW,
--    C_WR_ACK_LOW                        => C_WR_ACK_LOW,
    C_WR_DATA_COUNT_WIDTH               => log2roundup_pl_fifo_depth,
    C_WR_DEPTH                          => pl_fifo_depth,
    C_WR_FREQ                           => C_WR_FREQ,
    C_WR_PNTR_WIDTH                     => log2roundup_pl_fifo_depth,
--    C_WR_RESPONSE_LATENCY               => C_WR_RESPONSE_LATENCY,
--    C_MSGON_VAL                         => C_MSGON_VAL,
--    C_ENABLE_RST_SYNC                   => C_ENABLE_RST_SYNC,
--    C_ERROR_INJECTION_TYPE              => C_ERROR_INJECTION_TYPE,
    C_SYNCHRONIZER_STAGE                => MTBF_STAGES,

              -- AXI Interface related parameters start here
              C_INTERFACE_TYPE               =>  0,    --           : integer := 0; -- 0: Native Interface; 1: AXI Interface
              C_AXI_TYPE                     =>  0,    --           : integer := 0; -- 0: AXI Stream; 1: AXI Full; 2: AXI Lite
              C_HAS_AXI_WR_CHANNEL           =>  0,    --           : integer := 0;
              C_HAS_AXI_RD_CHANNEL           =>  0,    --           : integer := 0;
              C_HAS_SLAVE_CE                 =>  0,    --           : integer := 0;
              C_HAS_MASTER_CE                =>  0,    --           : integer := 0;
              C_ADD_NGC_CONSTRAINT           =>  0,    --           : integer := 0;
              C_USE_COMMON_OVERFLOW          =>  0,    --           : integer := 0;
              C_USE_COMMON_UNDERFLOW         =>  0,    --           : integer := 0;
              C_USE_DEFAULT_SETTINGS         =>  0,    --           : integer := 0;

              -- AXI Full/Lite
              C_AXI_ID_WIDTH                 =>  4 ,    --           : integer := 0;
              C_AXI_ADDR_WIDTH               =>  32,    --           : integer := 0;
              C_AXI_DATA_WIDTH               =>  64,    --           : integer := 0;
              C_AXI_LEN_WIDTH                =>  8,     --           : integer := 8;
              C_AXI_LOCK_WIDTH               =>  2,     --           : integer := 2;
              C_HAS_AXI_ID                   =>  0,     --           : integer := 0;
              C_HAS_AXI_AWUSER               =>  0 ,    --           : integer := 0;
              C_HAS_AXI_WUSER                =>  0 ,    --           : integer := 0;
              C_HAS_AXI_BUSER                =>  0 ,    --           : integer := 0;
              C_HAS_AXI_ARUSER               =>  0 ,    --           : integer := 0;
              C_HAS_AXI_RUSER                =>  0 ,    --           : integer := 0;
              C_AXI_ARUSER_WIDTH             =>  1 ,    --           : integer := 0;
              C_AXI_AWUSER_WIDTH             =>  1 ,    --           : integer := 0;
              C_AXI_WUSER_WIDTH              =>  1 ,    --           : integer := 0;
              C_AXI_BUSER_WIDTH              =>  1 ,    --           : integer := 0;
              C_AXI_RUSER_WIDTH              =>  1 ,    --           : integer := 0;
                                                 
              -- AXI Streaming
              C_HAS_AXIS_TDATA               =>  0 ,    --           : integer := 0;
              C_HAS_AXIS_TID                 =>  0 ,    --           : integer := 0;
              C_HAS_AXIS_TDEST               =>  0 ,    --           : integer := 0;
              C_HAS_AXIS_TUSER               =>  0 ,    --           : integer := 0;
              C_HAS_AXIS_TREADY              =>  1 ,    --           : integer := 0;
              C_HAS_AXIS_TLAST               =>  0 ,    --           : integer := 0;
              C_HAS_AXIS_TSTRB               =>  0 ,    --           : integer := 0;
              C_HAS_AXIS_TKEEP               =>  0 ,    --           : integer := 0;
              C_AXIS_TDATA_WIDTH             =>  64,    --           : integer := 1;
              C_AXIS_TID_WIDTH               =>  8 ,    --           : integer := 1;
              C_AXIS_TDEST_WIDTH             =>  4 ,    --           : integer := 1;
              C_AXIS_TUSER_WIDTH             =>  4 ,    --           : integer := 1;
              C_AXIS_TSTRB_WIDTH             =>  4 ,    --           : integer := 1;
              C_AXIS_TKEEP_WIDTH             =>  4 ,    --           : integer := 1;

              -- AXI Channel Type
              -- WACH --> Write Address Channel
              -- WDCH --> Write Data Channel
              -- WRCH --> Write Response Channel
              -- RACH --> Read Address Channel
              -- RDCH --> Read Data Channel
              -- AXIS --> AXI Streaming
              C_WACH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logic
              C_WDCH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
              C_WRCH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
              C_RACH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
              C_RDCH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
              C_AXIS_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie

              -- AXI Implementation Type
              -- 1 = Common Clock Block RAM FIFO
              -- 2 = Common Clock Distributed RAM FIFO
              -- 11 = Independent Clock Block RAM FIFO
              -- 12 = Independent Clock Distributed RAM FIFO
              C_IMPLEMENTATION_TYPE_WACH    =>  1,    --            : integer := 0;
              C_IMPLEMENTATION_TYPE_WDCH    =>  1,    --            : integer := 0;
              C_IMPLEMENTATION_TYPE_WRCH    =>  1,    --            : integer := 0;
              C_IMPLEMENTATION_TYPE_RACH    =>  1,    --            : integer := 0;
              C_IMPLEMENTATION_TYPE_RDCH    =>  1,    --            : integer := 0;
              C_IMPLEMENTATION_TYPE_AXIS    =>  1,    --            : integer := 0;

              -- AXI FIFO Type
              -- 0 = Data FIFO
              -- 1 = Packet FIFO
              -- 2 = Low Latency Data FIFO
              C_APPLICATION_TYPE_WACH      =>  0,    --             : integer := 0;
              C_APPLICATION_TYPE_WDCH      =>  0,    --             : integer := 0;
              C_APPLICATION_TYPE_WRCH      =>  0,    --             : integer := 0;
              C_APPLICATION_TYPE_RACH      =>  0,    --             : integer := 0;
              C_APPLICATION_TYPE_RDCH      =>  0,    --             : integer := 0;
              C_APPLICATION_TYPE_AXIS      =>  0,    --             : integer := 0;

              -- Enable ECC
              -- 0 = ECC disabled
              -- 1 = ECC enabled
              C_USE_ECC_WACH               =>  0,    --             : integer := 0;
              C_USE_ECC_WDCH               =>  0,    --             : integer := 0;
              C_USE_ECC_WRCH               =>  0,    --             : integer := 0;
              C_USE_ECC_RACH               =>  0,    --             : integer := 0;
              C_USE_ECC_RDCH               =>  0,    --             : integer := 0;
              C_USE_ECC_AXIS               =>  0,    --             : integer := 0;

              -- ECC Error Injection Type
              -- 0 = No Error Injection
              -- 1 = Single Bit Error Injection
              -- 2 = Double Bit Error Injection
              -- 3 = Single Bit and Double Bit Error Injection
              C_ERROR_INJECTION_TYPE_WACH  =>  0,    --             : integer := 0;
              C_ERROR_INJECTION_TYPE_WDCH  =>  0,    --             : integer := 0;
              C_ERROR_INJECTION_TYPE_WRCH  =>  0,    --             : integer := 0;
              C_ERROR_INJECTION_TYPE_RACH  =>  0,    --             : integer := 0;
              C_ERROR_INJECTION_TYPE_RDCH  =>  0,    --             : integer := 0;
              C_ERROR_INJECTION_TYPE_AXIS  =>  0,    --             : integer := 0;

              -- Input Data Width
              -- Accumulation of all AXI input signal's width
              C_DIN_WIDTH_WACH                    =>  32,    --      : integer := 1;
              C_DIN_WIDTH_WDCH                    =>  64,    --      : integer := 1;
              C_DIN_WIDTH_WRCH                    =>  2 ,    --      : integer := 1;
              C_DIN_WIDTH_RACH                    =>  32,    --      : integer := 1;
              C_DIN_WIDTH_RDCH                    =>  64,    --      : integer := 1;
              C_DIN_WIDTH_AXIS                    =>  1 ,    --      : integer := 1;

              C_WR_DEPTH_WACH                     =>  16  ,   --      : integer := 16;
              C_WR_DEPTH_WDCH                     =>  1024,   --      : integer := 16;
              C_WR_DEPTH_WRCH                     =>  16  ,   --      : integer := 16;
              C_WR_DEPTH_RACH                     =>  16  ,   --      : integer := 16;
              C_WR_DEPTH_RDCH                     =>  1024,   --      : integer := 16;
              C_WR_DEPTH_AXIS                     =>  1024,   --      : integer := 16;

              C_WR_PNTR_WIDTH_WACH                =>  4 ,    --      : integer := 4;
              C_WR_PNTR_WIDTH_WDCH                =>  10,    --      : integer := 4;
              C_WR_PNTR_WIDTH_WRCH                =>  4 ,    --      : integer := 4;
              C_WR_PNTR_WIDTH_RACH                =>  4 ,    --      : integer := 4;
              C_WR_PNTR_WIDTH_RDCH                =>  10,    --      : integer := 4;
              C_WR_PNTR_WIDTH_AXIS                =>  10,    --      : integer := 4;

              C_HAS_DATA_COUNTS_WACH              =>  0,    --      : integer := 0;
              C_HAS_DATA_COUNTS_WDCH              =>  0,    --      : integer := 0;
              C_HAS_DATA_COUNTS_WRCH              =>  0,    --      : integer := 0;
              C_HAS_DATA_COUNTS_RACH              =>  0,    --      : integer := 0;
              C_HAS_DATA_COUNTS_RDCH              =>  0,    --      : integer := 0;
              C_HAS_DATA_COUNTS_AXIS              =>  0,    --      : integer := 0;

              C_HAS_PROG_FLAGS_WACH               =>  0,    --      : integer := 0;
              C_HAS_PROG_FLAGS_WDCH               =>  0,    --      : integer := 0;
              C_HAS_PROG_FLAGS_WRCH               =>  0,    --      : integer := 0;
              C_HAS_PROG_FLAGS_RACH               =>  0,    --      : integer := 0;
              C_HAS_PROG_FLAGS_RDCH               =>  0,    --      : integer := 0;
              C_HAS_PROG_FLAGS_AXIS               =>  0,    --      : integer := 0;

              C_PROG_FULL_TYPE_WACH               =>  5   ,    --      : integer := 0;
              C_PROG_FULL_TYPE_WDCH               =>  5   ,    --      : integer := 0;
              C_PROG_FULL_TYPE_WRCH               =>  5   ,    --      : integer := 0;
              C_PROG_FULL_TYPE_RACH               =>  5   ,    --      : integer := 0;
              C_PROG_FULL_TYPE_RDCH               =>  5   ,    --      : integer := 0;
              C_PROG_FULL_TYPE_AXIS               =>  5   ,    --      : integer := 0;
              C_PROG_FULL_THRESH_ASSERT_VAL_WACH  =>  1023,    --      : integer := 0;
              C_PROG_FULL_THRESH_ASSERT_VAL_WDCH  =>  1023,    --      : integer := 0;
              C_PROG_FULL_THRESH_ASSERT_VAL_WRCH  =>  1023,    --      : integer := 0;
              C_PROG_FULL_THRESH_ASSERT_VAL_RACH  =>  1023,    --      : integer := 0;
              C_PROG_FULL_THRESH_ASSERT_VAL_RDCH  =>  1023,    --      : integer := 0;
              C_PROG_FULL_THRESH_ASSERT_VAL_AXIS  =>  1023,    --      : integer := 0;

              C_PROG_EMPTY_TYPE_WACH              =>  5   ,    --      : integer := 0;
              C_PROG_EMPTY_TYPE_WDCH              =>  5   ,    --      : integer := 0;
              C_PROG_EMPTY_TYPE_WRCH              =>  5   ,    --      : integer := 0;
              C_PROG_EMPTY_TYPE_RACH              =>  5   ,    --      : integer := 0;
              C_PROG_EMPTY_TYPE_RDCH              =>  5   ,    --      : integer := 0;
              C_PROG_EMPTY_TYPE_AXIS              =>  5   ,    --      : integer := 0;
              C_PROG_EMPTY_THRESH_ASSERT_VAL_WACH =>  1022,    --      : integer := 0;
              C_PROG_EMPTY_THRESH_ASSERT_VAL_WDCH =>  1022,    --      : integer := 0;
              C_PROG_EMPTY_THRESH_ASSERT_VAL_WRCH =>  1022,    --      : integer := 0;
              C_PROG_EMPTY_THRESH_ASSERT_VAL_RACH =>  1022,    --      : integer := 0;
              C_PROG_EMPTY_THRESH_ASSERT_VAL_RDCH =>  1022,    --      : integer := 0;
              C_PROG_EMPTY_THRESH_ASSERT_VAL_AXIS =>  1022,    --      : integer := 0;

              C_REG_SLICE_MODE_WACH               =>  0,    --      : integer := 0;
              C_REG_SLICE_MODE_WDCH               =>  0,    --      : integer := 0;
              C_REG_SLICE_MODE_WRCH               =>  0,    --      : integer := 0;
              C_REG_SLICE_MODE_RACH               =>  0,    --      : integer := 0;
              C_REG_SLICE_MODE_RDCH               =>  0,    --      : integer := 0;
              C_REG_SLICE_MODE_AXIS               =>  0     --      : integer := 0


  )
  PORT MAP (
    backup                              => GND,
    backup_marker                       => GND,
    clk                                 => GND,
    rst                                 => rst_i,
    srst                                => srst_i,
    wr_clk                              => wr_clk,
    wr_rst                              => GND,
    rd_clk                              => rd_clk,
    rd_rst                              => GND,
    din                                 => din,
    wr_en                               => wr_en,
    rd_en                               => rd_en,
    sleep                     		=> sleep,
    wr_rst_busy                     	=> wr_rst_busy_sig,
    rd_rst_busy                     	=> rd_rst_busy_sig,

    prog_empty_thresh                   => ZERO_pntr,
    prog_empty_thresh_assert            => ZERO_pntr,
    prog_empty_thresh_negate            => ZERO_pntr,
    prog_full_thresh                    => ZERO_pntr,
    prog_full_thresh_assert             => ZERO_pntr,
    prog_full_thresh_negate             => ZERO_pntr,
    int_clk                             => GND,
    injectdbiterr                       => GND,
    injectsbiterr                       => GND,
    dout                                => dout,
    full                                => full,
    empty                               => empty,
    almost_full                         => ALMOST_FULL,
    wr_ack                              => WR_ACK,
    overflow                            => OVERFLOW,
    almost_empty                        => ALMOST_EMPTY,
    valid                               => VALID,
    underflow                           => UNDERFLOW,
    data_count                          => DATA_COUNT,
    rd_data_count                       => RD_DATA_COUNT,
    wr_data_count                       => WR_DATA_COUNT,
    prog_full                           => PROG_FULL,
    prog_empty                          => PROG_EMPTY,
    sbiterr                             => SBITERR,
    dbiterr                             => DBITERR,
              m_aclk                    =>  '0',                   --       : IN  std_logic := '0';
              s_aclk                    =>  '0',                   --       : IN  std_logic := '0';
              s_aresetn                 =>  '0',                   --       : IN  std_logic := '0';
              m_aclk_en                 =>  '0',                   --       : IN  std_logic := '0';
              s_aclk_en                 =>  '0',                   --       : IN  std_logic := '0';

              -- AXI Full/Lite Slave Write Channel (write side)
              s_axi_awid                =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_awaddr              =>  "00000000000000000000000000000000",   --(others => '0'),      --      : IN  std_logic_vector(C_AXI_ADDR_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_awlen               =>  "00000000",          --(others => '0'),      --      : IN  std_logic_vector(8-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_awsize              =>  "000",          --(others => '0'),      --      : IN  std_logic_vector(3-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_awburst             =>  "00",           --(others => '0'),      --      : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_awlock              =>  "00",           --(others => '0'),      --      : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_awcache             =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_awprot              =>  "000",          --(others => '0'),      --      : IN  std_logic_vector(3-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_awqos               =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_awregion            =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_awuser              =>  "0",            --(others => '0'),      --      : IN  std_logic_vector(C_AXI_AWUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_awvalid             =>  '0',                  --      : IN  std_logic := '0';
              s_axi_awready             =>  S_AXI_AWREADY,        --      : OUT std_logic;
              s_axi_wid                 =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_wdata               =>  "0000000000000000000000000000000000000000000000000000000000000000", --(others => '0'),      --      : IN  std_logic_vector(C_AXI_DATA_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_wstrb               =>  "00000000",          --(others => '0'),      --      : IN  std_logic_vector(C_AXI_DATA_WIDTH/8-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_wlast               =>  '0',                  --      : IN  std_logic := '0';
              s_axi_wuser               =>  "0",            --(others => '0'),      --      : IN  std_logic_vector(C_AXI_WUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_wvalid              =>  '0',                  --      : IN  std_logic := '0';
              s_axi_wready              =>  S_AXI_WREADY,         --      : OUT std_logic;
              s_axi_bid                 =>  S_AXI_BID,            --      : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_bresp               =>  S_AXI_BRESP,          --      : OUT std_logic_vector(2-1 DOWNTO 0);
              s_axi_buser               =>  S_AXI_BUSER,          --      : OUT std_logic_vector(C_AXI_BUSER_WIDTH-1 DOWNTO 0);
              s_axi_bvalid              =>  S_AXI_BVALID,          --      : OUT std_logic;
              s_axi_bready              =>  '0',                  --      : IN  std_logic := '0';

              -- AXI Full/Lite Master Write Channel (Read side)
              m_axi_awid                =>  M_AXI_AWID,           --       : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0);
              m_axi_awaddr              =>  M_AXI_AWADDR,         --       : OUT std_logic_vector(C_AXI_ADDR_WIDTH-1 DOWNTO 0);
              m_axi_awlen               =>  M_AXI_AWLEN,          --       : OUT std_logic_vector(8-1 DOWNTO 0);
              m_axi_awsize              =>  M_AXI_AWSIZE,         --       : OUT std_logic_vector(3-1 DOWNTO 0);
              m_axi_awburst             =>  M_AXI_AWBURST,        --       : OUT std_logic_vector(2-1 DOWNTO 0);
              m_axi_awlock              =>  M_AXI_AWLOCK,         --       : OUT std_logic_vector(2-1 DOWNTO 0);
              m_axi_awcache             =>  M_AXI_AWCACHE,        --       : OUT std_logic_vector(4-1 DOWNTO 0);
              m_axi_awprot              =>  M_AXI_AWPROT,         --       : OUT std_logic_vector(3-1 DOWNTO 0);
              m_axi_awqos               =>  M_AXI_AWQOS,          --       : OUT std_logic_vector(4-1 DOWNTO 0);
              m_axi_awregion            =>  M_AXI_AWREGION,       --       : OUT std_logic_vector(4-1 DOWNTO 0);
              m_axi_awuser              =>  M_AXI_AWUSER,         --       : OUT std_logic_vector(C_AXI_AWUSER_WIDTH-1 DOWNTO 0);
              m_axi_awvalid             =>  M_AXI_AWVALID,        --       : OUT std_logic;
              m_axi_awready             =>  '0',                  --       : IN  std_logic := '0';
              m_axi_wid                 =>  M_AXI_WID,            --       : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0);
              m_axi_wdata               =>  M_AXI_WDATA,          --       : OUT std_logic_vector(C_AXI_DATA_WIDTH-1 DOWNTO 0);
              m_axi_wstrb               =>  M_AXI_WSTRB,          --       : OUT std_logic_vector(C_AXI_DATA_WIDTH/8-1 DOWNTO 0);
              m_axi_wlast               =>  M_AXI_WLAST,          --       : OUT std_logic;
              m_axi_wuser               =>  M_AXI_WUSER,          --       : OUT std_logic_vector(C_AXI_WUSER_WIDTH-1 DOWNTO 0);
              m_axi_wvalid              =>  M_AXI_WVALID,         --       : OUT std_logic;
              m_axi_wready              =>  '0',                  --       : IN  std_logic := '0';
              m_axi_bid                 =>  "0000",               --(others => '0'),      --       : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              m_axi_bresp               =>  "00",                 --(others => '0'),      --       : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
              m_axi_buser               =>  "0",                  --(others => '0'),      --       : IN  std_logic_vector(C_AXI_BUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              m_axi_bvalid              =>  '0',                  --       : IN  std_logic := '0';
              m_axi_bready              =>  M_AXI_BREADY,         --       : OUT std_logic;

              -- AXI Full/Lite Slave Read Channel (Write side)
              s_axi_arid               =>  "0000",         --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_araddr             =>  "00000000000000000000000000000000",   --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(C_AXI_ADDR_WIDTH-1 DOWNTO 0) := (OTHERS => '0'); 
              s_axi_arlen              =>  "00000000",          --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(8-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_arsize             =>  "000",          --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(3-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_arburst            =>  "00",           --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_arlock             =>  "00",           --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_arcache            =>  "0000",         --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_arprot             =>  "000",          --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(3-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_arqos              =>  "0000",         --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_arregion           =>  "0000",         --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_aruser             =>  "0",            --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(C_AXI_ARUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axi_arvalid            =>  '0',                   --       : IN  std_logic := '0';
              s_axi_arready            =>  S_AXI_ARREADY,         --       : OUT std_logic;
              s_axi_rid                =>  S_AXI_RID,             --       : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0);       
              s_axi_rdata              =>  S_AXI_RDATA,           --       : OUT std_logic_vector(C_AXI_DATA_WIDTH-1 DOWNTO 0); 
              s_axi_rresp              =>  S_AXI_RRESP,           --       : OUT std_logic_vector(2-1 DOWNTO 0);
              s_axi_rlast              =>  S_AXI_RLAST,           --       : OUT std_logic;
              s_axi_ruser              =>  S_AXI_RUSER,           --       : OUT std_logic_vector(C_AXI_RUSER_WIDTH-1 DOWNTO 0);
              s_axi_rvalid             =>  S_AXI_RVALID,          --       : OUT std_logic;
              s_axi_rready             =>  '0',                   --       : IN  std_logic := '0';

              -- AXI Full/Lite Master Read Channel (Read side)
              m_axi_arid               =>  M_AXI_ARID,           --        : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0);        
              m_axi_araddr             =>  M_AXI_ARADDR,         --        : OUT std_logic_vector(C_AXI_ADDR_WIDTH-1 DOWNTO 0);  
              m_axi_arlen              =>  M_AXI_ARLEN,          --        : OUT std_logic_vector(8-1 DOWNTO 0);
              m_axi_arsize             =>  M_AXI_ARSIZE,         --        : OUT std_logic_vector(3-1 DOWNTO 0);
              m_axi_arburst            =>  M_AXI_ARBURST,        --        : OUT std_logic_vector(2-1 DOWNTO 0);
              m_axi_arlock             =>  M_AXI_ARLOCK,         --        : OUT std_logic_vector(2-1 DOWNTO 0);
              m_axi_arcache            =>  M_AXI_ARCACHE,        --        : OUT std_logic_vector(4-1 DOWNTO 0);
              m_axi_arprot             =>  M_AXI_ARPROT,         --        : OUT std_logic_vector(3-1 DOWNTO 0);
              m_axi_arqos              =>  M_AXI_ARQOS,          --        : OUT std_logic_vector(4-1 DOWNTO 0);
              m_axi_arregion           =>  M_AXI_ARREGION,       --        : OUT std_logic_vector(4-1 DOWNTO 0);
              m_axi_aruser             =>  M_AXI_ARUSER,         --        : OUT std_logic_vector(C_AXI_ARUSER_WIDTH-1 DOWNTO 0);
              m_axi_arvalid            =>  M_AXI_ARVALID,        --        : OUT std_logic;
              m_axi_arready            =>  '0',                  --        : IN  std_logic := '0';
              m_axi_rid                =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');        
              m_axi_rdata              =>  "0000000000000000000000000000000000000000000000000000000000000000", --(others => '0'),      --        : IN  std_logic_vector(C_AXI_DATA_WIDTH-1 DOWNTO 0) := (OTHERS => '0');  
              m_axi_rresp              =>  "00",                 --(others => '0'),      --        : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
              m_axi_rlast              =>  '0',                  --        : IN  std_logic := '0';
              m_axi_ruser              =>  "0",                  --(others => '0'),      --        : IN  std_logic_vector(C_AXI_RUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              m_axi_rvalid             =>  '0',                  --        : IN  std_logic := '0';
              m_axi_rready             =>  M_AXI_RREADY,         --        : OUT std_logic;

              -- AXI Streaming Slave Signals (Write side)
              s_axis_tvalid            =>  '0',                  --        : IN  std_logic := '0';
              s_axis_tready            =>  S_AXIS_TREADY,        --        : OUT std_logic;
              s_axis_tdata             =>  "0000000000000000000000000000000000000000000000000000000000000000", --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TDATA_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axis_tstrb             =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TSTRB_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axis_tkeep             =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TKEEP_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axis_tlast             =>  '0',                  --        : IN  std_logic := '0';
              s_axis_tid               =>  "00000000",                 --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axis_tdest             =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TDEST_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
              s_axis_tuser             =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');

              -- AXI Streaming Master Signals (Read side)
              m_axis_tvalid            =>  M_AXIS_TVALID,        --        : OUT std_logic;
              m_axis_tready            =>  '0',                  --        : IN  std_logic := '0';
              m_axis_tdata             =>  M_AXIS_TDATA,         --        : OUT std_logic_vector(C_AXIS_TDATA_WIDTH-1 DOWNTO 0);
              m_axis_tstrb             =>  M_AXIS_TSTRB,         --        : OUT std_logic_vector(C_AXIS_TSTRB_WIDTH-1 DOWNTO 0);
              m_axis_tkeep             =>  M_AXIS_TKEEP,         --        : OUT std_logic_vector(C_AXIS_TKEEP_WIDTH-1 DOWNTO 0);
              m_axis_tlast             =>  M_AXIS_TLAST,         --        : OUT std_logic;
              m_axis_tid               =>  M_AXIS_TID,           --        : OUT std_logic_vector(C_AXIS_TID_WIDTH-1 DOWNTO 0);
              m_axis_tdest             =>  M_AXIS_TDEST,         --        : OUT std_logic_vector(C_AXIS_TDEST_WIDTH-1 DOWNTO 0);
              m_axis_tuser             =>  M_AXIS_TUSER,         --        : OUT std_logic_vector(C_AXIS_TUSER_WIDTH-1 DOWNTO 0);

              -- AXI Full/Lite Write Address Channel Signals
              axi_aw_injectsbiterr     =>  '0',                  --        : IN  std_logic := '0';
              axi_aw_injectdbiterr     =>  '0',                  --        : IN  std_logic := '0';
              axi_aw_prog_full_thresh  =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WACH-1 DOWNTO 0) := (OTHERS => '0');
              axi_aw_prog_empty_thresh =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WACH-1 DOWNTO 0) := (OTHERS => '0');
              axi_aw_data_count        =>  AXI_AW_DATA_COUNT,    --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WACH DOWNTO 0);
              axi_aw_wr_data_count     =>  AXI_AW_WR_DATA_COUNT, --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WACH DOWNTO 0);
              axi_aw_rd_data_count     =>  AXI_AW_RD_DATA_COUNT, --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WACH DOWNTO 0);
              axi_aw_sbiterr           =>  AXI_AW_SBITERR,       --        : OUT std_logic;
              axi_aw_dbiterr           =>  AXI_AW_DBITERR,       --        : OUT std_logic;
              axi_aw_overflow          =>  AXI_AW_OVERFLOW,      --        : OUT std_logic;
              axi_aw_underflow         =>  AXI_AW_UNDERFLOW,     --        : OUT std_logic;
              axi_aw_prog_full         =>  AXI_AW_PROG_FULL,     --        : OUT STD_LOGIC := '0';
              axi_aw_prog_empty        =>  AXI_AW_PROG_EMPTY,    --        : OUT STD_LOGIC := '1';


              -- AXI Full/Lite Write Data Channel Signals
              axi_w_injectsbiterr      =>  '0',                  --        : IN  std_logic := '0';
              axi_w_injectdbiterr      =>  '0',                  --        : IN  std_logic := '0';
              axi_w_prog_full_thresh   =>  "0000000000",         --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WDCH-1 DOWNTO 0) := (OTHERS => '0');
              axi_w_prog_empty_thresh  =>  "0000000000",         --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WDCH-1 DOWNTO 0) := (OTHERS => '0');
              axi_w_data_count         =>  AXI_W_DATA_COUNT,     --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WDCH DOWNTO 0);
              axi_w_wr_data_count      =>  AXI_W_WR_DATA_COUNT,  --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WDCH DOWNTO 0);
              axi_w_rd_data_count      =>  AXI_W_RD_DATA_COUNT,  --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WDCH DOWNTO 0);
              axi_w_sbiterr            =>  AXI_W_SBITERR,        --        : OUT std_logic;
              axi_w_dbiterr            =>  AXI_W_DBITERR,        --        : OUT std_logic;
              axi_w_overflow           =>  AXI_W_OVERFLOW,       --        : OUT std_logic;
              axi_w_underflow          =>  AXI_W_UNDERFLOW,      --        : OUT std_logic;
              axi_w_prog_full          =>  AXI_W_PROG_FULL,      --        : OUT STD_LOGIC := '0';
              axi_w_prog_empty         =>  AXI_W_PROG_EMPTY,     --        : OUT STD_LOGIC := '1';

              -- AXI Full/Lite Write Response Channel Signals
              axi_b_injectsbiterr      =>  '0',                  --        : IN  std_logic := '0';
              axi_b_injectdbiterr      =>  '0',                  --        : IN  std_logic := '0';
              axi_b_prog_full_thresh   =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WRCH-1 DOWNTO 0) := (OTHERS => '0');
              axi_b_prog_empty_thresh  =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WRCH-1 DOWNTO 0) := (OTHERS => '0');
              axi_b_data_count         =>  AXI_B_DATA_COUNT,     --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WRCH DOWNTO 0);
              axi_b_wr_data_count      =>  AXI_B_WR_DATA_COUNT,  --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WRCH DOWNTO 0);
              axi_b_rd_data_count      =>  AXI_B_RD_DATA_COUNT,  --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WRCH DOWNTO 0);
              axi_b_sbiterr            =>  AXI_B_SBITERR,        --        : OUT std_logic;
              axi_b_dbiterr            =>  AXI_B_DBITERR,        --        : OUT std_logic;
              axi_b_overflow           =>  AXI_B_OVERFLOW,       --        : OUT std_logic;
              axi_b_underflow          =>  AXI_B_UNDERFLOW,      --        : OUT std_logic;
              axi_b_prog_full          =>  AXI_B_PROG_FULL,      --        : OUT STD_LOGIC := '0';
              axi_b_prog_empty         =>  AXI_B_PROG_EMPTY,     --        : OUT STD_LOGIC := '1';

              -- AXI Full/Lite Read Address Channel Signals
              axi_ar_injectsbiterr     =>  '0',                  --        : IN  std_logic := '0';
              axi_ar_injectdbiterr     =>  '0',                  --        : IN  std_logic := '0';
              axi_ar_prog_full_thresh  =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_RACH-1 DOWNTO 0) := (OTHERS => '0');
              axi_ar_prog_empty_thresh =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_RACH-1 DOWNTO 0) := (OTHERS => '0');
              axi_ar_data_count        =>  AXI_AR_DATA_COUNT,    --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_RACH DOWNTO 0);
              axi_ar_wr_data_count     =>  AXI_AR_WR_DATA_COUNT, --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_RACH DOWNTO 0);
              axi_ar_rd_data_count     =>  AXI_AR_RD_DATA_COUNT, --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_RACH DOWNTO 0);
              axi_ar_sbiterr           =>  AXI_AR_SBITERR,       --        : OUT std_logic;
              axi_ar_dbiterr           =>  AXI_AR_DBITERR,       --        : OUT std_logic;
              axi_ar_overflow          =>  AXI_AR_OVERFLOW,      --        : OUT std_logic;
              axi_ar_underflow         =>  AXI_AR_UNDERFLOW,     --        : OUT std_logic;
              axi_ar_prog_full         =>  AXI_AR_PROG_FULL,     --        : OUT STD_LOGIC := '0';
              axi_ar_prog_empty        =>  AXI_AR_PROG_EMPTY,    --        : OUT STD_LOGIC := '1';

              -- AXI Full/Lite Read Data Channel Signals
              axi_r_injectsbiterr     =>  '0',                  --         : IN  std_logic := '0';
              axi_r_injectdbiterr     =>  '0',                  --         : IN  std_logic := '0';
              axi_r_prog_full_thresh  =>  "0000000000",         --(others => '0'),      --         : IN  std_logic_vector(C_WR_PNTR_WIDTH_RDCH-1 DOWNTO 0) := (OTHERS => '0');
              axi_r_prog_empty_thresh =>  "0000000000",         --(others => '0'),      --         : IN  std_logic_vector(C_WR_PNTR_WIDTH_RDCH-1 DOWNTO 0) := (OTHERS => '0');
              axi_r_data_count        =>  AXI_R_DATA_COUNT,     --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_RDCH DOWNTO 0);
              axi_r_wr_data_count     =>  AXI_R_WR_DATA_COUNT,  --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_RDCH DOWNTO 0);
              axi_r_rd_data_count     =>  AXI_R_RD_DATA_COUNT,  --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_RDCH DOWNTO 0);
              axi_r_sbiterr           =>  AXI_R_SBITERR,        --         : OUT std_logic;
              axi_r_dbiterr           =>  AXI_R_DBITERR,        --         : OUT std_logic;
              axi_r_overflow          =>  AXI_R_OVERFLOW,       --         : OUT std_logic;
              axi_r_underflow         =>  AXI_R_UNDERFLOW,      --         : OUT std_logic;
              axi_r_prog_full         =>  AXI_R_PROG_FULL,      --         : OUT STD_LOGIC := '0';
              axi_r_prog_empty        =>  AXI_R_PROG_EMPTY,     --         : OUT STD_LOGIC := '1';

              -- AXI Streaming FIFO Related Signals
              axis_injectsbiterr      =>  '0',                  --         : IN  std_logic := '0';
              axis_injectdbiterr      =>  '0',                  --         : IN  std_logic := '0';
              axis_prog_full_thresh   =>  "0000000000",         --(others => '0'),      --         : IN  std_logic_vector(C_WR_PNTR_WIDTH_AXIS-1 DOWNTO 0) := (OTHERS => '0');
              axis_prog_empty_thresh  =>  "0000000000",         --(others => '0'),      --         : IN  std_logic_vector(C_WR_PNTR_WIDTH_AXIS-1 DOWNTO 0) := (OTHERS => '0');
              axis_data_count         =>  AXIS_DATA_COUNT,      --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_AXIS DOWNTO 0);
              axis_wr_data_count      =>  AXIS_WR_DATA_COUNT,   --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_AXIS DOWNTO 0);
              axis_rd_data_count      =>  AXIS_RD_DATA_COUNT,   --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_AXIS DOWNTO 0);
              axis_sbiterr            =>  AXIS_SBITERR,         --         : OUT std_logic;
              axis_dbiterr            =>  AXIS_DBITERR,         --         : OUT std_logic;
              axis_overflow           =>  AXIS_OVERFLOW,        --         : OUT std_logic;
              axis_underflow          =>  AXIS_UNDERFLOW,       --         : OUT std_logic
              axis_prog_full          =>  AXIS_PROG_FULL,       --         : OUT STD_LOGIC := '0';
              axis_prog_empty         =>  AXIS_PROG_EMPTY       --         : OUT STD_LOGIC := '1';


  );


END ARCHITECTURE xilinx;


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- axi_vdma_afifo.vhd - entity/architecture pair
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010, 2012-2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library fifo_generator_v13_2_5;
use fifo_generator_v13_2_5.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.all;
--use proc_common_v4_0.coregen_comp_defs.all;
--use proc_common_v4_0.family_support.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

Library xpm;
use xpm.vcomponents.all;

-- synopsys translate_off
--library XilinxCoreLib;
--use XilinxCoreLib.all;
-- synopsys translate_on




ENTITY axi_vdma_afifo IS
  GENERIC (
    -------------------------------------------------------------------------
    -- Generic Declarations
    -------------------------------------------------------------------------
    C_FAMILY       	  : STRING  := "virtex7";   --
    C_FULL_FLAGS_RST_VAL  : INTEGER := 1;          -- 0,1 ; Default 1
    UW_DATA_WIDTH         : INTEGER := 16;          -- 1 - 1024; Default 16
    UW_FIFO_DEPTH         : INTEGER := 1024         -- 16 - 256K; Default 1K
    );
  PORT (

    -- Common signal
    rst              : in  std_logic := '0';

    sleep            : in  std_logic := '0';
    wr_rst_busy      : out std_logic := '0';
    rd_rst_busy      : out std_logic := '0';
    -- Write Domain signals
    wr_clk           : in  std_logic := '0';
    din              : in  std_logic_vector(UW_DATA_WIDTH-1 downto 0) := (others => '0');
    wr_en            : in  std_logic := '0';
    full             : out std_logic := '0';
    wr_data_count    : out std_logic_vector(clog2(uw_fifo_depth)-1 downto 0) := (others => '0');

    -- Read Domain signals
    rd_data_count    : out std_logic_vector(clog2(uw_fifo_depth)-1 downto 0) := (others => '0');
    rd_clk           : in  std_logic := '0';
    rd_en            : in  std_logic := '0';
    dout             : out std_logic_vector(UW_DATA_WIDTH-1 downto 0) := (others => '0');
    empty            : out std_logic := '1'

    );
END ENTITY axi_vdma_afifo;

ARCHITECTURE xilinx OF axi_vdma_afifo IS
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of xilinx : architecture is "yes";

  --CONSTANT GND : std_logic := '0';
  CONSTANT VCC : std_logic := '1';

  CONSTANT clog2_uw_fifo_depth   : integer := clog2(uw_fifo_depth);
  CONSTANT clog2_uw_fifo_depth_plus_1   : integer := clog2(uw_fifo_depth) + 1;
  --Signals added to fix MTI and XSIM issues caused by fix for VCS issues not to use "LIBRARY_SCAN = TRUE"
  signal ZERO_pntr : std_logic_vector(clog2_uw_fifo_depth-1 downto 0) := (others => '0');
  signal GND : std_logic := '0';
   signal ALMOST_FULL           : std_logic;                 
   signal WR_ACK           : std_logic;                 
   signal OVERFLOW           : std_logic;                 
   signal ALMOST_EMPTY           : std_logic;                 
   signal VALID           : std_logic;                 
   signal UNDERFLOW           : std_logic;                 
   signal PROG_FULL           : std_logic;                 
   signal PROG_EMPTY          : std_logic;                 
   signal SBITERR             : std_logic;                 
   signal DBITERR             : std_logic;                  
--   signal S_AXI_AWREADY       : std_logic;
--   signal S_AXI_WREADY        : std_logic;
--   signal S_AXI_BID           : std_logic_vector(3 DOWNTO 0);
--   signal S_AXI_BRESP         : std_logic_vector(2-1 DOWNTO 0);
--   signal S_AXI_BUSER         : std_logic_vector(0 downto 0);
--   signal S_AXI_BVALID        : std_logic;
--
--   -- AXI Full/Lite Master Write Channel (Read side)
--   signal M_AXI_AWID          : std_logic_vector(3 DOWNTO 0);
--   signal M_AXI_AWADDR        : std_logic_vector(31 DOWNTO 0);
--   signal M_AXI_AWLEN         : std_logic_vector(8-1 DOWNTO 0);
--   signal M_AXI_AWSIZE        : std_logic_vector(3-1 DOWNTO 0);
--   signal M_AXI_AWBURST       : std_logic_vector(2-1 DOWNTO 0);
--   signal M_AXI_AWLOCK        : std_logic_vector(2-1 DOWNTO 0);
--   signal M_AXI_AWCACHE       : std_logic_vector(4-1 DOWNTO 0);
--   signal M_AXI_AWPROT        : std_logic_vector(3-1 DOWNTO 0);
--   signal M_AXI_AWQOS         : std_logic_vector(4-1 DOWNTO 0);
--   signal M_AXI_AWREGION      : std_logic_vector(4-1 DOWNTO 0);
--   signal M_AXI_AWUSER        : std_logic_vector(0 downto 0);
--   signal M_AXI_AWVALID       : std_logic;
--   signal M_AXI_WID           : std_logic_vector(3 DOWNTO 0);
--   signal M_AXI_WDATA         : std_logic_vector(63 DOWNTO 0);
--   signal M_AXI_WSTRB         : std_logic_vector(7 DOWNTO 0);
--   signal M_AXI_WLAST         : std_logic;
--   signal M_AXI_WUSER         : std_logic_vector(0 downto 0);
--   signal M_AXI_WVALID        : std_logic;
--   signal M_AXI_BREADY        : std_logic;
--
--   -- AXI Full/Lite Slave Read Channel (Write side)
--   signal S_AXI_ARREADY       : std_logic;
--   signal S_AXI_RID           : std_logic_vector(3 DOWNTO 0);       
--   signal S_AXI_RDATA         : std_logic_vector(63 DOWNTO 0); 
--   signal S_AXI_RRESP         : std_logic_vector(2-1 DOWNTO 0);
--   signal S_AXI_RLAST         : std_logic;
--   signal S_AXI_RUSER         : std_logic_vector(0 downto 0);
--   signal S_AXI_RVALID        : std_logic;
--
--   -- AXI Full/Lite Master Read Channel (Read side)
--   signal M_AXI_ARID          : std_logic_vector(3 DOWNTO 0);        
--   signal M_AXI_ARADDR        : std_logic_vector(31 DOWNTO 0);  
--   signal M_AXI_ARLEN         : std_logic_vector(8-1 DOWNTO 0);
--   signal M_AXI_ARSIZE        : std_logic_vector(3-1 DOWNTO 0);
--   signal M_AXI_ARBURST       : std_logic_vector(2-1 DOWNTO 0);
--   signal M_AXI_ARLOCK        : std_logic_vector(2-1 DOWNTO 0);
--   signal M_AXI_ARCACHE       : std_logic_vector(4-1 DOWNTO 0);
--   signal M_AXI_ARPROT        : std_logic_vector(3-1 DOWNTO 0);
--   signal M_AXI_ARQOS         : std_logic_vector(4-1 DOWNTO 0);
--   signal M_AXI_ARREGION      : std_logic_vector(4-1 DOWNTO 0);
--   signal M_AXI_ARUSER        : std_logic_vector(0 downto 0);
--   signal M_AXI_ARVALID       : std_logic;
--   signal M_AXI_RREADY        : std_logic;
--
--   -- AXI Streaming Slave Signals (Write side)
--   signal S_AXIS_TREADY       : std_logic;
--
--   -- AXI Streaming Master Signals (Read side)
--   signal M_AXIS_TVALID       : std_logic;
--   signal M_AXIS_TDATA        : std_logic_vector(63 DOWNTO 0);
--   signal M_AXIS_TSTRB        : std_logic_vector(3 DOWNTO 0);
--   signal M_AXIS_TKEEP        : std_logic_vector(3 DOWNTO 0);
--   signal M_AXIS_TLAST        : std_logic;
--   signal M_AXIS_TID          : std_logic_vector(7 DOWNTO 0);
--   signal M_AXIS_TDEST        : std_logic_vector(3 DOWNTO 0);
--   signal M_AXIS_TUSER        : std_logic_vector(3 DOWNTO 0);
--
--   -- AXI Full/Lite Write Address Channel Signals
--   signal AXI_AW_DATA_COUNT    : std_logic_vector(4 DOWNTO 0);
--   signal AXI_AW_WR_DATA_COUNT : std_logic_vector(4 DOWNTO 0);
--   signal AXI_AW_RD_DATA_COUNT : std_logic_vector(4 DOWNTO 0);
--   signal AXI_AW_SBITERR       : std_logic;
--   signal AXI_AW_DBITERR       : std_logic;
--   signal AXI_AW_OVERFLOW      : std_logic;
--   signal AXI_AW_UNDERFLOW     : std_logic;
--   signal AXI_AW_PROG_FULL     : STD_LOGIC;
--   signal AXI_AW_PROG_EMPTY    : STD_LOGIC;
--
--
--   -- AXI Full/Lite Write Data Channel Signals
--   signal AXI_W_DATA_COUNT     : std_logic_vector(10 DOWNTO 0);
--   signal AXI_W_WR_DATA_COUNT  : std_logic_vector(10 DOWNTO 0);
--   signal AXI_W_RD_DATA_COUNT  : std_logic_vector(10 DOWNTO 0);
--   signal AXI_W_SBITERR        : std_logic;
--   signal AXI_W_DBITERR        : std_logic;
--   signal AXI_W_OVERFLOW       : std_logic;
--   signal AXI_W_UNDERFLOW      : std_logic;
--   signal AXI_W_PROG_FULL      : STD_LOGIC;
--   signal AXI_W_PROG_EMPTY     : STD_LOGIC;
--
--   -- AXI Full/Lite Write Response Channel Signals
--   signal AXI_B_DATA_COUNT     : std_logic_vector(4 DOWNTO 0);
--   signal AXI_B_WR_DATA_COUNT  : std_logic_vector(4 DOWNTO 0);
--   signal AXI_B_RD_DATA_COUNT  : std_logic_vector(4 DOWNTO 0);
--   signal AXI_B_SBITERR        : std_logic;
--   signal AXI_B_DBITERR        : std_logic;
--   signal AXI_B_OVERFLOW       : std_logic;
--   signal AXI_B_UNDERFLOW      : std_logic;
--   signal AXI_B_PROG_FULL      : STD_LOGIC;
--   signal AXI_B_PROG_EMPTY     : STD_LOGIC;
--
--   -- AXI Full/Lite Read Address Channel Signals
--   signal AXI_AR_DATA_COUNT    : std_logic_vector(4 DOWNTO 0);
--   signal AXI_AR_WR_DATA_COUNT : std_logic_vector(4 DOWNTO 0);
--   signal AXI_AR_RD_DATA_COUNT : std_logic_vector(4 DOWNTO 0);
--   signal AXI_AR_SBITERR       : std_logic;
--   signal AXI_AR_DBITERR       : std_logic;
--   signal AXI_AR_OVERFLOW      : std_logic;
--   signal AXI_AR_UNDERFLOW     : std_logic;
--   signal AXI_AR_PROG_FULL     : STD_LOGIC;
--   signal AXI_AR_PROG_EMPTY    : STD_LOGIC;
--
--   -- AXI Full/Lite Read Data Channel Signals
--   signal AXI_R_DATA_COUNT     : std_logic_vector(10 DOWNTO 0);
--   signal AXI_R_WR_DATA_COUNT  : std_logic_vector(10 DOWNTO 0);
--   signal AXI_R_RD_DATA_COUNT  : std_logic_vector(10 DOWNTO 0);
--   signal AXI_R_SBITERR        : std_logic;
--   signal AXI_R_DBITERR        : std_logic;
--   signal AXI_R_OVERFLOW       : std_logic;
--   signal AXI_R_UNDERFLOW      : std_logic;
--   signal AXI_R_PROG_FULL      : STD_LOGIC;
--   signal AXI_R_PROG_EMPTY     : STD_LOGIC;
--
--   -- AXI Streaming FIFO Related Signals
--   signal AXIS_DATA_COUNT      : std_logic_vector(10 DOWNTO 0);
--   signal AXIS_WR_DATA_COUNT   : std_logic_vector(10 DOWNTO 0);
--   signal AXIS_RD_DATA_COUNT   : std_logic_vector(10 DOWNTO 0);
--   signal AXIS_SBITERR         : std_logic;
--   signal AXIS_DBITERR         : std_logic;
--   signal AXIS_OVERFLOW        : std_logic;
--   signal AXIS_UNDERFLOW       : std_logic;
--   signal AXIS_PROG_FULL       : STD_LOGIC;
--   signal AXIS_PROG_EMPTY      : STD_LOGIC;
  --Signals added to fix MTI and XSIM issues caused by fix for VCS issues not to use "LIBRARY_SCAN = TRUE"
   signal DATA_COUNT          : std_logic_vector(clog2_uw_fifo_depth-1 DOWNTO 0);                 

  signal  sig_data_count_rd    : std_logic_vector(clog2_uw_fifo_depth downto 0) := (others => '0');
  signal  sig_data_count_wr    : std_logic_vector(clog2_uw_fifo_depth downto 0) := (others => '0');
  signal  sig_data_count_rd_minus1    : std_logic_vector(clog2_uw_fifo_depth  downto 0) := (others => '0');
  signal  sig_data_count_wr_minus1    : std_logic_vector(clog2_uw_fifo_depth  downto 0) := (others => '0');
  signal  data_1   : std_logic_vector(clog2_uw_fifo_depth  downto 0) := (others => '0');

BEGIN
ZERO_pntr <= (others => '0');
data_1 <= ZERO_pntr & '1';
GND <= '0';

        sig_data_count_rd_minus1 <= std_logic_vector(unsigned(sig_data_count_rd) - unsigned(data_1));
	sig_data_count_wr_minus1 <= std_logic_vector(unsigned(sig_data_count_wr) - unsigned(data_1));
rd_data_count <= sig_data_count_rd_minus1(clog2_uw_fifo_depth-1 downto 0) when (unsigned(sig_data_count_rd) > 0) else (others => '0');
wr_data_count <= sig_data_count_wr_minus1(clog2_uw_fifo_depth-1 downto 0) when (unsigned(sig_data_count_wr) > 0) else (others => '0');

  xpm_fifo_async_inst : xpm_fifo_async
   generic map (
      CDC_SYNC_STAGES => 2,       
      DOUT_RESET_VALUE => "0",    
      ECC_MODE => "no_ecc",       
      FIFO_MEMORY_TYPE => "auto", 
      FIFO_READ_LATENCY => 0,     
      FIFO_WRITE_DEPTH => uw_fifo_depth,   
      FULL_RESET_VALUE => 0,      
      PROG_EMPTY_THRESH => 10,     
      PROG_FULL_THRESH => 10,      
      RD_DATA_COUNT_WIDTH => clog2_uw_fifo_depth_plus_1,   
      READ_DATA_WIDTH => uw_data_width,      
      READ_MODE => "fwft",         
      RELATED_CLOCKS => 0,        
      USE_ADV_FEATURES => "1717", 
      WAKEUP_TIME => 0,           
      WRITE_DATA_WIDTH => uw_data_width,     
      WR_DATA_COUNT_WIDTH => clog2_uw_fifo_depth_plus_1    
   )
   port map (
      almost_empty => ALMOST_EMPTY,   
      almost_full => ALMOST_FULL,     
      data_valid => VALID,       
      dbiterr => DBITERR,             
      overflow => OVERFLOW,           
      prog_empty => PROG_EMPTY,       
      prog_full => PROG_FULL,         
      sbiterr => SBITERR,             
      underflow => UNDERFLOW,         
      wr_ack => WR_ACK,               

      wr_data_count => sig_data_count_wr, 
      rd_data_count => sig_data_count_rd, 

      injectdbiterr => GND, 
      injectsbiterr => GND, 
      dout => dout,                   
      empty => empty,                 
      full => full,                   
      wr_clk => wr_clk,               
      rd_clk => rd_clk,               
      rst => rst,                     
      din => din,                     
      rd_en => rd_en,                 
      sleep => sleep,                 
      wr_rst_busy => wr_rst_busy,     
      rd_rst_busy => rd_rst_busy,     
      wr_en => wr_en                  
   );



--    clk                                 => GND,
--    rst                                 => rst,
--    srst                                => GND,
--    wr_clk                              => wr_clk,
--    wr_rst                              => GND,
--    rd_clk                              => rd_clk,
--    rd_rst                              => GND,
--    din                                 => din,
--    wr_en                               => wr_en,
--    rd_en                               => rd_en,
--    sleep                     		=> sleep,
--    wr_rst_busy                     	=> wr_rst_busy,
--    rd_rst_busy                     	=> rd_rst_busy,
--
--    prog_empty_thresh                   => ZERO_pntr,
--    prog_empty_thresh_assert            => ZERO_pntr,
--    prog_empty_thresh_negate            => ZERO_pntr,
--    prog_full_thresh                    => ZERO_pntr,
--    prog_full_thresh_assert             => ZERO_pntr,
--    prog_full_thresh_negate             => ZERO_pntr,
--
--    int_clk                             => GND,
--    injectdbiterr                       => GND,
--    injectsbiterr                       => GND,
--    dout                                => dout,
--    full                                => full,
--    empty                               => empty,
--    almost_full                         => ALMOST_FULL,
--    wr_ack                              => WR_ACK,
--    overflow                            => OVERFLOW,
--    almost_empty                        => ALMOST_EMPTY,
--    valid                               => VALID,
--    underflow                           => UNDERFLOW,
--    data_count                          => DATA_COUNT,
--    rd_data_count                       => rd_data_count,
--    wr_data_count                       => wr_data_count,
--    prog_full                           => PROG_FULL,
--    prog_empty                          => PROG_EMPTY,
--    sbiterr                             => SBITERR,
--    dbiterr                             => DBITERR,

--  fg_inst : entity fifo_generator_v13_2_5.fifo_generator_v13_2_5
--  GENERIC MAP (
--    C_COMMON_CLOCK                      => 0,
----    C_COUNT_TYPE                        => C_COUNT_TYPE,
--    C_COUNT_TYPE                        => 0,					--my
----    C_DATA_COUNT_WIDTH                  => C_DATA_COUNT_WIDTH,
--    C_DATA_COUNT_WIDTH                  => clog2_uw_fifo_depth,		--my
----    C_DEFAULT_VALUE                     => C_DEFAULT_VALUE,
--    C_DIN_WIDTH                         => uw_data_width,
----    C_DOUT_RST_VAL                      => C_DOUT_RST_VAL,
--    C_DOUT_WIDTH                        => uw_data_width,
----    C_ENABLE_RLOCS                      => C_ENABLE_RLOCS,
--    --C_FAMILY                            => "virtex7",
--    C_FAMILY                            => C_FAMILY,				--my
--    --C_FULL_FLAGS_RST_VAL                => uw_full_flags_rst_val,
--    C_FULL_FLAGS_RST_VAL                => C_FULL_FLAGS_RST_VAL,					--my
----    C_HAS_ALMOST_EMPTY                  => C_HAS_ALMOST_EMPTY,
----    C_HAS_ALMOST_FULL                   => C_HAS_ALMOST_FULL,
----    C_HAS_BACKUP                        => C_HAS_BACKUP,
--    C_EN_SAFETY_CKT                     =>  1,  
--    C_HAS_DATA_COUNT                    => 0,					--my
----    C_HAS_DATA_COUNT                    => C_HAS_DATA_COUNT,
----    C_HAS_INT_CLK                       => C_HAS_INT_CLK,
----    C_HAS_MEMINIT_FILE                  => C_HAS_MEMINIT_FILE,
----    C_HAS_OVERFLOW                      => C_HAS_OVERFLOW,
--    C_HAS_RD_DATA_COUNT                 => 1,					--my
----    C_HAS_RD_DATA_COUNT                 => C_HAS_RD_DATA_COUNT,
----    C_HAS_RD_RST                        => C_HAS_RD_RST,
--    C_HAS_RST                           => 1,
--    C_HAS_SRST                          => 0,
----    C_HAS_UNDERFLOW                     => C_HAS_UNDERFLOW,
----    C_HAS_VALID                         => C_HAS_VALID,
----    C_HAS_WR_ACK                        => C_HAS_WR_ACK,
--    C_HAS_WR_DATA_COUNT                 => 1,					--my
----    C_HAS_WR_DATA_COUNT                 => C_HAS_WR_DATA_COUNT,
----    C_HAS_WR_RST                        => C_HAS_WR_RST,
--    --C_IMPLEMENTATION_TYPE               => C_IMPLEMENTATION_TYPE,
--    C_IMPLEMENTATION_TYPE               => 2,					--my --Block RAM
----    C_INIT_WR_PNTR_VAL                  => C_INIT_WR_PNTR_VAL,
--    --C_MEMORY_TYPE                       => C_MEMORY_TYPE,		
--    C_MEMORY_TYPE                       => 1,					--my --Block RAM
----    C_MIF_FILE_NAME                     => C_MIF_FILE_NAME,
----    C_OPTIMIZATION_MODE                 => C_OPTIMIZATION_MODE,
----    C_OVERFLOW_LOW                      => C_OVERFLOW_LOW,
--    --C_PRELOAD_LATENCY                   => C_PRELOAD_LATENCY,
--    --C_PRELOAD_REGS                      => C_PRELOAD_REGS,
--    C_PRELOAD_LATENCY                   => 0,					--my
--    C_PRELOAD_REGS                      => 1,					--my	
--    --C_PRIM_FIFO_TYPE                    => C_PRIM_FIFO_TYPE,
--              C_PRIM_FIFO_TYPE               =>  "512x36",  -- only used for V5 Hard FIFO        
--
--
--
--
--
--
--    C_PROG_EMPTY_THRESH_ASSERT_VAL      => 10,
--    C_PROG_EMPTY_THRESH_NEGATE_VAL      => 9,
--    C_PROG_EMPTY_TYPE                   => 0,
--    --C_PROG_FULL_THRESH_ASSERT_VAL       => if_then_else((UW_FIFO_TYPE = "BUILT_IN"), UW_FIFO_DEPTH-150, 14),		--my
--    --C_PROG_FULL_THRESH_NEGATE_VAL       => if_then_else((UW_FIFO_TYPE = "BUILT_IN"), UW_FIFO_DEPTH-160, 12),		--my
--    C_PROG_FULL_TYPE                    => 0,
--    C_RD_DATA_COUNT_WIDTH               => clog2_uw_fifo_depth,		--my
----    C_RD_DATA_COUNT_WIDTH               => C_RD_DATA_COUNT_WIDTH,
--    C_RD_DEPTH                          => uw_fifo_depth,
--    --C_RD_FREQ                           => C_RD_FREQ,
--    C_RD_FREQ                           => 1,					--my
--    C_RD_PNTR_WIDTH                     => clog2_uw_fifo_depth,
----    C_UNDERFLOW_LOW                     => C_UNDERFLOW_LOW,
----    C_USE_DOUT_RST                      => C_USE_DOUT_RST,
----    C_USE_ECC                           => C_USE_ECC,
--    C_USE_EMBEDDED_REG                  => 1,					--my
----    C_USE_EMBEDDED_REG                  => C_USE_EMBEDDED_REG,
----    C_USE_FIFO16_FLAGS                  => C_USE_FIFO16_FLAGS,
--    C_USE_FWFT_DATA_COUNT               => 0,					--my
----    C_USE_FWFT_DATA_COUNT               => C_USE_FWFT_DATA_COUNT,
----    C_VALID_LOW                         => C_VALID_LOW,
----    C_WR_ACK_LOW                        => C_WR_ACK_LOW,
--    C_WR_DATA_COUNT_WIDTH               => clog2_uw_fifo_depth,		--my
----    C_WR_DATA_COUNT_WIDTH               => C_WR_DATA_COUNT_WIDTH,
--    C_WR_DEPTH                          => uw_fifo_depth,
--    --C_WR_FREQ                           => C_WR_FREQ,
--    C_WR_FREQ                           => 1,					--my
--    C_WR_PNTR_WIDTH                     => clog2_uw_fifo_depth,
----    C_WR_RESPONSE_LATENCY               => C_WR_RESPONSE_LATENCY,
----    C_MSGON_VAL                         => C_MSGON_VAL,
----    C_ENABLE_RST_SYNC                   => C_ENABLE_RST_SYNC,
----    C_ERROR_INJECTION_TYPE              => C_ERROR_INJECTION_TYPE,
--    C_SYNCHRONIZER_STAGE                => MTBF_STAGES,
--              -- AXI Interface related parameters start here
--              C_INTERFACE_TYPE               =>  0,    --           : integer := 0; -- 0: Native Interface; 1: AXI Interface
--              C_AXI_TYPE                     =>  0,    --           : integer := 0; -- 0: AXI Stream; 1: AXI Full; 2: AXI Lite
--              C_HAS_AXI_WR_CHANNEL           =>  0,    --           : integer := 0;
--              C_HAS_AXI_RD_CHANNEL           =>  0,    --           : integer := 0;
--              C_HAS_SLAVE_CE                 =>  0,    --           : integer := 0;
--              C_HAS_MASTER_CE                =>  0,    --           : integer := 0;
--              C_ADD_NGC_CONSTRAINT           =>  0,    --           : integer := 0;
--              C_USE_COMMON_OVERFLOW          =>  0,    --           : integer := 0;
--              C_USE_COMMON_UNDERFLOW         =>  0,    --           : integer := 0;
--              C_USE_DEFAULT_SETTINGS         =>  0,    --           : integer := 0;
--
--              -- AXI Full/Lite
--              C_AXI_ID_WIDTH                 =>  4 ,    --           : integer := 0;
--              C_AXI_ADDR_WIDTH               =>  32,    --           : integer := 0;
--              C_AXI_DATA_WIDTH               =>  64,    --           : integer := 0;
--              C_AXI_LEN_WIDTH                =>  8,     --           : integer := 8;
--              C_AXI_LOCK_WIDTH               =>  2,     --           : integer := 2;
--              C_HAS_AXI_ID                   =>  0,     --           : integer := 0;
--              C_HAS_AXI_AWUSER               =>  0 ,    --           : integer := 0;
--              C_HAS_AXI_WUSER                =>  0 ,    --           : integer := 0;
--              C_HAS_AXI_BUSER                =>  0 ,    --           : integer := 0;
--              C_HAS_AXI_ARUSER               =>  0 ,    --           : integer := 0;
--              C_HAS_AXI_RUSER                =>  0 ,    --           : integer := 0;
--              C_AXI_ARUSER_WIDTH             =>  1 ,    --           : integer := 0;
--              C_AXI_AWUSER_WIDTH             =>  1 ,    --           : integer := 0;
--              C_AXI_WUSER_WIDTH              =>  1 ,    --           : integer := 0;
--              C_AXI_BUSER_WIDTH              =>  1 ,    --           : integer := 0;
--              C_AXI_RUSER_WIDTH              =>  1 ,    --           : integer := 0;
--                                                 
--              -- AXI Streaming
--              C_HAS_AXIS_TDATA               =>  0 ,    --           : integer := 0;
--              C_HAS_AXIS_TID                 =>  0 ,    --           : integer := 0;
--              C_HAS_AXIS_TDEST               =>  0 ,    --           : integer := 0;
--              C_HAS_AXIS_TUSER               =>  0 ,    --           : integer := 0;
--              C_HAS_AXIS_TREADY              =>  1 ,    --           : integer := 0;
--              C_HAS_AXIS_TLAST               =>  0 ,    --           : integer := 0;
--              C_HAS_AXIS_TSTRB               =>  0 ,    --           : integer := 0;
--              C_HAS_AXIS_TKEEP               =>  0 ,    --           : integer := 0;
--              C_AXIS_TDATA_WIDTH             =>  64,    --           : integer := 1;
--              C_AXIS_TID_WIDTH               =>  8 ,    --           : integer := 1;
--              C_AXIS_TDEST_WIDTH             =>  4 ,    --           : integer := 1;
--              C_AXIS_TUSER_WIDTH             =>  4 ,    --           : integer := 1;
--              C_AXIS_TSTRB_WIDTH             =>  4 ,    --           : integer := 1;
--              C_AXIS_TKEEP_WIDTH             =>  4 ,    --           : integer := 1;
--
--              -- AXI Channel Type
--              -- WACH --> Write Address Channel
--              -- WDCH --> Write Data Channel
--              -- WRCH --> Write Response Channel
--              -- RACH --> Read Address Channel
--              -- RDCH --> Read Data Channel
--              -- AXIS --> AXI Streaming
--              C_WACH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logic
--              C_WDCH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
--              C_WRCH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
--              C_RACH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
--              C_RDCH_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
--              C_AXIS_TYPE                   =>  0,    --            : integer := 0; -- 0 = FIFO; 1 = Register Slice; 2 = Pass Through Logie
--
--              -- AXI Implementation Type
--              -- 1 = Common Clock Block RAM FIFO
--              -- 2 = Common Clock Distributed RAM FIFO
--              -- 11 = Independent Clock Block RAM FIFO
--              -- 12 = Independent Clock Distributed RAM FIFO
--              C_IMPLEMENTATION_TYPE_WACH    =>  1,    --            : integer := 0;
--              C_IMPLEMENTATION_TYPE_WDCH    =>  1,    --            : integer := 0;
--              C_IMPLEMENTATION_TYPE_WRCH    =>  1,    --            : integer := 0;
--              C_IMPLEMENTATION_TYPE_RACH    =>  1,    --            : integer := 0;
--              C_IMPLEMENTATION_TYPE_RDCH    =>  1,    --            : integer := 0;
--              C_IMPLEMENTATION_TYPE_AXIS    =>  1,    --            : integer := 0;
--
--              -- AXI FIFO Type
--              -- 0 = Data FIFO
--              -- 1 = Packet FIFO
--              -- 2 = Low Latency Data FIFO
--              C_APPLICATION_TYPE_WACH      =>  0,    --             : integer := 0;
--              C_APPLICATION_TYPE_WDCH      =>  0,    --             : integer := 0;
--              C_APPLICATION_TYPE_WRCH      =>  0,    --             : integer := 0;
--              C_APPLICATION_TYPE_RACH      =>  0,    --             : integer := 0;
--              C_APPLICATION_TYPE_RDCH      =>  0,    --             : integer := 0;
--              C_APPLICATION_TYPE_AXIS      =>  0,    --             : integer := 0;
--
--              -- Enable ECC
--              -- 0 = ECC disabled
--              -- 1 = ECC enabled
--              C_USE_ECC_WACH               =>  0,    --             : integer := 0;
--              C_USE_ECC_WDCH               =>  0,    --             : integer := 0;
--              C_USE_ECC_WRCH               =>  0,    --             : integer := 0;
--              C_USE_ECC_RACH               =>  0,    --             : integer := 0;
--              C_USE_ECC_RDCH               =>  0,    --             : integer := 0;
--              C_USE_ECC_AXIS               =>  0,    --             : integer := 0;
--
--              -- ECC Error Injection Type
--              -- 0 = No Error Injection
--              -- 1 = Single Bit Error Injection
--              -- 2 = Double Bit Error Injection
--              -- 3 = Single Bit and Double Bit Error Injection
--              C_ERROR_INJECTION_TYPE_WACH  =>  0,    --             : integer := 0;
--              C_ERROR_INJECTION_TYPE_WDCH  =>  0,    --             : integer := 0;
--              C_ERROR_INJECTION_TYPE_WRCH  =>  0,    --             : integer := 0;
--              C_ERROR_INJECTION_TYPE_RACH  =>  0,    --             : integer := 0;
--              C_ERROR_INJECTION_TYPE_RDCH  =>  0,    --             : integer := 0;
--              C_ERROR_INJECTION_TYPE_AXIS  =>  0,    --             : integer := 0;
--
--              -- Input Data Width
--              -- Accumulation of all AXI input signal's width
--              C_DIN_WIDTH_WACH                    =>  32,    --      : integer := 1;
--              C_DIN_WIDTH_WDCH                    =>  64,    --      : integer := 1;
--              C_DIN_WIDTH_WRCH                    =>  2 ,    --      : integer := 1;
--              C_DIN_WIDTH_RACH                    =>  32,    --      : integer := 1;
--              C_DIN_WIDTH_RDCH                    =>  64,    --      : integer := 1;
--              C_DIN_WIDTH_AXIS                    =>  1 ,    --      : integer := 1;
--
--              C_WR_DEPTH_WACH                     =>  16  ,   --      : integer := 16;
--              C_WR_DEPTH_WDCH                     =>  1024,   --      : integer := 16;
--              C_WR_DEPTH_WRCH                     =>  16  ,   --      : integer := 16;
--              C_WR_DEPTH_RACH                     =>  16  ,   --      : integer := 16;
--              C_WR_DEPTH_RDCH                     =>  1024,   --      : integer := 16;
--              C_WR_DEPTH_AXIS                     =>  1024,   --      : integer := 16;
--
--              C_WR_PNTR_WIDTH_WACH                =>  4 ,    --      : integer := 4;
--              C_WR_PNTR_WIDTH_WDCH                =>  10,    --      : integer := 4;
--              C_WR_PNTR_WIDTH_WRCH                =>  4 ,    --      : integer := 4;
--              C_WR_PNTR_WIDTH_RACH                =>  4 ,    --      : integer := 4;
--              C_WR_PNTR_WIDTH_RDCH                =>  10,    --      : integer := 4;
--              C_WR_PNTR_WIDTH_AXIS                =>  10,    --      : integer := 4;
--
--              C_HAS_DATA_COUNTS_WACH              =>  0,    --      : integer := 0;
--              C_HAS_DATA_COUNTS_WDCH              =>  0,    --      : integer := 0;
--              C_HAS_DATA_COUNTS_WRCH              =>  0,    --      : integer := 0;
--              C_HAS_DATA_COUNTS_RACH              =>  0,    --      : integer := 0;
--              C_HAS_DATA_COUNTS_RDCH              =>  0,    --      : integer := 0;
--              C_HAS_DATA_COUNTS_AXIS              =>  0,    --      : integer := 0;
--
--              C_HAS_PROG_FLAGS_WACH               =>  0,    --      : integer := 0;
--              C_HAS_PROG_FLAGS_WDCH               =>  0,    --      : integer := 0;
--              C_HAS_PROG_FLAGS_WRCH               =>  0,    --      : integer := 0;
--              C_HAS_PROG_FLAGS_RACH               =>  0,    --      : integer := 0;
--              C_HAS_PROG_FLAGS_RDCH               =>  0,    --      : integer := 0;
--              C_HAS_PROG_FLAGS_AXIS               =>  0,    --      : integer := 0;
--
--              C_PROG_FULL_TYPE_WACH               =>  5   ,    --      : integer := 0;
--              C_PROG_FULL_TYPE_WDCH               =>  5   ,    --      : integer := 0;
--              C_PROG_FULL_TYPE_WRCH               =>  5   ,    --      : integer := 0;
--              C_PROG_FULL_TYPE_RACH               =>  5   ,    --      : integer := 0;
--              C_PROG_FULL_TYPE_RDCH               =>  5   ,    --      : integer := 0;
--              C_PROG_FULL_TYPE_AXIS               =>  5   ,    --      : integer := 0;
--              C_PROG_FULL_THRESH_ASSERT_VAL_WACH  =>  1023,    --      : integer := 0;
--              C_PROG_FULL_THRESH_ASSERT_VAL_WDCH  =>  1023,    --      : integer := 0;
--              C_PROG_FULL_THRESH_ASSERT_VAL_WRCH  =>  1023,    --      : integer := 0;
--              C_PROG_FULL_THRESH_ASSERT_VAL_RACH  =>  1023,    --      : integer := 0;
--              C_PROG_FULL_THRESH_ASSERT_VAL_RDCH  =>  1023,    --      : integer := 0;
--              C_PROG_FULL_THRESH_ASSERT_VAL_AXIS  =>  1023,    --      : integer := 0;
--
--              C_PROG_EMPTY_TYPE_WACH              =>  5   ,    --      : integer := 0;
--              C_PROG_EMPTY_TYPE_WDCH              =>  5   ,    --      : integer := 0;
--              C_PROG_EMPTY_TYPE_WRCH              =>  5   ,    --      : integer := 0;
--              C_PROG_EMPTY_TYPE_RACH              =>  5   ,    --      : integer := 0;
--              C_PROG_EMPTY_TYPE_RDCH              =>  5   ,    --      : integer := 0;
--              C_PROG_EMPTY_TYPE_AXIS              =>  5   ,    --      : integer := 0;
--              C_PROG_EMPTY_THRESH_ASSERT_VAL_WACH =>  1022,    --      : integer := 0;
--              C_PROG_EMPTY_THRESH_ASSERT_VAL_WDCH =>  1022,    --      : integer := 0;
--              C_PROG_EMPTY_THRESH_ASSERT_VAL_WRCH =>  1022,    --      : integer := 0;
--              C_PROG_EMPTY_THRESH_ASSERT_VAL_RACH =>  1022,    --      : integer := 0;
--              C_PROG_EMPTY_THRESH_ASSERT_VAL_RDCH =>  1022,    --      : integer := 0;
--              C_PROG_EMPTY_THRESH_ASSERT_VAL_AXIS =>  1022,    --      : integer := 0;
--
--              C_REG_SLICE_MODE_WACH               =>  0,    --      : integer := 0;
--              C_REG_SLICE_MODE_WDCH               =>  0,    --      : integer := 0;
--              C_REG_SLICE_MODE_WRCH               =>  0,    --      : integer := 0;
--              C_REG_SLICE_MODE_RACH               =>  0,    --      : integer := 0;
--              C_REG_SLICE_MODE_RDCH               =>  0,    --      : integer := 0;
--              C_REG_SLICE_MODE_AXIS               =>  0     --      : integer := 0
--
--
--  )
--  PORT MAP (
--    backup                              => GND,
--    backup_marker                       => GND,
--    clk                                 => GND,
--    rst                                 => rst,
--    srst                                => GND,
--    wr_clk                              => wr_clk,
--    wr_rst                              => GND,
--    rd_clk                              => rd_clk,
--    rd_rst                              => GND,
--    din                                 => din,
--    wr_en                               => wr_en,
--    rd_en                               => rd_en,
--    sleep                     		=> sleep,
--    wr_rst_busy                     	=> wr_rst_busy,
--    rd_rst_busy                     	=> rd_rst_busy,
--
--    prog_empty_thresh                   => ZERO_pntr,
--    prog_empty_thresh_assert            => ZERO_pntr,
--    prog_empty_thresh_negate            => ZERO_pntr,
--    prog_full_thresh                    => ZERO_pntr,
--    prog_full_thresh_assert             => ZERO_pntr,
--    prog_full_thresh_negate             => ZERO_pntr,
--
--    int_clk                             => GND,
--    injectdbiterr                       => GND,
--    injectsbiterr                       => GND,
--    dout                                => dout,
--    full                                => full,
--    empty                               => empty,
--    almost_full                         => ALMOST_FULL,
--    wr_ack                              => WR_ACK,
--    overflow                            => OVERFLOW,
--    almost_empty                        => ALMOST_EMPTY,
--    valid                               => VALID,
--    underflow                           => UNDERFLOW,
--    data_count                          => DATA_COUNT,
--    rd_data_count                       => rd_data_count,
--    wr_data_count                       => wr_data_count,
--    prog_full                           => PROG_FULL,
--    prog_empty                          => PROG_EMPTY,
--    sbiterr                             => SBITERR,
--    dbiterr                             => DBITERR,
--              m_aclk                    =>  '0',                   --       : IN  std_logic := '0';
--              s_aclk                    =>  '0',                   --       : IN  std_logic := '0';
--              s_aresetn                 =>  '0',                   --       : IN  std_logic := '0';
--              m_aclk_en                 =>  '0',                   --       : IN  std_logic := '0';
--              s_aclk_en                 =>  '0',                   --       : IN  std_logic := '0';
--
--              -- AXI Full/Lite Slave Write Channel (write side)
--              s_axi_awid                =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awaddr              =>  "00000000000000000000000000000000",   --(others => '0'),      --      : IN  std_logic_vector(C_AXI_ADDR_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awlen               =>  "00000000",          --(others => '0'),      --      : IN  std_logic_vector(8-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awsize              =>  "000",          --(others => '0'),      --      : IN  std_logic_vector(3-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awburst             =>  "00",           --(others => '0'),      --      : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awlock              =>  "00",           --(others => '0'),      --      : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awcache             =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awprot              =>  "000",          --(others => '0'),      --      : IN  std_logic_vector(3-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awqos               =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awregion            =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awuser              =>  "0",            --(others => '0'),      --      : IN  std_logic_vector(C_AXI_AWUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_awvalid             =>  '0',                  --      : IN  std_logic := '0';
--              s_axi_awready             =>  S_AXI_AWREADY,        --      : OUT std_logic;
--              s_axi_wid                 =>  "0000",         --(others => '0'),      --      : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_wdata               =>  "0000000000000000000000000000000000000000000000000000000000000000", --(others => '0'),      --      : IN  std_logic_vector(C_AXI_DATA_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_wstrb               =>  "00000000",          --(others => '0'),      --      : IN  std_logic_vector(C_AXI_DATA_WIDTH/8-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_wlast               =>  '0',                  --      : IN  std_logic := '0';
--              s_axi_wuser               =>  "0",            --(others => '0'),      --      : IN  std_logic_vector(C_AXI_WUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_wvalid              =>  '0',                  --      : IN  std_logic := '0';
--              s_axi_wready              =>  S_AXI_WREADY,         --      : OUT std_logic;
--              s_axi_bid                 =>  S_AXI_BID,            --      : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_bresp               =>  S_AXI_BRESP,          --      : OUT std_logic_vector(2-1 DOWNTO 0);
--              s_axi_buser               =>  S_AXI_BUSER,          --      : OUT std_logic_vector(C_AXI_BUSER_WIDTH-1 DOWNTO 0);
--              s_axi_bvalid              =>  S_AXI_BVALID,          --      : OUT std_logic;
--              s_axi_bready              =>  '0',                  --      : IN  std_logic := '0';
--
--              -- AXI Full/Lite Master Write Channel (Read side)
--              m_axi_awid                =>  M_AXI_AWID,           --       : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0);
--              m_axi_awaddr              =>  M_AXI_AWADDR,         --       : OUT std_logic_vector(C_AXI_ADDR_WIDTH-1 DOWNTO 0);
--              m_axi_awlen               =>  M_AXI_AWLEN,          --       : OUT std_logic_vector(8-1 DOWNTO 0);
--              m_axi_awsize              =>  M_AXI_AWSIZE,         --       : OUT std_logic_vector(3-1 DOWNTO 0);
--              m_axi_awburst             =>  M_AXI_AWBURST,        --       : OUT std_logic_vector(2-1 DOWNTO 0);
--              m_axi_awlock              =>  M_AXI_AWLOCK,         --       : OUT std_logic_vector(2-1 DOWNTO 0);
--              m_axi_awcache             =>  M_AXI_AWCACHE,        --       : OUT std_logic_vector(4-1 DOWNTO 0);
--              m_axi_awprot              =>  M_AXI_AWPROT,         --       : OUT std_logic_vector(3-1 DOWNTO 0);
--              m_axi_awqos               =>  M_AXI_AWQOS,          --       : OUT std_logic_vector(4-1 DOWNTO 0);
--              m_axi_awregion            =>  M_AXI_AWREGION,       --       : OUT std_logic_vector(4-1 DOWNTO 0);
--              m_axi_awuser              =>  M_AXI_AWUSER,         --       : OUT std_logic_vector(C_AXI_AWUSER_WIDTH-1 DOWNTO 0);
--              m_axi_awvalid             =>  M_AXI_AWVALID,        --       : OUT std_logic;
--              m_axi_awready             =>  '0',                  --       : IN  std_logic := '0';
--              m_axi_wid                 =>  M_AXI_WID,            --       : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0);
--              m_axi_wdata               =>  M_AXI_WDATA,          --       : OUT std_logic_vector(C_AXI_DATA_WIDTH-1 DOWNTO 0);
--              m_axi_wstrb               =>  M_AXI_WSTRB,          --       : OUT std_logic_vector(C_AXI_DATA_WIDTH/8-1 DOWNTO 0);
--              m_axi_wlast               =>  M_AXI_WLAST,          --       : OUT std_logic;
--              m_axi_wuser               =>  M_AXI_WUSER,          --       : OUT std_logic_vector(C_AXI_WUSER_WIDTH-1 DOWNTO 0);
--              m_axi_wvalid              =>  M_AXI_WVALID,         --       : OUT std_logic;
--              m_axi_wready              =>  '0',                  --       : IN  std_logic := '0';
--              m_axi_bid                 =>  "0000",               --(others => '0'),      --       : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              m_axi_bresp               =>  "00",                 --(others => '0'),      --       : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
--              m_axi_buser               =>  "0",                  --(others => '0'),      --       : IN  std_logic_vector(C_AXI_BUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              m_axi_bvalid              =>  '0',                  --       : IN  std_logic := '0';
--              m_axi_bready              =>  M_AXI_BREADY,         --       : OUT std_logic;
--
--              -- AXI Full/Lite Slave Read Channel (Write side)
--              s_axi_arid               =>  "0000",         --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_araddr             =>  "00000000000000000000000000000000",   --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(C_AXI_ADDR_WIDTH-1 DOWNTO 0) := (OTHERS => '0'); 
--              s_axi_arlen              =>  "00000000",          --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(8-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arsize             =>  "000",          --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(3-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arburst            =>  "00",           --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arlock             =>  "00",           --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arcache            =>  "0000",         --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arprot             =>  "000",          --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(3-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arqos              =>  "0000",         --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arregion           =>  "0000",         --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(4-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_aruser             =>  "0",            --(others => '0'),      (others => '0'),       --       : IN  std_logic_vector(C_AXI_ARUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axi_arvalid            =>  '0',                   --       : IN  std_logic := '0';
--              s_axi_arready            =>  S_AXI_ARREADY,         --       : OUT std_logic;
--              s_axi_rid                =>  S_AXI_RID,             --       : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0);       
--              s_axi_rdata              =>  S_AXI_RDATA,           --       : OUT std_logic_vector(C_AXI_DATA_WIDTH-1 DOWNTO 0); 
--              s_axi_rresp              =>  S_AXI_RRESP,           --       : OUT std_logic_vector(2-1 DOWNTO 0);
--              s_axi_rlast              =>  S_AXI_RLAST,           --       : OUT std_logic;
--              s_axi_ruser              =>  S_AXI_RUSER,           --       : OUT std_logic_vector(C_AXI_RUSER_WIDTH-1 DOWNTO 0);
--              s_axi_rvalid             =>  S_AXI_RVALID,          --       : OUT std_logic;
--              s_axi_rready             =>  '0',                   --       : IN  std_logic := '0';
--
--              -- AXI Full/Lite Master Read Channel (Read side)
--              m_axi_arid               =>  M_AXI_ARID,           --        : OUT std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0);        
--              m_axi_araddr             =>  M_AXI_ARADDR,         --        : OUT std_logic_vector(C_AXI_ADDR_WIDTH-1 DOWNTO 0);  
--              m_axi_arlen              =>  M_AXI_ARLEN,          --        : OUT std_logic_vector(8-1 DOWNTO 0);
--              m_axi_arsize             =>  M_AXI_ARSIZE,         --        : OUT std_logic_vector(3-1 DOWNTO 0);
--              m_axi_arburst            =>  M_AXI_ARBURST,        --        : OUT std_logic_vector(2-1 DOWNTO 0);
--              m_axi_arlock             =>  M_AXI_ARLOCK,         --        : OUT std_logic_vector(2-1 DOWNTO 0);
--              m_axi_arcache            =>  M_AXI_ARCACHE,        --        : OUT std_logic_vector(4-1 DOWNTO 0);
--              m_axi_arprot             =>  M_AXI_ARPROT,         --        : OUT std_logic_vector(3-1 DOWNTO 0);
--              m_axi_arqos              =>  M_AXI_ARQOS,          --        : OUT std_logic_vector(4-1 DOWNTO 0);
--              m_axi_arregion           =>  M_AXI_ARREGION,       --        : OUT std_logic_vector(4-1 DOWNTO 0);
--              m_axi_aruser             =>  M_AXI_ARUSER,         --        : OUT std_logic_vector(C_AXI_ARUSER_WIDTH-1 DOWNTO 0);
--              m_axi_arvalid            =>  M_AXI_ARVALID,        --        : OUT std_logic;
--              m_axi_arready            =>  '0',                  --        : IN  std_logic := '0';
--              m_axi_rid                =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXI_ID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');        
--              m_axi_rdata              =>  "0000000000000000000000000000000000000000000000000000000000000000", --(others => '0'),      --        : IN  std_logic_vector(C_AXI_DATA_WIDTH-1 DOWNTO 0) := (OTHERS => '0');  
--              m_axi_rresp              =>  "00",                 --(others => '0'),      --        : IN  std_logic_vector(2-1 DOWNTO 0) := (OTHERS => '0');
--              m_axi_rlast              =>  '0',                  --        : IN  std_logic := '0';
--              m_axi_ruser              =>  "0",                  --(others => '0'),      --        : IN  std_logic_vector(C_AXI_RUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              m_axi_rvalid             =>  '0',                  --        : IN  std_logic := '0';
--              m_axi_rready             =>  M_AXI_RREADY,         --        : OUT std_logic;
--
--              -- AXI Streaming Slave Signals (Write side)
--              s_axis_tvalid            =>  '0',                  --        : IN  std_logic := '0';
--              s_axis_tready            =>  S_AXIS_TREADY,        --        : OUT std_logic;
--              s_axis_tdata             =>  "0000000000000000000000000000000000000000000000000000000000000000", --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TDATA_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axis_tstrb             =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TSTRB_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axis_tkeep             =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TKEEP_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axis_tlast             =>  '0',                  --        : IN  std_logic := '0';
--              s_axis_tid               =>  "00000000",                 --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TID_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axis_tdest             =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TDEST_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--              s_axis_tuser             =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_AXIS_TUSER_WIDTH-1 DOWNTO 0) := (OTHERS => '0');
--
--              -- AXI Streaming Master Signals (Read side)
--              m_axis_tvalid            =>  M_AXIS_TVALID,        --        : OUT std_logic;
--              m_axis_tready            =>  '0',                  --        : IN  std_logic := '0';
--              m_axis_tdata             =>  M_AXIS_TDATA,         --        : OUT std_logic_vector(C_AXIS_TDATA_WIDTH-1 DOWNTO 0);
--              m_axis_tstrb             =>  M_AXIS_TSTRB,         --        : OUT std_logic_vector(C_AXIS_TSTRB_WIDTH-1 DOWNTO 0);
--              m_axis_tkeep             =>  M_AXIS_TKEEP,         --        : OUT std_logic_vector(C_AXIS_TKEEP_WIDTH-1 DOWNTO 0);
--              m_axis_tlast             =>  M_AXIS_TLAST,         --        : OUT std_logic;
--              m_axis_tid               =>  M_AXIS_TID,           --        : OUT std_logic_vector(C_AXIS_TID_WIDTH-1 DOWNTO 0);
--              m_axis_tdest             =>  M_AXIS_TDEST,         --        : OUT std_logic_vector(C_AXIS_TDEST_WIDTH-1 DOWNTO 0);
--              m_axis_tuser             =>  M_AXIS_TUSER,         --        : OUT std_logic_vector(C_AXIS_TUSER_WIDTH-1 DOWNTO 0);
--
--              -- AXI Full/Lite Write Address Channel Signals
--              axi_aw_injectsbiterr     =>  '0',                  --        : IN  std_logic := '0';
--              axi_aw_injectdbiterr     =>  '0',                  --        : IN  std_logic := '0';
--              axi_aw_prog_full_thresh  =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WACH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_aw_prog_empty_thresh =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WACH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_aw_data_count        =>  AXI_AW_DATA_COUNT,    --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WACH DOWNTO 0);
--              axi_aw_wr_data_count     =>  AXI_AW_WR_DATA_COUNT, --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WACH DOWNTO 0);
--              axi_aw_rd_data_count     =>  AXI_AW_RD_DATA_COUNT, --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WACH DOWNTO 0);
--              axi_aw_sbiterr           =>  AXI_AW_SBITERR,       --        : OUT std_logic;
--              axi_aw_dbiterr           =>  AXI_AW_DBITERR,       --        : OUT std_logic;
--              axi_aw_overflow          =>  AXI_AW_OVERFLOW,      --        : OUT std_logic;
--              axi_aw_underflow         =>  AXI_AW_UNDERFLOW,     --        : OUT std_logic;
--              axi_aw_prog_full         =>  AXI_AW_PROG_FULL,     --        : OUT STD_LOGIC := '0';
--              axi_aw_prog_empty        =>  AXI_AW_PROG_EMPTY,    --        : OUT STD_LOGIC := '1';
--
--
--              -- AXI Full/Lite Write Data Channel Signals
--              axi_w_injectsbiterr      =>  '0',                  --        : IN  std_logic := '0';
--              axi_w_injectdbiterr      =>  '0',                  --        : IN  std_logic := '0';
--              axi_w_prog_full_thresh   =>  "0000000000",         --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WDCH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_w_prog_empty_thresh  =>  "0000000000",         --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WDCH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_w_data_count         =>  AXI_W_DATA_COUNT,     --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WDCH DOWNTO 0);
--              axi_w_wr_data_count      =>  AXI_W_WR_DATA_COUNT,  --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WDCH DOWNTO 0);
--              axi_w_rd_data_count      =>  AXI_W_RD_DATA_COUNT,  --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WDCH DOWNTO 0);
--              axi_w_sbiterr            =>  AXI_W_SBITERR,        --        : OUT std_logic;
--              axi_w_dbiterr            =>  AXI_W_DBITERR,        --        : OUT std_logic;
--              axi_w_overflow           =>  AXI_W_OVERFLOW,       --        : OUT std_logic;
--              axi_w_underflow          =>  AXI_W_UNDERFLOW,      --        : OUT std_logic;
--              axi_w_prog_full          =>  AXI_W_PROG_FULL,      --        : OUT STD_LOGIC := '0';
--              axi_w_prog_empty         =>  AXI_W_PROG_EMPTY,     --        : OUT STD_LOGIC := '1';
--
--              -- AXI Full/Lite Write Response Channel Signals
--              axi_b_injectsbiterr      =>  '0',                  --        : IN  std_logic := '0';
--              axi_b_injectdbiterr      =>  '0',                  --        : IN  std_logic := '0';
--              axi_b_prog_full_thresh   =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WRCH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_b_prog_empty_thresh  =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_WRCH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_b_data_count         =>  AXI_B_DATA_COUNT,     --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WRCH DOWNTO 0);
--              axi_b_wr_data_count      =>  AXI_B_WR_DATA_COUNT,  --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WRCH DOWNTO 0);
--              axi_b_rd_data_count      =>  AXI_B_RD_DATA_COUNT,  --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_WRCH DOWNTO 0);
--              axi_b_sbiterr            =>  AXI_B_SBITERR,        --        : OUT std_logic;
--              axi_b_dbiterr            =>  AXI_B_DBITERR,        --        : OUT std_logic;
--              axi_b_overflow           =>  AXI_B_OVERFLOW,       --        : OUT std_logic;
--              axi_b_underflow          =>  AXI_B_UNDERFLOW,      --        : OUT std_logic;
--              axi_b_prog_full          =>  AXI_B_PROG_FULL,      --        : OUT STD_LOGIC := '0';
--              axi_b_prog_empty         =>  AXI_B_PROG_EMPTY,     --        : OUT STD_LOGIC := '1';
--
--              -- AXI Full/Lite Read Address Channel Signals
--              axi_ar_injectsbiterr     =>  '0',                  --        : IN  std_logic := '0';
--              axi_ar_injectdbiterr     =>  '0',                  --        : IN  std_logic := '0';
--              axi_ar_prog_full_thresh  =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_RACH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_ar_prog_empty_thresh =>  "0000",               --(others => '0'),      --        : IN  std_logic_vector(C_WR_PNTR_WIDTH_RACH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_ar_data_count        =>  AXI_AR_DATA_COUNT,    --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_RACH DOWNTO 0);
--              axi_ar_wr_data_count     =>  AXI_AR_WR_DATA_COUNT, --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_RACH DOWNTO 0);
--              axi_ar_rd_data_count     =>  AXI_AR_RD_DATA_COUNT, --        : OUT std_logic_vector(C_WR_PNTR_WIDTH_RACH DOWNTO 0);
--              axi_ar_sbiterr           =>  AXI_AR_SBITERR,       --        : OUT std_logic;
--              axi_ar_dbiterr           =>  AXI_AR_DBITERR,       --        : OUT std_logic;
--              axi_ar_overflow          =>  AXI_AR_OVERFLOW,      --        : OUT std_logic;
--              axi_ar_underflow         =>  AXI_AR_UNDERFLOW,     --        : OUT std_logic;
--              axi_ar_prog_full         =>  AXI_AR_PROG_FULL,     --        : OUT STD_LOGIC := '0';
--              axi_ar_prog_empty        =>  AXI_AR_PROG_EMPTY,    --        : OUT STD_LOGIC := '1';
--
--              -- AXI Full/Lite Read Data Channel Signals
--              axi_r_injectsbiterr     =>  '0',                  --         : IN  std_logic := '0';
--              axi_r_injectdbiterr     =>  '0',                  --         : IN  std_logic := '0';
--              axi_r_prog_full_thresh  =>  "0000000000",         --(others => '0'),      --         : IN  std_logic_vector(C_WR_PNTR_WIDTH_RDCH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_r_prog_empty_thresh =>  "0000000000",         --(others => '0'),      --         : IN  std_logic_vector(C_WR_PNTR_WIDTH_RDCH-1 DOWNTO 0) := (OTHERS => '0');
--              axi_r_data_count        =>  AXI_R_DATA_COUNT,     --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_RDCH DOWNTO 0);
--              axi_r_wr_data_count     =>  AXI_R_WR_DATA_COUNT,  --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_RDCH DOWNTO 0);
--              axi_r_rd_data_count     =>  AXI_R_RD_DATA_COUNT,  --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_RDCH DOWNTO 0);
--              axi_r_sbiterr           =>  AXI_R_SBITERR,        --         : OUT std_logic;
--              axi_r_dbiterr           =>  AXI_R_DBITERR,        --         : OUT std_logic;
--              axi_r_overflow          =>  AXI_R_OVERFLOW,       --         : OUT std_logic;
--              axi_r_underflow         =>  AXI_R_UNDERFLOW,      --         : OUT std_logic;
--              axi_r_prog_full         =>  AXI_R_PROG_FULL,      --         : OUT STD_LOGIC := '0';
--              axi_r_prog_empty        =>  AXI_R_PROG_EMPTY,     --         : OUT STD_LOGIC := '1';
--
--              -- AXI Streaming FIFO Related Signals
--              axis_injectsbiterr      =>  '0',                  --         : IN  std_logic := '0';
--              axis_injectdbiterr      =>  '0',                  --         : IN  std_logic := '0';
--              axis_prog_full_thresh   =>  "0000000000",         --(others => '0'),      --         : IN  std_logic_vector(C_WR_PNTR_WIDTH_AXIS-1 DOWNTO 0) := (OTHERS => '0');
--              axis_prog_empty_thresh  =>  "0000000000",         --(others => '0'),      --         : IN  std_logic_vector(C_WR_PNTR_WIDTH_AXIS-1 DOWNTO 0) := (OTHERS => '0');
--              axis_data_count         =>  AXIS_DATA_COUNT,      --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_AXIS DOWNTO 0);
--              axis_wr_data_count      =>  AXIS_WR_DATA_COUNT,   --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_AXIS DOWNTO 0);
--              axis_rd_data_count      =>  AXIS_RD_DATA_COUNT,   --         : OUT std_logic_vector(C_WR_PNTR_WIDTH_AXIS DOWNTO 0);
--              axis_sbiterr            =>  AXIS_SBITERR,         --         : OUT std_logic;
--              axis_dbiterr            =>  AXIS_DBITERR,         --         : OUT std_logic;
--              axis_overflow           =>  AXIS_OVERFLOW,        --         : OUT std_logic;
--              axis_underflow          =>  AXIS_UNDERFLOW,       --         : OUT std_logic
--              axis_prog_full          =>  AXIS_PROG_FULL,       --         : OUT STD_LOGIC := '0';
--              axis_prog_empty         =>  AXIS_PROG_EMPTY       --         : OUT STD_LOGIC := '1';
--  );

END ARCHITECTURE xilinx;


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- axi_vdma_afifo_autord.vhd - entity/architecture pair
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_afifo_autord.vhd
-- Version:         initial
-- Description:
--    This file contains the logic to generate a CoreGen call to create a
-- asynchronous FIFO as part of the synthesis process of XST. This eliminates
-- the need for multiple fixed netlists for various sizes and widths of FIFOs.
--
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;


library lib_cdc_v1_0_2;
library lib_fifo_v1_0_14;
use lib_fifo_v1_0_14.async_fifo_fg;

-----------------------------------------------------------------------------
-- Entity section
-----------------------------------------------------------------------------

entity axi_vdma_afifo_autord is
  generic (
     C_DWIDTH        : integer := 32;
       -- Sets the width of the FIFO Data

     C_DEPTH         : integer := 16;
       -- Sets the depth of the FIFO

     C_CNT_WIDTH     : Integer := 5;
       -- Sets the width of the FIFO Data Count output

     C_USE_BLKMEM    : Integer := 1 ;
       -- Sets the type of memory to use for the FIFO
       -- 0 = Distributed Logic
       -- 1 = Block Ram

     C_FAMILY        : String  := "virtex7"
       -- Specifies the target FPGA Family

    );
  port (
    -- FIFO Inputs --------------------------------------------------------------
     AFIFO_Ainit                : In  std_logic;                               --
     AFIFO_Wr_clk               : In  std_logic;                               --
     AFIFO_Wr_en                : In  std_logic;                               --
     AFIFO_Din                  : In  std_logic_vector(C_DWIDTH-1 downto 0);   --
     AFIFO_Rd_clk               : In  std_logic;                               --
     AFIFO_Rd_en                : In  std_logic;                               --
     AFIFO_Clr_Rd_Data_Valid    : In  std_logic;                               --
     ----------------------------------------------------------------------------

    -- FIFO Outputs --------------------------------------------------------------
     AFIFO_DValid               : Out std_logic;                                --
     AFIFO_Dout                 : Out std_logic_vector(C_DWIDTH-1 downto 0);    --
     AFIFO_Full                 : Out std_logic;                                --
     AFIFO_Empty                : Out std_logic;                                --
     AFIFO_Almost_full          : Out std_logic;                                --
     AFIFO_Almost_empty         : Out std_logic;                                --
     AFIFO_Wr_count             : Out std_logic_vector(C_CNT_WIDTH-1 downto 0); --
     AFIFO_Rd_count             : Out std_logic_vector(C_CNT_WIDTH-1 downto 0); --
     AFIFO_Corr_Rd_count        : Out std_logic_vector(C_CNT_WIDTH downto 0);   --
     AFIFO_Corr_Rd_count_minus1 : Out std_logic_vector(C_CNT_WIDTH downto 0);   --
     AFIFO_Rd_ack               : Out std_logic                                 --
     -----------------------------------------------------------------------------

    );
end entity axi_vdma_afifo_autord;


-----------------------------------------------------------------------------
-- Architecture section
-----------------------------------------------------------------------------

architecture imp of axi_vdma_afifo_autord is

attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";


-- Constant declarations
constant ZERO_VALUE_VECT    : std_logic_vector(128 downto 0) := (others => '0');


-- Signal declarations
   signal write_data_lil_end       : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
   signal read_data_lil_end        : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');

--   signal wr_count_lil_end         : std_logic_vector(C_CNT_WIDTH-1 downto 0) := (others => '0');
--   signal rd_count_lil_end         : std_logic_vector(C_CNT_WIDTH-1 downto 0) := (others => '0');
   signal wr_count_lil_end         : std_logic_vector(C_CNT_WIDTH-2 downto 0) := (others => '0');
   signal rd_count_lil_end         : std_logic_vector(C_CNT_WIDTH-2 downto 0) := (others => '0');

   signal rd_count_int             : natural   :=  0;
   signal rd_count_int_corr        : natural   :=  0;
   signal rd_count_int_corr_minus1 : natural   :=  0;
   Signal corrected_empty          : std_logic := '0';
   Signal corrected_almost_empty   : std_logic := '0';
   Signal sig_afifo_empty          : std_logic := '0';
   Signal sig_afifo_almost_empty   : std_logic := '0';

 -- backend fifo read ack sample and hold
   Signal sig_rddata_valid         : std_logic := '0';
   Signal hold_ff_q                : std_logic := '0';
   Signal ored_ack_ff_reset        : std_logic := '0';
   Signal autoread                 : std_logic := '0';
   Signal sig_wrfifo_rdack         : std_logic := '0';
   Signal fifo_read_enable         : std_logic := '0';

   signal afifo_full_i             : std_logic := '0';
   signal AFIFO_Ainit_reg             : std_logic ;
-----------------------------------------------------------------------------
-- Begin architecture
-----------------------------------------------------------------------------
begin

 -- Bit ordering translations

    write_data_lil_end   <=  AFIFO_Din;  -- translate from Big Endian to little
                                         -- endian.
    AFIFO_Rd_ack         <= sig_wrfifo_rdack;

    AFIFO_Dout           <= read_data_lil_end;  -- translate from Little Endian to
                                                -- Big endian.

    AFIFO_Almost_empty   <= corrected_almost_empty;

    AFIFO_Empty          <= corrected_empty;

    AFIFO_Full          <= afifo_full_i;

--    AFIFO_Wr_count       <= wr_count_lil_end;
    AFIFO_Wr_count       <= afifo_full_i & wr_count_lil_end;

--    AFIFO_Rd_count       <= 'rd_count_lil_end;
    AFIFO_Rd_count       <= '0' & rd_count_lil_end;


    AFIFO_Corr_Rd_count  <= CONV_STD_LOGIC_VECTOR(rd_count_int_corr,
                                                  C_CNT_WIDTH+1);

    AFIFO_Corr_Rd_count_minus1 <= CONV_STD_LOGIC_VECTOR(rd_count_int_corr_minus1,
                                                        C_CNT_WIDTH+1);

    AFIFO_DValid         <= sig_rddata_valid; -- Output data valid indicator


    fifo_read_enable     <= AFIFO_Rd_en or autoread;



   -------------------------------------------------------------------------------
   -- Instantiate the CoreGen FIFO
   --
   -- NOTE:
   -- This instance refers to a wrapper file that interm will use the
   -- CoreGen FIFO Generator Async FIFO utility.
   --
   -------------------------------------------------------------------------------
    I_ASYNC_FIFOGEN_FIFO : entity lib_fifo_v1_0_14.async_fifo_fg
       generic map (
	  C_XPM_FIFO		=>  1,
          C_ALLOW_2N_DEPTH      =>  1 ,
          C_FAMILY              =>  C_FAMILY,
          C_DATA_WIDTH          =>  C_DWIDTH,
          C_ENABLE_RLOCS        =>  0,
          C_FIFO_DEPTH          =>  C_DEPTH,
          C_SYNCHRONIZER_STAGE  =>  MTBF_STAGES,
          C_HAS_ALMOST_EMPTY    =>  1,
          C_HAS_ALMOST_FULL     =>  1,
          C_HAS_RD_ACK          =>  1,
          C_HAS_RD_COUNT        =>  1,
          C_HAS_RD_ERR          =>  0,
          C_HAS_WR_ACK          =>  0,
          C_HAS_WR_COUNT        =>  1,
          C_HAS_WR_ERR          =>  0,
          C_RD_ACK_LOW          =>  0,
--          C_RD_COUNT_WIDTH      =>  C_CNT_WIDTH,
          C_RD_COUNT_WIDTH      =>  C_CNT_WIDTH-1,
          C_RD_ERR_LOW          =>  0,
          C_USE_BLOCKMEM        =>  C_USE_BLKMEM,
          C_WR_ACK_LOW          =>  0,
--          C_WR_COUNT_WIDTH      =>  C_CNT_WIDTH,
          C_EN_SAFETY_CKT       =>  1,  
          C_WR_COUNT_WIDTH      =>  C_CNT_WIDTH-1,
          C_WR_ERR_LOW          =>  0
          --C_WR_ERR_LOW          =>  0,
          --C_USE_EMBEDDED_REG    =>  1, -- 0 ;
          --C_PRELOAD_REGS        =>  0, -- 0 ;
          --C_PRELOAD_LATENCY     =>  1  -- 1 ;
         )
      port Map (
         Din                 =>  write_data_lil_end,
         Wr_en               =>  AFIFO_Wr_en,
         Wr_clk              =>  AFIFO_Wr_clk,
         Rd_en               =>  fifo_read_enable,
         Rd_clk              =>  AFIFO_Rd_clk,
         Ainit               =>  AFIFO_Ainit,
         Dout                =>  read_data_lil_end,
--         Full                =>  AFIFO_Full,
         Full                =>  afifo_full_i,
         Empty               =>  sig_afifo_empty,
         Almost_full         =>  AFIFO_Almost_full,
         Almost_empty        =>  sig_afifo_almost_empty,
         Wr_count            =>  wr_count_lil_end,
         Rd_count            =>  rd_count_lil_end,
         Rd_ack              =>  sig_wrfifo_rdack,
         Rd_err              =>  open,
         Wr_ack              =>  open,
         Wr_err              =>  open
        );


   ----------------------------------------------------------------------------
   -- Read Ack assert & hold logic (needed because:
   --     1) The Async FIFO has to be read once to get valid
   --        data to the read data port (data is discarded).
   --     2) The Read ack from the fifo is only asserted for 1 clock.
   --     3) A signal is needed that indicates valid data is at the read
   --        port of the FIFO and has not yet been read. This signal needs
   --        to be held until the next read operation occurs or a clear
   --        signal is received.





    ---------------------------------------------------------------------------
    -- AFIFO_Ainit synchronization in AFIFO_Rd_clk domain
    ---------------------------------------------------------------------------

----    AFIFO_Ainit_RESET_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE          => CDC_TYPE_LEVEL_P_S_NO_RST                   ,
----            C_VECTOR_WIDTH      => 1
----        )
----        port map(
----            prmry_aclk                  => AFIFO_Wr_clk           ,
----            prmry_resetn                => '1'                      ,
----
----            scndry_aclk                 => AFIFO_Rd_clk          ,
----            scndry_resetn               => '1'                      ,
----
----            -- Secondary to Primary Clock Crossing
----            scndry_in                   => '0'                      ,
----            prmry_out                   => open                     ,
----
----            -- Primary to Secondary Clock Crossing
----            prmry_in                    => AFIFO_Ainit        ,
----            scndry_out                  => AFIFO_Ainit_reg       ,
----
----            -- Secondary Vector to Primary Vector Clock Crossing
----            scndry_vect_s_h             => '0'                      ,
----            scndry_vect_in              => ZERO_VALUE_VECT(0 downto 0),
----            prmry_vect_out              => open                     ,
----
----            -- Primary Vector to Secondary Vector Clock Crossing
----            prmry_vect_s_h              => '0'                      ,
----            prmry_vect_in               => ZERO_VALUE_VECT(0 downto 0),
----            scndry_vect_out             => open
----
----        );
----



AFIFO_Ainit_RESET_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => AFIFO_Wr_clk,
        prmry_resetn               => '1', 
        prmry_in                   => AFIFO_Ainit, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => AFIFO_Rd_clk, 
        scndry_resetn              => '1',
        scndry_out                 => AFIFO_Ainit_reg,
        scndry_vect_out            => open
    );







    ored_ack_ff_reset  <=  fifo_read_enable or
                           AFIFO_Ainit_reg or
                           AFIFO_Clr_Rd_Data_Valid;

    sig_rddata_valid   <=  hold_ff_q or
                           sig_wrfifo_rdack;




    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_ACK_HOLD_FLOP
    --
    -- Process Description:
    --  Flop for registering the hold flag
    --
    -------------------------------------------------------------
    IMP_ACK_HOLD_FLOP : process (AFIFO_Rd_clk)
       begin
         if (AFIFO_Rd_clk'event and AFIFO_Rd_clk = '1') then
           if (ored_ack_ff_reset = '1') then
             hold_ff_q  <= '0';
           else
             hold_ff_q  <= sig_rddata_valid;
           end if;
         end if;
       end process IMP_ACK_HOLD_FLOP;



  -- generate auto-read enable. This keeps fresh data at the output
  -- of the FIFO whenever it is available.
    autoread <= '1'                     -- create a read strobe when the
      when (sig_rddata_valid = '0' and  -- output data is NOT valid
            sig_afifo_empty = '0')      -- and the FIFO is not empty
      Else '0';


    rd_count_int <=  CONV_INTEGER(rd_count_lil_end);


    -------------------------------------------------------------
    -- Combinational Process
    --
    -- Label: CORRECT_RD_CNT
    --
    -- Process Description:
    --  This process corrects the FIFO Read Count output for the
    -- auto read function.
    --
    -------------------------------------------------------------
    CORRECT_RD_CNT : process (sig_rddata_valid,
                              sig_afifo_empty ,
                              sig_afifo_almost_empty,
                              rd_count_int)
       begin

          if (sig_rddata_valid = '0') then

             rd_count_int_corr        <= 0;
             rd_count_int_corr_minus1 <= 0;
             corrected_empty          <= '1';
             corrected_almost_empty   <= '0';

          elsif (sig_afifo_empty = '1') then         -- rddata valid and fifo empty

             rd_count_int_corr        <= 1;
             rd_count_int_corr_minus1 <= 0;
             corrected_empty          <= '0';
             corrected_almost_empty   <= '1';

          Elsif (sig_afifo_almost_empty = '1') Then  -- rddata valid and fifo almost empty

             rd_count_int_corr        <= 2;
             rd_count_int_corr_minus1 <= 1;
             corrected_empty          <= '0';
             corrected_almost_empty   <= '0';

          else                                       -- rddata valid and modify rd count from FIFO

             rd_count_int_corr        <= rd_count_int+1;
             rd_count_int_corr_minus1 <= rd_count_int;
             corrected_empty          <= '0';
             corrected_almost_empty   <= '0';

          end if;

       end process CORRECT_RD_CNT;



end imp;


-------------------------------------------------------------------------------
-- axi_vdma_mm2s_linebuf
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************

--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_mm2s_linebuf.vhd
-- Description: This entity encompases the mm2s line buffer logic
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library lib_cdc_v1_0_2;
library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_mm2s_linebuf is
    generic (
        C_DATA_WIDTH                	: integer range 8 to 1024           := 32;
        C_M_AXIS_MM2S_TDATA_WIDTH   	: integer range 8 to 1024           	:= 32;
            -- Line Buffer Data Width

        C_INCLUDE_S2MM              	: integer range 0 to 1              	:= 0;
        C_INCLUDE_MM2S_SF           	: integer range 0 to 1              	:= 0;
            -- Include or exclude MM2S Store And Forward Functionality
            -- 0 = Exclude MM2S Store and Forward
            -- 1 = Include MM2S Store and Forward
        C_INCLUDE_MM2S_DRE              : integer range 0 to 1      	:= 0;

        C_MM2S_SOF_ENABLE               : integer range 0 to 1      		:= 0;
            -- Enable/Disable start of frame generation on tuser(0). This
            -- is only valid for external frame sync (C_USE_FSYNC = 1)
            -- 0 = disable SOF
            -- 1 = enable SOF

        C_M_AXIS_MM2S_TUSER_BITS        : integer range 1 to 1          	:= 1;
            -- Master AXI Stream User Width for MM2S Channel

        C_TOPLVL_LINEBUFFER_DEPTH   	: integer range 0 to 65536          	:= 512; -- 
            -- Depth as set by user at top level parameter

        C_LINEBUFFER_DEPTH          	: integer range 0 to 65536          	:= 512;
            -- Linebuffer depth in Bytes. Must be a power of 2

        C_LINEBUFFER_AE_THRESH       	: integer range 1 to 65536         	:= 1;
            -- Linebuffer almost empty threshold in Bytes. Must be a power of 2

        C_PRMRY_IS_ACLK_ASYNC       	: integer range 0 to 1              	:= 0 ;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.
          --C_ENABLE_DEBUG_INFO             : string := "1111111111111111";		-- 1 to 16 -- 
        --C_ENABLE_DEBUG_INFO             : bit_vector(15 downto 0) 	:= (others => '1');		--15 downto 0  -- 
        C_ENABLE_DEBUG_ALL       : integer range 0 to 1      	:= 1;
            -- Setting this make core backward compatible to 2012.4 version in terms of ports and registers
        C_ENABLE_DEBUG_INFO_0       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 0
        C_ENABLE_DEBUG_INFO_1       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 1
        C_ENABLE_DEBUG_INFO_2       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 2
        C_ENABLE_DEBUG_INFO_3       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 3
        C_ENABLE_DEBUG_INFO_4       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 4
        C_ENABLE_DEBUG_INFO_5       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 5
        C_ENABLE_DEBUG_INFO_6       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 6
        C_ENABLE_DEBUG_INFO_7       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 7
        C_ENABLE_DEBUG_INFO_8       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 8
        C_ENABLE_DEBUG_INFO_9       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 9
        C_ENABLE_DEBUG_INFO_10      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 10
        C_ENABLE_DEBUG_INFO_11      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 11
        C_ENABLE_DEBUG_INFO_12      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 12
        C_ENABLE_DEBUG_INFO_13      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 13
        C_ENABLE_DEBUG_INFO_14      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 14
        C_ENABLE_DEBUG_INFO_15      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 15

        ENABLE_FLUSH_ON_FSYNC       	: integer range 0 to 1        		:= 0      ;

        C_FAMILY                    	: string            			:= "virtex7"
            -- Device family used for proper BRAM selection
    );
    port (
        -- MM2S AXIS Input Side (i.e. Datamover side)
        s_axis_aclk                 : in  std_logic                         ;   --
        s_axis_resetn               : in  std_logic                         ;   --
                                                                                --
        -- MM2S AXIS Output Side                                                --
        m_axis_aclk                 : in  std_logic                         ;   --
        m_axis_resetn               : in  std_logic                         ;   --
        mm2s_axis_linebuf_reset_out : out  std_logic                         ;   --

        s2mm_axis_resetn            : in  std_logic           := '1'              ;                   --
        s_axis_s2mm_aclk            : in  std_logic           := '0'              ;                   --

        mm2s_fsync                  : in  std_logic                         ;   --
        s2mm_fsync                  : in  std_logic                         ;   --
        mm2s_fsync_core             : out  std_logic                         ;   --
        mm2s_fsize_mismatch_err_s   : out  std_logic                         ;   --
        mm2s_fsize_mismatch_err_m   : out  std_logic                         ;   --
        mm2s_vsize_cntr_clr_flag    : out  std_logic                         ;   --
MM2S_DROP_RESIDUAL_OF_FSIZE_ERR_FRAME_S   : out  std_logic                         ;   --

        fsync_src_select            : in  std_logic_vector(1 downto 0)      ;           --

                                                                                --
        run_stop                    : in  std_logic                         ;   --
        -- Graceful shut down control                                           --
        dm_halt                     : in  std_logic                         ;   --
        dm_halt_reg_out             : out  std_logic                         ;   --
        cmdsts_idle                 : in  std_logic                         ;   --
        stop                        : in  std_logic                         ;   -- 
        stop_reg_out                : out  std_logic                         ;   -- 
                                                                                --
        -- Vertical Line Count control                                          --
        fsync_out                   : in  std_logic                         ;   -- 
        fsync_out_m                 : out  std_logic                         ;   -- 
        mm2s_fsize_mismatch_err_flag: in  std_logic                         ;   -- 
        frame_sync                  : in  std_logic                         ;   -- 
        crnt_vsize                  : in  std_logic_vector                      --
                                        (VSIZE_DWIDTH-1 downto 0)           ;   -- 
        crnt_vsize_d2_out           : out  std_logic_vector                      --
                                        (VSIZE_DWIDTH-1 downto 0)           ;   -- 
                                                                             --
        linebuf_threshold           : in  std_logic_vector                      --
                                        (LINEBUFFER_THRESH_WIDTH-1 downto 0);   --
                                                                                --
        -- Stream In (Datamover To Line Buffer)                                 --
        s_axis_tdata                : in  std_logic_vector                      --
                                        (C_DATA_WIDTH-1 downto 0)           ;   --
        s_axis_tkeep                : in  std_logic_vector                      --
                                        ((C_DATA_WIDTH/8)-1 downto 0)       ;   --
        s_axis_tlast                : in  std_logic                         ;   --
        s_axis_tvalid               : in  std_logic                         ;   --
        s_axis_tready               : out std_logic                         ;   --
                                                                                --
                                                                                --
        -- Stream Out (Line Buffer To MM2S AXIS)                                --
        m_axis_tdata                : out std_logic_vector                      --
                                        (C_DATA_WIDTH-1 downto 0)           ;   --
        m_axis_tkeep                : out std_logic_vector                      --
                                        ((C_DATA_WIDTH/8)-1 downto 0)       ;   --
        m_axis_tlast                : out std_logic                         ;   --
        m_axis_tvalid               : out std_logic                         ;   --
        m_axis_tready               : in  std_logic                         ;   --
        m_axis_tuser                : out std_logic_vector                      --
                                        (C_M_AXIS_MM2S_TUSER_BITS-1 downto 0);  --
                                                                                --
        -- Fifo Status Flags                                                    --
        dwidth_fifo_pipe_empty      : in std_logic                         ;   --
        dwidth_fifo_pipe_empty_m    : out std_logic                         ;   --
        mm2s_fifo_pipe_empty        : out std_logic                         ;   --
        mm2s_fifo_empty             : out std_logic                         ;   --
        mm2s_fifo_almost_empty      : out std_logic                         ;   --
        mm2s_all_lines_xfred_s_dwidth      : in std_logic                         ;   --
        mm2s_all_lines_xfred_s      : out std_logic                         ;   --
        mm2s_all_lines_xfred        : out std_logic                             -- 
    );

end axi_vdma_mm2s_linebuf;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_mm2s_linebuf is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- Bufer depth
--constant BUFFER_DEPTH           : integer := max2(128,C_LINEBUFFER_DEPTH/(C_DATA_WIDTH/8));
constant BUFFER_DEPTH           : integer := C_LINEBUFFER_DEPTH;

-- Buffer width is data width + strobe width + 1 bit for tlast
-- Increase data width by 1 when tuser support included.
--constant BUFFER_WIDTH           : integer := C_DATA_WIDTH + (C_DATA_WIDTH/8) + 1;
constant BUFFER_WIDTH           : integer := C_DATA_WIDTH           -- tdata
                                          + (C_DATA_WIDTH/8)*C_INCLUDE_MM2S_DRE        -- tkeep
                                          + 1                       -- tlast
                                          + (C_MM2S_SOF_ENABLE      -- tuser
                                            *C_M_AXIS_MM2S_TUSER_BITS);






-- Buffer data count width
constant DATACOUNT_WIDTH        : integer := clog2(BUFFER_DEPTH);


constant DATA_COUNT_ZERO                : std_logic_vector(DATACOUNT_WIDTH-1 downto 0)
                                        := (others => '0');

constant USE_BRAM_FIFOS                 : integer   := 1; -- Use BRAM FIFOs


constant ZERO_VALUE_VECT                : std_logic_vector(255 downto 0) := (others => '0');

-- Constants for line tracking logic
constant VSIZE_ONE_VALUE            : std_logic_vector(VSIZE_DWIDTH-1 downto 0)
                                        := std_logic_vector(to_unsigned(1,VSIZE_DWIDTH));

constant VSIZE_ZERO_VALUE           : std_logic_vector(VSIZE_DWIDTH-1 downto 0)
                                        := (others => '0');

-- Linebuffer threshold support
constant THRESHOLD_LSB_INDEX        : integer := clog2((C_DATA_WIDTH/8));
constant THRESHOLD_PAD              : std_logic_vector(THRESHOLD_LSB_INDEX-1 downto 0)  := (others => '0');


-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal fifo_din                     : std_logic_vector(BUFFER_WIDTH - 1 downto 0) := (others => '0');
signal fifo_dout                    : std_logic_vector(BUFFER_WIDTH - 1 downto 0) := (others => '0');
signal fifo_wren                    : std_logic := '0';
signal fifo_rden                    : std_logic := '0';
signal fifo_empty_i                 : std_logic := '0';
signal fifo_full_i                  : std_logic := '0';
signal fifo_ainit                   : std_logic := '0';
signal fifo_rdcount                 : std_logic_vector(DATACOUNT_WIDTH -1 downto 0) := (others => '0');

signal s_axis_tready_i              : std_logic := '0'; -- 
signal m_axis_tready_i              : std_logic := '0';
signal m_axis_tvalid_i              : std_logic := '0';
signal m_axis_tlast_i               : std_logic := '0';
signal m_axis_tdata_i               : std_logic_vector(C_DATA_WIDTH-1 downto 0):= (others => '0');
signal m_axis_tkeep_i               : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0) := (others => '0');
signal m_axis_tkeep_signal          : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0) := (others => '0');
signal s_axis_tkeep_signal          : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0) := (others => '0');
signal m_axis_tuser_i               : std_logic_vector(C_M_AXIS_MM2S_TUSER_BITS - 1 downto 0) := (others => '0');

signal m_axis_tready_d1             : std_logic := '0';
signal m_axis_tlast_d1              : std_logic := '0';
signal m_axis_tvalid_d1             : std_logic := '0';

signal crnt_vsize_cdc_tig           : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');  -- 
signal crnt_vsize_d1                : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');  -- 
signal crnt_vsize_d2                : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');  -- 
signal vsize_counter                : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');  -- 
signal decr_vcount                  : std_logic := '0';                                              -- 
signal all_lines_xfred              : std_logic := '0'; -- 
signal all_lines_xfred_no_dwidth    : std_logic := '0'; -- 
signal mm2s_all_lines_xfred_s_sig   : std_logic := '0'; -- 

signal m_axis_tvalid_out            : std_logic := '0'; -- 
signal m_axis_tlast_out             : std_logic := '0'; -- 
signal slv2skid_s_axis_tvalid       : std_logic := '0'; -- 
signal fifo_empty_d1                : std_logic := '0'; -- 

-- FIFO Pipe empty signals
signal fifo_pipe_empty              : std_logic := '0';
signal fifo_wren_d1                 : std_logic := '0'; -- 
signal pot_empty                    : std_logic := '0'; -- 

signal fifo_almost_empty_i          : std_logic := '1'; -- 
signal fifo_almost_empty_d1         : std_logic := '1';
signal fifo_almost_empty_fe         : std_logic := '0'; -- 

signal fifo_almost_empty_reg        : std_logic := '1';
signal data_count_ae_threshold_cdc_tig      : std_logic_vector(DATACOUNT_WIDTH-1 downto 0) := (others => '0');
signal data_count_ae_threshold_d1      : std_logic_vector(DATACOUNT_WIDTH-1 downto 0) := (others => '0');
signal data_count_ae_threshold      : std_logic_vector(DATACOUNT_WIDTH-1 downto 0) := (others => '0');
signal m_data_count_ae_thresh       : std_logic_vector(DATACOUNT_WIDTH-1 downto 0) := (others => '0');
signal sf_threshold_met             : std_logic := '0';

signal cmdsts_idle_d1               : std_logic := '0';
signal cmdsts_idle_fe               : std_logic := '0';
signal stop_reg                     : std_logic := '0'; --

signal s_axis_fifo_ainit            : std_logic := '0';
signal m_axis_fifo_ainit            : std_logic := '0';
signal s_axis_fifo_ainit_nosync     : std_logic := '0';
signal s_axis_fifo_ainit_nosync_reg : std_logic := '0';
signal m_axis_fifo_ainit_nosync     : std_logic := '0';
signal dm_decr_vcount               : std_logic := '0';                                                 -- 
signal dm_xfred_all_lines           : std_logic := '0';                                                 -- 
signal dm_vsize_counter             : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');     -- 
signal dm_xfred_all_lines_reg       : std_logic := '0';                                                 -- 

signal sof_flag                     : std_logic := '0';
signal mm2s_fifo_pipe_empty_i       : std_logic := '0';
signal frame_sync_d1                : std_logic := '0';

signal m_skid_reset                 : std_logic := '0';
signal dm_halt_reg                  : std_logic := '0';
signal mm2s_axis_linebuf_reset_out_inv : std_logic       := '0'                  ;   --
signal sof_reset 		    : std_logic := '0';

signal wr_rst_busy_sig              : std_logic := '0';
signal rd_rst_busy_sig              : std_logic := '0';                  



  ATTRIBUTE async_reg                      : STRING;

  ATTRIBUTE async_reg OF crnt_vsize_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF crnt_vsize_d1       : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF data_count_ae_threshold_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF data_count_ae_threshold_d1       : SIGNAL IS "true"; 

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
mm2s_fifo_pipe_empty 	<= mm2s_fifo_pipe_empty_i;
dm_halt_reg_out 	<= dm_halt_reg;
stop_reg_out 		<= stop_reg;
crnt_vsize_d2_out 	<= crnt_vsize_d2;

GEN_MM2S_DRE_ON : if C_INCLUDE_MM2S_DRE = 1 generate
begin

m_axis_tkeep 	    <= m_axis_tkeep_signal;
s_axis_tkeep_signal <= s_axis_tkeep;

end generate GEN_MM2S_DRE_ON;

GEN_MM2S_DRE_OFF : if C_INCLUDE_MM2S_DRE = 0 generate
begin

m_axis_tkeep 	    <= (others => '1');
s_axis_tkeep_signal <= (others => '1');

end generate GEN_MM2S_DRE_OFF;

    GEN_LINEBUF_NO_SOF : if (ENABLE_FLUSH_ON_FSYNC = 0 or C_MM2S_SOF_ENABLE = 0) generate
    begin

	mm2s_fsync_core 			<= mm2s_fsync;
	MM2S_DROP_RESIDUAL_OF_FSIZE_ERR_FRAME_S <= '0';
	mm2s_fsize_mismatch_err_s 		<= '0';



--*****************************************************************************--
--**              LINE BUFFER MODE (Sync or Async)                           **--
--*****************************************************************************--
GEN_LINEBUFFER : if C_LINEBUFFER_DEPTH /= 0 generate
begin

    -- Divide by number bytes per data beat and add padding to dynamic
    -- threshold setting
    data_count_ae_threshold <= linebuf_threshold((DATACOUNT_WIDTH-1) + THRESHOLD_LSB_INDEX
                                            downto THRESHOLD_LSB_INDEX);

    -- Synchronous clock therefore instantiate an Asynchronous FIFO
    GEN_SYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
    begin
              
      
        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_sfifo
            generic map(
                 UW_DATA_WIDTH     => BUFFER_WIDTH        ,
          C_FULL_FLAGS_RST_VAL     => 1        ,
                 UW_FIFO_DEPTH     => BUFFER_DEPTH        ,
                 C_FAMILY          => C_FAMILY
            )
            port map(
                -- Inputs
                 rst               => s_axis_fifo_ainit_nosync   ,
                 sleep             => '0'         ,
                 wr_rst_busy       => wr_rst_busy_sig         ,
                 rd_rst_busy       => rd_rst_busy_sig         ,
                 clk               => s_axis_aclk         ,
                 wr_en             => fifo_wren           ,
                 din               => fifo_din            ,
                 rd_en             => fifo_rden           ,

                -- Outputs
                 dout              => fifo_dout           ,
                 full              => fifo_full_i         ,
                 empty             => fifo_empty_i        ,
                 data_count        => fifo_rdcount  
            );

--wr_rst_busy_sig <= '0';
--rd_rst_busy_sig <= '0';

    end generate GEN_SYNC_FIFO;

    -- Asynchronous clock therefore instantiate an Asynchronous FIFO
    GEN_ASYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
    begin
LB_BRAM : if ( (C_ENABLE_DEBUG_INFO_1 = 1 or C_ENABLE_DEBUG_ALL = 1) )
  generate   
    begin

        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_afifo
            generic map(
                 UW_DATA_WIDTH   => BUFFER_WIDTH                    ,
          C_FULL_FLAGS_RST_VAL   => 1        ,
                 UW_FIFO_DEPTH   => BUFFER_DEPTH                    ,
                 C_FAMILY        => C_FAMILY
            )
            port map(
                -- Inputs
                 rst             => s_axis_fifo_ainit_nosync_reg    ,
                 sleep           => '0'         ,
                 wr_rst_busy     => open         ,
                 rd_rst_busy     => open         ,
                 wr_clk          => s_axis_aclk          ,
                 wr_en           => fifo_wren            ,
                 din             => fifo_din             ,
                 rd_clk          => m_axis_aclk          ,
                 rd_en           => fifo_rden            ,

                -- Outputs
                 dout            => fifo_dout            ,
                 full            => fifo_full_i          ,
                 empty           => fifo_empty_i         ,
                 wr_data_count   => open         , --
                 rd_data_count   => fifo_rdcount         
            );

wr_rst_busy_sig <= '0';
rd_rst_busy_sig <= '0';

end generate LB_BRAM;                     


      
LB_BUILT_IN : if ( (C_ENABLE_DEBUG_INFO_1 = 0 and C_ENABLE_DEBUG_ALL = 0) )
  generate   
    begin

        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_afifo_builtin
            generic map(
                 PL_FIFO_TYPE    => "BUILT_IN"                    ,
                 PL_READ_MODE    => "FWFT"                    ,
                 PL_FASTER_CLOCK => "WR_CLK"                    , --RD_CLK
                 PL_FULL_FLAGS_RST_VAL => 0                     , -- ?
                 PL_DATA_WIDTH   => BUFFER_WIDTH                    ,
                 C_FAMILY        => C_FAMILY ,
                 PL_FIFO_DEPTH   => BUFFER_DEPTH                    
            )
            port map(
                -- Inputs
                 rst             => s_axis_fifo_ainit_nosync_reg    ,
                 sleep           => '0'         ,
                 wr_rst_busy     => wr_rst_busy_sig         ,
                 rd_rst_busy     => rd_rst_busy_sig         ,
                 wr_clk          => s_axis_aclk          ,
                 wr_en           => fifo_wren            ,
                 din             => fifo_din             ,
                 rd_clk          => m_axis_aclk          ,
                 rd_en           => fifo_rden            ,

                -- Outputs
                 dout            => fifo_dout            ,
                 full            => fifo_full_i          ,
                 empty           => fifo_empty_i         
            );


end generate LB_BUILT_IN;                     
      

     end generate GEN_ASYNC_FIFO;




    -- Generate an SOF on tuser(0). currently vdma only support 1 tuser bit that is set by
    -- frame sync and driven out on first data beat of mm2s packet.
   GEN_SOF : if ENABLE_FLUSH_ON_FSYNC = 0 and C_MM2S_SOF_ENABLE = 1 generate
   --signal sof_reset : std_logic := '0';
   begin
       sof_reset   <= '1' when (s_axis_resetn = '0')
                            or (dm_halt = '1')
                 else '0';

       -- On frame sync set flag and then clear flag when
       -- sof written to fifo.
       SOF_FLAG_PROCESS : process(s_axis_aclk)
           begin
               if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                   if(sof_reset = '1' or fifo_wren = '1')then
                       sof_flag <= '0';
                   elsif(frame_sync = '1')then
                       sof_flag <= '1';
                   end if;
               end if;
           end process SOF_FLAG_PROCESS;

   GEN_MM2S_DRE_ENABLED_TKEEP : if C_INCLUDE_MM2S_DRE = 1 generate
   begin

       -- AXI Slave Side of FIFO
       fifo_din            <= sof_flag & s_axis_tlast & s_axis_tkeep_signal & s_axis_tdata;
       fifo_wren           <= s_axis_tvalid and s_axis_tready_i;
       s_axis_tready_i     <= not fifo_full_i and not wr_rst_busy_sig and not s_axis_fifo_ainit;
       s_axis_tready       <= s_axis_tready_i; -- 

       -- AXI Master Side of FIFO
       fifo_rden           <= m_axis_tready_i and m_axis_tvalid_i;
       m_axis_tvalid_i     <= not fifo_empty_i and not rd_rst_busy_sig and sf_threshold_met;
       m_axis_tdata_i      <= fifo_dout(C_DATA_WIDTH-1 downto 0);
       m_axis_tkeep_i      <= fifo_dout(BUFFER_WIDTH-3 downto (BUFFER_WIDTH-3) - (C_DATA_WIDTH/8) + 1);
       m_axis_tlast_i      <= fifo_dout(BUFFER_WIDTH-2);
       m_axis_tuser_i(0)   <= fifo_dout(BUFFER_WIDTH-1);

   end generate GEN_MM2S_DRE_ENABLED_TKEEP;

   GEN_NO_MM2S_DRE_DISABLE_TKEEP : if C_INCLUDE_MM2S_DRE = 0 generate
   begin

       -- AXI Slave Side of FIFO
       fifo_din            <= sof_flag & s_axis_tlast & s_axis_tdata;
       fifo_wren           <= s_axis_tvalid and s_axis_tready_i;
       s_axis_tready_i     <= not fifo_full_i and not wr_rst_busy_sig and not s_axis_fifo_ainit;
       s_axis_tready       <= s_axis_tready_i; -- 

       -- AXI Master Side of FIFO
       fifo_rden           <= m_axis_tready_i and m_axis_tvalid_i;
       m_axis_tvalid_i     <= not fifo_empty_i and not rd_rst_busy_sig and sf_threshold_met;
       m_axis_tdata_i      <= fifo_dout(C_DATA_WIDTH-1 downto 0);
       m_axis_tkeep_i      <= (others => '1');
       m_axis_tlast_i      <= fifo_dout(BUFFER_WIDTH-2);
       m_axis_tuser_i(0)   <= fifo_dout(BUFFER_WIDTH-1);

   end generate GEN_NO_MM2S_DRE_DISABLE_TKEEP;


   end generate GEN_SOF;


   -- SOF turned off therefore do not generate SOF on tuser
   GEN_NO_SOF : if C_MM2S_SOF_ENABLE = 0 generate
   begin
   GEN_MM2S_DRE_ENABLED_TKEEP : if C_INCLUDE_MM2S_DRE = 1 generate
   begin


        sof_flag <= '0';

        -- AXI Slave Side of FIFO
        fifo_din            <= s_axis_tlast & s_axis_tkeep_signal & s_axis_tdata;
       fifo_wren            <= s_axis_tvalid and s_axis_tready_i;
       s_axis_tready_i      <= not fifo_full_i and not wr_rst_busy_sig and not s_axis_fifo_ainit;
        s_axis_tready       <= s_axis_tready_i; -- 

        -- AXI Master Side of FIFO
        fifo_rden           <= m_axis_tready_i and m_axis_tvalid_i;
        m_axis_tvalid_i     <= not fifo_empty_i and not rd_rst_busy_sig and sf_threshold_met;
        m_axis_tdata_i      <= fifo_dout(C_DATA_WIDTH-1 downto 0);
        m_axis_tkeep_i      <= fifo_dout(BUFFER_WIDTH-2 downto (BUFFER_WIDTH-2) - (C_DATA_WIDTH/8) + 1);
        m_axis_tlast_i      <= fifo_dout(BUFFER_WIDTH-1);
        m_axis_tuser_i      <= (others => '0');

   end generate GEN_MM2S_DRE_ENABLED_TKEEP;

   GEN_NO_MM2S_DRE_DISABLE_TKEEP : if C_INCLUDE_MM2S_DRE = 0 generate
   begin

        sof_flag <= '0';

        -- AXI Slave Side of FIFO
        fifo_din            <= s_axis_tlast & s_axis_tdata;
       fifo_wren            <= s_axis_tvalid and s_axis_tready_i;
       s_axis_tready_i      <= not fifo_full_i and not wr_rst_busy_sig and not s_axis_fifo_ainit;
        s_axis_tready       <= s_axis_tready_i; -- 

        -- AXI Master Side of FIFO
        fifo_rden           <= m_axis_tready_i and m_axis_tvalid_i;
        m_axis_tvalid_i     <= not fifo_empty_i and not rd_rst_busy_sig and sf_threshold_met;
        m_axis_tdata_i      <= fifo_dout(C_DATA_WIDTH-1 downto 0);
        m_axis_tkeep_i      <= (others => '1');
        m_axis_tlast_i      <= fifo_dout(BUFFER_WIDTH-1);
        m_axis_tuser_i      <= (others => '0');


   end generate GEN_NO_MM2S_DRE_DISABLE_TKEEP;


    end generate GEN_NO_SOF;

    -- Top level line buffer depth not equal to zero therefore gererate threshold
    -- flags. (
    GEN_THRESHOLD_ENABLED : if C_TOPLVL_LINEBUFFER_DEPTH /= 0 and (C_ENABLE_DEBUG_INFO_1 = 1 or C_ENABLE_DEBUG_ALL = 1)  generate
    begin

        -- Almost empty flag (note: asserts when empty also)
    
      
        REG_ALMST_EMPTY : process(m_axis_aclk)
            begin
                if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
                    if(m_axis_fifo_ainit = '1')then
                        fifo_almost_empty_reg <= '1';
                    --elsif(fifo_rdcount(DATACOUNT_WIDTH-1 downto 0) <= DATA_COUNT_AE_THRESHOLD or fifo_empty_i = '1')then
                    --elsif((fifo_rdcount(DATACOUNT_WIDTH-1 downto 0) <= m_data_count_ae_thresh
                    --  or fifo_empty_i = '1') and fifo_full_i = '0')then
                    elsif((fifo_rdcount(DATACOUNT_WIDTH-1 downto 0) <= m_data_count_ae_thresh
                      or (fifo_empty_i = '1' or rd_rst_busy_sig = '1')))then
                        fifo_almost_empty_reg <= '1';
                    else
                        fifo_almost_empty_reg <= '0';
                    end if;
                end if;
            end process REG_ALMST_EMPTY;


        mm2s_fifo_almost_empty  <= fifo_almost_empty_reg
                                or (not sf_threshold_met) -- 
                                or (not m_axis_tvalid_out); -- 

        mm2s_fifo_empty         <= not m_axis_tvalid_out;
    end generate GEN_THRESHOLD_ENABLED;

    -- Top level line buffer depth is zero therefore turn off threshold logic.
    -- this occurs for async operation where the async fifo is needed for CDC (
    GEN_THRESHOLD_DISABLED  : if C_TOPLVL_LINEBUFFER_DEPTH = 0 or (C_ENABLE_DEBUG_INFO_1 = 0 and C_ENABLE_DEBUG_ALL = 0)  generate
    begin
        mm2s_fifo_empty             <= '0';
        mm2s_fifo_almost_empty      <= '0';
        fifo_almost_empty_reg       <= '0';
    end generate GEN_THRESHOLD_DISABLED;

    -- 
    -- FIFO, FIFO Pipe, and Skid Buffer are all empty.  This is used to safely
    -- assert reset on shutdown and also used to safely generate fsync in free-run mode
    --  - need to look at write side of fifo to prevent false empties due to async fifo
    --fifo_pipe_empty <= '1' when (fifo_wrcount(DATACOUNT_WIDTH-1 downto 0) = DATA_COUNT_ZERO -- Data count is 0
    --                                and m_axis_tvalid_out = '0')                            -- Skid Buffer is done
    --                        -- Forced stop and Threshold not met ()
    --                        or  (sf_threshold_met = '0' and stop_reg = '1')
    --              else '0';
    --  fixed flase fifo_pipe_assertions due to extreme AXI4 throttling on
    -- mm2s reads causing fifo to go empty for extended periods of time.  This then
    -- caused flase idles to be flagged and frame syncs were then generated in free run mode
--------    fifo_pipe_empty <= '1' when (all_lines_xfred = '1' and m_axis_tvalid_out = '0') -- All data for frame transmitted
--------                            or  (sf_threshold_met = '0'              -- Or Threshold not met
--------                                and stop_reg = '1'                   -- Commanded to stop
--------                                and m_axis_tvalid_out = '0')         -- And NOT driving tvalid
--------                  else '0';
--------

    -- If store and forward is turned on by user then gate tvalid with
    -- threshold met
    GEN_THRESH_MET_FOR_SNF : if C_INCLUDE_MM2S_SF = 1  and C_TOPLVL_LINEBUFFER_DEPTH /= 0 and (C_ENABLE_DEBUG_INFO_1 = 1 or C_ENABLE_DEBUG_ALL = 1)  generate
    begin
            -- Register fifo_almost empty in order to generate
            -- almost empty fall edge pulse
            REG_ALMST_EMPTY_FE : process(m_axis_aclk)
                begin
                    if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
                        if(m_axis_fifo_ainit = '1')then
                            fifo_almost_empty_d1 <= '1';
                        else
                            fifo_almost_empty_d1 <= fifo_almost_empty_reg;
                        end if;
                    end if;
                end process REG_ALMST_EMPTY_FE;

            -- Almost empty falling edge
            fifo_almost_empty_fe <= not fifo_almost_empty_reg and fifo_almost_empty_d1;

            -- Store and Forward threshold met
            THRESH_MET : process(m_axis_aclk)
                begin
                    if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
                        if(m_axis_fifo_ainit = '1')then
                            sf_threshold_met <= '0';
                        elsif(fsync_out = '1')then
                            sf_threshold_met <= '0';
                        -- Reached threshold or all reads done for the frame
                        elsif(fifo_almost_empty_fe = '1'
                          or (dm_xfred_all_lines_reg = '1'))then
                            sf_threshold_met <= '1';
                        end if;
                    end if;
                end process THRESH_MET;

    end generate GEN_THRESH_MET_FOR_SNF;

    -- Store and forward off therefore do not need to meet threshold
    GEN_NO_THRESH_MET_FOR_SNF : if C_INCLUDE_MM2S_SF = 0  or C_TOPLVL_LINEBUFFER_DEPTH = 0  or (C_ENABLE_DEBUG_INFO_1 = 0 and C_ENABLE_DEBUG_ALL = 0)  generate
    begin
        sf_threshold_met <= '1';
    end generate GEN_NO_THRESH_MET_FOR_SNF;


    --*********************************************************--
    --**               MM2S MASTER SKID BUFFER               **--
    --*********************************************************--
    I_MSTR_SKID : entity axi_vdma_v6_3_10.axi_vdma_skid_buf
        generic map(
            C_WDATA_WIDTH           => C_DATA_WIDTH             ,
            C_TUSER_WIDTH           => C_M_AXIS_MM2S_TUSER_BITS
        )
        port map(
            -- System Ports
            ACLK                   => m_axis_aclk               ,
            ARST                   => m_axis_fifo_ainit_nosync              ,

            -- Shutdown control (assert for 1 clk pulse)
            skid_stop              => '0'                       ,

            -- Slave Side (Stream Data Input)
            S_VALID                => m_axis_tvalid_i           ,
            S_READY                => m_axis_tready_i           ,
            S_Data                 => m_axis_tdata_i            ,
            S_STRB                 => m_axis_tkeep_i            ,
            S_Last                 => m_axis_tlast_i            ,
            S_User                 => m_axis_tuser_i            ,

            -- Master Side (Stream Data Output)
            M_VALID                => m_axis_tvalid_out         ,
            M_READY                => m_axis_tready             ,
            M_Data                 => m_axis_tdata              ,
            M_STRB                 => m_axis_tkeep_signal              ,
            M_Last                 => m_axis_tlast_out          ,
            M_User                 => m_axis_tuser
        );

    -- Pass out of core
    m_axis_tvalid   <= m_axis_tvalid_out;
    m_axis_tlast    <= m_axis_tlast_out;

    -- Register to break long timing paths for use in
    -- transfer complete generation
    REG_STRM_SIGS : process(m_axis_aclk)
        begin
            if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
                if(m_axis_fifo_ainit = '1')then
                    m_axis_tlast_d1     <= '0';
                    m_axis_tvalid_d1    <= '0';
                    m_axis_tready_d1    <= '0';
                else
                    m_axis_tlast_d1     <= m_axis_tlast_out;
                    m_axis_tvalid_d1    <= m_axis_tvalid_out;
                    m_axis_tready_d1    <= m_axis_tready;
                end if;
            end if;
        end process REG_STRM_SIGS;



end generate GEN_LINEBUFFER;

--*****************************************************************************--
--**               NO LINE BUFFER MODE (Sync Only)                           **--
--*****************************************************************************--
-- LineBuffer forced on if asynchronous mode is enabled
GEN_NO_LINEBUFFER : if (C_LINEBUFFER_DEPTH = 0) generate     -- No Line Buffer
begin

    -- Map Datamover to AXIS Master Out
    m_axis_tdata        <= s_axis_tdata;
    m_axis_tkeep_signal <= s_axis_tkeep_signal;
    m_axis_tvalid       <= s_axis_tvalid;
    m_axis_tlast        <= s_axis_tlast;

    s_axis_tready       <= m_axis_tready;

    -- Tie FIFO Flags off
    mm2s_fifo_empty          <= '0';
    mm2s_fifo_almost_empty   <= '0';


    -- Generate sof on tuser(0)
    GEN_SOF : if C_MM2S_SOF_ENABLE = 1 generate
    begin
        -- On frame sync set flag and then clear flag when
        -- sof written to fifo.
        SOF_FLAG_PROCESS : process(s_axis_aclk)
            begin
                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                    if(s_axis_fifo_ainit = '1' or (s_axis_tvalid = '1' and m_axis_tready = '1'))then
                        sof_flag <= '0';
                    elsif(frame_sync = '1')then
                        sof_flag <= '1';
                    end if;
                end if;
            end process SOF_FLAG_PROCESS;

        m_axis_tuser(0) <= sof_flag;

    end generate GEN_SOF;

    -- Do not generate sof on tuser(0)
    GEN_NO_SOF : if C_MM2S_SOF_ENABLE = 0 generate
    begin
        sof_flag        <= '0';
        m_axis_tuser    <= (others => '0');
    end generate GEN_NO_SOF;


    -- 
    -- Register tvalid to break timing paths for use in
    -- psuedo fifo empty for channel idle generation and
    -- for xfer complete generation.
    REG_STRM_SIGS : process(s_axis_aclk)
        begin
            if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                if(s_axis_resetn = '0' or dm_halt = '1')then
                    m_axis_tvalid_d1        <= '0';
                    m_axis_tlast_d1         <= '0';
                    m_axis_tready_d1        <= '0';
                else
                    m_axis_tvalid_d1        <= s_axis_tvalid;
                    m_axis_tlast_d1         <= s_axis_tlast;
                    m_axis_tready_d1        <= m_axis_tready;
                end if;
            end if;
        end process REG_STRM_SIGS;

    -- 
    -- Psuedo FIFO, FIFO Pipe, and Skid Buffer are all empty.  This is used to safely
    -- assert reset on shutdown and also used to safely generate fsync in free-run mode
    -- This flag is looked at at the end of frames.
    -- Order of else-if is critical
    --  modified method to prevent double fsync assertions
    REG_PIPE_EMPTY : process(s_axis_aclk)
        begin
            if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                if(s_axis_resetn = '0' or dm_halt = '1')then
                    fifo_pipe_empty <= '1';

                -- Command/Status not idle indicates pending datamover commands
                -- set psuedo fifo empty to NOT empty.
                elsif(cmdsts_idle_fe = '1')then
                    fifo_pipe_empty <= '0';

                -- On accepted tlast then clear psuedo empty flag back to being empty
                elsif(pot_empty = '1' and cmdsts_idle = '1')then
                    fifo_pipe_empty <= '1';
                end if;
            end if;
        end process REG_PIPE_EMPTY;

    REG_IDLE_FE : process(s_axis_aclk)
        begin
            if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                if(s_axis_resetn = '0' or dm_halt = '1')then
                    cmdsts_idle_d1 <= '1';
                else
                    cmdsts_idle_d1 <= cmdsts_idle;
                end if;
            end if;
        end process REG_IDLE_FE;

    --  Use falling edge to set pfifo empty
    cmdsts_idle_fe  <= not cmdsts_idle and cmdsts_idle_d1;

    -- 
    POTENTIAL_EMPTY_PROCESS : process(s_axis_aclk)
        begin
            if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                if(s_axis_resetn = '0' or dm_halt = '1')then
                    pot_empty <= '1';
                elsif(m_axis_tvalid_d1 = '1' and m_axis_tlast_d1 = '1' and m_axis_tready_d1 = '1')then
                    pot_empty <= '1';
                elsif(m_axis_tvalid_d1 = '1' and m_axis_tlast_d1 = '0')then
                    pot_empty <= '0';
                end if;
            end if;
        end process POTENTIAL_EMPTY_PROCESS;

end generate GEN_NO_LINEBUFFER;


--*****************************************************************************--
--**                    MM2S ASYNCH CLOCK SUPPORT                            **--
--*****************************************************************************--
-- Cross fifo pipe empty flag to secondary clock domain
GEN_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin

    -- Pipe Empty and Shutdown reset CDC
----    SHUTDOWN_RST_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_P_S                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axis_aclk                              ,
----            prmry_resetn            => m_axis_resetn                            ,
----            scndry_aclk             => s_axis_aclk                              ,
----            scndry_resetn           => s_axis_resetn                            ,
----            scndry_in               => '0'                                      ,
----            prmry_out               => open                                     ,
----            prmry_in                => fifo_pipe_empty                          ,
----            scndry_out              => mm2s_fifo_pipe_empty_i                   ,
----            scndry_vect_s_h         => '0'                                      ,
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----            prmry_vect_out          => open                                     ,
----            prmry_vect_s_h          => '0'                                      ,
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----            scndry_vect_out         => open
----        );
----


SHUTDOWN_RST_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => fifo_pipe_empty, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => mm2s_fifo_pipe_empty_i,
        scndry_vect_out            => open
    );








ALL_LINES_XFRED_P_S_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => all_lines_xfred, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => mm2s_all_lines_xfred,
        scndry_vect_out            => open
    );









ALL_LINES_XFRED_S_P_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => dm_xfred_all_lines, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => dm_xfred_all_lines_reg,
        scndry_vect_out            => open
    );




VSIZE_CNT_CROSSING : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then

	   crnt_vsize_cdc_tig <= crnt_vsize;
	   crnt_vsize_d1      <= crnt_vsize_cdc_tig;

        end if;
    end process VSIZE_CNT_CROSSING;


	   crnt_vsize_d2 <= crnt_vsize_d1;



STOP_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => stop, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => stop_reg,
        scndry_vect_out            => open
    );



    -- Cross datamover halt and threshold signals
----    HALT_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_S_P                           ,
----            C_VECTOR_WIDTH          => 1 
----        )
----        port map (
----            prmry_aclk              => m_axis_aclk                              ,
----            prmry_resetn            => m_axis_resetn                            ,
----            scndry_aclk             => s_axis_aclk                              ,
----            scndry_resetn           => s_axis_resetn                            ,
----            scndry_in               => dm_halt                                  ,
----            prmry_out               => dm_halt_reg                              ,
----            prmry_in                => '0'                                      ,
----            scndry_out              => open                                     ,
----            scndry_vect_s_h         => '0'                                      ,
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)                  ,
----            prmry_vect_out          => open                   ,
----            prmry_vect_s_h          => '0'                                      ,
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0),
----            scndry_vect_out         => open
----        );
----

HALT_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => dm_halt, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => dm_halt_reg,
        scndry_vect_out            => open
    );






THRESH_CNT_CROSSING : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then

	   data_count_ae_threshold_cdc_tig <= data_count_ae_threshold;
	   data_count_ae_threshold_d1      <= data_count_ae_threshold_cdc_tig;

        end if;
    end process THRESH_CNT_CROSSING;


	   m_data_count_ae_thresh <= data_count_ae_threshold_d1;







end generate GEN_FOR_ASYNC;

--*****************************************************************************--
--**                    MM2S SYNCH CLOCK SUPPORT                             **--
--*****************************************************************************--
GEN_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin
    mm2s_fifo_pipe_empty_i      <= fifo_pipe_empty;
    crnt_vsize_d2               <= crnt_vsize;              -- 
    mm2s_all_lines_xfred        <= all_lines_xfred;         -- 
    dm_xfred_all_lines_reg      <= dm_xfred_all_lines;      -- 
    stop_reg                    <= stop;                    -- 
    dm_halt_reg                 <= dm_halt;
    m_data_count_ae_thresh      <= data_count_ae_threshold;

end generate GEN_FOR_SYNC;



--*****************************************************************************
--** Vertical Line Tracking (
--*****************************************************************************
-- Decrement vertical count with each accept tlast
decr_vcount <= '1' when m_axis_tlast_d1 = '1'
                    and m_axis_tvalid_d1 = '1'
                    and m_axis_tready_d1 = '1'
          else '0';


-- Drive ready at fsync out then de-assert once all lines have
-- been accepted.
VERT_COUNTER : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
            if(m_axis_fifo_ainit = '1' and fsync_out = '0')then
                vsize_counter       <= (others => '0');
                all_lines_xfred     <= '1';
            elsif(fsync_out = '1')then
                vsize_counter       <= crnt_vsize_d2;
                all_lines_xfred     <= '0';
            elsif(decr_vcount = '1' and vsize_counter = VSIZE_ONE_VALUE)then
                vsize_counter       <= (others => '0');
                all_lines_xfred     <= '1';

            elsif(decr_vcount = '1' and vsize_counter /= VSIZE_ZERO_VALUE)then
                vsize_counter       <= std_logic_vector(unsigned(vsize_counter) - 1);
                all_lines_xfred     <= '0';

            end if;
        end if;
    end process VERT_COUNTER;

-- Store and forward or no line buffer (
GEN_VCOUNT_FOR_SNF : if C_LINEBUFFER_DEPTH /= 0 and C_INCLUDE_MM2S_SF = 1 generate
begin
    dm_decr_vcount <= '1' when s_axis_tlast = '1'
                           and s_axis_tvalid = '1'
                           and s_axis_tready_i = '1'
              else '0';

    -- Delay 1 pipe to align with cnrt_vsize
    REG_FSYNC_TO_ALIGN : process(s_axis_aclk)
        begin
            if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                if(s_axis_fifo_ainit = '1' and frame_sync = '0')then
                    frame_sync_d1 <= '0';
                else
                    frame_sync_d1 <= frame_sync;
                end if;
            end if;
        end process REG_FSYNC_TO_ALIGN;

    -- Count lines to determine when datamover done.  Used for snf mode
    -- for threshold met (
    DM_DONE     : process(s_axis_aclk)
        begin
            if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                if(s_axis_fifo_ainit = '1')then
                    dm_vsize_counter        <= (others => '0');
                    dm_xfred_all_lines      <= '0';
                --elsif(fsync_out = '1')then     -- 
                elsif(frame_sync_d1 = '1')then     -- 
                    dm_vsize_counter       <= crnt_vsize;
                    dm_xfred_all_lines     <= '0';
                elsif(dm_decr_vcount = '1' and dm_vsize_counter = VSIZE_ONE_VALUE)then
                    dm_vsize_counter       <= (others => '0');
                    dm_xfred_all_lines     <= '1';

                elsif(dm_decr_vcount = '1' and dm_vsize_counter /= VSIZE_ZERO_VALUE)then
                    dm_vsize_counter       <= std_logic_vector(unsigned(dm_vsize_counter) - 1);
                    dm_xfred_all_lines     <= '0';

                end if;
            end if;
        end process DM_DONE;

end generate GEN_VCOUNT_FOR_SNF;

-- Not store and forward or no line buffer (
GEN_NO_VCOUNT_FOR_SNF : if C_LINEBUFFER_DEPTH = 0 or C_INCLUDE_MM2S_SF = 0 generate
begin
    dm_vsize_counter        <= (others => '0');
    dm_xfred_all_lines      <= '0';
    dm_decr_vcount          <= '0';
end generate GEN_NO_VCOUNT_FOR_SNF;


--*****************************************************************************--
--**                    SPECIAL RESET GENERATION                             **--
--*****************************************************************************--


-- Assert reset to skid buffer on hard reset or on shutdown when fifo pipe empty
-- Waiting for fifo_pipe_empty is required to prevent a AXIS protocol violation
-- when channel shut down early
REG_SKID_RESET : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
            if(m_axis_resetn = '0')then
                m_skid_reset <= '1';

            elsif(fifo_pipe_empty = '1')then
                if(fsync_out = '1' or dm_halt_reg = '1')then
                    m_skid_reset <= '1';
                else
                    m_skid_reset <= '0';
                end if;
            else
                m_skid_reset <= '0';
            end if;
        end if;
    end process REG_SKID_RESET;

-- Fifo/logic reset for slave side clock domain (m_axi_mm2s_aclk)
-- If error (dm_halt=1) then halt immediatly without protocol violation
s_axis_fifo_ainit <= '1' when s_axis_resetn = '0'
                           or frame_sync = '1'          -- Frame sync
                           or dm_halt = '1'             -- Datamover being halted (halt due to error)
                else '0';

-- Fifo/logic reset for master side clock domain (m_axis_mm2s_aclk)
m_axis_fifo_ainit <= '1' when m_axis_resetn = '0'
                           or fsync_out = '1'           -- Frame sync
                           or dm_halt_reg = '1'         -- Datamover being halted
                else '0';




-- Fifo/logic reset for slave side clock domain (m_axi_mm2s_aclk)
-- If error (dm_halt=1) then halt immediatly without protocol violation
s_axis_fifo_ainit_nosync <= '1' when s_axis_resetn = '0'
                           or dm_halt = '1'             -- Datamover being halted (halt due to error)
                else '0';


        process(s_axis_aclk)
            begin
                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                        s_axis_fifo_ainit_nosync_reg <= s_axis_fifo_ainit_nosync;
                end if;
            end process ;




-- Fifo/logic reset for master side clock domain (m_axis_mm2s_aclk)
m_axis_fifo_ainit_nosync <= '1' when m_axis_resetn = '0'
                           or dm_halt_reg = '1'         -- Datamover being halted
                else '0';





--reset for axis_dwidth

mm2s_axis_linebuf_reset_out_inv <= m_axis_fifo_ainit_nosync;
mm2s_axis_linebuf_reset_out <= not (mm2s_axis_linebuf_reset_out_inv);



MM2S_DWIDTH_CONV_IS : if (C_DATA_WIDTH /=  C_M_AXIS_MM2S_TDATA_WIDTH) generate
  begin


fifo_pipe_empty <= dwidth_fifo_pipe_empty;
dwidth_fifo_pipe_empty_m <= mm2s_fifo_pipe_empty_i;

 end generate MM2S_DWIDTH_CONV_IS;


  MM2S_DWIDTH_CONV_IS_NOT : if (C_DATA_WIDTH =  C_M_AXIS_MM2S_TDATA_WIDTH) generate
  begin



    fifo_pipe_empty <= '1' when (all_lines_xfred = '1' and m_axis_tvalid_out = '0') -- All data for frame transmitted
                            or  (sf_threshold_met = '0'              -- Or Threshold not met
                                and stop_reg = '1'                   -- Commanded to stop
                                and m_axis_tvalid_out = '0')         -- And NOT driving tvalid
                  else '0';

dwidth_fifo_pipe_empty_m <= '1';

  end generate MM2S_DWIDTH_CONV_IS_NOT;


mm2s_all_lines_xfred_s 	     <= '0';
fsync_out_m                  <= '0';                    
mm2s_vsize_cntr_clr_flag     <= '0';                    
mm2s_fsize_mismatch_err_m    <= '0';                    


end generate GEN_LINEBUF_NO_SOF;

    GEN_LINEBUF_FLUSH_SOF : if (ENABLE_FLUSH_ON_FSYNC = 1 and C_MM2S_SOF_ENABLE = 1) generate

	signal s2mm_fsync_mm2s_s 		: std_logic 			:= '0';
	signal run_stop_reg                  	: std_logic 			:= '0';
	signal fsync_out_d1                  	: std_logic 			:= '0';
	signal mm2s_fsync_int 			: std_logic 			:= '0';
	signal fsize_mismatch_err_int_s 	: std_logic 			:= '0';
	signal fsize_mismatch_err_int_m 	: std_logic 			:= '0';
	signal fsize_mismatch_err_flag_s 	: std_logic 			:= '0';
	signal fsize_mismatch_err_flag_vsize_cntr_clr 	: std_logic 		:= '0';
	signal fsize_mismatch_err_flag_cmb_s 	: std_logic 			:= '0';
	signal fsync_src_select_cdc_tig 	: std_logic_vector(1 downto 0) 	:= (others => '0');
	signal fsync_src_select_d1       	: std_logic_vector(1 downto 0) 	:= (others => '0');
	signal fsync_src_select_s_int 		: std_logic_vector(1 downto 0) 	:= (others => '0');
	signal fsize_err_to_dm_halt_flag 	: std_logic 			:= '0';
	signal fsize_err_to_dm_halt_flag_ored 	: std_logic 			:= '0';
	signal delay_fsync_fsize_err_till_dm_halt_cmplt_pulse_s : std_logic 	:= '0';
	signal delay_fsync_fsize_err_till_dm_halt_cmplt_flag_s 	: std_logic 	:= '0';
	signal delay_fsync_fsize_err_till_dm_halt_cmplt_s_d1 	: std_logic 	:= '0';
	signal d_fsync_halt_cmplt_s 		: std_logic 			:= '0';

  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF fsync_src_select_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF fsync_src_select_d1       : SIGNAL IS "true"; 


    begin






--*****************************************************************************--
--**              LINE BUFFER MODE (Sync or Async)                           **--
--*****************************************************************************--
GEN_LINEBUFFER : if C_LINEBUFFER_DEPTH /= 0 generate
begin

    -- Divide by number bytes per data beat and add padding to dynamic
    -- threshold setting
    data_count_ae_threshold <= linebuf_threshold((DATACOUNT_WIDTH-1) + THRESHOLD_LSB_INDEX
                                            downto THRESHOLD_LSB_INDEX);

    -- Synchronous clock therefore instantiate an Asynchronous FIFO

    GEN_SYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
    begin
                
      
        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_sfifo
            generic map(
                 UW_DATA_WIDTH     => BUFFER_WIDTH        ,
          C_FULL_FLAGS_RST_VAL     => 1        ,
                 UW_FIFO_DEPTH     => BUFFER_DEPTH        ,
                 C_FAMILY          => C_FAMILY
            )
            port map(
                -- Inputs
                 rst               => s_axis_fifo_ainit_nosync   ,
                 sleep             => '0'         ,
                 wr_rst_busy       => wr_rst_busy_sig         ,
                 rd_rst_busy       => rd_rst_busy_sig         ,
                 clk               => s_axis_aclk         ,
                 wr_en             => fifo_wren           ,
                 din               => fifo_din            ,
                 rd_en             => fifo_rden           ,

                -- Outputs
                 dout              => fifo_dout           ,
                 full              => fifo_full_i         ,
                 empty             => fifo_empty_i        ,
                 data_count        => fifo_rdcount  
            );

--wr_rst_busy_sig <= '0';
--rd_rst_busy_sig <= '0';
    end generate GEN_SYNC_FIFO;

    -- Asynchronous clock therefore instantiate an Asynchronous FIFO

    GEN_ASYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
    begin


LB_BRAM : if ( (C_ENABLE_DEBUG_INFO_1 = 1 or C_ENABLE_DEBUG_ALL = 1) )
  generate   
    begin

        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_afifo
            generic map(
                 UW_DATA_WIDTH   => BUFFER_WIDTH                    ,
          C_FULL_FLAGS_RST_VAL   => 1        ,
                 UW_FIFO_DEPTH   => BUFFER_DEPTH                    ,
                 C_FAMILY        => C_FAMILY
            )
            port map(
                -- Inputs
                 rst             => s_axis_fifo_ainit_nosync_reg    ,
                 sleep           => '0'         ,
                 wr_rst_busy     => open         ,
                 rd_rst_busy     => open         ,
                 wr_clk          => s_axis_aclk          ,
                 wr_en           => fifo_wren            ,
                 din             => fifo_din             ,
                 rd_clk          => m_axis_aclk          ,
                 rd_en           => fifo_rden            ,

                -- Outputs
                 dout            => fifo_dout            ,
                 full            => fifo_full_i          ,
                 empty           => fifo_empty_i         ,
                 wr_data_count   => open         , --
                 rd_data_count   => fifo_rdcount         
            );

wr_rst_busy_sig <= '0';
rd_rst_busy_sig <= '0';

end generate LB_BRAM;                     


      
LB_BUILT_IN : if ( (C_ENABLE_DEBUG_INFO_1 = 0 and C_ENABLE_DEBUG_ALL = 0) )
  generate   
    begin

        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_afifo_builtin
            generic map(
                 PL_FIFO_TYPE    => "BUILT_IN"                    ,
                 PL_READ_MODE    => "FWFT"                    ,
                 PL_FASTER_CLOCK => "WR_CLK"                    , --RD_CLK
                 PL_FULL_FLAGS_RST_VAL => 0                     , -- ?
                 PL_DATA_WIDTH   => BUFFER_WIDTH                    ,
                 C_FAMILY        => C_FAMILY ,
                 PL_FIFO_DEPTH   => BUFFER_DEPTH                    
            )
            port map(
                -- Inputs
                 rst             => s_axis_fifo_ainit_nosync_reg    ,
                 sleep           => '0'         ,
                 wr_rst_busy     => wr_rst_busy_sig         ,
                 rd_rst_busy     => rd_rst_busy_sig         ,
                 wr_clk          => s_axis_aclk          ,
                 wr_en           => fifo_wren            ,
                 din             => fifo_din             ,
                 rd_clk          => m_axis_aclk          ,
                 rd_en           => fifo_rden            ,

                -- Outputs
                 dout            => fifo_dout            ,
                 full            => fifo_full_i          ,
                 empty           => fifo_empty_i         
            );


end generate LB_BUILT_IN;                     

     end generate GEN_ASYNC_FIFO;




    -- Generate an SOF on tuser(0). currently vdma only support 1 tuser bit that is set by
    -- frame sync and driven out on first data beat of mm2s packet.
------    GEN_SOF : if C_MM2S_SOF_ENABLE = 1 generate
------    signal sof_reset : std_logic := '0';
------    begin
        sof_reset   <= '1' when (s_axis_resetn = '0')
                             or (dm_halt = '1')
                  else '0';

        -- On frame sync set flag and then clear flag when
        -- sof written to fifo.
        SOF_FLAG_PROCESS : process(s_axis_aclk)
            begin
                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                    if(sof_reset = '1' or fifo_wren = '1')then
                        sof_flag <= '0';
                    elsif(frame_sync = '1')then
                        sof_flag <= '1';
                    end if;
                end if;
            end process SOF_FLAG_PROCESS;

   GEN_MM2S_DRE_ENABLED_TKEEP : if C_INCLUDE_MM2S_DRE = 1 generate
   begin
        -- AXI Slave Side of FIFO
        fifo_din            <= sof_flag & s_axis_tlast & s_axis_tkeep_signal & s_axis_tdata;
       fifo_wren            <= s_axis_tvalid and s_axis_tready_i;
       s_axis_tready_i      <= not fifo_full_i and not wr_rst_busy_sig and not s_axis_fifo_ainit;
        s_axis_tready       <= s_axis_tready_i; -- 

        -- AXI Master Side of FIFO
        fifo_rden           <= m_axis_tready_i and m_axis_tvalid_i;
        m_axis_tvalid_i     <= not fifo_empty_i and not rd_rst_busy_sig and sf_threshold_met;
        m_axis_tdata_i      <= fifo_dout(C_DATA_WIDTH-1 downto 0);
        m_axis_tkeep_i      <= fifo_dout(BUFFER_WIDTH-3 downto (BUFFER_WIDTH-3) - (C_DATA_WIDTH/8) + 1);
        m_axis_tlast_i      <= fifo_dout(BUFFER_WIDTH-2);
        m_axis_tuser_i(0)   <= fifo_dout(BUFFER_WIDTH-1);

   end generate GEN_MM2S_DRE_ENABLED_TKEEP;

   GEN_NO_MM2S_DRE_DISABLE_TKEEP : if C_INCLUDE_MM2S_DRE = 0 generate
   begin
        -- AXI Slave Side of FIFO
        fifo_din            <= sof_flag & s_axis_tlast  & s_axis_tdata;
       fifo_wren            <= s_axis_tvalid and s_axis_tready_i;
       s_axis_tready_i      <= not fifo_full_i and not wr_rst_busy_sig and not s_axis_fifo_ainit;
        s_axis_tready       <= s_axis_tready_i; -- 

        -- AXI Master Side of FIFO
        fifo_rden           <= m_axis_tready_i and m_axis_tvalid_i;
        m_axis_tvalid_i     <= not fifo_empty_i and not rd_rst_busy_sig and sf_threshold_met;
        m_axis_tdata_i      <= fifo_dout(C_DATA_WIDTH-1 downto 0);
        m_axis_tkeep_i      <= (others => '1');
        m_axis_tlast_i      <= fifo_dout(BUFFER_WIDTH-2);
        m_axis_tuser_i(0)   <= fifo_dout(BUFFER_WIDTH-1);

   end generate GEN_NO_MM2S_DRE_DISABLE_TKEEP;

------    end generate GEN_SOF;
------
------
    -- SOF turned off therefore do not generate SOF on tuser
----------    GEN_NO_SOF : if C_MM2S_SOF_ENABLE = 0 generate
----------    begin
----------
----------        sof_flag <= '0';
----------
----------        -- AXI Slave Side of FIFO
----------        fifo_din            <= s_axis_tlast & s_axis_tkeep & s_axis_tdata;
----------        fifo_wren           <= s_axis_tvalid and not fifo_full_i and not s_axis_fifo_ainit;
----------        s_axis_tready_i     <= not fifo_full_i and not s_axis_fifo_ainit;
----------        s_axis_tready       <= s_axis_tready_i; -- 
----------
----------        -- AXI Master Side of FIFO
----------        fifo_rden           <= m_axis_tready_i and not fifo_empty_i and sf_threshold_met;
----------        m_axis_tvalid_i     <= not fifo_empty_i and sf_threshold_met;
----------        m_axis_tdata_i      <= fifo_dout(C_DATA_WIDTH-1 downto 0);
----------        m_axis_tkeep_i      <= fifo_dout(BUFFER_WIDTH-2 downto (BUFFER_WIDTH-2) - (C_DATA_WIDTH/8) + 1);
----------        m_axis_tlast_i      <= not fifo_empty_i and fifo_dout(BUFFER_WIDTH-1);
----------        m_axis_tuser_i      <= (others => '0');
----------
----------    end generate GEN_NO_SOF;

    -- Top level line buffer depth not equal to zero therefore gererate threshold
    -- flags. (
    GEN_THRESHOLD_ENABLED : if C_TOPLVL_LINEBUFFER_DEPTH /= 0  and (C_ENABLE_DEBUG_INFO_1 = 1 or C_ENABLE_DEBUG_ALL = 1)  generate
    begin

        -- Almost empty flag (note: asserts when empty also)

    
      
        REG_ALMST_EMPTY : process(m_axis_aclk)
            begin
                if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
                    if(m_axis_fifo_ainit = '1')then
                        fifo_almost_empty_reg <= '1';
                    --elsif(fifo_rdcount(DATACOUNT_WIDTH-1 downto 0) <= DATA_COUNT_AE_THRESHOLD or fifo_empty_i = '1')then
                    --elsif((fifo_rdcount(DATACOUNT_WIDTH-1 downto 0) <= m_data_count_ae_thresh
                    --  or fifo_empty_i = '1') and fifo_full_i = '0')then
                    elsif((fifo_rdcount(DATACOUNT_WIDTH-1 downto 0) <= m_data_count_ae_thresh
                      or (fifo_empty_i = '1' or rd_rst_busy_sig = '1')))then
                        fifo_almost_empty_reg <= '1';
                    else
                        fifo_almost_empty_reg <= '0';
                    end if;
                end if;
            end process REG_ALMST_EMPTY;


        mm2s_fifo_almost_empty  <= fifo_almost_empty_reg
                                or (not sf_threshold_met) -- 
                                or (not m_axis_tvalid_out); -- 

        mm2s_fifo_empty         <= not m_axis_tvalid_out;
    end generate GEN_THRESHOLD_ENABLED;

    -- Top level line buffer depth is zero therefore turn off threshold logic.
    -- this occurs for async operation where the async fifo is needed for CDC (
    GEN_THRESHOLD_DISABLED  : if C_TOPLVL_LINEBUFFER_DEPTH = 0  or (C_ENABLE_DEBUG_INFO_1 = 0 and C_ENABLE_DEBUG_ALL = 0)  generate
    begin
        mm2s_fifo_empty             <= '0';
        mm2s_fifo_almost_empty      <= '0';
        fifo_almost_empty_reg       <= '0';
    end generate GEN_THRESHOLD_DISABLED;

    -- 
    -- FIFO, FIFO Pipe, and Skid Buffer are all empty.  This is used to safely
    -- assert reset on shutdown and also used to safely generate fsync in free-run mode
    --  need to look at write side of fifo to prevent false empties due to async fifo
    --fifo_pipe_empty <= '1' when (fifo_wrcount(DATACOUNT_WIDTH-1 downto 0) = DATA_COUNT_ZERO -- Data count is 0
    --                                and m_axis_tvalid_out = '0')                            -- Skid Buffer is done
    --                        -- Forced stop and Threshold not met ()
    --                        or  (sf_threshold_met = '0' and stop_reg = '1')
    --              else '0';
    --  fixed flase fifo_pipe_assertions due to extreme AXI4 throttling on
    -- mm2s reads causing fifo to go empty for extended periods of time.  This then
    -- caused flase idles to be flagged and frame syncs were then generated in free run mode
----------------    fifo_pipe_empty <= '1' when (all_lines_xfred = '1' and m_axis_tvalid_out = '0') -- All data for frame transmitted
----------------                            or  (sf_threshold_met = '0'              -- Or Threshold not met
----------------                                and stop_reg = '1'                   -- Commanded to stop
----------------                                and m_axis_tvalid_out = '0')         -- And NOT driving tvalid
----------------                  else '0';
----------------

    -- If store and forward is turned on by user then gate tvalid with
    -- threshold met
    GEN_THRESH_MET_FOR_SNF : if C_INCLUDE_MM2S_SF = 1 and C_TOPLVL_LINEBUFFER_DEPTH /= 0 and (C_ENABLE_DEBUG_INFO_1 = 1 or C_ENABLE_DEBUG_ALL = 1)  generate
    begin
            -- Register fifo_almost empty in order to generate
            -- almost empty fall edge pulse
            REG_ALMST_EMPTY_FE : process(m_axis_aclk)
                begin
                    if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
                        if(m_axis_fifo_ainit = '1')then
                            fifo_almost_empty_d1 <= '1';
                        else
                            fifo_almost_empty_d1 <= fifo_almost_empty_reg;
                        end if;
                    end if;
                end process REG_ALMST_EMPTY_FE;

            -- Almost empty falling edge
            fifo_almost_empty_fe <= not fifo_almost_empty_reg and fifo_almost_empty_d1;

            -- Store and Forward threshold met
            THRESH_MET : process(m_axis_aclk)
                begin
                    if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
                        if(m_axis_fifo_ainit = '1')then
                            sf_threshold_met <= '0';
                        elsif(fsync_out = '1')then
                            sf_threshold_met <= '0';
                        -- Reached threshold or all reads done for the frame
                        elsif(fifo_almost_empty_fe = '1'
                          or (dm_xfred_all_lines_reg = '1'))then
                            sf_threshold_met <= '1';
                        end if;
                    end if;
                end process THRESH_MET;

    end generate GEN_THRESH_MET_FOR_SNF;

    -- Store and forward off therefore do not need to meet threshold
    GEN_NO_THRESH_MET_FOR_SNF : if C_INCLUDE_MM2S_SF = 0 or C_TOPLVL_LINEBUFFER_DEPTH = 0  or (C_ENABLE_DEBUG_INFO_1 = 0 and C_ENABLE_DEBUG_ALL = 0)  generate
    begin
        sf_threshold_met <= '1';
    end generate GEN_NO_THRESH_MET_FOR_SNF;


    --*********************************************************--
    --**               MM2S MASTER SKID BUFFER               **--
    --*********************************************************--
    I_MSTR_SKID : entity axi_vdma_v6_3_10.axi_vdma_skid_buf
        generic map(
            C_WDATA_WIDTH           => C_DATA_WIDTH             ,
            C_TUSER_WIDTH           => C_M_AXIS_MM2S_TUSER_BITS
        )
        port map(
            -- System Ports
            ACLK                   => m_axis_aclk               ,
            ARST                   => m_axis_fifo_ainit_nosync              ,

            -- Shutdown control (assert for 1 clk pulse)
            skid_stop              => '0'                       ,

            -- Slave Side (Stream Data Input)
            S_VALID                => m_axis_tvalid_i           ,
            S_READY                => m_axis_tready_i           ,
            S_Data                 => m_axis_tdata_i            ,
            S_STRB                 => m_axis_tkeep_i            ,
            S_Last                 => m_axis_tlast_i            ,
            S_User                 => m_axis_tuser_i            ,

            -- Master Side (Stream Data Output)
            M_VALID                => m_axis_tvalid_out         ,
            M_READY                => m_axis_tready             ,
            M_Data                 => m_axis_tdata              ,
            M_STRB                 => m_axis_tkeep_signal              ,
            M_Last                 => m_axis_tlast_out          ,
            M_User                 => m_axis_tuser
        );

    -- Pass out of core
    m_axis_tvalid   <= m_axis_tvalid_out;
    m_axis_tlast    <= m_axis_tlast_out;

    -- Register to break long timing paths for use in
    -- transfer complete generation
    REG_STRM_SIGS : process(m_axis_aclk)
        begin
            if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
                if(m_axis_fifo_ainit = '1')then
                    m_axis_tlast_d1     <= '0';
                    m_axis_tvalid_d1    <= '0';
                    m_axis_tready_d1    <= '0';
                else
                    m_axis_tlast_d1     <= m_axis_tlast_out;
                    m_axis_tvalid_d1    <= m_axis_tvalid_out;
                    m_axis_tready_d1    <= m_axis_tready;
                end if;
            end if;
        end process REG_STRM_SIGS;



end generate GEN_LINEBUFFER;

--*****************************************************************************--
--**               NO LINE BUFFER MODE (Sync Only)                           **--
--*****************************************************************************--
-- LineBuffer forced on if asynchronous mode is enabled
GEN_NO_LINEBUFFER : if (C_LINEBUFFER_DEPTH = 0) generate     -- No Line Buffer
begin

    -- Map Datamover to AXIS Master Out
    m_axis_tdata        <= s_axis_tdata;
    m_axis_tkeep_signal <= s_axis_tkeep_signal;
    m_axis_tvalid       <= s_axis_tvalid;
    m_axis_tlast        <= s_axis_tlast;

    s_axis_tready       <= m_axis_tready;

    -- Tie FIFO Flags off
    mm2s_fifo_empty          <= '0';
    mm2s_fifo_almost_empty   <= '0';


    -- Generate sof on tuser(0)
----    GEN_SOF : if C_MM2S_SOF_ENABLE = 1 generate
---    begin
        -- On frame sync set flag and then clear flag when
        -- sof written to fifo.
        SOF_FLAG_PROCESS : process(s_axis_aclk)
            begin
                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                    if(s_axis_fifo_ainit = '1' or (s_axis_tvalid = '1' and m_axis_tready = '1'))then
                        sof_flag <= '0';
                    elsif(frame_sync = '1')then
                        sof_flag <= '1';
                    end if;
                end if;
            end process SOF_FLAG_PROCESS;

        m_axis_tuser(0) <= sof_flag;

---    end generate GEN_SOF;

    -- Do not generate sof on tuser(0)
-----    GEN_NO_SOF : if C_MM2S_SOF_ENABLE = 0 generate
-----    begin
-----        sof_flag        <= '0';
-----        m_axis_tuser    <= (others => '0');
-----    end generate GEN_NO_SOF;


    -- 
    -- Register tvalid to break timing paths for use in
    -- psuedo fifo empty for channel idle generation and
    -- for xfer complete generation.
    REG_STRM_SIGS : process(s_axis_aclk)
        begin
            if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                if(s_axis_resetn = '0' or dm_halt = '1')then
                    m_axis_tvalid_d1        <= '0';
                    m_axis_tlast_d1         <= '0';
                    m_axis_tready_d1        <= '0';
                else
                    m_axis_tvalid_d1        <= s_axis_tvalid;
                    m_axis_tlast_d1         <= s_axis_tlast;
                    m_axis_tready_d1        <= m_axis_tready;
                end if;
            end if;
        end process REG_STRM_SIGS;

    -- 
    -- Psuedo FIFO, FIFO Pipe, and Skid Buffer are all empty.  This is used to safely
    -- assert reset on shutdown and also used to safely generate fsync in free-run mode
    -- This flag is looked at at the end of frames.
    -- Order of else-if is critical
    -- modified method to prevent double fsync assertions
    REG_PIPE_EMPTY : process(s_axis_aclk)
        begin
            if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                if(s_axis_resetn = '0' or dm_halt = '1')then
                    fifo_pipe_empty <= '1';

                -- Command/Status not idle indicates pending datamover commands
                -- set psuedo fifo empty to NOT empty.
                elsif(cmdsts_idle_fe = '1')then
                    fifo_pipe_empty <= '0';

                -- On accepted tlast then clear psuedo empty flag back to being empty
                elsif(pot_empty = '1' and cmdsts_idle = '1')then
                    fifo_pipe_empty <= '1';
                end if;
            end if;
        end process REG_PIPE_EMPTY;

    REG_IDLE_FE : process(s_axis_aclk)
        begin
            if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                if(s_axis_resetn = '0' or dm_halt = '1')then
                    cmdsts_idle_d1 <= '1';
                else
                    cmdsts_idle_d1 <= cmdsts_idle;
                end if;
            end if;
        end process REG_IDLE_FE;

    -- Use falling edge to set pfifo empty
    cmdsts_idle_fe  <= not cmdsts_idle and cmdsts_idle_d1;

    -- 
    POTENTIAL_EMPTY_PROCESS : process(s_axis_aclk)
        begin
            if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                if(s_axis_resetn = '0' or dm_halt = '1')then
                    pot_empty <= '1';
                elsif(m_axis_tvalid_d1 = '1' and m_axis_tlast_d1 = '1' and m_axis_tready_d1 = '1')then
                    pot_empty <= '1';
                elsif(m_axis_tvalid_d1 = '1' and m_axis_tlast_d1 = '0')then
                    pot_empty <= '0';
                end if;
            end if;
        end process POTENTIAL_EMPTY_PROCESS;

end generate GEN_NO_LINEBUFFER;


--*****************************************************************************--
--**                    MM2S ASYNCH CLOCK SUPPORT                            **--
--*****************************************************************************--
-- Cross fifo pipe empty flag to secondary clock domain
GEN_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin

    -- Pipe Empty and Shutdown reset CDC
----    SHUTDOWN_RST_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_P_S                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axis_aclk                              ,
----            prmry_resetn            => m_axis_resetn                            ,
----            scndry_aclk             => s_axis_aclk                              ,
----            scndry_resetn           => s_axis_resetn                            ,
----            scndry_in               => '0'                                      ,
----            prmry_out               => open                                     ,
----            prmry_in                => fifo_pipe_empty                          ,
----            scndry_out              => mm2s_fifo_pipe_empty_i                   ,
----            scndry_vect_s_h         => '0'                                      ,
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----            prmry_vect_out          => open                                     ,
----            prmry_vect_s_h          => '0'                                      ,
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----            scndry_vect_out         => open
----        );
----


SHUTDOWN_RST_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => fifo_pipe_empty, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => mm2s_fifo_pipe_empty_i,
        scndry_vect_out            => open
    );








ALL_LINES_XFRED_P_S_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => all_lines_xfred, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => mm2s_all_lines_xfred,
        scndry_vect_out            => open
    );









ALL_LINES_XFRED_S_P_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => dm_xfred_all_lines, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => dm_xfred_all_lines_reg,
        scndry_vect_out            => open
    );





VSIZE_CNT_CROSSING : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then

	   crnt_vsize_cdc_tig <= crnt_vsize;
	   crnt_vsize_d1      <= crnt_vsize_cdc_tig;

        end if;
    end process VSIZE_CNT_CROSSING;


	   crnt_vsize_d2 <= crnt_vsize_d1;









    -- Cross stop signal  (
----    STOP_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_S_P                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axis_aclk                              ,
----            prmry_resetn            => m_axis_resetn                            ,
----            scndry_aclk             => s_axis_aclk                              ,
----            scndry_resetn           => s_axis_resetn                            ,
----            scndry_in               => stop                                     ,
----            prmry_out               => stop_reg                                 ,
----            prmry_in                => '0'                                      ,
----            scndry_out              => open                                     ,
----            scndry_vect_s_h         => '0'                                      ,
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----            prmry_vect_out          => open                                     ,
----            prmry_vect_s_h          => '0'                                      ,
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----            scndry_vect_out         => open
----        );

STOP_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => stop, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => stop_reg,
        scndry_vect_out            => open
    );






----    MM2S_RUN_STOP_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_S_P                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axis_aclk                              ,
----            prmry_resetn            => m_axis_resetn                            ,
----            scndry_aclk             => s_axis_aclk                              ,
----            scndry_resetn           => s_axis_resetn                            ,
----            scndry_in               => run_stop                                     ,
----            prmry_out               => run_stop_reg                                 ,
----            prmry_in                => '0'                                      ,
----            scndry_out              => open                                     ,
----            scndry_vect_s_h         => '0'                                      ,
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----            prmry_vect_out          => open                                     ,
----            prmry_vect_s_h          => '0'                                      ,
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----            scndry_vect_out         => open
----        );


MM2S_RUN_STOP_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => run_stop, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => run_stop_reg,
        scndry_vect_out            => open
    );









----    MM2S_FSIZE_ERR_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_PULSE_P_S_OPEN_ENDED                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axis_aclk                              ,
----            prmry_resetn            => m_axis_resetn                            ,
----            scndry_aclk             => s_axis_aclk                              ,
----            scndry_resetn           => s_axis_resetn                            ,
----            scndry_in               => '0'                                     ,
----            prmry_out               => open                                 ,
----            prmry_in                => fsize_mismatch_err_int_s                                      ,
----            scndry_out              => fsize_mismatch_err_int_m                                     ,
----            scndry_vect_s_h         => '0'                                      ,
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----            prmry_vect_out          => open                                     ,
----            prmry_vect_s_h          => '0'                                      ,
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----            scndry_vect_out         => open
----        );
----



MM2S_FSIZE_ERR_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => fsize_mismatch_err_int_s, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => fsize_mismatch_err_int_m,
        scndry_vect_out            => open
    );






----    MM2S_FSYNC_OUT_CDC_I_FLUSH_SOF : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_PULSE_P_S_OPEN_ENDED                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axis_aclk                               ,
----            prmry_resetn            => m_axis_resetn                             ,
----            scndry_aclk             => s_axis_aclk                              ,
----            scndry_resetn           => s_axis_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => fsync_out                         ,
----            scndry_out              =>  fsync_out_m                         ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----


MM2S_FSYNC_OUT_CDC_I_FLUSH_SOF : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => fsync_out, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => fsync_out_m,
        scndry_vect_out            => open
    );





GEN_FSYNC_SEL_CROSSING : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then

		fsync_src_select_cdc_tig <= fsync_src_select;
		fsync_src_select_d1      <= fsync_src_select_cdc_tig;

        end if;
    end process GEN_FSYNC_SEL_CROSSING;


fsync_src_select_s_int <= fsync_src_select_d1;



    -- Cross datamover halt and threshold signals
----    HALT_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_S_P                           ,
----            C_VECTOR_WIDTH          => 1 
----        )
----        port map (
----            prmry_aclk              => m_axis_aclk                              ,
----            prmry_resetn            => m_axis_resetn                            ,
----            scndry_aclk             => s_axis_aclk                              ,
----            scndry_resetn           => s_axis_resetn                            ,
----            scndry_in               => dm_halt                                  ,
----            prmry_out               => dm_halt_reg                              ,
----            prmry_in                => '0'                                      ,
----            scndry_out              => open                                     ,
----            scndry_vect_s_h         => '0'                                      ,
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)                  ,
----            prmry_vect_out          => open                   ,
----            prmry_vect_s_h          => '0'                                      ,
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0),
----            scndry_vect_out         => open
----        );
----


HALT_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => dm_halt, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => dm_halt_reg,
        scndry_vect_out            => open
    );






THRESH_CNT_CROSSING : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then

	   data_count_ae_threshold_cdc_tig <= data_count_ae_threshold;
	   data_count_ae_threshold_d1      <= data_count_ae_threshold_cdc_tig;

        end if;
    end process THRESH_CNT_CROSSING;


	   m_data_count_ae_thresh <= data_count_ae_threshold_d1;






GEN_ASYNC_CROSS_FSYNC : if C_INCLUDE_S2MM = 1 generate
begin


----    CROSS_FSYNC_CDC_I_FLUSH_MM2S_SOF : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_PULSE_P_S_OPEN_ENDED                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => s_axis_s2mm_aclk                               ,
----            prmry_resetn            => s2mm_axis_resetn                             ,
----            scndry_aclk             => m_axis_aclk                              ,
----            scndry_resetn           => m_axis_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => s2mm_fsync                         ,
----            scndry_out              => s2mm_fsync_mm2s_s                          ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----



CROSS_FSYNC_CDC_I_FLUSH_MM2S_SOF : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_s2mm_aclk,
        prmry_resetn               => s2mm_axis_resetn, 
        prmry_in                   => s2mm_fsync, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => s2mm_fsync_mm2s_s,
        scndry_vect_out            => open
    );







end generate GEN_ASYNC_CROSS_FSYNC;

GEN_ASYNC_NO_CROSS_FSYNC : if C_INCLUDE_S2MM = 0 generate
begin

s2mm_fsync_mm2s_s <= '0';

end generate GEN_ASYNC_NO_CROSS_FSYNC;





end generate GEN_FOR_ASYNC;

--*****************************************************************************--
--**                    MM2S SYNCH CLOCK SUPPORT                             **--
--*****************************************************************************--
GEN_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin
    mm2s_fifo_pipe_empty_i      <= fifo_pipe_empty;
    crnt_vsize_d2               <= crnt_vsize;              -- 
    mm2s_all_lines_xfred        <= all_lines_xfred;         -- 
    dm_xfred_all_lines_reg      <= dm_xfred_all_lines;      -- 
    stop_reg                    <= stop;                    -- 
    run_stop_reg                <= run_stop;                   
    fsync_out_m                 <= fsync_out;                  
    dm_halt_reg                 <= dm_halt;
    m_data_count_ae_thresh      <= data_count_ae_threshold;
    fsync_src_select_s_int      <= fsync_src_select;
    fsize_mismatch_err_int_m    <= fsize_mismatch_err_int_s;


GEN_SYNC_CROSS_FSYNC : if C_INCLUDE_S2MM = 1 generate
begin

    s2mm_fsync_mm2s_s           <= s2mm_fsync;

end generate GEN_SYNC_CROSS_FSYNC;

GEN_SYNC_NO_CROSS_FSYNC : if C_INCLUDE_S2MM = 0 generate
begin

s2mm_fsync_mm2s_s <= '0';

end generate GEN_SYNC_NO_CROSS_FSYNC;

end generate GEN_FOR_SYNC;


NO_DWIDTH_VERT_COUNTER : if (C_DATA_WIDTH =  C_M_AXIS_MM2S_TDATA_WIDTH) generate
  begin



--*****************************************************************************
--** Vertical Line Tracking (
--*****************************************************************************
-- Decrement vertical count with each accept tlast
decr_vcount <= '1' when m_axis_tlast_d1 = '1'
                    and m_axis_tvalid_d1 = '1'
                    and m_axis_tready_d1 = '1'
          else '0';


-- Drive ready at fsync out then de-assert once all lines have
-- been accepted.
VERT_COUNTER : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
            if((m_axis_fifo_ainit = '1' and fsync_out = '0') or fsize_mismatch_err_flag_vsize_cntr_clr = '1' )then
                vsize_counter       <= (others => '0');
                all_lines_xfred_no_dwidth     <= '1';
            elsif(fsync_out = '1')then
                vsize_counter       <= crnt_vsize_d2;
                all_lines_xfred_no_dwidth     <= '0';
            elsif(decr_vcount = '1' and vsize_counter = VSIZE_ONE_VALUE)then
                vsize_counter       <= (others => '0');
                all_lines_xfred_no_dwidth     <= '1';

            elsif(decr_vcount = '1' and vsize_counter /= VSIZE_ZERO_VALUE)then
                vsize_counter       <= std_logic_vector(unsigned(vsize_counter) - 1);
                all_lines_xfred_no_dwidth     <= '0';

            end if;
        end if;
    end process VERT_COUNTER;




  end generate NO_DWIDTH_VERT_COUNTER;




-- Store and forward or no line buffer (
GEN_VCOUNT_FOR_SNF : if C_LINEBUFFER_DEPTH /= 0 and C_INCLUDE_MM2S_SF = 1 generate
begin
    dm_decr_vcount <= '1' when s_axis_tlast = '1'
                           and s_axis_tvalid = '1'
                           and s_axis_tready_i = '1'
              else '0';

    -- Delay 1 pipe to align with cnrt_vsize
    REG_FSYNC_TO_ALIGN : process(s_axis_aclk)
        begin
            if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                if(s_axis_fifo_ainit = '1' and frame_sync = '0')then
                    frame_sync_d1 <= '0';
                else
                    frame_sync_d1 <= frame_sync;
                end if;
            end if;
        end process REG_FSYNC_TO_ALIGN;

    -- Count lines to determine when datamover done.  Used for snf mode
    -- for threshold met (
    DM_DONE     : process(s_axis_aclk)
        begin
            if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                if(s_axis_fifo_ainit = '1')then
                    dm_vsize_counter        <= (others => '0');
                    dm_xfred_all_lines      <= '0';
                --elsif(fsync_out = '1')then     -- 
                elsif(frame_sync_d1 = '1')then     -- 
                    dm_vsize_counter       <= crnt_vsize;
                    dm_xfred_all_lines     <= '0';
                elsif(dm_decr_vcount = '1' and dm_vsize_counter = VSIZE_ONE_VALUE)then
                    dm_vsize_counter       <= (others => '0');
                    dm_xfred_all_lines     <= '1';

                elsif(dm_decr_vcount = '1' and dm_vsize_counter /= VSIZE_ZERO_VALUE)then
                    dm_vsize_counter       <= std_logic_vector(unsigned(dm_vsize_counter) - 1);
                    dm_xfred_all_lines     <= '0';

                end if;
            end if;
        end process DM_DONE;

end generate GEN_VCOUNT_FOR_SNF;

-- Not store and forward or no line buffer (
GEN_NO_VCOUNT_FOR_SNF : if C_LINEBUFFER_DEPTH = 0 or C_INCLUDE_MM2S_SF = 0 generate
begin
    dm_vsize_counter        <= (others => '0');
    dm_xfred_all_lines      <= '0';
    dm_decr_vcount          <= '0';
end generate GEN_NO_VCOUNT_FOR_SNF;


--*****************************************************************************--
--**                    SPECIAL RESET GENERATION                             **--
--*****************************************************************************--


-- Assert reset to skid buffer on hard reset or on shutdown when fifo pipe empty
-- Waiting for fifo_pipe_empty is required to prevent a AXIS protocol violation
-- when channel shut down early
REG_SKID_RESET : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
            if(m_axis_resetn = '0')then
                m_skid_reset <= '1';

            elsif(fifo_pipe_empty = '1')then
                if(fsync_out = '1' or dm_halt_reg = '1')then
                    m_skid_reset <= '1';
                else
                    m_skid_reset <= '0';
                end if;
            else
                m_skid_reset <= '0';
            end if;
        end if;
    end process REG_SKID_RESET;

-- Fifo/logic reset for slave side clock domain (m_axi_mm2s_aclk)
-- If error (dm_halt=1) then halt immediatly without protocol violation
s_axis_fifo_ainit <= '1' when s_axis_resetn = '0'
                           or frame_sync = '1'          -- Frame sync
                           or dm_halt = '1'             -- Datamover being halted (halt due to error)
                else '0';

-- Fifo/logic reset for master side clock domain (m_axis_mm2s_aclk)
m_axis_fifo_ainit <= '1' when m_axis_resetn = '0'
                           or fsync_out = '1'           -- Frame sync
                           or dm_halt_reg = '1'         -- Datamover being halted
                else '0';



-- Fifo/logic reset for slave side clock domain (m_axi_mm2s_aclk)
-- If error (dm_halt=1) then halt immediatly without protocol violation
s_axis_fifo_ainit_nosync <= '1' when s_axis_resetn = '0'
                           or dm_halt = '1'             -- Datamover being halted (halt due to error)
                else '0';

        process(s_axis_aclk)
            begin
                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                        s_axis_fifo_ainit_nosync_reg <= s_axis_fifo_ainit_nosync;
                end if;
            end process ;




-- Fifo/logic reset for master side clock domain (m_axis_mm2s_aclk)
m_axis_fifo_ainit_nosync <= '1' when m_axis_resetn = '0'
                           or dm_halt_reg = '1'         -- Datamover being halted
                else '0';





--reset for axis_dwidth

mm2s_axis_linebuf_reset_out_inv <= m_axis_fifo_ainit_nosync;
mm2s_axis_linebuf_reset_out <= not (mm2s_axis_linebuf_reset_out_inv);

all_lines_xfred 	<= mm2s_all_lines_xfred_s_sig;
mm2s_all_lines_xfred_s 	<= mm2s_all_lines_xfred_s_sig;


--C_DATA_WIDTH = C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED

MM2S_DWIDTH_CONV_IS : if (C_DATA_WIDTH /=  C_M_AXIS_MM2S_TDATA_WIDTH) generate
  begin


mm2s_all_lines_xfred_s_sig <= mm2s_all_lines_xfred_s_dwidth;
fifo_pipe_empty <= dwidth_fifo_pipe_empty;
dwidth_fifo_pipe_empty_m <= mm2s_fifo_pipe_empty_i;

 end generate MM2S_DWIDTH_CONV_IS;


  MM2S_DWIDTH_CONV_IS_NOT : if (C_DATA_WIDTH =  C_M_AXIS_MM2S_TDATA_WIDTH) generate
  begin


mm2s_all_lines_xfred_s_sig <= all_lines_xfred_no_dwidth;

    fifo_pipe_empty <= '1' when (all_lines_xfred = '1' and m_axis_tvalid_out = '0') -- All data for frame transmitted
                            or  (sf_threshold_met = '0'              -- Or Threshold not met
                                and stop_reg = '1'                   -- Commanded to stop
                                and m_axis_tvalid_out = '0')         -- And NOT driving tvalid
                  else '0';

dwidth_fifo_pipe_empty_m <= '1';

  end generate MM2S_DWIDTH_CONV_IS_NOT;


                        mm2s_fsync_int <= mm2s_fsync and run_stop_reg;

        -- Frame sync cross bar
----        FSYNC_CROSSBAR_MM2S_S : process(fsync_src_select_s_int,
----                                 run_stop_reg,
----                                 mm2s_fsync,
----                                 s2mm_fsync_mm2s_s)
----            begin
----                case fsync_src_select_s_int is
----
----                    when "00" =>   -- primary fsync (default)
----                        mm2s_fsync_int <= mm2s_fsync and run_stop_reg;
----                    when "01" =>   -- other channel fsync
----                        mm2s_fsync_int <= s2mm_fsync_mm2s_s and run_stop_reg;
----                    when others =>
----                        mm2s_fsync_int <= '0';
----                end case;
----            end process FSYNC_CROSSBAR_MM2S_S;


    FSIZE_MISMATCH_MM2S_FLUSH_SOF_s : process(m_axis_aclk)
        begin
            if(m_axis_aclk'EVENT and m_axis_aclk='1')then
                if(m_axis_resetn = '0')then
                    fsize_mismatch_err_int_s <= '0';
                -- fsync occurred when not all lines transferred
                elsif(mm2s_fsync_int = '1' and mm2s_all_lines_xfred_s_sig = '0')then
                    fsize_mismatch_err_int_s <= '1';
                else
                    fsize_mismatch_err_int_s <= '0';
                end if;
            end if;
        end process FSIZE_MISMATCH_MM2S_FLUSH_SOF_s;


    FSIZE_MISMATCH_FLAG_MM2S_FLUSH_SOF_s : process(m_axis_aclk)
        begin
            if(m_axis_aclk'EVENT and m_axis_aclk='1')then
                if(m_axis_resetn = '0' or mm2s_fsync_int = '1')then
                    fsize_mismatch_err_flag_s <= '0';
                elsif(fsize_mismatch_err_int_s = '1')then
                    fsize_mismatch_err_flag_s <= '1';
                end if;
            end if;
        end process FSIZE_MISMATCH_FLAG_MM2S_FLUSH_SOF_s;


fsize_mismatch_err_flag_cmb_s <= fsize_mismatch_err_int_s or fsize_mismatch_err_flag_s;

MM2S_DROP_RESIDUAL_OF_FSIZE_ERR_FRAME_S <= fsize_mismatch_err_flag_cmb_s;

mm2s_fsize_mismatch_err_s <= fsize_mismatch_err_int_s;
mm2s_fsize_mismatch_err_m <= fsize_mismatch_err_int_m;

mm2s_vsize_cntr_clr_flag  <= fsize_mismatch_err_flag_vsize_cntr_clr or fsize_mismatch_err_int_s;


    D1_FSYNC_OUT : process(m_axis_aclk)
        begin
            if(m_axis_aclk'EVENT and m_axis_aclk='1')then
                if(m_axis_resetn = '0')then
                    fsync_out_d1 <= '0';
                else
                    fsync_out_d1 <= fsync_out;
                end if;
            end if;
        end process D1_FSYNC_OUT;




    FLAG_VSIZE_CNTR_CLR : process(m_axis_aclk)
        begin
            if(m_axis_aclk'EVENT and m_axis_aclk='1')then
                if(m_axis_resetn = '0' or fsync_out_d1 = '1')then
                    fsize_mismatch_err_flag_vsize_cntr_clr <= '0';
                elsif(fsize_mismatch_err_int_s = '1')then
                    fsize_mismatch_err_flag_vsize_cntr_clr <= '1';
                end if;
            end if;
        end process FLAG_VSIZE_CNTR_CLR;



MM2S_FSIZE_ERR_TO_DM_HALT_FLAG : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
            if(m_axis_resetn = '0' or dm_halt_reg = '1')then
                fsize_err_to_dm_halt_flag  <= '0';
            elsif(fsize_mismatch_err_int_s = '1')then
                fsize_err_to_dm_halt_flag  <= '1';
            end if;
        end if;
    end process MM2S_FSIZE_ERR_TO_DM_HALT_FLAG;



fsize_err_to_dm_halt_flag_ored <= fsize_mismatch_err_int_s or fsize_err_to_dm_halt_flag or dm_halt_reg;


delay_fsync_fsize_err_till_dm_halt_cmplt_pulse_s    <= '1'  when  fsize_err_to_dm_halt_flag_ored = '1' and mm2s_fsync_int = '1' 
                                    else '0';


MM2S_FSIZE_LESS_DM_HALT_CMPLT_FLAG : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
            if(m_axis_resetn = '0' or fsize_err_to_dm_halt_flag_ored = '0')then
                delay_fsync_fsize_err_till_dm_halt_cmplt_flag_s  <= '0';
            elsif(delay_fsync_fsize_err_till_dm_halt_cmplt_pulse_s = '1')then
                delay_fsync_fsize_err_till_dm_halt_cmplt_flag_s  <= '1';
            end if;
        end if;
    end process MM2S_FSIZE_LESS_DM_HALT_CMPLT_FLAG;

MM2S_REG_D_FSYNC : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
            if(m_axis_resetn = '0')then
                delay_fsync_fsize_err_till_dm_halt_cmplt_s_d1  <= '0';
            else
                delay_fsync_fsize_err_till_dm_halt_cmplt_s_d1  <= delay_fsync_fsize_err_till_dm_halt_cmplt_flag_s;
            end if;
        end if;
    end process MM2S_REG_D_FSYNC;


d_fsync_halt_cmplt_s <= delay_fsync_fsize_err_till_dm_halt_cmplt_s_d1 and not delay_fsync_fsize_err_till_dm_halt_cmplt_flag_s;

mm2s_fsync_core <= (mm2s_fsync_int and not (delay_fsync_fsize_err_till_dm_halt_cmplt_pulse_s)) or d_fsync_halt_cmplt_s;


--mm2s_fsync_core <= mm2s_fsync_int;



end generate GEN_LINEBUF_FLUSH_SOF;








end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_s2mm_linebuf
-------------------------------------------------------------------------------
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_s2mm_linebuf.vhd
-- Description: This entity encompases the line buffer logic
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library lib_cdc_v1_0_2;
library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_s2mm_linebuf is
    generic (
        C_DATA_WIDTH                	: integer range 8 to 1024           	:= 32;
            -- Line Buffer Data Width
        C_INCLUDE_S2MM_DRE              : integer range 0 to 1      	:= 0;


        C_S2MM_SOF_ENABLE               : integer range 0 to 1      		:= 0;
            -- Enable/Disable start of frame generation on tuser(0). This
            -- is only valid for external frame sync (C_USE_FSYNC = 1)
            -- 0 = disable SOF
            -- 1 = enable SOF

        C_S_AXIS_S2MM_TUSER_BITS        : integer range 1 to 1      		:= 1;
            -- Slave AXI Stream User Width for S2MM Channel

        C_TOPLVL_LINEBUFFER_DEPTH   	: integer range 0 to 65536          	:= 512; -- 
            -- Depth as set by user at top level parameter

        C_LINEBUFFER_DEPTH          	: integer range 0 to 65536          	:= 512;
            -- Linebuffer depth in Bytes. Must be a power of 2

        C_LINEBUFFER_AF_THRESH       	: integer range 1 to 65536         	:= 1;
            -- Linebuffer almost full threshold in Bytes. Must be a power of 2

        C_PRMRY_IS_ACLK_ASYNC       	: integer range 0 to 1              	:= 0 ;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.
        ENABLE_FLUSH_ON_FSYNC      	: integer range 0 to 1        		:= 0      ;
        C_USE_S2MM_FSYNC                : integer range 0 to 2      	:= 2; --2013.1
        C_USE_FSYNC                 	: integer range 0 to 1      		:= 0;               
        C_INCLUDE_MM2S       		: integer range 0 to 1        		:= 0      ;
        C_ENABLE_DEBUG_ALL       : integer range 0 to 1      	:= 1;
            -- Setting this make core backward compatible to 2012.4 version in terms of ports and registers
 
        --C_ENABLE_DEBUG_INFO             : string := "1111111111111111";		-- 1 to 16 -- 
        --C_ENABLE_DEBUG_INFO             : bit_vector(15 downto 0) 	:= (others => '1');		--15 downto 0  -- 
        C_ENABLE_DEBUG_INFO_0       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 0
        C_ENABLE_DEBUG_INFO_1       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 1
        C_ENABLE_DEBUG_INFO_2       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 2
        C_ENABLE_DEBUG_INFO_3       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 3
        C_ENABLE_DEBUG_INFO_4       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 4
        C_ENABLE_DEBUG_INFO_5       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 5
        C_ENABLE_DEBUG_INFO_6       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 6
        C_ENABLE_DEBUG_INFO_7       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 7
        C_ENABLE_DEBUG_INFO_8       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 8
        C_ENABLE_DEBUG_INFO_9       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 9
        C_ENABLE_DEBUG_INFO_10      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 10
        C_ENABLE_DEBUG_INFO_11      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 11
        C_ENABLE_DEBUG_INFO_12      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 12
        C_ENABLE_DEBUG_INFO_13      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 13
        C_ENABLE_DEBUG_INFO_14      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 14
        C_ENABLE_DEBUG_INFO_15      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 15
        

        C_FAMILY                    : string            			:= "virtex7"
            -- Device family used for proper BRAM selection
    );
    port (
        s_axis_aclk                 : in  std_logic                         ;       --
        s_axis_resetn               : in  std_logic                         ;       --
                                                                                    --
        m_axis_aclk                 : in  std_logic                         ;       --
        m_axis_resetn               : in  std_logic                         ;       --
                                                                                    --
        s2mm_axis_linebuf_reset_out : out  std_logic                         ;   --
                                                                                    --
        strm_not_finished           : in  std_logic                         ;       --
        -- Graceful shut down control                                               --
        run_stop                    : in  std_logic                         ;       --
        dm_halt                     : in  std_logic                         ;       -- 
        dm_halt_cmplt               : in  std_logic                         ;       -- 
        s2mm_fsize_mismatch_err_s   : in  std_logic                         ;       -- 
        s2mm_fsize_mismatch_err     : in  std_logic                         ;       -- 
                                                                                    --
        -- Line Tracking Control                                                    --
        crnt_vsize                  : in  std_logic_vector                          -- 
                                        (VSIZE_DWIDTH-1 downto 0)           ;       -- 
        crnt_vsize_d2_s             : out  std_logic_vector                          -- 
                                        (VSIZE_DWIDTH-1 downto 0)           ;       -- 
        chnl_ready_external         : in  std_logic                         ;       -- 
        s2mm_fsync_core             : out  std_logic                         ;       -- 
        s2mm_fsync                  : in  std_logic                         ;       -- 
        s2mm_tuser_fsync_top        : in  std_logic                         ;       -- 
 
        mm2s_axis_resetn            : in  std_logic           := '1'              ;                   --
        m_axis_mm2s_aclk            : in  std_logic           := '0'              ;                   --
        mm2s_fsync                  : in  std_logic                         ;           --
        fsync_src_select            : in  std_logic_vector(1 downto 0)      ;           --
        fsync_src_select_s          : out  std_logic_vector(1 downto 0)      ;           --
        drop_fsync_d_pulse_gen_fsize_less_err  : out  std_logic      ;           --
        hold_dummy_tready_low       : out  std_logic      ;           --
        hold_dummy_tready_low2      : out  std_logic      ;           --


        s2mm_dmasr_fsize_less_err   : in  std_logic                         ;       --

   no_fsync_before_vsize_sel_00_01  : in  std_logic                         ;       -- 
       s2mm_fsize_mismatch_err_flag : in  std_logic                         ;       -- 
        fsync_out_m                 : out  std_logic                         ;       -- 
        fsync_out                   : in  std_logic                         ;       -- 
        frame_sync                  : in  std_logic                         ;       -- 
                                                                                    --
        -- Line Buffer Threshold                                                    --
        linebuf_threshold           : in  std_logic_vector                          --
                                        (LINEBUFFER_THRESH_WIDTH-1 downto 0);       --
        -- Stream In                                                                --
        s_axis_tdata                : in  std_logic_vector                          --
                                        (C_DATA_WIDTH-1 downto 0)           ;       --
        s_axis_tkeep                : in  std_logic_vector                          --
                                        ((C_DATA_WIDTH/8)-1 downto 0)       ;       --
        s_axis_tlast                : in  std_logic                         ;       --
        s_axis_tvalid               : in  std_logic                         ;       --
        s_axis_tready               : out std_logic                         ;       --
        s_axis_tuser                : in  std_logic_vector                          --
                                        (C_S_AXIS_S2MM_TUSER_BITS-1 downto 0);      --
 capture_dm_done_vsize_counter	    : out std_logic_vector(12 downto 0);                                                                                   --
        -- Stream Out                                                               --
        m_axis_tdata                : out std_logic_vector                          --
                                        (C_DATA_WIDTH-1 downto 0)           ;       --
        m_axis_tkeep                : out std_logic_vector                          --
                                        ((C_DATA_WIDTH/8)-1 downto 0)       ;       --
        m_axis_tlast                : out std_logic                         ;       --
        m_axis_tvalid               : out std_logic                         ;       --
        m_axis_tready               : in  std_logic                         ;       --
                                                                                    --
        -- Fifo Status Flags                                                        --
        s2mm_fifo_full              : out std_logic                         ;       --
        s2mm_fifo_almost_full       : out std_logic                         ;       --
        s2mm_all_lines_xfred        : out std_logic                         ;       -- 
        all_lasts_rcvd              : out std_logic			    ;	
        s2mm_tuser_fsync            : out std_logic
    );

end axi_vdma_s2mm_linebuf;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_s2mm_linebuf is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- Bufer depth
--constant BUFFER_DEPTH           : integer := max2(128,C_LINEBUFFER_DEPTH/(C_DATA_WIDTH/8));
constant BUFFER_DEPTH           : integer := C_LINEBUFFER_DEPTH;

-- Buffer width is data width + strobe width + 1 bit for tlast
constant BUFFER_WIDTH           : integer := C_DATA_WIDTH + (C_DATA_WIDTH/8)*C_INCLUDE_S2MM_DRE + 1; --tkeep
-- Buffer data count width




constant DATACOUNT_WIDTH        : integer := clog2(BUFFER_DEPTH);

constant USE_BRAM_FIFOS         : integer   := 1; -- Use BRAM FIFOs

-- Constants for line tracking logic
constant VSIZE_ONE_VALUE            : std_logic_vector(VSIZE_DWIDTH-1 downto 0)
                                        := std_logic_vector(to_unsigned(1,VSIZE_DWIDTH));
constant VSIZE_TWO_VALUE            : std_logic_vector(VSIZE_DWIDTH-1 downto 0)
                                        := std_logic_vector(to_unsigned(2,VSIZE_DWIDTH));


constant VSIZE_ZERO_VALUE           : std_logic_vector(VSIZE_DWIDTH-1 downto 0)
                                        := (others => '0');

constant ZERO_VALUE_VECT            : std_logic_vector(255 downto 0) := (others => '0');


-- Linebuffer threshold support
constant THRESHOLD_LSB_INDEX        : integer := clog2((C_DATA_WIDTH/8));

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal fifo_din                     : std_logic_vector(BUFFER_WIDTH - 1 downto 0) := (others => '0');
signal fifo_dout                    : std_logic_vector(BUFFER_WIDTH - 1 downto 0):= (others => '0');
signal fifo_wren                    : std_logic := '0';
signal fifo_rden                    : std_logic := '0';
signal fifo_empty_i                 : std_logic := '0';
signal fifo_full_i                  : std_logic := '0';
signal fifo_ainit                   : std_logic := '0';
signal fifo_wrcount                 : std_logic_vector(DATACOUNT_WIDTH-1 downto 0);
signal fifo_almost_full_i           : std_logic := '0'; -- 

signal s_axis_tready_i              : std_logic := '0';
signal s_axis_tvalid_i              : std_logic := '0';
signal s_axis_tlast_i               : std_logic := '0';
signal s_axis_tdata_i               : std_logic_vector(C_DATA_WIDTH-1 downto 0):= (others => '0');
signal s_axis_tkeep_i               : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0) := (others => '0');
signal s_axis_tkeep_signal          : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0) := (others => '0');
signal m_axis_tkeep_signal          : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0) := (others => '0');
signal s_axis_tuser_i               : std_logic_vector(C_S_AXIS_S2MM_TUSER_BITS-1 downto 0) := (others => '0');

signal crnt_vsize_cdc_tig                : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');
signal crnt_vsize_d1                : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');
signal crnt_vsize_d2                : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');
signal vsize_counter                : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');
signal decr_vcount                  : std_logic := '0';
signal chnl_ready                   : std_logic := '0';
signal s_axis_tready_out            : std_logic := '0';
signal slv2skid_s_axis_tvalid       : std_logic := '0';
signal data_count_af_threshold_cdc_tig      : std_logic_vector(DATACOUNT_WIDTH-1 downto 0) := (others => '0');
signal data_count_af_threshold_d1      : std_logic_vector(DATACOUNT_WIDTH-1 downto 0) := (others => '0');
signal data_count_af_threshold      : std_logic_vector(DATACOUNT_WIDTH-1 downto 0) := (others => '0');
signal s_data_count_af_thresh       : std_logic_vector(DATACOUNT_WIDTH-1 downto 0) := (others => '0');
signal dm_halt_reg                  : std_logic := '0'; -- 
signal run_stop_reg                 : std_logic := '0'; -- 

signal s_axis_fifo_ainit            : std_logic := '0';
signal s_axis_tuser_d1              : std_logic := '0';
signal tuser_fsync                  : std_logic := '0';

signal m_axis_fifo_ainit            : std_logic := '0';                                             -- 
signal done_vsize_counter           : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0'); -- 
signal m_axis_tlast_i               : std_logic := '0';                                             -- 
signal m_axis_tvalid_i              : std_logic := '0';                                             -- 
signal done_decr_vcount             : std_logic := '0';                                             -- 
signal p_fsync_out                  : std_logic := '0';
-- Added for 
signal s2mm_all_lines_xfred_i       : std_logic := '0';
signal s_axis_fifo_ainit_nosync     : std_logic := '0';
signal s_axis_fifo_ainit_nosync_reg : std_logic := '0';
signal m_axis_fifo_ainit_nosync     : std_logic := '0';
signal s2mm_axis_linebuf_reset_out_inv : std_logic := '0';
signal s2mm_tuser_fsync_sig         : std_logic := '0';

signal s2mm_dmasr_fsize_less_err_d1 : std_logic := '0';
signal s2mm_dmasr_fsize_less_err_fe : std_logic := '0';

signal wr_rst_busy_sig              : std_logic := '0';
signal rd_rst_busy_sig              : std_logic := '0';                  




  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF crnt_vsize_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF crnt_vsize_d1       : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF data_count_af_threshold_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF data_count_af_threshold_d1       : SIGNAL IS "true"; 


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
fsync_out_m <= p_fsync_out;
		s2mm_axis_linebuf_reset_out_inv <=    s_axis_fifo_ainit_nosync        ;


		s2mm_tuser_fsync <=    s2mm_tuser_fsync_sig        ;
		crnt_vsize_d2_s <=    crnt_vsize_d2        ;


s2mm_axis_linebuf_reset_out <=    not(s2mm_axis_linebuf_reset_out_inv)        ;

s_axis_fifo_ainit_nosync <= '1' when (s_axis_resetn = '0')
                           or (dm_halt_reg = '1')                          
                else '0';


        process(s_axis_aclk)
            begin
                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                        s_axis_fifo_ainit_nosync_reg <= s_axis_fifo_ainit_nosync;
                end if;
            end process ;




m_axis_fifo_ainit_nosync <= '1' when (m_axis_resetn = '0')
                                or (dm_halt = '1')                                            
                else '0';                                                                     



-- fifo ainit in the S_AXIS clock domain
s_axis_fifo_ainit <= '1' when (s_axis_resetn = '0')
                           or (fsync_out = '1')                            -- 
                           or (dm_halt_reg = '1')                          -- 
                else '0';

m_axis_fifo_ainit <= '1' when (m_axis_resetn = '0')
                           or (frame_sync = '1')                                                -- 
                           or (dm_halt = '1')                                                   -- 
                else '0';                                                                       -- 



GEN_VSIZE_SNAPSHOT_LOGIC : if (C_USE_FSYNC = 1 and (C_ENABLE_DEBUG_INFO_12 = 1 or C_ENABLE_DEBUG_ALL = 1)) generate

begin

	S2MM_DMASR_BIT7_D1 : process(m_axis_aclk)
	    begin
	        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
	            if(m_axis_resetn = '0')then
	                s2mm_dmasr_fsize_less_err_d1 <= '0';
	            else
	                s2mm_dmasr_fsize_less_err_d1 <= s2mm_dmasr_fsize_less_err;
	            end if;
	        end if;
	    end process S2MM_DMASR_BIT7_D1;
	
	
	s2mm_dmasr_fsize_less_err_fe <= s2mm_dmasr_fsize_less_err_d1 and not s2mm_dmasr_fsize_less_err;
	
	
	    DM_VSIZE_AT_FSIZE_LESS_ERR : process(m_axis_aclk)
	        begin
	            if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
	                if(m_axis_resetn = '0' or s2mm_dmasr_fsize_less_err_fe = '1')then
				
				capture_dm_done_vsize_counter   <= (others => '0');
	
			elsif (s2mm_fsize_mismatch_err = '1' and s2mm_dmasr_fsize_less_err = '0')then
	
				capture_dm_done_vsize_counter   <= done_vsize_counter;
	
	            	end if;
	            end if;
	        end process DM_VSIZE_AT_FSIZE_LESS_ERR;
	

end generate GEN_VSIZE_SNAPSHOT_LOGIC;


GEN_NO_VSIZE_SNAPSHOT_LOGIC : if (C_USE_FSYNC = 0 or (C_ENABLE_DEBUG_INFO_12 = 0 and C_ENABLE_DEBUG_ALL = 0)) generate

begin

	capture_dm_done_vsize_counter <= (others => '0');

end generate GEN_NO_VSIZE_SNAPSHOT_LOGIC;



GEN_S2MM_DRE_ON : if C_INCLUDE_S2MM_DRE = 1 generate
begin

m_axis_tkeep 	    <= m_axis_tkeep_signal;
s_axis_tkeep_signal <= s_axis_tkeep;

end generate GEN_S2MM_DRE_ON;

GEN_S2MM_DRE_OFF : if C_INCLUDE_S2MM_DRE = 0 generate
begin

m_axis_tkeep 	    <= (others => '1');
s_axis_tkeep_signal <= (others => '1');

end generate GEN_S2MM_DRE_OFF;





--*****************************************************************************--
--**              USE FSYNC MODE                         **--
--*****************************************************************************--
GEN_FSYNC_LOGIC : if (ENABLE_FLUSH_ON_FSYNC = 1 and C_S2MM_SOF_ENABLE = 0) generate


    type  STRM_WR_SM_TYPE is (STRM_WR_IDLE,
                              STRM_WR_START,
                              STRM_WR_RUNNING,
                              STRM_WR_LAST
                             );


    signal strm_write_ns            : STRM_WR_SM_TYPE;
    signal strm_write_cs            : STRM_WR_SM_TYPE;

    type  FIFO_RD_SM_TYPE is (FIFO_RD_IDLE,
                       --   FIFO_RD_START,
                              FIFO_RD_RUNNING,
                              FIFO_RD_FSYNC,
                              FIFO_RD_FSYNC_LAST,
                               FIFO_RD_LAST
                             );
    signal fifo_read_ns             : FIFO_RD_SM_TYPE;
    signal fifo_read_cs             : FIFO_RD_SM_TYPE;
    
    signal load_counter             : std_logic := '0';
    signal load_counter_sm          : std_logic := '0';
    signal strm_write_pending_sm    : std_logic := '0';
    signal strm_write_pending       : std_logic := '0';
    signal fifo_rd_pending_sm       : std_logic := '0';
    signal fifo_rd_pending          : std_logic := '0';
    signal stop_tready_sm           : std_logic := '0';
    signal stop_tready              : std_logic := '0';
    signal strm_write_pending_m_axi : std_logic := '0';
    signal stop_tready_s_axi        : std_logic := '0';
    signal dm_halt_frame            : std_logic := '0';    

begin

s2mm_all_lines_xfred <=            s2mm_all_lines_xfred_i;



--*****************************************************************************--
--**              LINE BUFFER MODE (Sync or Async)                           **--
--*****************************************************************************--
GEN_LINEBUFFER : if C_LINEBUFFER_DEPTH /= 0 generate
begin

    -- Divide by number bytes per data beat and add padding to dynamic
    -- threshold setting
    data_count_af_threshold <= linebuf_threshold((DATACOUNT_WIDTH-1) + THRESHOLD_LSB_INDEX
                                            downto THRESHOLD_LSB_INDEX);



    -- Synchronous clock therefore instantiate an Asynchronous FIFO
    GEN_SYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
    begin
               
      

        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_sfifo
            generic map(
                 UW_DATA_WIDTH     => BUFFER_WIDTH        ,
          C_FULL_FLAGS_RST_VAL     => 1        ,
                 UW_FIFO_DEPTH     => BUFFER_DEPTH        ,
                 C_FAMILY          => C_FAMILY
            )
            port map(
                -- Inputs
                 rst               => s_axis_fifo_ainit_nosync   ,
                 sleep             => '0'         ,
                 wr_rst_busy       => wr_rst_busy_sig         ,
                 rd_rst_busy       => rd_rst_busy_sig         ,
                 clk               => s_axis_aclk         ,
                 wr_en             => fifo_wren           ,
                 din               => fifo_din            ,
                 rd_en             => fifo_rden           ,

                -- Outputs
                 dout              => fifo_dout           ,
                 full              => fifo_full_i         ,
                 empty             => fifo_empty_i        ,
                 data_count        => fifo_wrcount  
            );



--wr_rst_busy_sig <= '0';
--rd_rst_busy_sig <= '0';

    end generate GEN_SYNC_FIFO;


    -- Asynchronous clock therefore instantiate an Asynchronous FIFO
    GEN_ASYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
    begin

      
LB_BRAM : if ( (C_ENABLE_DEBUG_INFO_9 = 1 or C_ENABLE_DEBUG_ALL = 1) )
  generate   
    begin


        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_afifo
            generic map(
                 UW_DATA_WIDTH   => BUFFER_WIDTH                    ,
          C_FULL_FLAGS_RST_VAL   => 1        ,
                 UW_FIFO_DEPTH   => BUFFER_DEPTH                    ,
                 C_FAMILY        => C_FAMILY
            )
            port map(
                 rst             => s_axis_fifo_ainit_nosync_reg    ,
                 sleep           => '0'         ,
                 wr_rst_busy     => open         ,
                 rd_rst_busy     => open         ,
                 wr_clk          => s_axis_aclk          ,
                 wr_en           => fifo_wren            ,
                 din             => fifo_din             ,
                 rd_clk          => m_axis_aclk          ,
                 rd_en           => fifo_rden            ,

                -- Outputs
                 dout            => fifo_dout            ,
                 full            => fifo_full_i          ,
                 empty           => fifo_empty_i         ,
                 wr_data_count   => fifo_wrcount         ,
                 rd_data_count   => open                 
            );

wr_rst_busy_sig <= '0';
rd_rst_busy_sig <= '0';
end generate LB_BRAM;                     

      
LB_BUILT_IN : if ( (C_ENABLE_DEBUG_INFO_9 = 0 and C_ENABLE_DEBUG_ALL = 0) )
  generate   
    begin


        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_afifo_builtin
            generic map(
                 PL_FIFO_TYPE    => "BUILT_IN"                    ,
                 PL_READ_MODE    => "FWFT"                    ,
                 PL_FASTER_CLOCK => "RD_CLK"                    , --WR_CLK
                 PL_FULL_FLAGS_RST_VAL => 0                     , -- ?
                 PL_DATA_WIDTH   => BUFFER_WIDTH                    ,
                 C_FAMILY        => C_FAMILY ,
                 PL_FIFO_DEPTH   => BUFFER_DEPTH                    
            )
            port map(
                 rst             => s_axis_fifo_ainit_nosync_reg    ,
                 sleep           => '0'         ,
                 wr_rst_busy     => wr_rst_busy_sig         ,
                 rd_rst_busy     => rd_rst_busy_sig         ,
                 wr_clk          => s_axis_aclk          ,
                 wr_en           => fifo_wren            ,
                 din             => fifo_din             ,
                 rd_clk          => m_axis_aclk          ,
                 rd_en           => fifo_rden            ,

                -- Outputs
                 dout            => fifo_dout            ,
                 full            => fifo_full_i          ,
                 empty           => fifo_empty_i         
            );

end generate LB_BUILT_IN;                     








     end generate GEN_ASYNC_FIFO;

   GEN_S2MM_DRE_ENABLED_TKEEP : if C_INCLUDE_S2MM_DRE = 1 generate
   begin


    -- AXI Slave Side of FIFO
    fifo_din            <= s_axis_tlast_i & s_axis_tkeep_i & s_axis_tdata_i;
    fifo_wren           <= s_axis_tvalid_i and  s_axis_tready_i;


    s_axis_tready_i     <= not fifo_full_i and not wr_rst_busy_sig and not s_axis_fifo_ainit;


    -- AXI Master Side of FIFO
    fifo_rden           <= m_axis_tready and m_axis_tvalid_i;
    m_axis_tvalid_i     <= not fifo_empty_i and not rd_rst_busy_sig;
    m_axis_tdata        <= fifo_dout(C_DATA_WIDTH-1 downto 0);
    m_axis_tkeep_signal <= fifo_dout(BUFFER_WIDTH-2 downto (BUFFER_WIDTH-2) - (C_DATA_WIDTH/8) + 1);
    m_axis_tlast_i      <= fifo_dout(BUFFER_WIDTH-1);


    m_axis_tlast    <= m_axis_tlast_i;
    m_axis_tvalid   <= m_axis_tvalid_i;

   end generate GEN_S2MM_DRE_ENABLED_TKEEP;

   GEN_NO_S2MM_DRE_DISABLE_TKEEP : if C_INCLUDE_S2MM_DRE = 0 generate
   begin


    -- AXI Slave Side of FIFO
    fifo_din            <= s_axis_tlast_i & s_axis_tdata_i;
    fifo_wren           <= s_axis_tvalid_i and  s_axis_tready_i;


    s_axis_tready_i     <= not fifo_full_i and not wr_rst_busy_sig and not s_axis_fifo_ainit;


    -- AXI Master Side of FIFO
    fifo_rden           <= m_axis_tready and m_axis_tvalid_i;
    m_axis_tvalid_i     <= not fifo_empty_i and not rd_rst_busy_sig;
    m_axis_tdata        <= fifo_dout(C_DATA_WIDTH-1 downto 0);
    m_axis_tkeep_signal <= (others => '1');
    m_axis_tlast_i      <= fifo_dout(BUFFER_WIDTH-1);


    m_axis_tlast    <= m_axis_tlast_i;
    m_axis_tvalid   <= m_axis_tvalid_i;



   end generate GEN_NO_S2MM_DRE_DISABLE_TKEEP;


    -- Top level line buffer depth not equal to zero therefore gererate threshold
    -- flags. (



    GEN_THRESHOLD_ENABLED : if C_TOPLVL_LINEBUFFER_DEPTH /= 0  and (C_ENABLE_DEBUG_INFO_9 = 1 or C_ENABLE_DEBUG_ALL = 1)  generate
    begin


------   GEN_THRESHOLD_ENABLED_NO_SOF : if C_S2MM_SOF_ENABLE = 0 generate
------    begin



        -- Almost full flag
        -- This flag is only used by S2MM and the threshold has been adjusted to allow registering
        -- of the flag for timing and also to assert and deassert from an outside S2MM perspective
      
        REG_ALMST_FULL : process(s_axis_aclk)
            begin
                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                    if(s_axis_fifo_ainit = '1')then
                        fifo_almost_full_i <= '0';
                    -- write count greater than or equal to threshold value therefore assert thresold flag
                    elsif(fifo_wrcount >= s_data_count_af_thresh or (fifo_full_i='1' or wr_rst_busy_sig = '1')) then
                        fifo_almost_full_i <= '1';
                    -- In all other cases de-assert flag
                    else
                        fifo_almost_full_i <= '0';
                    end if;
                end if;
            end process REG_ALMST_FULL;



        -- Drive fifo flags out if Linebuffer included
        s2mm_fifo_almost_full   <= fifo_almost_full_i or fifo_full_i or wr_rst_busy_sig;
        s2mm_fifo_full          <= fifo_full_i or wr_rst_busy_sig ;





-----    end generate GEN_THRESHOLD_ENABLED_NO_SOF;
-----
-----








    end generate GEN_THRESHOLD_ENABLED;

    -- Top level line buffer depth is zero therefore turn off threshold logic.
    -- this occurs for async operation where the async fifo is needed for CDC (
    GEN_THRESHOLD_DISABLED  : if C_TOPLVL_LINEBUFFER_DEPTH = 0  or (C_ENABLE_DEBUG_INFO_9 = 0 and C_ENABLE_DEBUG_ALL = 0)  generate
    begin
        fifo_almost_full_i      <= '0';
        s2mm_fifo_almost_full   <= '0';
        s2mm_fifo_full          <= '0';
    end generate GEN_THRESHOLD_DISABLED;

   



-----    GEN_MSTR_SKID_NO_SOF : if C_S2MM_SOF_ENABLE = 0 generate
-----    begin




 --*********************************************************--
    --**               S2MM SLAVE SKID BUFFER                **--
    --*********************************************************--
----    I_MSTR_SKID : entity axi_vdma_v6_3_10.axi_vdma_skid_buf
----        generic map(
----            C_WDATA_WIDTH           => C_DATA_WIDTH		,
----            C_TUSER_WIDTH           => C_S_AXIS_S2MM_TUSER_BITS
----
----        )
----        port map(
----            -- System Ports
----            ACLK                   => s_axis_aclk              ,
----            ARST                   => s_axis_fifo_ainit        ,
----
----            -- Shutdown control (assert for 1 clk pulse)
----            skid_stop              => '0'                      ,
----
----            -- Slave Side (Stream Data Input)
----            S_VALID                => slv2skid_s_axis_tvalid   ,
----            S_READY                => s_axis_tready_out        ,
----            S_Data                 => s_axis_tdata             ,
----            S_STRB                 => s_axis_tkeep             ,
----            S_Last                 => s_axis_tlast             ,
----            S_User                 => s_axis_tuser             ,
----
----            -- Master Side (Stream Data Output)
----            M_VALID                => s_axis_tvalid_i          ,
----            M_READY                => s_axis_tready_i          ,
----            M_Data                 => s_axis_tdata_i           ,
----            M_STRB                 => s_axis_tkeep_i           ,
----            M_Last                 => s_axis_tlast_i           ,
----            M_User                 => s_axis_tuser_i
----        );


s_axis_tvalid_i		<= 	slv2skid_s_axis_tvalid; 	 
s_axis_tdata_i 		<= 	s_axis_tdata;
s_axis_tkeep_i 		<= 	s_axis_tkeep_signal;
s_axis_tlast_i 		<= 	s_axis_tlast;
s_axis_tuser_i 		<= 	s_axis_tuser;

s_axis_tready_out	<= 	s_axis_tready_i; 	 



-----    end generate GEN_MSTR_SKID_NO_SOF;




    -- Pass out top level
    -- Qualify with channel ready to 'turn off' ready
    -- at end of video frame
    --s_axis_tready   <= s_axis_tready_out and not chnl_fsync ;
    s_axis_tready   <= s_axis_tready_out and chnl_ready and 
                       not stop_tready_s_axi ;

    -- Qualify with channel ready to 'turn off' writes to
    -- fifo at end of video frame
    slv2skid_s_axis_tvalid <= s_axis_tvalid and chnl_ready and 
                              not stop_tready_s_axi ;

    -- Generate start of frame fsync
-------    GEN_SOF_FSYNC : if C_S2MM_SOF_ENABLE = 1 generate
-------    begin
-------
-------        TUSER_RE_PROCESS : process(s_axis_aclk)
-------            begin
-------                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
-------                    if(s_axis_fifo_ainit_nosync = '1')then
-------                        s_axis_tuser_d1 <= '0';
-------                    else
-------                        s_axis_tuser_d1 <= s_axis_tuser_i(0) and s_axis_tvalid_i;
-------                    end if;
-------                end if;
-------            end process TUSER_RE_PROCESS;
-------
-------        tuser_fsync <= s_axis_tuser_i(0) and s_axis_tvalid_i and not s_axis_tuser_d1;
-------
-------    end generate GEN_SOF_FSYNC;
-------
-------    -- Do not generate start of frame fsync
-------    GEN_NO_SOF_FSYNC : if C_S2MM_SOF_ENABLE = 0 generate
-------    begin
        tuser_fsync <= '0';
-------    end generate GEN_NO_SOF_FSYNC;
-------
-------

end generate GEN_LINEBUFFER;

--*****************************************************************************--
--**               NO LINE BUFFER MODE (Sync Only)                           **--
--*****************************************************************************--
GEN_NO_LINEBUFFER : if (C_LINEBUFFER_DEPTH = 0) generate
begin

    m_axis_tdata        <= s_axis_tdata;
    m_axis_tkeep        <= s_axis_tkeep_signal;
    m_axis_tvalid_i     <= s_axis_tvalid and chnl_ready and 
                           not stop_tready_s_axi;
    m_axis_tlast_i      <= s_axis_tlast;


    m_axis_tvalid       <= m_axis_tvalid_i;
    m_axis_tlast        <= m_axis_tlast_i;


    s_axis_tready_i     <= m_axis_tready and chnl_ready and 
                           not stop_tready_s_axi;
    s_axis_tready_out   <= m_axis_tready and chnl_ready and 
                           not stop_tready_s_axi;
    s_axis_tready       <= s_axis_tready_i;

    -- fifo signals not used
    s2mm_fifo_full          <= '0';
    s2mm_fifo_almost_full   <= '0';

    -- Generate start of frame fsync
-----    GEN_SOF_FSYNC : if C_S2MM_SOF_ENABLE = 1 generate
-----    begin
-----
-----        TUSER_RE_PROCESS : process(s_axis_aclk)
-----            begin
-----                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
-----                    if(s_axis_fifo_ainit_nosync = '1')then
-----                        s_axis_tuser_d1 <= '0';
-----                    else
-----                        s_axis_tuser_d1 <= s_axis_tuser_i(0) and s_axis_tvalid_i;
-----                    end if;
-----                end if;
-----            end process TUSER_RE_PROCESS;
-----
-----        tuser_fsync <= s_axis_tuser_i(0) and s_axis_tvalid_i and not s_axis_tuser_d1;
-----
-----    end generate GEN_SOF_FSYNC;
-----
-----    -- Do not generate start of frame fsync
-----    GEN_NO_SOF_FSYNC : if C_S2MM_SOF_ENABLE = 0 generate
-----    begin
        tuser_fsync <= '0';
-----    end generate GEN_NO_SOF_FSYNC;



end generate GEN_NO_LINEBUFFER;


-- Instantiate Clock Domain Crossing for Asynchronous clock
GEN_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin



VSIZE_CNT_CROSSING : process(s_axis_aclk)
    begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then

	   crnt_vsize_cdc_tig <= crnt_vsize;
	   crnt_vsize_d1      <= crnt_vsize_cdc_tig;

        end if;
    end process VSIZE_CNT_CROSSING;


	   crnt_vsize_d2 <= crnt_vsize_d1;








        -- Cross datamover halt and fifo threshold to secondary for reset use
----        STRM_WR_HALT_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE              => CDC_TYPE_LEVEL_P_S                           ,
----                C_VECTOR_WIDTH          => 1 
----            )
----            port map (
----                prmry_aclk              => m_axis_aclk                              ,
----                prmry_resetn            => m_axis_resetn                            ,
----                scndry_aclk             => s_axis_aclk                              ,
----                scndry_resetn           => s_axis_resetn                            ,
----                scndry_in               => '0'                                      ,
----                prmry_out               => open                                     ,
----                prmry_in                => dm_halt                                  , -- 
----                scndry_out              => dm_halt_reg                              , -- 
----                scndry_vect_s_h         => '0'                                      ,
----                scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0),
----                prmry_vect_out          => open                                     ,
----                prmry_vect_s_h          => '0'                                      ,
----                prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)                  ,
----                scndry_vect_out         => open
----            );
  

STRM_WR_HALT_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => dm_halt, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => dm_halt_reg,
        scndry_vect_out            => open
    );









THRESH_CNT_CROSSING : process(s_axis_aclk)
    begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then

	   data_count_af_threshold_cdc_tig <= data_count_af_threshold;
	   data_count_af_threshold_d1      <= data_count_af_threshold_cdc_tig;

        end if;
    end process THRESH_CNT_CROSSING;


	   s_data_count_af_thresh <= data_count_af_threshold_d1;





      -- Cross run_stop  to secondary 
----    RUNSTOP_AXIS_1_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_P_S                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axis_aclk                               ,
----            prmry_resetn            => m_axis_resetn                             ,
----            scndry_aclk             => s_axis_aclk                              ,
----            scndry_resetn           => s_axis_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => run_stop                         ,
----            scndry_out              => run_stop_reg                          ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----


RUNSTOP_AXIS_1_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => run_stop, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => run_stop_reg,
        scndry_vect_out            => open
    );







        -- 
----        FSYNC_OUT_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE              => CDC_TYPE_PULSE_S_P_OPEN_ENDED                           ,
----                C_VECTOR_WIDTH          => 1
----            )
----            port map (
----                prmry_aclk              => m_axis_aclk                              ,
----                prmry_resetn            => m_axis_resetn                            ,
----                scndry_aclk             => s_axis_aclk                              ,
----                scndry_resetn           => s_axis_resetn                            ,
----                scndry_in               => fsync_out                                ,
----                prmry_out               => p_fsync_out                              ,
----                prmry_in                => '0'                                      ,
----                scndry_out              => open                                     ,
----                scndry_vect_s_h         => '0'                                      ,
----                scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----                prmry_vect_out          => open                                     ,
----                prmry_vect_s_h          => '0'                                      ,
----                prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----                scndry_vect_out         => open
----            );
----




FSYNC_OUT_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => fsync_out, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => p_fsync_out,
        scndry_vect_out            => open
    );









        -- Cross tuser fsync to primary
----        TUSER_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE              => CDC_TYPE_PULSE_S_P_OPEN_ENDED                           ,
----                C_VECTOR_WIDTH          => 1
----            )
----            port map (
----                prmry_aclk              => m_axis_aclk                              ,
----                prmry_resetn            => m_axis_resetn                            ,
----                scndry_aclk             => s_axis_aclk                              ,
----                scndry_resetn           => s_axis_resetn                            ,
----                scndry_in               => tuser_fsync                              ,
----                prmry_out               => s2mm_tuser_fsync_sig                         ,
----                prmry_in                => '0'                                      ,
----                scndry_out              => open                                     ,
----                scndry_vect_s_h         => '0'                                      ,
----                scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----                prmry_vect_out          => open                                     ,
----                prmry_vect_s_h          => '0'                                      ,
----                prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----                scndry_vect_out         => open
----            );
----


TUSER_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => tuser_fsync, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => s2mm_tuser_fsync_sig,
        scndry_vect_out            => open
    );





 

--       WR_PENDING_P_S_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
--            generic map(
--                C_CDC_TYPE              => CDC_TYPE_LEVEL_P_S                           ,
--                C_VECTOR_WIDTH          => DATACOUNT_WIDTH
--            )
--            port map (
--                prmry_aclk              => m_axis_aclk                              ,
--                prmry_resetn            => m_axis_resetn                            ,
--                scndry_aclk             => s_axis_aclk                              ,
--                scndry_resetn           => s_axis_resetn                            ,
--                scndry_in               => '0'                       ,
--                prmry_out               => open                 ,
--                prmry_in                => stop_tready                              , 
--                scndry_out              => stop_tready_s_axi                        , 
--                scndry_vect_s_h         => '0'                                      ,
--                scndry_vect_in          => ZERO_VALUE_VECT(DATACOUNT_WIDTH-1 downto 0),
--                prmry_vect_out          => open                                     ,
--                prmry_vect_s_h          => '1'                                      ,
--                prmry_vect_in           => ZERO_VALUE_VECT(DATACOUNT_WIDTH-1 downto 0)                  ,
--                scndry_vect_out         => open
--            );
--


WR_PENDING_P_S_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => stop_tready, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => stop_tready_s_axi,
        scndry_vect_out            => open
    );







----       WR_PENDING_S_P_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE              => CDC_TYPE_LEVEL_S_P                           ,
----                C_VECTOR_WIDTH          => DATACOUNT_WIDTH
----            )
----            port map (
----                prmry_aclk              => m_axis_aclk                              ,
----                prmry_resetn            => m_axis_resetn                            ,
----                scndry_aclk             => s_axis_aclk                              ,
----                scndry_resetn           => s_axis_resetn                            ,
----                scndry_in               => strm_write_pending                       ,
----                prmry_out               => strm_write_pending_m_axi                 ,
----                prmry_in                => '0'                              , 
----                scndry_out              => open                        , 
----                scndry_vect_s_h         => '0'                                      ,
----                scndry_vect_in          => ZERO_VALUE_VECT(DATACOUNT_WIDTH-1 downto 0),
----                prmry_vect_out          => open                                     ,
----                prmry_vect_s_h          => '1'                                      ,
----                prmry_vect_in           => ZERO_VALUE_VECT(DATACOUNT_WIDTH-1 downto 0)                  ,
----                scndry_vect_out         => open
----            );
----

WR_PENDING_S_P_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => strm_write_pending, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => strm_write_pending_m_axi,
        scndry_vect_out            => open
    );








--GEN_FIFO_SIDE_DM_HALT_REG_NO_SOF : if C_S2MM_SOF_ENABLE = 0 generate
--begin


   FIFO_SIDE_DM_HALT_REG : process(m_axis_aclk) is
   begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
            if(m_axis_resetn = '0' and p_fsync_out = '0')then
               dm_halt_frame <= '0';
            elsif (p_fsync_out = '1') then
               dm_halt_frame <= '0';
            elsif (dm_halt = '1') then
               dm_halt_frame <= '1';
            end if;
      end if;
   end process FIFO_SIDE_DM_HALT_REG;

--end generate GEN_FIFO_SIDE_DM_HALT_REG_NO_SOF; 



end generate GEN_FOR_ASYNC;

-- Synchronous clock therefore just map signals across
GEN_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin
    crnt_vsize_d2               <= crnt_vsize;
    dm_halt_reg                 <= dm_halt;
    run_stop_reg                 <= run_stop;
    dm_halt_frame               <= dm_halt;
    s2mm_tuser_fsync_sig            <= tuser_fsync;
    p_fsync_out                 <= fsync_out;
    --s2mm_all_lines_xfred        <= all_lines_xfred;   -- 
    s_data_count_af_thresh      <= data_count_af_threshold;
    strm_write_pending_m_axi    <= strm_write_pending;
    stop_tready_s_axi           <= stop_tready;

end generate GEN_FOR_SYNC;

--*****************************************************************************
--** Vertical Line Tracking
--*****************************************************************************
-- Decrement vertical count with each accept tlast
decr_vcount <= '1' when s_axis_tlast = '1'
                    and s_axis_tvalid = '1'
                    and s_axis_tready_out = '1'
          else '0';

----GEN_NO_SOF_SM : if C_S2MM_SOF_ENABLE = 0 generate
----begin


STRM_SIDE_SM: process (strm_write_cs,
                       fsync_out,
                       decr_vcount,
                       vsize_counter)is
begin
    
    strm_write_pending_sm <= '0';
    strm_write_ns <= strm_write_cs;
    
    case strm_write_cs is
    
    when STRM_WR_IDLE => 
                          if(fsync_out = '1') then
                               strm_write_ns <= STRM_WR_RUNNING;
                               strm_write_pending_sm <= '1';
                          end if;

    when STRM_WR_RUNNING => 
                          if (decr_vcount = '1' and 
                              vsize_counter = VSIZE_ONE_VALUE) then
                               strm_write_ns <= STRM_WR_IDLE;
                               strm_write_pending_sm <= '0';                          
                          elsif (decr_vcount = '1' and 
                                 vsize_counter = VSIZE_TWO_VALUE) then
                               strm_write_ns <= STRM_WR_LAST;
                          end if;
                          strm_write_pending_sm <= '1';
                                   
    when STRM_WR_LAST =>                             
                           if (decr_vcount = '1' ) then
                               strm_write_ns <= STRM_WR_IDLE;
                               strm_write_pending_sm <= '0';
                           end if;
                           strm_write_pending_sm <= '1';
    -- coverage off
     when others =>
                           strm_write_ns <= STRM_WR_IDLE;
    -- coverage on
    
    end case;
    
end process STRM_SIDE_SM;


   STRM_SIDE_SM_REG : process(s_axis_aclk) is
   begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
            if(s_axis_fifo_ainit_nosync = '1' and fsync_out = '0')then
               strm_write_cs <= STRM_WR_IDLE;
               strm_write_pending <= '0';
            else
               strm_write_cs <= strm_write_ns;
               strm_write_pending <= strm_write_pending_sm;
         end if;
      end if;
   end process STRM_SIDE_SM_REG;   

-- Drive ready at fsync out then de-assert once all lines have
-- been accepted.
VERT_COUNTER : process(s_axis_aclk)
    begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
            if(s_axis_fifo_ainit = '1' and fsync_out = '0')then
                vsize_counter   <= (others => '0');
                chnl_ready      <= '0';
            elsif(fsync_out = '1')then
                vsize_counter   <= crnt_vsize_d2;
                chnl_ready      <= '1';
            elsif(decr_vcount = '1' and vsize_counter = VSIZE_ONE_VALUE)then
                vsize_counter   <= (others => '0');
                chnl_ready      <= '0';
            elsif(decr_vcount = '1' and vsize_counter /= VSIZE_ZERO_VALUE)then
                vsize_counter   <= std_logic_vector(unsigned(vsize_counter) - 1);
                chnl_ready      <= '1';
            end if;
        end if;
    end process VERT_COUNTER;

 -- decrement based on master axis signals for determining done (
done_decr_vcount <= '1' when m_axis_tlast_i = '1'
                         and m_axis_tvalid_i = '1'
                         and m_axis_tready = '1'
          else '0';

-- 
DONE_VERT_COUNTER : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
            if(m_axis_fifo_ainit_nosync = '1' and p_fsync_out = '0')then
                done_vsize_counter   <= (others => '0');
            elsif(load_counter = '1')then
                done_vsize_counter   <= crnt_vsize;
            elsif(done_decr_vcount = '1' and done_vsize_counter = VSIZE_ONE_VALUE)then
                done_vsize_counter   <= (others => '0');
            elsif(done_decr_vcount = '1' and done_vsize_counter /= VSIZE_ZERO_VALUE)then
                done_vsize_counter   <= std_logic_vector(unsigned(done_vsize_counter) - 1);
            end if;
        end if;
    end process DONE_VERT_COUNTER;

FIFO_SIDE_SM: process (fifo_read_cs,
                       done_decr_vcount,
                       p_fsync_out,
                       done_vsize_counter,
                       strm_write_pending_m_axi,
                       crnt_vsize)is
begin

    fifo_read_ns <= fifo_read_cs;
    load_counter_sm <= '0';
    fifo_rd_pending_sm <= '0';
    stop_tready_sm <= '0';

    case fifo_read_cs is
    
         when FIFO_RD_IDLE => 
                                  if(p_fsync_out = '1') then
                                        fifo_rd_pending_sm <= '1';
                                        load_counter_sm <= '1';
                                        if (crnt_vsize = VSIZE_ONE_VALUE) then
                                          fifo_read_ns <= FIFO_RD_LAST;
                                        else
                                          fifo_read_ns <= FIFO_RD_RUNNING;
                                        end if;                                        
                                  end if;                                      
         
         when FIFO_RD_RUNNING =>                                    
                                  if (p_fsync_out = '1') then                                  
                                          if (strm_write_pending_m_axi = '0') then
                                              stop_tready_sm <= '1';
                                          end if;
                                          if (done_decr_vcount = '1' and 
                                              done_vsize_counter = VSIZE_ONE_VALUE) then
				               fifo_read_ns <= FIFO_RD_FSYNC_LAST;
				          else
                                               fifo_read_ns <= FIFO_RD_FSYNC;
				          end if; 
                                  else
                                      if (done_decr_vcount = '1' and 
                                          done_vsize_counter = VSIZE_TWO_VALUE) then
                                          fifo_read_ns <= FIFO_RD_LAST;
                                      end if;
                                  end if;
                                  fifo_rd_pending_sm <= '1';                                
         
         when FIFO_RD_FSYNC =>    
                                  if (done_decr_vcount = '1' and 
                                      done_vsize_counter = VSIZE_TWO_VALUE) then
                                     fifo_read_ns <= FIFO_RD_FSYNC_LAST;
                                  end if;
                                  fifo_rd_pending_sm <= '1';
                                  stop_tready_sm <= '1';
         
         when FIFO_RD_FSYNC_LAST =>
                                  if (done_decr_vcount = '1' ) then
                                     fifo_read_ns <= FIFO_RD_RUNNING;
                                     load_counter_sm <= '1';
                                     stop_tready_sm <= '0';
                                  end if;
                                  fifo_rd_pending_sm <= '1';
                                  stop_tready_sm <= '1';
         
         when FIFO_RD_LAST =>     
                                  if (p_fsync_out = '1') then                                  
                                      if (strm_write_pending_m_axi = '0') then
                                          stop_tready_sm <= '1';
                                      end if;
                                      if (done_decr_vcount = '1' ) then
                                         fifo_read_ns <= FIFO_RD_RUNNING;
                                         load_counter_sm <= '1';
                                      else                                             
                                         fifo_read_ns <= FIFO_RD_FSYNC_LAST;                                             
                                      end if;  
                                  else                                 
                                      if (done_decr_vcount = '1' ) then
                                         fifo_read_ns <= FIFO_RD_IDLE;
                                         fifo_rd_pending_sm <= '0';                                     
                                      end if;
                                  end if;
                                  fifo_rd_pending_sm <= '1';
         
         
         -- coverage off
          when others =>
                                 fifo_read_ns <= FIFO_RD_IDLE;
         -- coverage on
    end case;
        
 end process FIFO_SIDE_SM;


   FIFO_SIDE_SM_REG : process(m_axis_aclk) is
   begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
            if((m_axis_fifo_ainit_nosync = '1' and p_fsync_out = '0' ) or 
                dm_halt_frame = '1')then
             fifo_read_cs <= FIFO_RD_IDLE;
             load_counter <= '0';
             fifo_rd_pending <= '0';
             stop_tready <= '0';
         else
             fifo_read_cs <= fifo_read_ns;
             load_counter <= load_counter_sm;
             fifo_rd_pending <= fifo_rd_pending_sm;
             stop_tready <= stop_tready_sm;
         end if;
      end if;
   end process FIFO_SIDE_SM_REG;
   

DONE_XFER_SIG : process(m_axis_aclk)
    begin
        if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
            if(m_axis_fifo_ainit_nosync = '1' and p_fsync_out = '0')then
                s2mm_all_lines_xfred_i <= '1';
            elsif(load_counter = '1' )then
                s2mm_all_lines_xfred_i <= '0';
            elsif(done_decr_vcount = '1' and done_vsize_counter = VSIZE_ONE_VALUE)then
                s2mm_all_lines_xfred_i <= '1';
            elsif(done_decr_vcount = '1' and done_vsize_counter /= VSIZE_ZERO_VALUE)then
                s2mm_all_lines_xfred_i <= '0';
            end if;
        end if;
    end process DONE_XFER_SIG;

----end generate GEN_NO_SOF_SM; 




   all_lasts_rcvd <= not strm_write_pending_m_axi;
s2mm_fsync_core <= s2mm_fsync;
fsync_src_select_s <= (others => '0');
drop_fsync_d_pulse_gen_fsize_less_err <= '0';
hold_dummy_tready_low <= '0';
hold_dummy_tready_low2 <= '0';

end generate GEN_FSYNC_LOGIC;


--*****************************************************************************--
--**              USE FSYNC MODE                         **--
--*****************************************************************************--
GEN_NO_FSYNC_LOGIC : if ENABLE_FLUSH_ON_FSYNC = 0 generate
begin


--*****************************************************************************--

--*****************************************************************************--
--**              LINE BUFFER MODE (Sync or Async)                           **--
--*****************************************************************************--
GEN_LINEBUFFER : if C_LINEBUFFER_DEPTH /= 0 generate
begin

    -- Divide by number bytes per data beat and add padding to dynamic
    -- threshold setting
    data_count_af_threshold <= linebuf_threshold((DATACOUNT_WIDTH-1) + THRESHOLD_LSB_INDEX
                                            downto THRESHOLD_LSB_INDEX);


    -- Synchronous clock therefore instantiate an Asynchronous FIFO
    GEN_SYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
    begin
----
----	GEN_SYNC_FIFO_NO_SOF : if C_S2MM_SOF_ENABLE = 0 generate
----    begin


     
      
        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_sfifo
            generic map(
                 UW_DATA_WIDTH     => BUFFER_WIDTH        ,
          C_FULL_FLAGS_RST_VAL     => 1        ,
                 UW_FIFO_DEPTH     => BUFFER_DEPTH        ,
                 C_FAMILY          => C_FAMILY
            )
            port map(
                -- Inputs
                 rst               => s_axis_fifo_ainit_nosync   ,
                 sleep             => '0'         ,
                 wr_rst_busy       => wr_rst_busy_sig         ,
                 rd_rst_busy       => rd_rst_busy_sig         ,
                 clk               => s_axis_aclk         ,
                 wr_en             => fifo_wren           ,
                 din               => fifo_din            ,
                 rd_en             => fifo_rden           ,

                -- Outputs
                 dout              => fifo_dout           ,
                 full              => fifo_full_i         ,
                 empty             => fifo_empty_i        ,
                 data_count        => fifo_wrcount  
            );



--wr_rst_busy_sig <= '0';
--rd_rst_busy_sig <= '0';

----    end generate GEN_SYNC_FIFO_NO_SOF;
----


    end generate GEN_SYNC_FIFO;


    -- Asynchronous clock therefore instantiate an Asynchronous FIFO
    GEN_ASYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
    begin

----
----	GEN_ASYNC_FIFO_NO_SOF : if C_S2MM_SOF_ENABLE = 0 generate
----    begin
----


               
      
LB_BRAM : if ((C_ENABLE_DEBUG_INFO_9 = 1 or C_ENABLE_DEBUG_ALL = 1) )
  generate   
    begin


        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_afifo
            generic map(
                 UW_DATA_WIDTH   => BUFFER_WIDTH                    ,
          C_FULL_FLAGS_RST_VAL   => 1        ,
                 UW_FIFO_DEPTH   => BUFFER_DEPTH                    ,
                 C_FAMILY        => C_FAMILY
            )
            port map(
                 rst             => s_axis_fifo_ainit_nosync_reg    ,
                 sleep           => '0'         ,
                 wr_rst_busy     => open         ,
                 rd_rst_busy     => open         ,
                 wr_clk          => s_axis_aclk          ,
                 wr_en           => fifo_wren            ,
                 din             => fifo_din             ,
                 rd_clk          => m_axis_aclk          ,
                 rd_en           => fifo_rden            ,

                -- Outputs
                 dout            => fifo_dout            ,
                 full            => fifo_full_i          ,
                 empty           => fifo_empty_i         ,
                 wr_data_count   => fifo_wrcount         ,
                 rd_data_count   => open                 
            );

wr_rst_busy_sig <= '0';
rd_rst_busy_sig <= '0';
end generate LB_BRAM;                     

      
LB_BUILT_IN : if ( (C_ENABLE_DEBUG_INFO_9 = 0 and C_ENABLE_DEBUG_ALL = 0) )
  generate   
    begin


        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_afifo_builtin
            generic map(
                 PL_FIFO_TYPE    => "BUILT_IN"                    ,
                 PL_READ_MODE    => "FWFT"                    ,
                 PL_FASTER_CLOCK => "RD_CLK"                    , --WR_CLK
                 PL_FULL_FLAGS_RST_VAL => 0                     , -- ?
                 PL_DATA_WIDTH   => BUFFER_WIDTH                    ,
                 C_FAMILY        => C_FAMILY ,
                 PL_FIFO_DEPTH   => BUFFER_DEPTH                    
            )
            port map(
                 rst             => s_axis_fifo_ainit_nosync_reg    ,
                 sleep           => '0'         ,
                 wr_rst_busy     => wr_rst_busy_sig         ,
                 rd_rst_busy     => rd_rst_busy_sig         ,
                 wr_clk          => s_axis_aclk          ,
                 wr_en           => fifo_wren            ,
                 din             => fifo_din             ,
                 rd_clk          => m_axis_aclk          ,
                 rd_en           => fifo_rden            ,

                -- Outputs
                 dout            => fifo_dout            ,
                 full            => fifo_full_i          ,
                 empty           => fifo_empty_i         
            );

end generate LB_BUILT_IN;                     


      

----     end generate GEN_ASYNC_FIFO_NO_SOF;
----
----
----








     end generate GEN_ASYNC_FIFO;

   GEN_S2MM_DRE_ENABLED_TKEEP : if C_INCLUDE_S2MM_DRE = 1 generate
   begin


    -- AXI Slave Side of FIFO
    fifo_din            <= s_axis_tlast_i & s_axis_tkeep_i & s_axis_tdata_i;
    fifo_wren           <= s_axis_tvalid_i and  s_axis_tready_i;


    s_axis_tready_i     <= not fifo_full_i and not wr_rst_busy_sig and not s_axis_fifo_ainit;


    -- AXI Master Side of FIFO
    fifo_rden           <= m_axis_tready and m_axis_tvalid_i;
    m_axis_tvalid_i     <= not fifo_empty_i and not rd_rst_busy_sig;
    m_axis_tdata        <= fifo_dout(C_DATA_WIDTH-1 downto 0);
    m_axis_tkeep_signal <= fifo_dout(BUFFER_WIDTH-2 downto (BUFFER_WIDTH-2) - (C_DATA_WIDTH/8) + 1);
    m_axis_tlast_i      <= fifo_dout(BUFFER_WIDTH-1);


    m_axis_tlast    <= m_axis_tlast_i;
    m_axis_tvalid   <= m_axis_tvalid_i;

   end generate GEN_S2MM_DRE_ENABLED_TKEEP;

   GEN_NO_S2MM_DRE_DISABLE_TKEEP : if C_INCLUDE_S2MM_DRE = 0 generate
   begin


    -- AXI Slave Side of FIFO
    fifo_din            <= s_axis_tlast_i & s_axis_tdata_i;
    fifo_wren           <= s_axis_tvalid_i and  s_axis_tready_i;


    s_axis_tready_i     <= not fifo_full_i and not wr_rst_busy_sig and not s_axis_fifo_ainit;


    -- AXI Master Side of FIFO
    fifo_rden           <= m_axis_tready and m_axis_tvalid_i;
    m_axis_tvalid_i     <= not fifo_empty_i and not rd_rst_busy_sig;
    m_axis_tdata        <= fifo_dout(C_DATA_WIDTH-1 downto 0);
    m_axis_tkeep_signal <= (others => '1');
    m_axis_tlast_i      <= fifo_dout(BUFFER_WIDTH-1);


    m_axis_tlast    <= m_axis_tlast_i;
    m_axis_tvalid   <= m_axis_tvalid_i;



   end generate GEN_NO_S2MM_DRE_DISABLE_TKEEP;


    -- Generate start of frame fsync
    GEN_SOF_FSYNC : if C_S2MM_SOF_ENABLE = 1 generate
    begin

        TUSER_RE_PROCESS : process(s_axis_aclk)
            begin
                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                    if(s_axis_fifo_ainit_nosync = '1')then
                        s_axis_tuser_d1 <= '0';
                    else
                        s_axis_tuser_d1 <= s_axis_tuser_i(0) and s_axis_tvalid_i;
                    end if;
                end if;
            end process TUSER_RE_PROCESS;

        tuser_fsync <= s_axis_tuser_i(0) and s_axis_tvalid_i and not s_axis_tuser_d1;

    end generate GEN_SOF_FSYNC;

    -- Do not generate start of frame fsync
    GEN_NO_SOF_FSYNC : if C_S2MM_SOF_ENABLE = 0 generate
    begin
        tuser_fsync <= '0';
    end generate GEN_NO_SOF_FSYNC;

    -- Top level line buffer depth not equal to zero therefore gererate threshold
    -- flags. (
    GEN_THRESHOLD_ENABLED : if C_TOPLVL_LINEBUFFER_DEPTH /= 0   and (C_ENABLE_DEBUG_INFO_9 = 1 or C_ENABLE_DEBUG_ALL = 1)  generate
    begin

----    GEN_THRESHOLD_ENABLED_NO_SOF : if C_S2MM_SOF_ENABLE = 0 generate
----    begin




        -- Almost full flag
        -- This flag is only used by S2MM and the threshold has been adjusted to allow registering
        -- of the flag for timing and also to assert and deassert from an outside S2MM perspective

            
      
        REG_ALMST_FULL : process(s_axis_aclk)
            begin
                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                    if(s_axis_fifo_ainit = '1')then
                        fifo_almost_full_i <= '0';
                    -- write count greater than or equal to threshold value therefore assert thresold flag
                    elsif(fifo_wrcount >= s_data_count_af_thresh or (fifo_full_i='1' or wr_rst_busy_sig = '1')) then
                        fifo_almost_full_i <= '1';
                    -- In all other cases de-assert flag
                    else
                        fifo_almost_full_i <= '0';
                    end if;
                end if;
            end process REG_ALMST_FULL;




        -- Drive fifo flags out if Linebuffer included
        s2mm_fifo_almost_full   <= fifo_almost_full_i or fifo_full_i or wr_rst_busy_sig;
        s2mm_fifo_full          <= fifo_full_i or wr_rst_busy_sig;

----    end generate GEN_THRESHOLD_ENABLED_NO_SOF;







    end generate GEN_THRESHOLD_ENABLED;

    -- Top level line buffer depth is zero therefore turn off threshold logic.
    -- this occurs for async operation where the async fifo is needed for CDC (
    GEN_THRESHOLD_DISABLED  : if C_TOPLVL_LINEBUFFER_DEPTH = 0   or (C_ENABLE_DEBUG_INFO_9 = 0 and C_ENABLE_DEBUG_ALL = 0)  generate
    begin
        fifo_almost_full_i      <= '0';
        s2mm_fifo_almost_full   <= '0';
        s2mm_fifo_full          <= '0';
    end generate GEN_THRESHOLD_DISABLED;




----    GEN_MSTR_SKID_NO_SOF : if C_S2MM_SOF_ENABLE = 0 generate
----    begin

    --*********************************************************--
    --**               S2MM SLAVE SKID BUFFER                **--
    --*********************************************************--
   ---- I_MSTR_SKID : entity axi_vdma_v6_3_10.axi_vdma_skid_buf
   ----     generic map(
   ----         C_WDATA_WIDTH           => C_DATA_WIDTH             ,
   ----         C_TUSER_WIDTH           => C_S_AXIS_S2MM_TUSER_BITS
   ----     )
   ----     port map(
   ----         -- System Ports
   ----         ACLK                   => s_axis_aclk              ,
   ----         ARST                   => s_axis_fifo_ainit        ,

   ----         -- Shutdown control (assert for 1 clk pulse)
   ----         skid_stop              => '0'                      ,

   ----         -- Slave Side (Stream Data Input)
   ----         S_VALID                => slv2skid_s_axis_tvalid   ,
   ----         S_READY                => s_axis_tready_out        ,
   ----         S_Data                 => s_axis_tdata             ,
   ----         S_STRB                 => s_axis_tkeep             ,
   ----         S_Last                 => s_axis_tlast             ,
   ----         S_User                 => s_axis_tuser             ,

   ----         -- Master Side (Stream Data Output)
   ----         M_VALID                => s_axis_tvalid_i          ,
   ----         M_READY                => s_axis_tready_i          ,
   ----         M_Data                 => s_axis_tdata_i           ,
   ----         M_STRB                 => s_axis_tkeep_i           ,
   ----         M_Last                 => s_axis_tlast_i           ,
   ----         M_User                 => s_axis_tuser_i
   ----     );




s_axis_tvalid_i		<= 	slv2skid_s_axis_tvalid; 	 
s_axis_tdata_i 		<= 	s_axis_tdata;
s_axis_tkeep_i 		<= 	s_axis_tkeep_signal;
s_axis_tlast_i 		<= 	s_axis_tlast;
s_axis_tuser_i 		<= 	s_axis_tuser;

s_axis_tready_out	<= 	s_axis_tready_i; 	 





    -- Pass out top level
    -- Qualify with channel ready to 'turn off' ready
    -- at end of video frame
    s_axis_tready   <= s_axis_tready_out and chnl_ready;


    -- Qualify with channel ready to 'turn off' writes to
    -- fifo at end of video frame
    slv2skid_s_axis_tvalid <= s_axis_tvalid and chnl_ready;


end generate GEN_LINEBUFFER;

--*****************************************************************************--
--**               NO LINE BUFFER MODE (Sync Only)                           **--
--*****************************************************************************--
GEN_NO_LINEBUFFER : if (C_LINEBUFFER_DEPTH = 0) generate
begin

    m_axis_tdata        <= s_axis_tdata;
    m_axis_tkeep        <= s_axis_tkeep_signal;
    m_axis_tvalid_i     <= s_axis_tvalid and chnl_ready;
    m_axis_tlast_i      <= s_axis_tlast;


    m_axis_tvalid   <= m_axis_tvalid_i;
    m_axis_tlast    <= m_axis_tlast_i;


    s_axis_tready_i     <= m_axis_tready and chnl_ready;
    s_axis_tready_out   <= m_axis_tready and chnl_ready;
    s_axis_tready       <= s_axis_tready_i;

    -- fifo signals not used
    s2mm_fifo_full          <= '0';
    s2mm_fifo_almost_full   <= '0';


    -- Generate start of frame fsync
    GEN_SOF_FSYNC : if C_S2MM_SOF_ENABLE = 1 generate
    begin

        TUSER_RE_PROCESS : process(s_axis_aclk)
            begin
                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                    if(s_axis_fifo_ainit_nosync = '1')then
                        s_axis_tuser_d1 <= '0';
                    else
                        s_axis_tuser_d1 <= s_axis_tuser_i(0) and s_axis_tvalid_i;
                    end if;
                end if;
            end process TUSER_RE_PROCESS;

        tuser_fsync <= s_axis_tuser_i(0) and s_axis_tvalid_i and not s_axis_tuser_d1;

    end generate GEN_SOF_FSYNC;

    -- Do not generate start of frame fsync
    GEN_NO_SOF_FSYNC : if C_S2MM_SOF_ENABLE = 0 generate
    begin
        tuser_fsync <= '0';
    end generate GEN_NO_SOF_FSYNC;


end generate GEN_NO_LINEBUFFER;


-- Instantiate Clock Domain Crossing for Asynchronous clock
GEN_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin



VSIZE_CNT_CROSSING : process(s_axis_aclk)
    begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then

	   crnt_vsize_cdc_tig <= crnt_vsize;
	   crnt_vsize_d1      <= crnt_vsize_cdc_tig;

        end if;
    end process VSIZE_CNT_CROSSING;


	   crnt_vsize_d2 <= crnt_vsize_d1;



        -- Cross datamover halt and fifo threshold to secondary for reset use
----        STRM_WR_HALT_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE              => CDC_TYPE_LEVEL_P_S                           ,
----                C_VECTOR_WIDTH          => 1 
----            )
----            port map (
----                prmry_aclk              => m_axis_aclk                              ,
----                prmry_resetn            => m_axis_resetn                            ,
----                scndry_aclk             => s_axis_aclk                              ,
----                scndry_resetn           => s_axis_resetn                            ,
----                scndry_in               => '0'                                      ,
----                prmry_out               => open                                     ,
----                prmry_in                => dm_halt                                  , -- 
----                scndry_out              => dm_halt_reg                              , -- 
----                scndry_vect_s_h         => '0'                                      ,
----                scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0),
----                prmry_vect_out          => open                                     ,
----                prmry_vect_s_h          => '0'                                      ,
----                prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)                  ,
----                scndry_vect_out         => open
----            );
  
STRM_WR_HALT_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => dm_halt, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => dm_halt_reg,
        scndry_vect_out            => open
    );




THRESH_CNT_CROSSING : process(s_axis_aclk)
    begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then

	   data_count_af_threshold_cdc_tig <= data_count_af_threshold;
	   data_count_af_threshold_d1      <= data_count_af_threshold_cdc_tig;

        end if;
    end process THRESH_CNT_CROSSING;


	   s_data_count_af_thresh <= data_count_af_threshold_d1;








        -- Cross run_stop  to secondary 

----    RUNSTOP_AXIS_0_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_P_S                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axis_aclk                               ,
----            prmry_resetn            => m_axis_resetn                             ,
----            scndry_aclk             => s_axis_aclk                              ,
----            scndry_resetn           => s_axis_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => run_stop                         ,
----            scndry_out              => run_stop_reg                          ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----


RUNSTOP_AXIS_0_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => run_stop, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => run_stop_reg,
        scndry_vect_out            => open
    );





        -- 
----        FSYNC_OUT_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE              => CDC_TYPE_PULSE_S_P_OPEN_ENDED                           ,
----                C_VECTOR_WIDTH          => 1
----            )
----            port map (
----                prmry_aclk              => m_axis_aclk                              ,
----                prmry_resetn            => m_axis_resetn                            ,
----                scndry_aclk             => s_axis_aclk                              ,
----                scndry_resetn           => s_axis_resetn                            ,
----                scndry_in               => fsync_out                                ,
----                prmry_out               => p_fsync_out                              ,
----                prmry_in                => '0'                                      ,
----                scndry_out              => open                                     ,
----                scndry_vect_s_h         => '0'                                      ,
----                scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----                prmry_vect_out          => open                                     ,
----                prmry_vect_s_h          => '0'                                      ,
----                prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----                scndry_vect_out         => open
----            );
----



FSYNC_OUT_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => fsync_out, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => p_fsync_out,
        scndry_vect_out            => open
    );





        -- Cross tuser fsync to primary
----        TUSER_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE              => CDC_TYPE_PULSE_S_P_OPEN_ENDED                           ,
----                C_VECTOR_WIDTH          => 1
----            )
----            port map (
----                prmry_aclk              => m_axis_aclk                              ,
----                prmry_resetn            => m_axis_resetn                            ,
----                scndry_aclk             => s_axis_aclk                              ,
----                scndry_resetn           => s_axis_resetn                            ,
----                scndry_in               => tuser_fsync                              ,
----                prmry_out               => s2mm_tuser_fsync_sig                         ,
----                prmry_in                => '0'                                      ,
----                scndry_out              => open                                     ,
----                scndry_vect_s_h         => '0'                                      ,
----                scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----                prmry_vect_out          => open                                     ,
----                prmry_vect_s_h          => '0'                                      ,
----                prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----                scndry_vect_out         => open
----            );
----


TUSER_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => tuser_fsync, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => s2mm_tuser_fsync_sig,
        scndry_vect_out            => open
    );






end generate GEN_FOR_ASYNC;

-- Synchronous clock therefore just map signals across
GEN_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin
    crnt_vsize_d2               <= crnt_vsize;
    dm_halt_reg                 <= dm_halt;
    run_stop_reg                 <= run_stop;
    p_fsync_out                 <= fsync_out;
    s2mm_tuser_fsync_sig            <= tuser_fsync;
    s_data_count_af_thresh      <= data_count_af_threshold;

end generate GEN_FOR_SYNC;

--*****************************************************************************
--** Vertical Line Tracking
--*****************************************************************************

-- Generate vertical size counter for case when SOF not used
GEN_NO_SOF_VCOUNT : if C_S2MM_SOF_ENABLE = 0 generate
begin

    -- Decrement vertical count with each accept tlast
    decr_vcount <= '1' when s_axis_tlast = '1'
                        and s_axis_tvalid = '1'
                        and s_axis_tready_out = '1'
              else '0';

    -- Drive ready at fsync out then de-assert once all lines have
    -- been accepted.
    VERT_COUNTER : process(s_axis_aclk)
        begin
            if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
            if(s_axis_fifo_ainit = '1' and fsync_out = '0')then
                    vsize_counter   <= (others => '0');
                    chnl_ready      <= '0';
                elsif(fsync_out = '1')then
                    vsize_counter   <= crnt_vsize_d2;
                    chnl_ready      <= '1';
                elsif(decr_vcount = '1' and vsize_counter = VSIZE_ONE_VALUE)then
                    vsize_counter   <= (others => '0');
                    chnl_ready      <= '0';
                elsif(decr_vcount = '1' and vsize_counter /= VSIZE_ZERO_VALUE)then
                    vsize_counter   <= std_logic_vector(unsigned(vsize_counter) - 1);
                    chnl_ready      <= '1';
                end if;
            end if;
        end process VERT_COUNTER;

    -- decrement based on master axis signals for determining done (
    done_decr_vcount <= '1' when m_axis_tlast_i = '1'
                             and m_axis_tvalid_i = '1'
                             and m_axis_tready = '1'
              else '0';


    -- 
    DONE_VERT_COUNTER : process(m_axis_aclk)
        begin
            if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
                if(m_axis_fifo_ainit = '1' and p_fsync_out = '0')then
                    done_vsize_counter   <= (others => '0');
                    s2mm_all_lines_xfred_i <= '1';
                elsif(p_fsync_out = '1')then
                    done_vsize_counter   <= crnt_vsize;
                    s2mm_all_lines_xfred_i <= '0';

                elsif(done_decr_vcount = '1' and done_vsize_counter = VSIZE_ONE_VALUE)then
                    done_vsize_counter   <= (others => '0');
                    s2mm_all_lines_xfred_i <= '1';

                elsif(done_decr_vcount = '1' and done_vsize_counter /= VSIZE_ZERO_VALUE)then
                    done_vsize_counter   <= std_logic_vector(unsigned(done_vsize_counter) - 1);
                    s2mm_all_lines_xfred_i <= '0';

                end if;
            end if;
        end process DONE_VERT_COUNTER;



end generate GEN_NO_SOF_VCOUNT;
----
----
----
------ Generate vertical size counter for case when SOF is used
GEN_SOF_VCOUNT : if C_S2MM_SOF_ENABLE = 1 generate
begin

    chnl_ready <= run_stop_reg;

    -- decrement based on master axis signals for determining done (
    done_decr_vcount <= '1' when m_axis_tlast_i = '1'
                             and m_axis_tvalid_i = '1'
                             and m_axis_tready = '1'
              else '0';


    -- 
    DONE_VERT_COUNTER : process(m_axis_aclk)
        begin
            if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
                if(m_axis_fifo_ainit = '1' and p_fsync_out = '0')then
                    done_vsize_counter   <= (others => '0');
                    s2mm_all_lines_xfred_i <= '1';
                elsif(p_fsync_out = '1')then
                    done_vsize_counter   <= crnt_vsize;
                    s2mm_all_lines_xfred_i <= '0';

                elsif(done_decr_vcount = '1' and done_vsize_counter = VSIZE_ONE_VALUE)then
                    done_vsize_counter   <= (others => '0');
                    s2mm_all_lines_xfred_i <= '1';

                elsif(done_decr_vcount = '1' and done_vsize_counter /= VSIZE_ZERO_VALUE)then
                    done_vsize_counter   <= std_logic_vector(unsigned(done_vsize_counter) - 1);
                    s2mm_all_lines_xfred_i <= '0';

                end if;
            end if;
        end process DONE_VERT_COUNTER;


end generate GEN_SOF_VCOUNT;



s2mm_all_lines_xfred <= s2mm_all_lines_xfred_i;
all_lasts_rcvd <= s2mm_all_lines_xfred_i;
s2mm_fsync_core <= s2mm_fsync;
fsync_src_select_s <= (others => '0');
drop_fsync_d_pulse_gen_fsize_less_err <= '0';
hold_dummy_tready_low <= '0';
hold_dummy_tready_low2 <= '0';
end generate GEN_NO_FSYNC_LOGIC;









--*****************************************************************************--
--**              USE FSYNC MODE                         **--
--*****************************************************************************--
GEN_S2MM_FLUSH_SOF_LOGIC : if (ENABLE_FLUSH_ON_FSYNC = 1 and C_S2MM_SOF_ENABLE = 1) generate





signal fsync_src_select_s_int 				: std_logic_vector(1 downto 0) := (others => '0');
signal fsync_src_select_cdc_tig 			: std_logic_vector(1 downto 0) := (others => '0');
signal fsync_src_select_d1 				: std_logic_vector(1 downto 0) := (others => '0');
signal mmap_not_finished 				: std_logic := '0';
signal mmap_not_finished_s 				: std_logic := '0';
signal mm2s_fsync_s2mm_s 				: std_logic := '0';
signal s2mm_fsync_int 					: std_logic := '0';
signal s2mm_fsync_d_pulse 				: std_logic := '0';
signal delay_s2mm_fsync_core_till_mmap_done 		: std_logic := '0';
signal delay_s2mm_fsync_core_till_mmap_done_flag 	: std_logic := '0';
signal delay_s2mm_fsync_core_till_mmap_done_flag_d1 	: std_logic := '0';
signal sig_drop_fsync_d_pulse_gen_fsize_less_err 	: std_logic := '0';
signal delay_fsync_fsize_err_till_dm_halt_cmplt_s 	: std_logic := '0';
signal delay_fsync_fsize_err_till_dm_halt_cmplt_pulse_s : std_logic := '0';
signal dm_halt_cmplt_flag_s 				: std_logic := '0';
signal delay_fsync_fsize_err_till_dm_halt_cmplt_flag_s 	: std_logic := '0';
signal delay_fsync_fsize_err_till_dm_halt_cmplt_s_d1 	: std_logic := '0';
signal d_fsync_halt_cmplt_s 				: std_logic := '0';
signal fsize_err_to_dm_halt_flag 			: std_logic := '0';
signal fsize_err_to_dm_halt_flag_ored 			: std_logic := '0';

  ATTRIBUTE async_reg                      : STRING;
  ATTRIBUTE async_reg OF fsync_src_select_cdc_tig  : SIGNAL IS "true"; 
  ATTRIBUTE async_reg OF fsync_src_select_d1       : SIGNAL IS "true"; 

begin


--*****************************************************************************--

--*****************************************************************************--
--**              LINE BUFFER MODE (Sync or Async)                           **--
--*****************************************************************************--
GEN_LINEBUFFER_FLUSH_SOF : if C_LINEBUFFER_DEPTH /= 0 generate
begin

    -- Divide by number bytes per data beat and add padding to dynamic
    -- threshold setting
    data_count_af_threshold <= linebuf_threshold((DATACOUNT_WIDTH-1) + THRESHOLD_LSB_INDEX
                                            downto THRESHOLD_LSB_INDEX);


    -- Synchronous clock therefore instantiate an Asynchronous FIFO
    GEN_SYNC_FIFO_FLUSH_SOF : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
    begin

                
      
        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_sfifo
            generic map(
                 UW_DATA_WIDTH     => BUFFER_WIDTH        ,
          C_FULL_FLAGS_RST_VAL     => 1        ,
                 UW_FIFO_DEPTH     => BUFFER_DEPTH        ,
                 C_FAMILY          => C_FAMILY
            )
            port map(
                -- Inputs
                 rst               => s_axis_fifo_ainit_nosync   ,
                 sleep             => '0'         ,
                 wr_rst_busy       =>  wr_rst_busy_sig        ,
                 rd_rst_busy       =>  rd_rst_busy_sig        ,
                 clk               => s_axis_aclk         ,
                 wr_en             => fifo_wren           ,
                 din               => fifo_din            ,
                 rd_en             => fifo_rden           ,

                -- Outputs
                 dout              => fifo_dout           ,
                 full              => fifo_full_i         ,
                 empty             => fifo_empty_i        ,
                 data_count        => fifo_wrcount  
            );



--wr_rst_busy_sig <= '0';
--rd_rst_busy_sig <= '0';

    end generate GEN_SYNC_FIFO_FLUSH_SOF;


    -- Asynchronous clock therefore instantiate an Asynchronous FIFO
    GEN_ASYNC_FIFO_FLUSH_SOF : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
    begin

          
      
LB_BRAM : if ((C_ENABLE_DEBUG_INFO_9 = 1 or C_ENABLE_DEBUG_ALL = 1) )
  generate   
    begin


        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_afifo
            generic map(
                 UW_DATA_WIDTH   => BUFFER_WIDTH                    ,
          C_FULL_FLAGS_RST_VAL   => 1        ,
                 UW_FIFO_DEPTH   => BUFFER_DEPTH                    ,
                 C_FAMILY        => C_FAMILY
            )
            port map(
                 rst             => s_axis_fifo_ainit_nosync_reg    ,
                 sleep           => '0'         ,
                 wr_rst_busy     => open         ,
                 rd_rst_busy     => open         ,
                 wr_clk          => s_axis_aclk          ,
                 wr_en           => fifo_wren            ,
                 din             => fifo_din             ,
                 rd_clk          => m_axis_aclk          ,
                 rd_en           => fifo_rden            ,

                -- Outputs
                 dout            => fifo_dout            ,
                 full            => fifo_full_i          ,
                 empty           => fifo_empty_i         ,
                 wr_data_count   => fifo_wrcount         ,
                 rd_data_count   => open                 
            );

wr_rst_busy_sig <= '0';
rd_rst_busy_sig <= '0';
end generate LB_BRAM;                     

      
LB_BUILT_IN : if ((C_ENABLE_DEBUG_INFO_9 = 0 and C_ENABLE_DEBUG_ALL = 0) )
  generate   
    begin


        I_LINEBUFFER_FIFO : entity axi_vdma_v6_3_10.axi_vdma_afifo_builtin
            generic map(
                 PL_FIFO_TYPE    => "BUILT_IN"                    ,
                 PL_READ_MODE    => "FWFT"                    ,
                 PL_FASTER_CLOCK => "RD_CLK"                    , --WR_CLK
                 PL_FULL_FLAGS_RST_VAL => 0                     , -- ?
                 PL_DATA_WIDTH   => BUFFER_WIDTH                    ,
                 C_FAMILY        => C_FAMILY ,
                 PL_FIFO_DEPTH   => BUFFER_DEPTH                    
            )
            port map(
                 rst             => s_axis_fifo_ainit_nosync_reg    ,
                 sleep           => '0'         ,
                 wr_rst_busy     => wr_rst_busy_sig         ,
                 rd_rst_busy     => rd_rst_busy_sig         ,
                 wr_clk          => s_axis_aclk          ,
                 wr_en           => fifo_wren            ,
                 din             => fifo_din             ,
                 rd_clk          => m_axis_aclk          ,
                 rd_en           => fifo_rden            ,

                -- Outputs
                 dout            => fifo_dout            ,
                 full            => fifo_full_i          ,
                 empty           => fifo_empty_i         
            );

end generate LB_BUILT_IN;                     


      


     end generate GEN_ASYNC_FIFO_FLUSH_SOF;
   GEN_S2MM_DRE_ENABLED_TKEEP : if C_INCLUDE_S2MM_DRE = 1 generate
   begin


    -- AXI Slave Side of FIFO
    fifo_din            <= s_axis_tlast_i & s_axis_tkeep_i & s_axis_tdata_i;
    fifo_wren           <= s_axis_tvalid_i and  s_axis_tready_i;


    s_axis_tready_i     <= not fifo_full_i and not wr_rst_busy_sig and not s_axis_fifo_ainit;


    -- AXI Master Side of FIFO
    fifo_rden           <= m_axis_tready and m_axis_tvalid_i;
    m_axis_tvalid_i     <= not fifo_empty_i and not rd_rst_busy_sig;
    m_axis_tdata        <= fifo_dout(C_DATA_WIDTH-1 downto 0);
    m_axis_tkeep_signal <= fifo_dout(BUFFER_WIDTH-2 downto (BUFFER_WIDTH-2) - (C_DATA_WIDTH/8) + 1);
    m_axis_tlast_i      <= fifo_dout(BUFFER_WIDTH-1);


    m_axis_tlast    <= m_axis_tlast_i;
    m_axis_tvalid   <= m_axis_tvalid_i;

   end generate GEN_S2MM_DRE_ENABLED_TKEEP;

   GEN_NO_S2MM_DRE_DISABLE_TKEEP : if C_INCLUDE_S2MM_DRE = 0 generate
   begin


    -- AXI Slave Side of FIFO
    fifo_din            <= s_axis_tlast_i & s_axis_tdata_i;
    fifo_wren           <= s_axis_tvalid_i and  s_axis_tready_i;


    s_axis_tready_i     <= not fifo_full_i and not wr_rst_busy_sig and not s_axis_fifo_ainit;


    -- AXI Master Side of FIFO
    fifo_rden           <= m_axis_tready and m_axis_tvalid_i;
    m_axis_tvalid_i     <= not fifo_empty_i and not rd_rst_busy_sig;
    m_axis_tdata        <= fifo_dout(C_DATA_WIDTH-1 downto 0);
    m_axis_tkeep_signal <= (others => '1');
    m_axis_tlast_i      <= fifo_dout(BUFFER_WIDTH-1);


    m_axis_tlast    <= m_axis_tlast_i;
    m_axis_tvalid   <= m_axis_tvalid_i;



   end generate GEN_NO_S2MM_DRE_DISABLE_TKEEP;


    -- Top level line buffer depth not equal to zero therefore gererate threshold
    -- flags. (
    GEN_THRESHOLD_ENABLED_FLUSH_SOF : if C_TOPLVL_LINEBUFFER_DEPTH /= 0   and (C_ENABLE_DEBUG_INFO_9 = 1 or C_ENABLE_DEBUG_ALL = 1)  generate
    begin

        -- Almost full flag
        -- This flag is only used by S2MM and the threshold has been adjusted to allow registering
        -- of the flag for timing and also to assert and deassert from an outside S2MM perspective




      
        REG_ALMST_FULL : process(s_axis_aclk)
            begin
                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
                    if(s_axis_fifo_ainit = '1')then
                        fifo_almost_full_i <= '0';
                    -- write count greater than or equal to threshold value therefore assert thresold flag
                    elsif(fifo_wrcount >= s_data_count_af_thresh or (fifo_full_i='1' or wr_rst_busy_sig = '1')) then
                        fifo_almost_full_i <= '1';
                    -- In all other cases de-assert flag
                    else
                        fifo_almost_full_i <= '0';
                    end if;
                end if;
            end process REG_ALMST_FULL;




        -- Drive fifo flags out if Linebuffer included
        s2mm_fifo_almost_full   <= fifo_almost_full_i or fifo_full_i or wr_rst_busy_sig;
        s2mm_fifo_full          <= fifo_full_i or wr_rst_busy_sig;

    end generate GEN_THRESHOLD_ENABLED_FLUSH_SOF;

    -- Top level line buffer depth is zero therefore turn off threshold logic.
    -- this occurs for async operation where the async fifo is needed for CDC (
    GEN_THRESHOLD_DISABLED_FLUSH_SOF  : if C_TOPLVL_LINEBUFFER_DEPTH = 0   or (C_ENABLE_DEBUG_INFO_9 = 0 and C_ENABLE_DEBUG_ALL = 0)  generate
    begin
        fifo_almost_full_i      <= '0';
        s2mm_fifo_almost_full   <= '0';
        s2mm_fifo_full          <= '0';
    end generate GEN_THRESHOLD_DISABLED_FLUSH_SOF;



    --*********************************************************--
    --**               S2MM SLAVE SKID BUFFER                **--
    --*********************************************************--
--    I_MSTR_SKID_FLUSH_SOF : entity axi_vdma_v6_3_10.axi_vdma_skid_buf
--        generic map(
--            C_WDATA_WIDTH           => C_DATA_WIDTH             ,
--            C_TUSER_WIDTH           => C_S_AXIS_S2MM_TUSER_BITS
--        )
--        port map(
--            -- System Ports
--            ACLK                   => s_axis_aclk              ,
--            ARST                   => s_axis_fifo_ainit        ,
--
--            -- Shutdown control (assert for 1 clk pulse)
--            skid_stop              => '0'                      ,
--
--            -- Slave Side (Stream Data Input)
--            S_VALID                => slv2skid_s_axis_tvalid   ,
--            S_READY                => s_axis_tready_out        ,
--            S_Data                 => s_axis_tdata             ,
--            S_STRB                 => s_axis_tkeep             ,
--            S_Last                 => s_axis_tlast             ,
--            S_User                 => s_axis_tuser             ,
--
--            -- Master Side (Stream Data Output)
--            M_VALID                => s_axis_tvalid_i          ,
--            M_READY                => s_axis_tready_i          ,
--            M_Data                 => s_axis_tdata_i           ,
--            M_STRB                 => s_axis_tkeep_i           ,
--            M_Last                 => s_axis_tlast_i           ,
--            M_User                 => s_axis_tuser_i
--        );


s_axis_tvalid_i		<= 	slv2skid_s_axis_tvalid; 	 
s_axis_tdata_i 		<= 	s_axis_tdata;
s_axis_tkeep_i 		<= 	s_axis_tkeep_signal;
s_axis_tlast_i 		<= 	s_axis_tlast;
s_axis_tuser_i 		<= 	s_axis_tuser;

s_axis_tready_out	<= 	s_axis_tready_i; 	 


    -- Pass out top level
    -- Qualify with channel ready to 'turn off' ready
    -- at end of video frame
    --------s_axis_tready   <= s_axis_tready_out and chnl_ready_external;
    s_axis_tready   <= s_axis_tready_out ;


    -- Qualify with channel ready to 'turn off' writes to
    -- fifo at end of video frame
    ------slv2skid_s_axis_tvalid <= s_axis_tvalid and chnl_ready_external;
    slv2skid_s_axis_tvalid <= s_axis_tvalid ;


end generate GEN_LINEBUFFER_FLUSH_SOF;

--*****************************************************************************--
--**               NO LINE BUFFER MODE (Sync Only)                           **--
--*****************************************************************************--
GEN_NO_LINEBUFFER_FLUSH_SOF : if (C_LINEBUFFER_DEPTH = 0) generate
begin

    m_axis_tdata        <= s_axis_tdata;
    m_axis_tkeep        <= s_axis_tkeep_signal;
    m_axis_tvalid_i     <= s_axis_tvalid;
    --------------------m_axis_tvalid_i     <= s_axis_tvalid and chnl_ready_external;
    m_axis_tlast_i      <= s_axis_tlast;


    m_axis_tvalid   <= m_axis_tvalid_i;
    m_axis_tlast    <= m_axis_tlast_i;


    ----------s_axis_tready_i     <= m_axis_tready and chnl_ready_external;
    s_axis_tready_i     <= m_axis_tready;
    ---------s_axis_tready_out   <= m_axis_tready and chnl_ready_external;
    s_axis_tready_out   <= m_axis_tready;
    s_axis_tready       <= s_axis_tready_i;

    -- fifo signals not used
    s2mm_fifo_full          <= '0';
    s2mm_fifo_almost_full   <= '0';


--------------------------    -- Generate start of frame fsync
--------------------------    GEN_SOF_FSYNC : if C_S2MM_SOF_ENABLE = 1 generate
--------------------------    begin
--------------------------
--------------------------        TUSER_RE_PROCESS : process(s_axis_aclk)
--------------------------            begin
--------------------------                if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
--------------------------                    if(s_axis_fifo_ainit_nosync = '1')then
--------------------------                        s_axis_tuser_d1 <= '0';
--------------------------                    else
--------------------------                        s_axis_tuser_d1 <= s_axis_tuser_i(0) and s_axis_tvalid_i;
--------------------------                    end if;
--------------------------                end if;
--------------------------            end process TUSER_RE_PROCESS;
--------------------------
--------------------------        tuser_fsync <= s_axis_tuser_i(0) and s_axis_tvalid_i and not s_axis_tuser_d1;
--------------------------
--------------------------    end generate GEN_SOF_FSYNC;
--------------------------
--------------------------    -- Do not generate start of frame fsync
--------------------------    GEN_NO_SOF_FSYNC : if C_S2MM_SOF_ENABLE = 0 generate
--------------------------    begin
--------------------------        tuser_fsync <= '0';
--------------------------    end generate GEN_NO_SOF_FSYNC;


end generate GEN_NO_LINEBUFFER_FLUSH_SOF;


-- Instantiate Clock Domain Crossing for Asynchronous clock
GEN_FOR_ASYNC_FLUSH_SOF : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin



VSIZE_CNT_CROSSING : process(s_axis_aclk)
    begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then

	   crnt_vsize_cdc_tig <= crnt_vsize;
	   crnt_vsize_d1      <= crnt_vsize_cdc_tig;

        end if;
    end process VSIZE_CNT_CROSSING;


	   crnt_vsize_d2 <= crnt_vsize_d1;



        -- Cross datamover halt and fifo threshold to secondary for reset use
----        STRM_WR_HALT_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE              => CDC_TYPE_LEVEL_P_S                           ,
----                C_VECTOR_WIDTH          => 1 
----            )
----            port map (
----                prmry_aclk              => m_axis_aclk                              ,
----                prmry_resetn            => m_axis_resetn                            ,
----                scndry_aclk             => s_axis_aclk                              ,
----                scndry_resetn           => s_axis_resetn                            ,
----                scndry_in               => '0'                                      ,
----                prmry_out               => open                                     ,
----                prmry_in                => dm_halt                                  , -- 
----                scndry_out              => dm_halt_reg                              , -- 
----                scndry_vect_s_h         => '0'                                      ,
----                scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0),
----                prmry_vect_out          => open                                     ,
----                prmry_vect_s_h          => '0'                                      ,
----                prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)                  ,
----                scndry_vect_out         => open
----            );
  
STRM_WR_HALT_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => dm_halt, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => dm_halt_reg,
        scndry_vect_out            => open
    );




THRESH_CNT_CROSSING : process(s_axis_aclk)
    begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then

	   data_count_af_threshold_cdc_tig <= data_count_af_threshold;
	   data_count_af_threshold_d1      <= data_count_af_threshold_cdc_tig;

        end if;
    end process THRESH_CNT_CROSSING;


	   s_data_count_af_thresh <= data_count_af_threshold_d1;







        -- Cross run_stop  to secondary 

----    RUNSTOP_AXIS_0_CDC_I_FLUSH_SOF : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_P_S                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axis_aclk                               ,
----            prmry_resetn            => m_axis_resetn                             ,
----            scndry_aclk             => s_axis_aclk                              ,
----            scndry_resetn           => s_axis_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => run_stop                         ,
----            scndry_out              => run_stop_reg                          ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----


RUNSTOP_AXIS_0_CDC_I_FLUSH_SOF : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => run_stop, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => run_stop_reg,
        scndry_vect_out            => open
    );




        -- 
----        FSYNC_OUT_CDC_I_FLUSH_SOF : entity axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE              => CDC_TYPE_PULSE_S_P_OPEN_ENDED                           ,
----                C_VECTOR_WIDTH          => 1
----            )
----            port map (
----                prmry_aclk              => m_axis_aclk                              ,
----                prmry_resetn            => m_axis_resetn                            ,
----                scndry_aclk             => s_axis_aclk                              ,
----                scndry_resetn           => s_axis_resetn                            ,
----                scndry_in               => fsync_out                                ,
----                prmry_out               => p_fsync_out                              ,
----                prmry_in                => '0'                                      ,
----                scndry_out              => open                                     ,
----                scndry_vect_s_h         => '0'                                      ,
----                scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----                prmry_vect_out          => open                                     ,
----                prmry_vect_s_h          => '0'                                      ,
----                prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----                scndry_vect_out         => open
----            );
----


FSYNC_OUT_CDC_I_FLUSH_SOF : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => fsync_out, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => p_fsync_out,
        scndry_vect_out            => open
    );





        -- Cross tuser fsync to primary
----        TUSER_CDC_I_FLUSH_SOF : entity axi_vdma_v6_3_10.axi_vdma_cdc
----            generic map(
----                C_CDC_TYPE              => CDC_TYPE_PULSE_S_P_OPEN_ENDED                           ,
----                C_VECTOR_WIDTH          => 1
----            )
----            port map (
----                prmry_aclk              => m_axis_aclk                              ,
----                prmry_resetn            => m_axis_resetn                            ,
----                scndry_aclk             => s_axis_aclk                              ,
----                scndry_resetn           => s_axis_resetn                            ,
----                scndry_in               => tuser_fsync                              ,
----                prmry_out               => s2mm_tuser_fsync_sig                         ,
----                prmry_in                => '0'                                      ,
----                scndry_out              => open                                     ,
----                scndry_vect_s_h         => '0'                                      ,
----                scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,
----                prmry_vect_out          => open                                     ,
----                prmry_vect_s_h          => '0'                                      ,
----                prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,
----                scndry_vect_out         => open
----            );



TUSER_CDC_I_FLUSH_SOF : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_aclk,
        prmry_resetn               => s_axis_resetn, 
        prmry_in                   => tuser_fsync, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axis_aclk, 
        scndry_resetn              => m_axis_resetn,
        scndry_out                 => s2mm_tuser_fsync_sig,
        scndry_vect_out            => open
    );





----    MMAP_NOT_FINISHED_CDC_I_FLUSH_SOF : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_P_S                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axis_aclk                               ,
----            prmry_resetn            => m_axis_resetn                             ,
----            scndry_aclk             => s_axis_aclk                              ,
----            scndry_resetn           => s_axis_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => mmap_not_finished                         ,
----            scndry_out              => mmap_not_finished_s                          ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----


MMAP_NOT_FINISHED_CDC_I_FLUSH_SOF : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_aclk,
        prmry_resetn               => m_axis_resetn, 
        prmry_in                   => mmap_not_finished, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => mmap_not_finished_s,
        scndry_vect_out            => open
    );





GEN_FSYNC_SEL_CROSSING : process(s_axis_aclk)
    begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then

		fsync_src_select_cdc_tig <= fsync_src_select;
		fsync_src_select_d1      <= fsync_src_select_cdc_tig;

        end if;
    end process GEN_FSYNC_SEL_CROSSING;
fsync_src_select_s_int <= fsync_src_select_d1;



GEN_FOR_ASYNC_CROSS_FSYNC : if C_INCLUDE_MM2S = 1 generate
begin


----    CROSS_FSYNC_CDC_I_FLUSH_SOF : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_PULSE_P_S_OPEN_ENDED                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axis_mm2s_aclk                               ,
----            prmry_resetn            => mm2s_axis_resetn                             ,
----            scndry_aclk             => s_axis_aclk                              ,
----            scndry_resetn           => s_axis_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => mm2s_fsync                         ,
----            scndry_out              => mm2s_fsync_s2mm_s                          ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----


CROSS_FSYNC_CDC_I_FLUSH_SOF : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axis_mm2s_aclk,
        prmry_resetn               => mm2s_axis_resetn, 
        prmry_in                   => mm2s_fsync, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_aclk, 
        scndry_resetn              => s_axis_resetn,
        scndry_out                 => mm2s_fsync_s2mm_s,
        scndry_vect_out            => open
    );




end generate GEN_FOR_ASYNC_CROSS_FSYNC;

GEN_FOR_ASYNC_NO_CROSS_FSYNC : if C_INCLUDE_MM2S = 0 generate
begin

mm2s_fsync_s2mm_s <= '0';

end generate GEN_FOR_ASYNC_NO_CROSS_FSYNC;


end generate GEN_FOR_ASYNC_FLUSH_SOF;



-- Synchronous clock therefore just map signals across
GEN_FOR_SYNC_FLUSH_SOF : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin
    crnt_vsize_d2               <= crnt_vsize;
    mmap_not_finished_s         <= mmap_not_finished;
    fsync_src_select_s_int          <= fsync_src_select;
    dm_halt_reg                 <= dm_halt;
    --dm_halt_cmplt_s                 <= dm_halt_cmplt;
    run_stop_reg                <= run_stop;
    p_fsync_out                 <= fsync_out;
    s2mm_tuser_fsync_sig        <= tuser_fsync;
    s_data_count_af_thresh      <= data_count_af_threshold;


GEN_FOR_SYNC_CROSS_FSYNC : if C_INCLUDE_MM2S = 1 generate
begin

    mm2s_fsync_s2mm_s           <= mm2s_fsync;

end generate GEN_FOR_SYNC_CROSS_FSYNC;

GEN_FOR_SYNC_NO_CROSS_FSYNC : if C_INCLUDE_MM2S = 0 generate
begin

mm2s_fsync_s2mm_s <= '0';

end generate GEN_FOR_SYNC_NO_CROSS_FSYNC;




end generate GEN_FOR_SYNC_FLUSH_SOF;

--*****************************************************************************
--** Vertical Line Tracking
--*****************************************************************************

-----------------------GEN_SOF_VCOUNT : if C_S2MM_SOF_ENABLE = 1 generate
-----------------------begin


    -- decrement based on master axis signals for determining done (
    done_decr_vcount <= '1' when m_axis_tlast_i = '1'
                             and m_axis_tvalid_i = '1'
                             and m_axis_tready = '1'
              else '0';


    -- 
    DONE_VERT_COUNTER_FLUSH_SOF : process(m_axis_aclk)
        begin
            if(m_axis_aclk'EVENT and m_axis_aclk = '1')then
                if((m_axis_fifo_ainit = '1' and p_fsync_out = '0') or s2mm_fsize_mismatch_err_flag = '1')then
                    done_vsize_counter   <= (others => '0');
                    mmap_not_finished <= '0';
                elsif(p_fsync_out = '1')then
                    done_vsize_counter   <= crnt_vsize;
                    mmap_not_finished <= '1';

                elsif(done_decr_vcount = '1' and done_vsize_counter = VSIZE_ONE_VALUE)then
                    done_vsize_counter   <= (others => '0');
                    mmap_not_finished <= '0';

                elsif(done_decr_vcount = '1' and done_vsize_counter /= VSIZE_ZERO_VALUE)then
                    done_vsize_counter   <= std_logic_vector(unsigned(done_vsize_counter) - 1);
                    mmap_not_finished <= '1';

                end if;
            end if;
        end process DONE_VERT_COUNTER_FLUSH_SOF;


delay_s2mm_fsync_core_till_mmap_done    <= '1'  when  mmap_not_finished_s = '1' and  strm_not_finished = '0' and s2mm_fsync_int = '1' and delay_s2mm_fsync_core_till_mmap_done_flag = '0'
                                    else '0';


hold_dummy_tready_low <= delay_s2mm_fsync_core_till_mmap_done or delay_s2mm_fsync_core_till_mmap_done_flag;

HOLD_DELAY_FSYNC_IN_FLAG : process(s_axis_aclk)
    begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
            if(s_axis_resetn = '0' or mmap_not_finished_s = '0' or sig_drop_fsync_d_pulse_gen_fsize_less_err = '1')then
                delay_s2mm_fsync_core_till_mmap_done_flag  <= '0';
            elsif(delay_s2mm_fsync_core_till_mmap_done = '1')then
                delay_s2mm_fsync_core_till_mmap_done_flag  <= '1';
            end if;
        end if;
    end process HOLD_DELAY_FSYNC_IN_FLAG;



D1_HOLD_DELAY_FSYNC_IN_FLAG : process(s_axis_aclk)
    begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
            if(s_axis_resetn = '0' or sig_drop_fsync_d_pulse_gen_fsize_less_err = '1')then
                delay_s2mm_fsync_core_till_mmap_done_flag_d1  <= '0';
            else
                delay_s2mm_fsync_core_till_mmap_done_flag_d1  <= delay_s2mm_fsync_core_till_mmap_done_flag;
            end if;
        end if;
    end process D1_HOLD_DELAY_FSYNC_IN_FLAG;


s2mm_fsync_d_pulse <= delay_s2mm_fsync_core_till_mmap_done_flag_d1 and (not delay_s2mm_fsync_core_till_mmap_done_flag) ;





s2mm_fsync_core <= (s2mm_fsync_int and not (delay_s2mm_fsync_core_till_mmap_done) and not (delay_fsync_fsize_err_till_dm_halt_cmplt_pulse_s)) or s2mm_fsync_d_pulse or d_fsync_halt_cmplt_s;


sig_drop_fsync_d_pulse_gen_fsize_less_err    <= '1'  when  delay_s2mm_fsync_core_till_mmap_done_flag = '1' and s2mm_fsync_int = '1'
                                        else '0';




GEN_FOR_C_USE_S2MM_FSYNC_1 : if C_USE_S2MM_FSYNC = 1 generate
begin
                 s2mm_fsync_int <= s2mm_fsync and run_stop_reg and no_fsync_before_vsize_sel_00_01;

end generate GEN_FOR_C_USE_S2MM_FSYNC_1;


GEN_FOR_C_USE_S2MM_FSYNC_2 : if C_USE_S2MM_FSYNC = 2 generate
begin
                 s2mm_fsync_int <= s2mm_tuser_fsync_top and run_stop_reg;

end generate GEN_FOR_C_USE_S2MM_FSYNC_2;




        -- Frame sync cross bar
------        FSYNC_CROSSBAR_S2MM_S : process(fsync_src_select_s_int,
------                                 run_stop_reg,
------                                 s2mm_fsync,
------                                 mm2s_fsync_s2mm_s, no_fsync_before_vsize_sel_00_01,
------                                 s2mm_tuser_fsync_top)
------            begin
------                case fsync_src_select_s_int is
------
------                    when "00" =>   -- primary fsync (default)
------                        s2mm_fsync_int <= s2mm_fsync and run_stop_reg and no_fsync_before_vsize_sel_00_01;
------                    when "01" =>   -- other channel fsync
------                        s2mm_fsync_int <= mm2s_fsync_s2mm_s and run_stop_reg and no_fsync_before_vsize_sel_00_01;
------                    when "10" =>   -- s2mm_tuser_fsync_top fsync  (used only by s2mm)
------                        s2mm_fsync_int <= s2mm_tuser_fsync_top and run_stop_reg;
------                    when others =>
------                        s2mm_fsync_int <= '0';
------                end case;
------            end process FSYNC_CROSSBAR_S2MM_S;
------

-----------------------end generate GEN_SOF_VCOUNT;


S2MM_FSIZE_ERR_TO_DM_HALT_FLAG : process(s_axis_aclk)
    begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
            if(s_axis_resetn = '0' or dm_halt_reg = '1')then
                fsize_err_to_dm_halt_flag  <= '0';
            elsif(s2mm_fsize_mismatch_err_s = '1')then
                fsize_err_to_dm_halt_flag  <= '1';
            end if;
        end if;
    end process S2MM_FSIZE_ERR_TO_DM_HALT_FLAG;



fsize_err_to_dm_halt_flag_ored <= s2mm_fsize_mismatch_err_s or fsize_err_to_dm_halt_flag or dm_halt_reg;



delay_fsync_fsize_err_till_dm_halt_cmplt_pulse_s    <= '1'  when  fsize_err_to_dm_halt_flag_ored = '1' and s2mm_fsync_int = '1' 
                                    else '0';


FSIZE_LESS_DM_HALT_CMPLT_FLAG : process(s_axis_aclk)
    begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
            if(s_axis_resetn = '0' or fsize_err_to_dm_halt_flag_ored = '0')then
                delay_fsync_fsize_err_till_dm_halt_cmplt_flag_s  <= '0';
            elsif(delay_fsync_fsize_err_till_dm_halt_cmplt_pulse_s = '1')then
                delay_fsync_fsize_err_till_dm_halt_cmplt_flag_s  <= '1';
            end if;
        end if;
    end process FSIZE_LESS_DM_HALT_CMPLT_FLAG;

REG_D_FSYNC : process(s_axis_aclk)
    begin
        if(s_axis_aclk'EVENT and s_axis_aclk = '1')then
            if(s_axis_resetn = '0')then
                delay_fsync_fsize_err_till_dm_halt_cmplt_s_d1  <= '0';
            else
                delay_fsync_fsize_err_till_dm_halt_cmplt_s_d1  <= delay_fsync_fsize_err_till_dm_halt_cmplt_flag_s;
            end if;
        end if;
    end process REG_D_FSYNC;


d_fsync_halt_cmplt_s <= delay_fsync_fsize_err_till_dm_halt_cmplt_s_d1 and not delay_fsync_fsize_err_till_dm_halt_cmplt_flag_s;


hold_dummy_tready_low2 <= delay_fsync_fsize_err_till_dm_halt_cmplt_pulse_s or delay_fsync_fsize_err_till_dm_halt_cmplt_flag_s;


s2mm_all_lines_xfred <= '0';
all_lasts_rcvd <= '0';
tuser_fsync <= '0';
fsync_src_select_s <= fsync_src_select_s_int;
drop_fsync_d_pulse_gen_fsize_less_err <= sig_drop_fsync_d_pulse_gen_fsize_less_err;

end generate GEN_S2MM_FLUSH_SOF_LOGIC;





end implementation;


-------------------------------------------------------------------------------
--axi_vdma_blkmem.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_blkmem.vhd
--
-- Description:     This file is the top level wrapper for properly configuring
--                  and calling blk_mem_gen_wrapper
--
--
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
-- Library definitions

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library lib_bmg_v1_0_13;
use lib_bmg_v1_0_13.blk_mem_gen_wrapper;
library xpm;
--use proc_common_v4_0.family_support.all;

-------------------------------------------------------------------------------
entity axi_vdma_blkmem is
    generic (
        C_DATA_WIDTH        : integer := 32;
        C_ADDR_WIDTH        : integer := 9;
        C_SELECT_XPM        : integer := 1;
        C_FAMILY            : string  := "virtex7"
      );
    port(
        Clk         : in  std_logic                             ;--
        Rst         : in  std_logic                             ;--
                                                                 --
                                                                 --
        -- Write Port signals                                    --
        Wr_Enable   : in  std_logic                             ;--
        Wr_Req      : in  std_logic                             ;--
        Wr_Address  : in  std_logic_vector(0 to C_ADDR_WIDTH-1) ;--
        Wr_Data     : in  std_logic_vector(0 to C_DATA_WIDTH-1) ;--
                                                                 --
        -- Read Port Signals                                     --
        Rd_Enable   : in  std_logic                             ;--
        Rd_Address  : in  std_logic_vector(0 to C_ADDR_WIDTH-1) ;--
        Rd_Data     : out std_logic_vector(0 to C_DATA_WIDTH-1)  --
    );
end axi_vdma_blkmem ;

-------------------------------------------------------------------------------

architecture implementation of axi_vdma_blkmem is

attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


component  xpm_memory_tdpram
  generic (
  MEMORY_SIZE         : integer :=  4096;
  MEMORY_PRIMITIVE    : string  :=  "blockram";
  CLOCKING_MODE       : string  :=  "common_clock";
  ECC_MODE            : string  :=  "no_ecc";
  MEMORY_INIT_FILE    : string  :=  "none";
  WAKEUP_TIME         : string  :=  "disable_sleep";
  MESSAGE_CONTROL     : integer :=  0;

  WRITE_DATA_WIDTH_A  : integer :=  32;
  READ_DATA_WIDTH_A   : integer :=  32;
  BYTE_WRITE_WIDTH_A  : integer :=  32;
  ADDR_WIDTH_A        : integer :=  12;
  READ_RESET_VALUE_A  : string  := "0";
  READ_LATENCY_A      : integer :=  1;
  WRITE_MODE_A        : string  :=  "write_first";

  WRITE_DATA_WIDTH_B  : integer :=  32;
  READ_DATA_WIDTH_B   : integer :=  32;
  BYTE_WRITE_WIDTH_B  : integer :=  32;
  ADDR_WIDTH_B        : integer :=  12;
  READ_RESET_VALUE_B  : string  := "0";
  READ_LATENCY_B      : integer :=  1;
  WRITE_MODE_B        : string  :=  "write_first"

); 
  port (

  -- Common module ports
   sleep              : in std_logic;

  -- Port A module ports
   clka               : in std_logic;
   rsta               : in std_logic;
   ena                : in std_logic;
   regcea             : in std_logic;
   wea                : in std_logic_vector (0 downto 0);
   addra              : in std_logic_vector (0 to C_ADDR_WIDTH-1); 
   dina               : in std_logic_vector (0 to C_DATA_WIDTH-1);
   injectsbiterra     : in std_logic;
   injectdbiterra     : in std_logic;
   douta              : out std_logic_vector(0 to C_DATA_WIDTH-1);              
   sbiterra           : out std_logic;
   dbiterra           : out std_logic;

-- Port B module ports
   clkb               : in std_logic;
   rstb               : in std_logic;
   enb                : in std_logic;
   regceb             : in std_logic;
   web                : in std_logic_vector (0 downto 0);
   addrb              : in std_logic_vector (0 to C_ADDR_WIDTH-1);
   dinb               : in std_logic_vector (0 to C_DATA_WIDTH-1); 
   injectsbiterrb     : in std_logic;
   injectdbiterrb     : in std_logic;
   doutb              : out std_logic_vector(0 to C_DATA_WIDTH-1);               
   sbiterrb           : out std_logic;
   dbiterrb           : out std_logic
  );
end component;

-------------------------------------------------------------------------------
-- Function Declarations
-------------------------------------------------------------------------------
function get_bram_primitive (target_width: integer)
           return integer is
variable primitive_blk_mem : integer;
constant prim_type_1bit         : integer := 0;     -- ( 1-bit wide)
constant prim_type_2bit         : integer := 1;     -- ( 2-bit wide)
constant prim_type_4bit         : integer := 2;     -- ( 4-bit wide)
constant prim_type_9bit         : integer := 3;     -- ( 9-bit wide)
constant prim_type_18bit        : integer := 4;     -- (18-bit wide)
constant prim_type_36bit        : integer := 5;     -- (36-bit wide)
constant prim_type_72bit        : integer := 6;     -- (72-bit wide, single port only)
begin
    case target_width Is
        when 1  =>
            primitive_blk_mem  := prim_type_1bit;

        when 2  =>
            primitive_blk_mem  := prim_type_2bit;

        when 3 | 4  =>
            primitive_blk_mem  := prim_type_4bit;

        when 5 | 6 | 7 | 8 | 9  =>
            primitive_blk_mem  := prim_type_9bit;

        when 10 | 11 | 12 | 13 | 14 |
          15 | 16 | 17 | 18  =>
            primitive_blk_mem  := prim_type_18bit;

        when others   =>
            primitive_blk_mem  := prim_type_36bit;
    end case;
    return primitive_blk_mem;
end function get_bram_primitive;

----------------------------------------------------------------------------
-- Constants Declarations
----------------------------------------------------------------------------
constant PRIM_TYPE              : integer := get_bram_primitive(C_DATA_WIDTH);
constant MEM_TYPE               : integer := 2;     -- True dual port RAM

-- Determine the number of BRAM storage locations needed
constant FIFO_DEPTH             : integer := 2**C_ADDR_WIDTH;

-------------------------------------------------------------------------------
-- Signal Declarations
-------------------------------------------------------------------------------
signal port_a_addr              : std_logic_vector(C_ADDR_WIDTH-1 downto 0);
signal port_a_data_in           : std_logic_vector(C_DATA_WIDTH-1 downto 0);
signal port_a_enable            : std_logic;
signal port_a_wr_enable         : std_logic_vector(0 downto 0);

signal port_b_addr              : std_logic_vector(C_ADDR_WIDTH-1 downto 0);
signal port_b_data_in           : std_logic_vector(C_DATA_WIDTH-1 downto 0);
signal port_b_data_out          : std_logic_vector(C_DATA_WIDTH-1 downto 0);
signal port_b_enable            : std_logic;
signal port_b_wr_enable         : std_logic_vector(0 downto 0);

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------

begin

-- translate big-endian and little_endian indexes of the
-- data buses
TRANSLATE_DATA : process (Wr_Data, port_b_data_out)
    begin

        port_a_data_in <= (others => '0');
        for i in C_DATA_WIDTH-1 downto 0 loop
            port_a_data_in(i)          <= Wr_Data(C_DATA_WIDTH-1-i);
            Rd_Data(C_DATA_WIDTH-1-i)  <= port_b_data_out(i);
        end loop;

end process TRANSLATE_DATA;


-- translate big-endian and little_endian indexes of the
-- address buses (makes simulation easier)
TRANSLATE_ADDRESS : process (Wr_Address, Rd_Address)
begin

    port_a_addr <= (others => '0');
    port_b_addr <= (others => '0');
    for i in C_ADDR_WIDTH-1 downto 0 loop
        port_a_addr(i)   <=  Wr_Address(C_ADDR_WIDTH-1-i);
        port_b_addr(i)   <=  Rd_Address(C_ADDR_WIDTH-1-i);
    end loop;

end process TRANSLATE_ADDRESS;

port_a_enable           <= Wr_Enable;
port_a_wr_enable(0)     <= Wr_Req;

port_b_enable           <= Rd_Enable;
port_b_data_in          <= (others => '0');
port_b_wr_enable        <= (others => '0');

xpm_mem_gen : if (C_SELECT_XPM = 1) generate 
xpm_memory_inst: xpm_memory_tdpram

   generic map (
      MEMORY_SIZE             =>  FIFO_DEPTH*C_DATA_WIDTH,
      MEMORY_PRIMITIVE        =>  "blockram",
      CLOCKING_MODE           =>  "common_clock",
      ECC_MODE                =>  "no_ecc",
      MEMORY_INIT_FILE        =>  "none",
      WAKEUP_TIME             =>  "disable_sleep",
      MESSAGE_CONTROL         =>  1,

      WRITE_DATA_WIDTH_A      =>  C_DATA_WIDTH,
      READ_DATA_WIDTH_A       =>  C_DATA_WIDTH,
      BYTE_WRITE_WIDTH_A      =>  C_DATA_WIDTH,
      ADDR_WIDTH_A            =>  C_ADDR_WIDTH, 
      READ_RESET_VALUE_A      =>  "0",
      READ_LATENCY_A          =>  1,
      WRITE_MODE_A            =>  "write_first",

      WRITE_DATA_WIDTH_B      =>  C_DATA_WIDTH,
      READ_DATA_WIDTH_B       =>  C_DATA_WIDTH,
      BYTE_WRITE_WIDTH_B      =>  C_DATA_WIDTH,
      ADDR_WIDTH_B            =>  C_ADDR_WIDTH,
      READ_RESET_VALUE_B      =>  "0",
      READ_LATENCY_B          =>  1,
      WRITE_MODE_B            =>  "write_first"
      )
      port map (
       -- Common module ports
      sleep                   =>  '0',
    
     -- Port A module ports
      clka                    => Clk,
      rsta                    => Rst, 
      ena                     => port_a_enable, 
      regcea                  => '0',
      wea                     => port_a_wr_enable,
      addra                   => port_a_addr,
      dina                    => port_a_data_in,
      injectsbiterra          => '0',
      injectdbiterra          => '0',
      douta                   => open,
      sbiterra                => open,
      dbiterra                => open,
    
     -- Port B module ports
      clkb                    => Clk,
      rstb                    => Rst,
      enb                     => port_b_enable,
      regceb                  => '0',
      web                     => port_b_wr_enable,
      addrb                   => port_b_addr,
      dinb                    => port_b_data_in,
      injectsbiterrb          => '0',
      injectdbiterrb          => '0',
      doutb                   => port_b_data_out,
      sbiterrb                => open,
      dbiterrb                => open
      );
end generate;

blk_mem_gen : if (C_SELECT_XPM = 0) generate
-- For V6 and S6 use block memory generator to
-- generate BRAM
I_BLK_MEM : entity lib_bmg_v1_0_13.blk_mem_gen_wrapper
    generic map (
        c_family                  =>  C_FAMILY,
        c_xdevicefamily           =>  C_FAMILY,
        c_mem_type                =>  MEM_TYPE,
        c_algorithm               =>  1,
        c_prim_type               =>  PRIM_TYPE,
        c_byte_size               =>  8,
        c_sim_collision_check     =>  "All",
        c_common_clk              =>  1,
        c_disable_warn_bhv_coll   =>  0,
        c_disable_warn_bhv_range  =>  0,

        c_load_init_file          =>  0,
        c_init_file_name          =>  "no_coe_file_loaded",
        c_use_default_data        =>  0,
        c_default_data            =>  "0",

        -- Port A Settings
        c_has_mem_output_regs_a   =>  0,
        c_has_mux_output_regs_a   =>  0,
        c_write_width_a           =>  C_DATA_WIDTH,
        c_read_width_a            =>  C_DATA_WIDTH,
        c_write_depth_a           =>  FIFO_DEPTH,
        c_read_depth_a            =>  FIFO_DEPTH,
        c_addra_width             =>  C_ADDR_WIDTH,
        c_write_mode_a            =>  "WRITE_FIRST",
        c_has_ena                 =>  1,
        c_has_regcea              =>  0,
        c_has_ssra                =>  0,
        c_sinita_val              =>  "0",

        c_use_byte_wea            =>  0,
        c_wea_width               =>  1,

        -- Port B Settings
        c_has_mem_output_regs_b   =>  0,
        c_has_mux_output_regs_b   =>  0,
        c_write_width_b           =>  C_DATA_WIDTH,
        c_read_width_b            =>  C_DATA_WIDTH,
        c_write_depth_b           =>  FIFO_DEPTH,
        c_read_depth_b            =>  FIFO_DEPTH,
        c_addrb_width             =>  C_ADDR_WIDTH,
        c_write_mode_b            =>  "WRITE_FIRST",
        c_has_enb                 =>  1,
        c_has_regceb              =>  0,
        c_has_ssrb                =>  0,
        c_sinitb_val              =>  "0",
        c_use_byte_web            =>  0,
        c_web_width               =>  1,

        -- Misc Settings
        c_mux_pipeline_stages     =>  0,
        c_use_ecc                 =>  0,
        c_use_ramb16bwer_rst_bhv  =>  0        -- No use of S3A DSP embedded RAM primitives
    )
    port map (
        clka      =>  Clk                       ,
        ssra      =>  Rst                       ,
        dina      =>  port_a_data_in            ,
        addra     =>  port_a_addr               ,
        ena       =>  port_a_enable             ,
        regcea    =>  '0'                       ,
        wea       =>  port_a_wr_enable          ,
        douta     =>  open                      ,

        clkb      =>  Clk                       ,
        ssrb      =>  Rst                       ,
        dinb      =>  port_b_data_in            ,
        addrb     =>  port_b_addr               ,
        enb       =>  port_b_enable             ,
        regceb    =>  '0'                       ,
        web       =>  port_b_wr_enable          ,
        doutb     =>  port_b_data_out           ,

        dbiterr   =>  open                      ,       -- No ECC
        sbiterr   =>  open                              -- No ECC
);
end generate;
end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_fsync_gen
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_vdma_fsync_gen.vhd
-- Description: This entity generates the frame sync for vdma operations.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_fsync_gen is
    generic (
        C_USE_FSYNC                 	: integer range 0 to 1        := 0;
            -- Specifies DMA oeration synchronized to frame sync input
            -- 0 = Free running
            -- 1 = Fsync synchronous

        ENABLE_FLUSH_ON_MM2S_FSYNC      : integer range 0 to 1        := 0      ;
        ENABLE_FLUSH_ON_S2MM_FSYNC      : integer range 0 to 1        := 0      ;
        C_INCLUDE_S2MM                  : integer range 0 to 1        := 0      ;
        C_INCLUDE_MM2S                  : integer range 0 to 1        := 0      ;
        
        C_SOF_ENABLE                	: integer range 0 to 1        := 0
            -- Enable/Disable start of frame generation on tuser(0). This
            -- is only valid for external frame sync (C_USE_FSYNC = 1)
            -- 0 = disable SOF
            -- 1 = enable SOF
    );
    port (
        prmry_aclk                  : in  std_logic                         ;           --
        prmry_resetn                : in  std_logic                         ;           --
                                                                                        --
        -- Frame Count Enable Support                                                   --
        valid_video_prmtrs          : in  std_logic                         ;           --
        valid_frame_sync_cmb        : in  std_logic                         ;           --
        frmcnt_ioc                  : in  std_logic                         ;           --
        dmacr_frmcnt_enbl           : in  std_logic                         ;           --
        dmasr_frmcnt_status         : in  std_logic_vector(7 downto 0)      ;           --
        mask_fsync_out              : out std_logic                         ;           --
                                                                                        --
        -- VDMA status for free run (C_USE_FSYNC = 0)                                   --
        run_stop                    : in  std_logic                         ;           --
        all_idle                    : in  std_logic                         ;           --
        parameter_update            : in  std_logic                         ;           --
                                                                                        --
        -- Frame Sync Sources (C_USE_FSYNC = 1)                                         --
        fsync                       : in  std_logic                         ;           --
        tuser_fsync                 : in  std_logic                         ;           --
        othrchnl_fsync              : in  std_logic                         ;           --
        fsync_src_select            : in  std_logic_vector(1 downto 0)      ;           --
                                                                                        --
        -- Sync out for VDMA logic                                                      --
        frame_sync                  : out std_logic                         ;           --
                                                                                        --
        -- Sync / Update out top level for Video IP                                     --
        frame_sync_out              : out std_logic                         ;           --
        prmtr_update                : out std_logic                                     --


    );

end axi_vdma_fsync_gen;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_fsync_gen is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

constant FRAME_COUNT_ONE : std_logic_vector(7 downto 0) := std_logic_vector(to_unsigned(1,8));

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------

-- No Signals Declared

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

-------------------------------------------------------------------------------
-- Generate Free Run Mode (Internal Frame Sync)
-------------------------------------------------------------------------------
GEN_FREE_RUN_MODE : if C_USE_FSYNC = 0 generate
-- For internal fsync generation
signal all_idle_d1          : std_logic := '0';
signal all_idle_d2          : std_logic := '0';
signal all_idle_re          : std_logic := '0';

-- For internal fsync and fsync out
signal frame_sync_aligned   : std_logic := '0';
signal frame_sync_i         : std_logic := '0';
signal mask_fsync_out_i     : std_logic := '0';
begin

    -- Register all idle for use in creating rising edge pulse
    REG_IDLE : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                -- On reset clear flag
                if(prmry_resetn = '0')then
                    all_idle_d1  <= '0';
                    all_idle_d2  <= '0';
                -- Otherwise pass idle state through to gen re pulse
                else
                    all_idle_d1  <= all_idle;
                    all_idle_d2  <= all_idle_d1;
                end if;
            end if;
        end process REG_IDLE;

    all_idle_re <= all_idle_d1 and not all_idle_d2;

    -- Register frame sync source to shift all processes started
    -- by fsync 1 clock later in time.  This allows initial FrameDelay
    -- and resulting calculation to be registered before
    -- being latched by frame_sync.
    REG_FSYNC_PROCESS : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    frame_sync_i <= '0';
                else
                    frame_sync_i <= all_idle_re and run_stop;
                end if;
            end if;
        end process REG_FSYNC_PROCESS;

    -- Pass out for internal use (secondary clock domain)
    frame_sync  <= frame_sync_i;

    -- For frame count enable, mask fsync out at end of frame.
    FRAME_SYNC_MASK : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then

                    mask_fsync_out_i <= '0';

                -- If masked and ioc occurs then clear mask
                elsif(mask_fsync_out_i = '1' and frmcnt_ioc = '1')then
                    mask_fsync_out_i <= '0';

                -- On frame count enable at end of last frame mask off last fsync out
                elsif(dmacr_frmcnt_enbl = '1' and dmasr_frmcnt_status = FRAME_COUNT_ONE and valid_frame_sync_cmb = '1')then
                    mask_fsync_out_i <= '1';

                end if;
            end if;
        end process FRAME_SYNC_MASK;

    mask_fsync_out  <= mask_fsync_out_i or not valid_video_prmtrs;

    -------------------------------------------------------------------
    -- GENERATE FSYNC OUT FOR VIDEO IP
    -------------------------------------------------------------------
    -- Align internal fsync with parameter update.  Parameter update
    -- asserts on next clock after frame_sync therefor by adding 1
    -- pipe of delay we align parameter_update input with frame_sync
    REG_DELAY_FSYNC : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                -- clear on reset or s_h clear
                if(prmry_resetn = '0')then
                    frame_sync_aligned <= '0';
                else
                    frame_sync_aligned <= frame_sync_i;
                end if;
            end if;
        end process REG_DELAY_FSYNC;

    -- Provide output of frame sync to target Video IP.
    REG_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    frame_sync_out <= '0';
                else
                    frame_sync_out  <= frame_sync_aligned and not mask_fsync_out_i and valid_video_prmtrs;
                end if;
            end if;
        end process REG_FSYNC_OUT;

    -------------------------------------------------------------------
    -- GENERATE PARAMETER UPDATE OUT FOR VIDEO IP
    -------------------------------------------------------------------
    -- Provide output of video parameter update to target Video IP.
    REG_PRMTRUPDT_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    prmtr_update   <= '0';
                else
                    prmtr_update   <= parameter_update and not mask_fsync_out_i;
                end if;
            end if;
        end process REG_PRMTRUPDT_OUT;


end generate GEN_FREE_RUN_MODE;


-------------------------------------------------------------------------------
-- Generate Frame Sync Mode (External frame sync)
-------------------------------------------------------------------------------
-- Note: Treated async and sync clock modes as async so fsync out behavior is
-- identical regardless of mode.
GEN_FSYNC_MODE_MM2S_NO_SOF : if (C_USE_FSYNC = 1 and C_INCLUDE_MM2S = 1 and (ENABLE_FLUSH_ON_MM2S_FSYNC = 0 or C_SOF_ENABLE = 0)) generate
-- Frame sync for VDMA and for core output
signal frame_sync_i         : std_logic := '0';
signal frame_sync_aligned   : std_logic := '0';
signal mask_fsync_out_i     : std_logic := '0';


begin
        -- Frame sync cross bar
        FSYNC_CROSSBAR : process(fsync_src_select,
                                 run_stop,
                                 fsync,
                                 othrchnl_fsync)
            begin
                case fsync_src_select is

                    when "00" =>   -- primary fsync (default)
                        frame_sync_i <= fsync and run_stop;
                    when "01" =>   -- other channel fsync
                        frame_sync_i <= othrchnl_fsync and run_stop;
                    when others =>
                        frame_sync_i <= '0';
                end case;
            end process FSYNC_CROSSBAR;

----    end generate GEN_FSYNC_NO_SOF;


    -- Pass out for VDMA use
    frame_sync <= frame_sync_i;

    -- For frame count enable, mask fsync out at end of frame.
    FRAME_SYNC_MASK : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then

                    mask_fsync_out_i <= '0';

                -- If masked and ioc occurs then clear mask
                elsif(mask_fsync_out_i = '1' and frmcnt_ioc = '1')then
                    mask_fsync_out_i <= '0';

                -- On frame count enable at end of last frame mask off last fsync out
                elsif(dmacr_frmcnt_enbl = '1' and dmasr_frmcnt_status = FRAME_COUNT_ONE and valid_frame_sync_cmb = '1')then
                    mask_fsync_out_i <= '1';

                end if;
            end if;
        end process FRAME_SYNC_MASK;

    mask_fsync_out  <= mask_fsync_out_i or not valid_video_prmtrs;

    -------------------------------------------------------------------
    -- GENERATE FSYNC OUT FOR VIDEO IP
    -------------------------------------------------------------------
    -- Align internal fsync with parameter update.  Parameter update
    -- asserts on next clock after frame_sync therefor by adding 1
    -- pipe of delay we align parameter_update input with frame_sync
    REG_DELAY_FSYNC : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                -- clear on reset or s_h clear
                if(prmry_resetn = '0')then
                    frame_sync_aligned <= '0';
                else
                    frame_sync_aligned <= frame_sync_i;
                end if;
            end if;
        end process REG_DELAY_FSYNC;

    -- Provide output of frame sync to target Video IP.
    REG_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    frame_sync_out <= '0';
                else
                    frame_sync_out  <= frame_sync_aligned and not mask_fsync_out_i and valid_video_prmtrs;
                end if;
            end if;
        end process REG_FSYNC_OUT;

    -------------------------------------------------------------------
    -- GENERATE PARAMETER UPDATE OUT FOR VIDEO IP
    -------------------------------------------------------------------
    -- Provide output of video parameter update to target Video IP.
    REG_PRMTRUPDT_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    prmtr_update   <= '0';
                else
                    prmtr_update   <= parameter_update and not mask_fsync_out_i;
                end if;
            end if;
        end process REG_PRMTRUPDT_OUT;

end generate GEN_FSYNC_MODE_MM2S_NO_SOF;

GEN_FSYNC_MODE_MM2S_SOF : if (C_USE_FSYNC = 1 and C_INCLUDE_MM2S = 1 and ENABLE_FLUSH_ON_MM2S_FSYNC = 1 and C_SOF_ENABLE = 1) generate
-- Frame sync for VDMA and for core output
signal frame_sync_i         : std_logic := '0';
signal frame_sync_aligned   : std_logic := '0';
signal mask_fsync_out_i     : std_logic := '0';


begin

    frame_sync_i <= fsync;
    -- Pass out for VDMA use
    frame_sync <= frame_sync_i;

    -- For frame count enable, mask fsync out at end of frame.
    FRAME_SYNC_MASK : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then

                    mask_fsync_out_i <= '0';

                -- If masked and ioc occurs then clear mask
                elsif(mask_fsync_out_i = '1' and frmcnt_ioc = '1')then
                    mask_fsync_out_i <= '0';

                -- On frame count enable at end of last frame mask off last fsync out
                elsif(dmacr_frmcnt_enbl = '1' and dmasr_frmcnt_status = FRAME_COUNT_ONE and valid_frame_sync_cmb = '1')then
                    mask_fsync_out_i <= '1';

                end if;
            end if;
        end process FRAME_SYNC_MASK;

    mask_fsync_out  <= mask_fsync_out_i or not valid_video_prmtrs;

    -------------------------------------------------------------------
    -- GENERATE FSYNC OUT FOR VIDEO IP
    -------------------------------------------------------------------
    -- Align internal fsync with parameter update.  Parameter update
    -- asserts on next clock after frame_sync therefor by adding 1
    -- pipe of delay we align parameter_update input with frame_sync
    REG_DELAY_FSYNC : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                -- clear on reset or s_h clear
                if(prmry_resetn = '0')then
                    frame_sync_aligned <= '0';
                else
                    frame_sync_aligned <= frame_sync_i;
                end if;
            end if;
        end process REG_DELAY_FSYNC;

    -- Provide output of frame sync to target Video IP.
    REG_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    frame_sync_out <= '0';
                else
                    frame_sync_out  <= frame_sync_aligned and not mask_fsync_out_i and valid_video_prmtrs;
                end if;
            end if;
        end process REG_FSYNC_OUT;

    -------------------------------------------------------------------
    -- GENERATE PARAMETER UPDATE OUT FOR VIDEO IP
    -------------------------------------------------------------------
    -- Provide output of video parameter update to target Video IP.
    REG_PRMTRUPDT_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    prmtr_update   <= '0';
                else
                    prmtr_update   <= parameter_update and not mask_fsync_out_i;
                end if;
            end if;
        end process REG_PRMTRUPDT_OUT;

end generate GEN_FSYNC_MODE_MM2S_SOF;




-------------------------------------------------------------------------------
-- Generate Frame Sync Mode (External frame sync)
-------------------------------------------------------------------------------
-- Note: Treated async and sync clock modes as async so fsync out behavior is
-- identical regardless of mode.
GEN_FSYNC_MODE_S2MM_NON_FLUSH : if (C_USE_FSYNC = 1 and C_INCLUDE_S2MM = 1 and ENABLE_FLUSH_ON_S2MM_FSYNC = 0) generate
-- Frame sync for VDMA and for core output
signal frame_sync_i         : std_logic := '0';
signal frame_sync_aligned   : std_logic := '0';
signal mask_fsync_out_i     : std_logic := '0';


begin
    -- generate fsync from tuser
    GEN_FSYNC_FOR_SOF : if C_SOF_ENABLE = 1 generate
    begin

        -- frame_sync_i <= tuser_fsync and run_stop;

        -- Frame sync cross bar
        FSYNC_CROSSBAR : process(fsync_src_select,
                                 run_stop,
                                 fsync,
                                 othrchnl_fsync,
                                 tuser_fsync)
            begin
                case fsync_src_select is

                    when "00" =>   -- primary fsync (default)
                        frame_sync_i <= fsync and run_stop;
                    when "01" =>   -- other channel fsync
                        frame_sync_i <= othrchnl_fsync and run_stop;
                    when "10" =>   -- tuser fsync  (used only by s2mm)
                        frame_sync_i <= tuser_fsync and run_stop;
                    when others =>
                        frame_sync_i <= '0';
                end case;
            end process FSYNC_CROSSBAR;

    end generate GEN_FSYNC_FOR_SOF;

    -- generate fsync from fsync
    GEN_FSYNC_NO_SOF  : if C_SOF_ENABLE = 0 generate
    begin
        -- Internal fsync on fe for vdma if running
        --frame_sync_i <= fsync and run_stop;


        -- Frame sync cross bar
        FSYNC_CROSSBAR : process(fsync_src_select,
                                 run_stop,
                                 fsync,
                                 othrchnl_fsync)
            begin
                case fsync_src_select is

                    when "00" =>   -- primary fsync (default)
                        frame_sync_i <= fsync and run_stop;
                    when "01" =>   -- other channel fsync
                        frame_sync_i <= othrchnl_fsync and run_stop;
                    when others =>
                        frame_sync_i <= '0';
                end case;
            end process FSYNC_CROSSBAR;

    end generate GEN_FSYNC_NO_SOF;


    -- Pass out for VDMA use
    frame_sync <= frame_sync_i;

    -- For frame count enable, mask fsync out at end of frame.
    FRAME_SYNC_MASK : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then

                    mask_fsync_out_i <= '0';

                -- If masked and ioc occurs then clear mask
                elsif(mask_fsync_out_i = '1' and frmcnt_ioc = '1')then
                    mask_fsync_out_i <= '0';

                -- On frame count enable at end of last frame mask off last fsync out
                elsif(dmacr_frmcnt_enbl = '1' and dmasr_frmcnt_status = FRAME_COUNT_ONE and valid_frame_sync_cmb = '1')then
                    mask_fsync_out_i <= '1';

                end if;
            end if;
        end process FRAME_SYNC_MASK;

    mask_fsync_out  <= mask_fsync_out_i or not valid_video_prmtrs;

    -------------------------------------------------------------------
    -- GENERATE FSYNC OUT FOR VIDEO IP
    -------------------------------------------------------------------
    -- Align internal fsync with parameter update.  Parameter update
    -- asserts on next clock after frame_sync therefor by adding 1
    -- pipe of delay we align parameter_update input with frame_sync
    REG_DELAY_FSYNC : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                -- clear on reset or s_h clear
                if(prmry_resetn = '0')then
                    frame_sync_aligned <= '0';
                else
                    frame_sync_aligned <= frame_sync_i;
                end if;
            end if;
        end process REG_DELAY_FSYNC;

    -- Provide output of frame sync to target Video IP.
    REG_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    frame_sync_out <= '0';
                else
                    frame_sync_out  <= frame_sync_aligned and not mask_fsync_out_i and valid_video_prmtrs;
                end if;
            end if;
        end process REG_FSYNC_OUT;

    -------------------------------------------------------------------
    -- GENERATE PARAMETER UPDATE OUT FOR VIDEO IP
    -------------------------------------------------------------------
    -- Provide output of video parameter update to target Video IP.
    REG_PRMTRUPDT_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    prmtr_update   <= '0';
                else
                    prmtr_update   <= parameter_update and not mask_fsync_out_i;
                end if;
            end if;
        end process REG_PRMTRUPDT_OUT;

end generate GEN_FSYNC_MODE_S2MM_NON_FLUSH;


-------------------------------------------------------------------------------
-- Generate Frame Sync Mode (External frame sync)
-------------------------------------------------------------------------------
-- Note: Treated async and sync clock modes as async so fsync out behavior is
-- identical regardless of mode.
GEN_FSYNC_MODE_S2MM_FLUSH_NON_SOF : if (C_USE_FSYNC = 1 and C_INCLUDE_S2MM = 1 and ENABLE_FLUSH_ON_S2MM_FSYNC = 1 and C_SOF_ENABLE = 0) generate
-- Frame sync for VDMA and for core output
signal frame_sync_i         : std_logic := '0';
signal frame_sync_aligned   : std_logic := '0';
signal mask_fsync_out_i     : std_logic := '0';


begin

        -- Frame sync cross bar
        FSYNC_CROSSBAR : process(fsync_src_select,
                                 run_stop,
                                 fsync,
                                 othrchnl_fsync)
            begin
                case fsync_src_select is

                    when "00" =>   -- primary fsync (default)
                        frame_sync_i <= fsync and run_stop;
                    when "01" =>   -- other channel fsync
                        frame_sync_i <= othrchnl_fsync and run_stop;
                    when others =>
                        frame_sync_i <= '0';
                end case;
            end process FSYNC_CROSSBAR;



    -- Pass out for VDMA use
    frame_sync <= frame_sync_i;

    -- For frame count enable, mask fsync out at end of frame.
    FRAME_SYNC_MASK : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then

                    mask_fsync_out_i <= '0';

                -- If masked and ioc occurs then clear mask
                elsif(mask_fsync_out_i = '1' and frmcnt_ioc = '1')then
                    mask_fsync_out_i <= '0';

                -- On frame count enable at end of last frame mask off last fsync out
                elsif(dmacr_frmcnt_enbl = '1' and dmasr_frmcnt_status = FRAME_COUNT_ONE and valid_frame_sync_cmb = '1')then
                    mask_fsync_out_i <= '1';

                end if;
            end if;
        end process FRAME_SYNC_MASK;

    mask_fsync_out  <= mask_fsync_out_i or not valid_video_prmtrs;

    -------------------------------------------------------------------
    -- GENERATE FSYNC OUT FOR VIDEO IP
    -------------------------------------------------------------------
    -- Align internal fsync with parameter update.  Parameter update
    -- asserts on next clock after frame_sync therefor by adding 1
    -- pipe of delay we align parameter_update input with frame_sync
    REG_DELAY_FSYNC : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                -- clear on reset or s_h clear
                if(prmry_resetn = '0')then
                    frame_sync_aligned <= '0';
                else
                    frame_sync_aligned <= frame_sync_i;
                end if;
            end if;
        end process REG_DELAY_FSYNC;

    -- Provide output of frame sync to target Video IP.
    REG_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    frame_sync_out <= '0';
                else
                    frame_sync_out  <= frame_sync_aligned and not mask_fsync_out_i and valid_video_prmtrs;
                end if;
            end if;
        end process REG_FSYNC_OUT;

    -------------------------------------------------------------------
    -- GENERATE PARAMETER UPDATE OUT FOR VIDEO IP
    -------------------------------------------------------------------
    -- Provide output of video parameter update to target Video IP.
    REG_PRMTRUPDT_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    prmtr_update   <= '0';
                else
                    prmtr_update   <= parameter_update and not mask_fsync_out_i;
                end if;
            end if;
        end process REG_PRMTRUPDT_OUT;

end generate GEN_FSYNC_MODE_S2MM_FLUSH_NON_SOF;


-------------------------------------------------------------------------------
-- Generate Frame Sync Mode (External frame sync)
-------------------------------------------------------------------------------
-- Note: Treated async and sync clock modes as async so fsync out behavior is
-- identical regardless of mode.
GEN_FSYNC_MODE_S2MM_FLUSH_SOF : if (C_USE_FSYNC = 1 and C_INCLUDE_S2MM = 1 and ENABLE_FLUSH_ON_S2MM_FSYNC = 1 and C_SOF_ENABLE = 1) generate
-- Frame sync for VDMA and for core output
signal frame_sync_i         : std_logic := '0';
signal frame_sync_aligned   : std_logic := '0';
signal mask_fsync_out_i     : std_logic := '0';


begin


    frame_sync_i <= fsync;
    -- Pass out for VDMA use
    frame_sync <= frame_sync_i;

    -- For frame count enable, mask fsync out at end of frame.
    FRAME_SYNC_MASK : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then

                    mask_fsync_out_i <= '0';

                -- If masked and ioc occurs then clear mask
                elsif(mask_fsync_out_i = '1' and frmcnt_ioc = '1')then
                    mask_fsync_out_i <= '0';

                -- On frame count enable at end of last frame mask off last fsync out
                elsif(dmacr_frmcnt_enbl = '1' and dmasr_frmcnt_status = FRAME_COUNT_ONE and valid_frame_sync_cmb = '1')then
                    mask_fsync_out_i <= '1';

                end if;
            end if;
        end process FRAME_SYNC_MASK;

    mask_fsync_out  <= mask_fsync_out_i or not valid_video_prmtrs;

    -------------------------------------------------------------------
    -- GENERATE FSYNC OUT FOR VIDEO IP
    -------------------------------------------------------------------
    -- Align internal fsync with parameter update.  Parameter update
    -- asserts on next clock after frame_sync therefor by adding 1
    -- pipe of delay we align parameter_update input with frame_sync
    REG_DELAY_FSYNC : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk ='1')then
                -- clear on reset or s_h clear
                if(prmry_resetn = '0')then
                    frame_sync_aligned <= '0';
                else
                    frame_sync_aligned <= frame_sync_i;
                end if;
            end if;
        end process REG_DELAY_FSYNC;

    -- Provide output of frame sync to target Video IP.
    REG_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    frame_sync_out <= '0';
                else
                    frame_sync_out  <= frame_sync_aligned and not mask_fsync_out_i and valid_video_prmtrs;
                end if;
            end if;
        end process REG_FSYNC_OUT;

    -------------------------------------------------------------------
    -- GENERATE PARAMETER UPDATE OUT FOR VIDEO IP
    -------------------------------------------------------------------
    -- Provide output of video parameter update to target Video IP.
    REG_PRMTRUPDT_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    prmtr_update   <= '0';
                else
                    prmtr_update   <= parameter_update and not mask_fsync_out_i;
                end if;
            end if;
        end process REG_PRMTRUPDT_OUT;

end generate GEN_FSYNC_MODE_S2MM_FLUSH_SOF;






end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_vregister
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_vregister.vhd
--
-- Description: Top level for video register block.  These registers provide
--              the video parameters to the DMA controllers.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;
use lib_pkg_v1_0_2.lib_pkg.max2;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_vregister is
    generic(
        C_NUM_FSTORES             : integer range 1 to 32       := 1        ;
            -- Number of Frame Stores

        C_ADDR_WIDTH              : integer range 32 to 32      := 32
            -- Start Address Width
    );
    port (
        prmry_aclk                  : in  std_logic                         ;           --
        prmry_resetn                : in  std_logic                         ;           --
                                                                                        --
        -- Video Register Update control                                                --
        video_reg_update            : in  std_logic                         ;           --
                                                                                        --
        dmasr_halt                  : in  std_logic                         ;           --
        -- Scatter Gather register Bank                                                 --
        vsize_sg                    : in  std_logic_vector                              --
                                        (VSIZE_DWIDTH-1 downto 0)           ;           --
        hsize_sg                    : in  std_logic_vector                              --
                                        (HSIZE_DWIDTH-1 downto 0)           ;           --
        stride_sg                   : in  std_logic_vector                              --
                                        (STRIDE_DWIDTH-1 downto 0)          ;           --
        frmdly_sg                   : in  std_logic_vector                              --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;           --
        start_address_sg            : in STARTADDR_ARRAY_TYPE                              --
                                        (0 to C_NUM_FSTORES - 1)            ;           --
        -- Video Register Bank                                                          --
        vsize_vid                   : out std_logic_vector                              --
                                        (VSIZE_DWIDTH-1 downto 0)           ;           --
        hsize_vid                   : out std_logic_vector                              --
                                        (HSIZE_DWIDTH-1 downto 0)           ;           --
        stride_vid                  : out std_logic_vector                              --
                                        (STRIDE_DWIDTH-1 downto 0)          ;           --
        frmdly_vid                  : out std_logic_vector                              --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;           --
        start_address_vid           : out STARTADDR_ARRAY_TYPE
                                        (0 to C_NUM_FSTORES - 1)                        --

    );
end axi_vdma_vregister;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_vregister is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------

-- No Signals Declared

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin


-- Vertical Size - Video Side
REG_VSIZE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                vsize_vid <= (others => '0');
            -- update video register
            elsif(video_reg_update='1') then
                vsize_vid <= vsize_sg;
            end if;
        end if;
    end process REG_VSIZE;

-- Horizontal Size - Video Side
REG_HSIZE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                hsize_vid <= (others => '0');
            -- update video register
            elsif(video_reg_update='1') then
                hsize_vid <= hsize_sg;
            end if;
        end if;
    end process REG_HSIZE;

-- Stride - Video Side
REG_STRIDE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                stride_vid <= (others => '0');
            -- update video register
            elsif(video_reg_update='1') then
                stride_vid <= stride_sg;
            end if;
        end if;
    end process REG_STRIDE;

-- Frame Delay - Video Side
REG_FRMDLY : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or dmasr_halt = '1')then
                frmdly_vid <= (others => '0');
            -- update video register
            elsif(video_reg_update='1') then
                frmdly_vid <= frmdly_sg;
            end if;
        end if;
    end process REG_FRMDLY;


-- Generate C_NUM_FSTORE start address registeres
GEN_START_ADDR_REG : for i in 0 to C_NUM_FSTORES-1 generate
begin
        -- Start Address Registers
        REG_START_ADDR : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address_vid(i)   <= (others => '0');
                    elsif(video_reg_update = '1')then
                        start_address_vid(i)   <= start_address_sg(i);

                    end if;
                end if;
            end process REG_START_ADDR;

end generate GEN_START_ADDR_REG;

end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_vregister_64
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_vregister_64.vhd
--
-- Description: Top level for video register block.  These registers provide
--              the video parameters to the DMA controllers.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister_64.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister_64.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;
use lib_pkg_v1_0_2.lib_pkg.max2;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_vregister_64 is
    generic(
        C_NUM_FSTORES             : integer range 1 to 32       := 1        ;
            -- Number of Frame Stores

        C_ADDR_WIDTH              : integer range 32 to 64      := 32
            -- Start Address Width
    );
    port (
        prmry_aclk                  : in  std_logic                         ;           --
        prmry_resetn                : in  std_logic                         ;           --
                                                                                        --
        -- Video Register Update control                                                --
        video_reg_update            : in  std_logic                         ;           --
                                                                                        --
        dmasr_halt                  : in  std_logic                         ;           --
        -- Scatter Gather register Bank                                                 --
        vsize_sg                    : in  std_logic_vector                              --
                                        (VSIZE_DWIDTH-1 downto 0)           ;           --
        hsize_sg                    : in  std_logic_vector                              --
                                        (HSIZE_DWIDTH-1 downto 0)           ;           --
        stride_sg                   : in  std_logic_vector                              --
                                        (STRIDE_DWIDTH-1 downto 0)          ;           --
        frmdly_sg                   : in  std_logic_vector                              --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;           --
        start_address_sg            : in STARTADDR_ARRAY_TYPE_64                              --
                                        (0 to C_NUM_FSTORES - 1)            ;           --
        -- Video Register Bank                                                          --
        vsize_vid                   : out std_logic_vector                              --
                                        (VSIZE_DWIDTH-1 downto 0)           ;           --
        hsize_vid                   : out std_logic_vector                              --
                                        (HSIZE_DWIDTH-1 downto 0)           ;           --
        stride_vid                  : out std_logic_vector                              --
                                        (STRIDE_DWIDTH-1 downto 0)          ;           --
        frmdly_vid                  : out std_logic_vector                              --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;           --
        start_address_vid           : out STARTADDR_ARRAY_TYPE_64
                                        (0 to C_NUM_FSTORES - 1)                        --

    );
end axi_vdma_vregister_64;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_vregister_64 is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------

-- No Signals Declared

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin


-- Vertical Size - Video Side
REG_VSIZE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                vsize_vid <= (others => '0');
            -- update video register
            elsif(video_reg_update='1') then
                vsize_vid <= vsize_sg;
            end if;
        end if;
    end process REG_VSIZE;

-- Horizontal Size - Video Side
REG_HSIZE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                hsize_vid <= (others => '0');
            -- update video register
            elsif(video_reg_update='1') then
                hsize_vid <= hsize_sg;
            end if;
        end if;
    end process REG_HSIZE;

-- Stride - Video Side
REG_STRIDE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                stride_vid <= (others => '0');
            -- update video register
            elsif(video_reg_update='1') then
                stride_vid <= stride_sg;
            end if;
        end if;
    end process REG_STRIDE;

-- Frame Delay - Video Side
REG_FRMDLY : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or dmasr_halt = '1')then
                frmdly_vid <= (others => '0');
            -- update video register
            elsif(video_reg_update='1') then
                frmdly_vid <= frmdly_sg;
            end if;
        end if;
    end process REG_FRMDLY;


-- Generate C_NUM_FSTORE start address registeres
GEN_START_ADDR_REG : for i in 0 to C_NUM_FSTORES-1 generate
begin
        -- Start Address Registers
        REG_START_ADDR : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address_vid(i)   <= (others => '0');
                    elsif(video_reg_update = '1')then
                        start_address_vid(i)   <= start_address_sg(i);

                    end if;
                end if;
            end process REG_START_ADDR;

end generate GEN_START_ADDR_REG;

end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_sgregister.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_sgregister.vhd
--
-- Description:     This entity encompasses the sg video register block and is
--                  were video parameters are intiallly written on descriptor
--                  fetch.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;
use lib_pkg_v1_0_2.lib_pkg.max2;
--use proc_common_v4_0.family_support.all;
library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_sgregister is
    generic(
        C_NUM_FSTORES             : integer range 1 to 32       := 1        ;
            -- Number of Frame Stores

        C_ADDR_WIDTH              : integer range 32 to 32      := 32       ;
            -- Start Address Width
        C_SELECT_XPM              : integer := 1; 
        C_FAMILY                  : string := "virtex7"
    );
    port (
        prmry_aclk                  : in  std_logic                         ;           --
        prmry_resetn                : in  std_logic                         ;           --
                                                                                        --
        -- Update Control                                                               --
        video_parameter_updt        : in  std_logic                         ;           --
        video_parameter_valid       : in  std_logic                         ;           --
        video_reg_update            : in  std_logic                         ;           --
        dmasr_halt                  : in  std_logic                         ;           --
        strt_addr_clr               : in  std_logic                         ;           --
        desc_data_wren              : in  std_logic                         ;           --
        frame_number                : in  std_logic_vector                              --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;           --
        ftch_complete               : in  std_logic                         ;           --
        ftch_complete_clr           : in  std_logic                         ;           --
        update_complete             : out std_logic                         ;           --
        num_fstore_minus1           : in  std_logic_vector                              --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;           --
                                                                                        --
        -- Video Start Address / Parameters In from Scatter Gather Engine               --
        desc_vsize                  : in  std_logic_vector                              --
                                        (VSIZE_DWIDTH-1 downto 0)           ;           --
        desc_hsize                  : in  std_logic_vector                              --
                                        (HSIZE_DWIDTH-1 downto 0)           ;           --
        desc_stride                 : in  std_logic_vector                              --
                                        (STRIDE_DWIDTH-1 downto 0)          ;           --
        desc_frmdly                 : in  std_logic_vector                              --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;           --
        desc_strtaddress            : in  std_logic_vector                              --
                                        (C_ADDR_WIDTH-1 downto 0)           ;           --
                                                                                        --
        -- Video Start Address / Parameters Out to DMA Controller                       --
        crnt_vsize                  : out std_logic_vector                              --
                                        (VSIZE_DWIDTH-1 downto 0)           ;           --
        crnt_hsize                  : out std_logic_vector                              --
                                        (HSIZE_DWIDTH-1 downto 0)           ;           --
        crnt_stride                 : out std_logic_vector                              --
                                        (STRIDE_DWIDTH-1 downto 0)          ;           --
        crnt_frmdly                 : out std_logic_vector                              --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;           --
        crnt_start_address          : out std_logic_vector                              --
                                        (C_ADDR_WIDTH - 1 downto 0)                     --
    );
end axi_vdma_sgregister;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_sgregister is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant STRT_ADDR_CNT_WIDTH    : integer := max2(1,clog2(C_NUM_FSTORES));
-- 
--constant STRT_ADDR_TC           : std_logic_vector(STRT_ADDR_CNT_WIDTH-1 downto 0)
--                                    := std_logic_vector(to_unsigned(C_NUM_FSTORES-1,STRT_ADDR_CNT_WIDTH));

--constant USE_LUTRAM             : boolean := supported(C_FAMILY,u_RAM16X1S);
constant USE_LUTRAM             : boolean := FALSE;
constant USE_BRAM               : boolean := USE_LUTRAM=FALSE;

constant ADDRESS_1              : std_logic_vector(STRT_ADDR_CNT_WIDTH-1 downto 0)
                                    := (others => '0');
constant ADDRESS_2              : std_logic_vector(STRT_ADDR_CNT_WIDTH-1 downto 0)
                                    := std_logic_vector(to_unsigned(1,STRT_ADDR_CNT_WIDTH));
constant ADDRESS_3              : std_logic_vector(STRT_ADDR_CNT_WIDTH-1 downto 0)
                                    := std_logic_vector(to_unsigned(2,STRT_ADDR_CNT_WIDTH));


-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal strt_addr_count      : std_logic_vector(STRT_ADDR_CNT_WIDTH-1 downto 0) := (others => '0');
--signal s_h_wren             : std_logic := '0';
--signal ram_address_incr     : std_logic := '0';


signal vsize_sg             : std_logic_vector(VSIZE_DWIDTH-1 downto 0)  := (others => '0');
signal hsize_sg             : std_logic_vector(HSIZE_DWIDTH-1 downto 0)  := (others => '0');
signal stride_sg            : std_logic_vector(STRIDE_DWIDTH-1 downto 0) := (others => '0');
signal frmdly_sg            : std_logic_vector(FRMDLY_DWIDTH-1 downto 0) := (others => '0');
signal start_address_sg     : std_logic_vector(C_ADDR_WIDTH - 1 downto 0):= (others => '0');
signal start_address_out    : std_logic_vector(C_ADDR_WIDTH - 1 downto 0):= (others => '0');

signal start_address1_sg    : std_logic_vector(C_ADDR_WIDTH - 1 downto 0):= (others => '0');
signal start_address2_sg    : std_logic_vector(C_ADDR_WIDTH - 1 downto 0):= (others => '0');
signal start_address3_sg    : std_logic_vector(C_ADDR_WIDTH - 1 downto 0):= (others => '0');

signal start_address_addr1  : std_logic_vector(C_ADDR_WIDTH - 1 downto 0):= (others => '0');
signal start_address_addr2  : std_logic_vector(C_ADDR_WIDTH - 1 downto 0):= (others => '0');
signal start_address_addr3  : std_logic_vector(C_ADDR_WIDTH - 1 downto 0):= (others => '0');


signal update_complete_i    : std_logic := '0';
signal ping_pong            : std_logic := '0';
signal start_address_pong   : std_logic_vector(C_ADDR_WIDTH - 1 downto 0):= (others => '0');
signal start_address_ping   : std_logic_vector(C_ADDR_WIDTH - 1 downto 0):= (others => '0');
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin



-------------------------------------------------------------------------------
-- VIDEO TRANSFER PARAMETERS - FROM SG ENGINE
-------------------------------------------------------------------------------
-- Vertical Size - Video Side
REG_VSIZE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                vsize_sg <= (others => '0');
            -- update video register
            elsif(desc_data_wren='1' and video_parameter_updt = '1') then
                vsize_sg <= desc_vsize;
            end if;
        end if;
    end process REG_VSIZE;

-- Horizontal Size - Video Side
REG_HSIZE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                hsize_sg <= (others => '0');
            -- update video register
            elsif(desc_data_wren='1' and video_parameter_updt = '1') then
                hsize_sg <= desc_hsize;
            end if;
        end if;
    end process REG_HSIZE;

-- Stride - Video Side
REG_STRIDE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                stride_sg <= (others => '0');
            -- update video register
            elsif(desc_data_wren='1' and video_parameter_updt = '1') then
                stride_sg <= desc_stride;
            end if;
        end if;
    end process REG_STRIDE;

-- Frame Delay - Video Side
REG_FRMDLY : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or dmasr_halt = '1')then
                frmdly_sg <= (others => '0');
            -- update video register
            elsif(desc_data_wren='1' and video_parameter_updt = '1') then
                frmdly_sg <= desc_frmdly;
            end if;
        end if;
    end process REG_FRMDLY;



-------------------------------------------------------------------------------
-- VIDEO START ADDRESSES - FROM SG ENGINE
-------------------------------------------------------------------------------
-- If more than one FSTORE then need counter to address
-- start_address_registers
GEN_STRTADDR_CNTR : if C_NUM_FSTORES /= 1 generate
begin
    REG_DESC_CNTR : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- on reset or clear then reset start address count
                if(prmry_resetn = '0' or strt_addr_clr = '1')then
                    strt_addr_count <= (others => '0');
                -- on desc write and address count reached terminal count then reset
                -- 
                --elsif(desc_data_wren = '1' and strt_addr_count = STRT_ADDR_TC)then
                --elsif(desc_data_wren = '1' and strt_addr_count = num_fstore_minus1)then
                -- 
                elsif(desc_data_wren = '1' and strt_addr_count = num_fstore_minus1(STRT_ADDR_CNT_WIDTH-1 downto 0))then
                    strt_addr_count <= (others => '0');
                -- otherwise on each desc write increment the count
                elsif(desc_data_wren = '1')then
                    strt_addr_count <= std_logic_vector(unsigned(strt_addr_count) + 1);
                end if;
            end if;
        end process REG_DESC_CNTR;

end generate GEN_STRTADDR_CNTR;


-- No counter need for FSTORE = 1
GEN_NO_STRTADDR_CNTR : if C_NUM_FSTORES = 1 generate
begin
    strt_addr_count <= (others => '0');

end generate GEN_NO_STRTADDR_CNTR;


-------------------------------------------------------------------------------
-- N0 LUT RAM
-- Do not use a LUT RAM is less than 4 frame stores are required.
-------------------------------------------------------------------------------
GEN_NO_RAM : if C_NUM_FSTORES < 4 generate

    -- For 1 Frame Store
    GEN_FSTORE1 : if C_NUM_FSTORES = 1 generate
    begin
        -----------------------------------------------------------------------
        --  Holding registers for start address fetched via Scatter/Gather
        -----------------------------------------------------------------------
        -- Start Address Register 1 on SG Side
        REG_START_ADDR1_SG : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address1_sg <= (others => '0');
                    elsif(desc_data_wren='1') then
                        start_address1_sg <= desc_strtaddress;
                    end if;
                end if;
            end process REG_START_ADDR1_SG;

        -----------------------------------------------------------------------
        --  Sample and Hold for DMA Controller
        -----------------------------------------------------------------------
        -- Start Address Register 1 on SG Side
        REG_START_ADDR1 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address_sg <= (others => '0');
                    elsif(video_reg_update='1') then
                        start_address_sg <= start_address1_sg;
                    end if;
                end if;
            end process REG_START_ADDR1;

    end generate GEN_FSTORE1;

    -- For 2 Frame Stores
    GEN_FSTORE2 : if C_NUM_FSTORES = 2 generate
    begin
        -----------------------------------------------------------------------
        --  Holding registers for start address fetched via Scatter/Gather
        -----------------------------------------------------------------------
        -- Start Address Register 1 on SG Side
        REG_START_ADDR1_SG : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address1_sg <= (others => '0');
                    elsif(desc_data_wren='1' and strt_addr_count = ADDRESS_1) then
                        start_address1_sg <= desc_strtaddress;
                    end if;
                end if;
            end process REG_START_ADDR1_SG;

        -- Start Address Register 2 on SG Side
        REG_START_ADDR2_SG : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address2_sg <= (others => '0');
                    elsif(desc_data_wren='1' and strt_addr_count = ADDRESS_2) then
                        start_address2_sg <= desc_strtaddress;
                    end if;
                end if;
            end process REG_START_ADDR2_SG;

        -----------------------------------------------------------------------
        --  Sample and Hold for DMA Controller
        -----------------------------------------------------------------------
        -- Start Address Register 1 on SG Side
        REG_START_ADDR1 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address_addr1 <= (others => '0');
                    elsif(video_reg_update='1') then
                        start_address_addr1 <= start_address1_sg;
                    end if;
                end if;
            end process REG_START_ADDR1;

        -- Start Address Register 2 on SG Side
        REG_START_ADDR2 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address_addr2 <= (others => '0');
                    elsif(video_reg_update='1') then
                        start_address_addr2 <= start_address2_sg;
                    end if;
                end if;
            end process REG_START_ADDR2;

        START_ADDRESS_MUX : process(frame_number,
                                    start_address_addr1,
                                    start_address_addr2)
            begin
                case frame_number is
                    when "00000" =>
                        start_address_sg <= start_address_addr1;
                    when others =>
                        start_address_sg <= start_address_addr2;
                end case;
            end process START_ADDRESS_MUX;

    end generate GEN_FSTORE2;

    -- For 3 Frame Stores
    GEN_FSTORE3 : if C_NUM_FSTORES = 3 generate
    begin
        -----------------------------------------------------------------------
        --  Holding registers for start address fetched via Scatter/Gather
        -----------------------------------------------------------------------
        -- Start Address Register 1 on SG Side
        REG_START_ADDR1_SG : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address1_sg <= (others => '0');
                    elsif(desc_data_wren='1' and strt_addr_count = ADDRESS_1) then
                        start_address1_sg <= desc_strtaddress;
                    end if;
                end if;
            end process REG_START_ADDR1_SG;

        -- Start Address Register 2 on SG Side
        REG_START_ADDR2_SG : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address2_sg <= (others => '0');
                    elsif(desc_data_wren='1' and strt_addr_count = ADDRESS_2) then
                        start_address2_sg <= desc_strtaddress;
                    end if;
                end if;
            end process REG_START_ADDR2_SG;

        -- Start Address Register 3 on SG Side
        REG_START_ADDR3_SG : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address3_sg <= (others => '0');
                    elsif(desc_data_wren = '1' and strt_addr_count = ADDRESS_3) then
                        start_address3_sg <= desc_strtaddress;
                    end if;
                end if;
            end process REG_START_ADDR3_SG;

        -----------------------------------------------------------------------
        --  Sample and Hold for DMA Controller
        -----------------------------------------------------------------------
        -- Start Address Register 1 on SG Side
        REG_START_ADDR1 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address_addr1 <= (others => '0');
                    elsif(video_reg_update='1') then
                        start_address_addr1 <= start_address1_sg;
                    end if;
                end if;
            end process REG_START_ADDR1;

        -- Start Address Register 2 on SG Side
        REG_START_ADDR2 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address_addr2 <= (others => '0');
                    elsif(video_reg_update='1') then
                        start_address_addr2 <= start_address2_sg;
                    end if;
                end if;
            end process REG_START_ADDR2;

        -- Start Address Register 3 on SG Side
        REG_START_ADDR3 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        start_address_addr3 <= (others => '0');
                    elsif(video_reg_update='1') then
                        start_address_addr3 <= start_address3_sg;
                    end if;
                end if;
            end process REG_START_ADDR3;

        START_ADDRESS_MUX : process(frame_number,
                                    start_address_addr1,
                                    start_address_addr2,
                                    start_address_addr3)
            begin
                case frame_number is
                    when "00000" =>
                        start_address_sg <= start_address_addr1;
                    when "00001" =>
                        start_address_sg <= start_address_addr2;
                    when others =>
                        start_address_sg <= start_address_addr3;
                end case;
            end process START_ADDRESS_MUX;

    end generate GEN_FSTORE3;

    update_complete     <= ftch_complete;
    start_address_out   <= start_address_sg;


end generate GEN_NO_RAM;


-------------------------------------------------------------------------------
-- LUT RAM
-- Use a lut RAM if the selected device supports LUT RAM's and the Address
-- width is within the bounds of a LUT RAM and if frame stores is greater
-- than 3.  There is no resource savings for less frame stores.
-------------------------------------------------------------------------------
GEN_LUTRAM : if USE_LUTRAM and STRT_ADDR_CNT_WIDTH <= 4 and C_NUM_FSTORES > 3 generate
constant ZERO_ADDR  : std_logic_vector(3 downto 0) := (others => '0');

signal addr                 : std_logic_vector(3 downto 0) := (others => '0');
signal copy_addr            : std_logic_vector(3 downto 0) := (others => '0');
signal copy_wren            : std_logic := '0';
--signal copyram_addr         : std_logic_vector(3 downto 0) := (others => '0');

signal copy_wren_ping       : std_logic := '0';
signal copy_wren_pong       : std_logic := '0';

signal copyram_addr_ping    : std_logic_vector(3 downto 0) := (others => '0');
signal copyram_addr_pong    : std_logic_vector(3 downto 0) := (others => '0');


begin

    -- Need to pad address up to 4 bits wide
    GEN_ADDR_WIDTH_LESS_4 : if STRT_ADDR_CNT_WIDTH < 4 generate
    constant ADDR_PAD_WIDTH : integer := 4 - STRT_ADDR_CNT_WIDTH;
    constant ADDRESS_PAD    : std_logic_vector
                                (ADDR_PAD_WIDTH-1 downto 0)
                                :=(others => '0');
    begin
        addr <= (ADDRESS_PAD & strt_addr_count) when copy_wren = '0'
           else copy_addr;

    end generate GEN_ADDR_WIDTH_LESS_4;

    -- Do not need to pad address, already at 4 bits
    GEN_ADDR_WIDTH_EQL_4 : if STRT_ADDR_CNT_WIDTH = 4 generate
    begin
        addr <= strt_addr_count when copy_wren = '0'
           else copy_addr;

    end generate GEN_ADDR_WIDTH_EQL_4;

    -- Instantiate LUTRAM
    GEN_BUFFER1 : for i in C_ADDR_WIDTH - 1 downto 0 generate
        LUT_RAM : RAM16X1S
            generic map
            (
                INIT    => X"0000"
            )
            port map
            (
                WE      => desc_data_wren           ,
                D       => desc_strtaddress(i)      ,
                WCLK    => prmry_aclk            ,
                A0      => addr(0)                  ,
                A1      => addr(1)                  ,
                A2      => addr(2)                  ,
                A3      => addr(3)                  ,
                O       => start_address_sg(i)
            );
    end generate GEN_BUFFER1;

    -- On completion of descriptor fetch, enable copying of
    -- sg LUTRAM (buffer1) to output LUTRAM (ping or pong)
    -- This copy of entire RAM is required because users may only
    -- update 1 start address or all addresses and a full copy is
    -- the simplest approach
    COPY_COUNTER : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' or ftch_complete_clr = '1' or dmasr_halt = '1')then
                    copy_addr           <= (others => '1');
                    copy_wren           <= '0';
                    update_complete_i   <= '0';
                -- done with copy, hold wren able clear asserts
                elsif(copy_addr = ZERO_ADDR)then
                    copy_wren           <= '0';
                    copy_addr           <= (others => '0');
                    update_complete_i   <= '1';

                -- decrement address on copy
                elsif(copy_wren = '1')then
                    copy_addr           <= std_logic_vector(unsigned(copy_addr) - 1);
                    copy_wren           <= '1';
                    update_complete_i   <= '0';

                -- all desc data fetched therefore start copy
                elsif(ftch_complete = '1')then
                    copy_addr           <= (others => '1');
                    copy_wren           <= '1';
                    update_complete_i   <= '0';

                end if;
            end if;
        end process COPY_COUNTER;
    -- Pass out for setting flags
    update_complete <= update_complete_i;


    copy_wren_ping    <= copy_wren when (ping_pong = '1' and video_parameter_valid = '1')
                                     or (update_complete_i = '0' and video_parameter_valid = '0')
                    else '0';

    copyram_addr_ping <= copy_addr when ping_pong = '1'
                                     or (video_parameter_valid = '0' and update_complete_i = '0')
                    else frame_number(3 downto 0);

    copy_wren_pong    <= copy_wren when (ping_pong = '0' and video_parameter_valid = '1')
                                     or (update_complete_i = '0' and video_parameter_valid = '0')
                   else '0';

    copyram_addr_pong <= copy_addr when ping_pong = '0'
                                     or (video_parameter_valid = '0' and update_complete_i = '0')
                    else frame_number(3 downto 0);

    -- Ping Pong control for selecting which LUTRAM the DMA controller
    -- will fetch from and which one Scatter Gather will update.
    PING_PONG_PROCESS : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' or dmasr_halt = '1' or video_parameter_valid = '0')then
                    ping_pong <= '0';
                elsif(update_complete_i = '1' and video_reg_update = '1')then
                    ping_pong <= not ping_pong;
                end if;
            end if;
        end process PING_PONG_PROCESS;

    -- Instantiate PING LUTRAM
    GEN_BUFFER_PING : for i in C_ADDR_WIDTH - 1 downto 0 generate
        LUT_RAM : RAM16X1S
            generic map
            (
                INIT    => X"0000"
            )
            port map
            (
                WE      => copy_wren_ping                ,
                D       => start_address_sg(i)      ,
                WCLK    => prmry_aclk            ,
                A0      => copyram_addr_ping(0)          ,
                A1      => copyram_addr_ping(1)          ,
                A2      => copyram_addr_ping(2)          ,
                A3      => copyram_addr_ping(3)          ,
                O       => start_address_ping(i)
            );
    end generate GEN_BUFFER_PING;


    -- Instantiate PONG LUTRAM
    GEN_BUFFER_PONG : for i in C_ADDR_WIDTH - 1 downto 0 generate
        LUT_RAM : RAM16X1S
            generic map
            (
                INIT    => X"0000"
            )
            port map
            (
                WE      => copy_wren_pong                ,
                D       => start_address_sg(i)      ,
                WCLK    => prmry_aclk            ,
                A0      => copyram_addr_pong(0)          ,
                A1      => copyram_addr_pong(1)          ,
                A2      => copyram_addr_pong(2)          ,
                A3      => copyram_addr_pong(3)          ,
                O       => start_address_pong(i)
            );
    end generate GEN_BUFFER_PONG;

    -- Feed start address from LUTRAM opposite from what is being
    -- written to by scatter gather fetch and update.
    start_address_out <= start_address_ping when ping_pong = '0'
                    else start_address_pong;


end generate GEN_LUTRAM;

-------------------------------------------------------------------------------
-- BRAM
-- Use a BRAM if LUT RAMS are NOT supported or the Address width is out
-- of the bounds of a LUT RAM.
-------------------------------------------------------------------------------
GEN_BRAM    : if (USE_BRAM or STRT_ADDR_CNT_WIDTH > 4) and C_NUM_FSTORES > 3 generate
constant READ_ENABLED   : std_logic := '1';
constant ZERO_ADDR      : std_logic_vector(STRT_ADDR_CNT_WIDTH-1 downto 0) := (others => '0');

--signal read_addr        : std_logic_vector(STRT_ADDR_CNT_WIDTH-1 downto 0) := (others => '0');
signal copy_addr        : std_logic_vector(STRT_ADDR_CNT_WIDTH-1 downto 0) := (others => '1');
signal copy_wren        : std_logic := '0';
--signal copyram_addr     : std_logic_vector(STRT_ADDR_CNT_WIDTH-1 downto 0) := (others => '0');

signal copy_wren_ping       : std_logic := '0';
signal copy_wren_pong       : std_logic := '0';

signal copyram_addr_ping    : std_logic_vector(STRT_ADDR_CNT_WIDTH-1 downto 0) := (others => '0');
signal copyram_addr_pong    : std_logic_vector(STRT_ADDR_CNT_WIDTH-1 downto 0) := (others => '0');


signal copy_wren_ping_p       : std_logic := '0';
signal copy_wren_pong_p       : std_logic := '0';

signal copyram_addr_ping_p    : std_logic_vector(STRT_ADDR_CNT_WIDTH-1 downto 0) := (others => '0');
signal copyram_addr_pong_p    : std_logic_vector(STRT_ADDR_CNT_WIDTH-1 downto 0) := (others => '0');

begin

    GEN_BUFFER1 : entity axi_vdma_v6_3_10.axi_vdma_blkmem
        generic map(
            C_DATA_WIDTH        => C_ADDR_WIDTH         ,
            C_ADDR_WIDTH        => STRT_ADDR_CNT_WIDTH  ,
            C_SELECT_XPM        => C_SELECT_XPM,
            C_FAMILY            => C_FAMILY
        )
        port map(
            Clk         => prmry_aclk        ,
            Rst         => prmry_resetn        ,

            -- Write Port signals
            Wr_Enable   =>  desc_data_wren      ,
            Wr_Req      =>  desc_data_wren      ,
            Wr_Address  =>  strt_addr_count     ,
            Wr_Data     =>  desc_strtaddress    ,

            -- Read Port Signals
            Rd_Enable   =>  READ_ENABLED        ,
            Rd_Address  =>  copy_addr           ,
            Rd_Data     =>  start_address_sg
        );

    -- On completion of descriptor fetch, enable copying of
    -- sg LUTRAM (buffer1) to output LUTRAM (ping or pong)
    -- This copy of entire RAM is required because users may only
    -- update 1 start address or all addresses and a full copy is
    -- the simplest approach
    COPY_COUNTER : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' or ftch_complete_clr = '1' or dmasr_halt = '1')then
                    copy_addr       <= (others => '1');
                    copy_wren       <= '0';
                    update_complete_i <= '0';
                -- done with copy, hold wren able clear asserts
                elsif(copy_addr = ZERO_ADDR)then
                    copy_wren       <= '0';
                    copy_addr       <= (others => '0');
                    update_complete_i <= '1';

                -- decrement address on copy
                elsif(copy_wren = '1')then
                    copy_addr <= std_logic_vector(unsigned(copy_addr) - 1);
                    copy_wren <= '1';
                    update_complete_i <= '0';

                -- all desc data fetched therefore start copy
                elsif(ftch_complete = '1')then
                    copy_addr <= (others => '1');
                    copy_wren <= '1';
                    update_complete_i <= '0';

                end if;
            end if;
        end process COPY_COUNTER;
    -- Pass out for setting flags
    update_complete <= update_complete_i;


    copy_wren_ping_p    <= copy_wren when (ping_pong = '1' and video_parameter_valid = '1')
                                     or (update_complete_i = '0' and video_parameter_valid = '0')
                    else '0';

    copyram_addr_ping_p <= copy_addr when ping_pong = '1'
                                     or (video_parameter_valid = '0' and update_complete_i = '0')
                    else frame_number(STRT_ADDR_CNT_WIDTH-1 downto 0);

    copy_wren_pong_p    <= copy_wren when (ping_pong = '0' and video_parameter_valid = '1')
                                     or (update_complete_i = '0' and video_parameter_valid = '0')
                   else '0';

    copyram_addr_pong_p <= copy_addr when ping_pong = '0'
                                     or (video_parameter_valid = '0' and update_complete_i = '0')
                    else frame_number(STRT_ADDR_CNT_WIDTH-1 downto 0);

   -- Delaying Ping Pong Write and Address signals for BRAM


    DELAY_PING_PONG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    copy_wren_ping <= '0';
                    copy_wren_pong <= '0';
		    copyram_addr_ping <= (others => '0');
		    copyram_addr_pong <= (others => '0');
                else
                    copy_wren_ping <= copy_wren_ping_p;
                    copy_wren_pong <= copy_wren_pong_p;
		    copyram_addr_ping <= copyram_addr_ping_p;
		    copyram_addr_pong <= copyram_addr_pong_p;
                end if;
            end if;
        end process DELAY_PING_PONG;

    -- Ping Pong control for selecting which LUTRAM the DMA controller
    -- will fetch from and which one Scatter Gather will update.
    PING_PONG_PROCESS : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' or dmasr_halt = '1' or video_parameter_valid = '0')then
                    ping_pong <= '0';
                elsif(update_complete_i = '1' and video_reg_update = '1')then
                    ping_pong <= not ping_pong;
                end if;
            end if;
        end process PING_PONG_PROCESS;

    GEN_BUFFER_PING : entity axi_vdma_v6_3_10.axi_vdma_blkmem
        generic map(
            C_DATA_WIDTH        => C_ADDR_WIDTH         ,
            C_ADDR_WIDTH        => STRT_ADDR_CNT_WIDTH  ,
            C_SELECT_XPM        => C_SELECT_XPM,
            C_FAMILY            => C_FAMILY
        )
        port map(
            Clk         => prmry_aclk        ,
            Rst         => prmry_resetn        ,

            -- Write Port signals
            Wr_Enable   =>  copy_wren_ping           ,
            Wr_Req      =>  copy_wren_ping           ,
            Wr_Address  =>  copyram_addr_ping           ,
            Wr_Data     =>  start_address_sg    ,

            -- Read Port Signals
            Rd_Enable   =>  READ_ENABLED        ,
            Rd_Address  =>  frame_number(STRT_ADDR_CNT_WIDTH-1 downto 0), -- 
            Rd_Data     =>  start_address_ping
        );

    GEN_BUFFER_PONG : entity axi_vdma_v6_3_10.axi_vdma_blkmem
        generic map(
            C_DATA_WIDTH        => C_ADDR_WIDTH         ,
            C_ADDR_WIDTH        => STRT_ADDR_CNT_WIDTH  ,
            C_SELECT_XPM        => C_SELECT_XPM,
            C_FAMILY            => C_FAMILY
        )
        port map(
            Clk         => prmry_aclk        ,
            Rst         => prmry_resetn        ,

            -- Write Port signals
            Wr_Enable   =>  copy_wren_pong           ,
            Wr_Req      =>  copy_wren_pong           ,
            Wr_Address  =>  copyram_addr_pong           ,
            Wr_Data     =>  start_address_sg    ,

            -- Read Port Signals
            Rd_Enable   =>  READ_ENABLED        ,
            Rd_Address  =>  frame_number(STRT_ADDR_CNT_WIDTH-1 downto 0), -- 
            Rd_Data     =>  start_address_pong
        );

    -- Feed start address from LUTRAM opposite from what is being
    -- written to by scatter gather fetch and update.
    start_address_out <= start_address_ping when ping_pong = '0'
                    else start_address_pong;


end generate GEN_BRAM;


-------------------------------------------------------------------------------
-- VIDEO DOUBLE REGISTER BLOCK FOR DMA CONTROLLER
-------------------------------------------------------------------------------
-- Vertical Size - Video Side
REG_VSIZE_OUT : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                crnt_vsize <= (others => '0');
            -- update video register
            elsif(video_reg_update='1') then
                crnt_vsize <= vsize_sg;
            end if;
        end if;
    end process REG_VSIZE_OUT;

-- Horizontal Size - Video Side
REG_HSIZE_OUT : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                crnt_hsize <= (others => '0');
            -- update video register
            elsif(video_reg_update='1') then
                crnt_hsize <= hsize_sg;
            end if;
        end if;
    end process REG_HSIZE_OUT;

-- Stride - Video Side
REG_STRIDE_OUT : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                crnt_stride <= (others => '0');
            -- update video register
            elsif(video_reg_update='1') then
                crnt_stride <= stride_sg;
            end if;
        end if;
    end process REG_STRIDE_OUT;

-- Frame Delay - Video Side
REG_FRMDLY_OUT : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or dmasr_halt = '1')then
                crnt_frmdly <= (others => '0');
            -- update video register
            elsif(video_reg_update='1') then
                crnt_frmdly <= frmdly_sg;
            end if;
        end if;
    end process REG_FRMDLY_OUT;

-- Pipe line for fmax (dble to allow for adjustments later if need be)
REG_ADDR_OUT : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                crnt_start_address   <= (others => '0');
            else
                crnt_start_address   <= start_address_out;
            end if;
        end if;
    end process REG_ADDR_OUT;

end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_vaddrreg_mux
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_vaddrreg_mux.vhd
--
-- Description: This entity contains the mux for driving current video start
--              address to DMA Controller.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_vaddrreg_mux is
    generic(
        C_NUM_FSTORES             : integer range 1 to 32       := 1        ;
            -- Number of Frame Stores

        C_ADDR_WIDTH              : integer range 32 to 32      := 32
            -- Start Address Width
    );
    port (

        prmry_aclk                  : in  std_logic                         ;       --
        prmry_resetn                : in  std_logic                         ;       --
                                                                                    --
                                                                                    --
        -- Current Frame Number                                                     --
        frame_number                : in  std_logic_vector                          --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;       --
                                                                                    --
        -- Video Register Bank                                                      --
        start_address_vid           : in  STARTADDR_ARRAY_TYPE                      --
                                        (0 to C_NUM_FSTORES - 1)            ;       --
                                                                                    --
        crnt_start_address          : out std_logic_vector                          --
                                        (C_ADDR_WIDTH - 1 downto 0)                 --

    );
end axi_vdma_vaddrreg_mux;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_vaddrreg_mux is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal crnt_start_address_i         : std_logic_vector(C_ADDR_WIDTH - 1 downto 0) := (others => '0');
--signal crnt_start_address_d1        : std_logic_vector(C_ADDR_WIDTH - 1 downto 0) := (others => '0');
--signal crnt_start_address_d2        : std_logic_vector(C_ADDR_WIDTH - 1 downto 0) := (others => '0');

signal frame_number_index           : integer := 0;
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

frame_number_index  <= to_integer(unsigned(frame_number));

crnt_start_address_i <= start_address_vid(frame_number_index);

-- Pipe line for fmax (dble to allow for adjustments later if need be)
-----REG_ADDR_OUT : process(prmry_aclk)
-----    begin
-----        if(prmry_aclk'EVENT and prmry_aclk = '1')then
-----            if(prmry_resetn = '0')then
-----                crnt_start_address_d1   <= (others => '0');
-----                crnt_start_address_d2   <= (others => '0');
-----            else
-----                crnt_start_address_d1   <= crnt_start_address_i;
-----                crnt_start_address_d2   <= crnt_start_address_d1;
-----            end if;
-----        end if;
-----    end process REG_ADDR_OUT;
-----

------crnt_start_address <= crnt_start_address_d2;
crnt_start_address <= crnt_start_address_i;

end implementation;



-------------------------------------------------------------------------------
-- axi_vdma_vaddrreg_mux_64
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_vaddrreg_mux_64.vhd
--
-- Description: This entity contains the mux for driving current video start
--              address to DMA Controller.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux_64.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux_64.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_vaddrreg_mux_64 is
    generic(
        C_NUM_FSTORES             : integer range 1 to 32       := 1        ;
            -- Number of Frame Stores

        C_ADDR_WIDTH              : integer range 32 to 64      := 32
            -- Start Address Width
    );
    port (

        prmry_aclk                  : in  std_logic                         ;       --
        prmry_resetn                : in  std_logic                         ;       --
                                                                                    --
                                                                                    --
        -- Current Frame Number                                                     --
        frame_number                : in  std_logic_vector                          --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;       --
                                                                                    --
        -- Video Register Bank                                                      --
        start_address_vid           : in  STARTADDR_ARRAY_TYPE_64                      --
                                        (0 to C_NUM_FSTORES - 1)            ;       --
                                                                                    --
        crnt_start_address          : out std_logic_vector                          --
                                        (C_ADDR_WIDTH - 1 downto 0)                 --

    );
end axi_vdma_vaddrreg_mux_64;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_vaddrreg_mux_64 is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal crnt_start_address_i         : std_logic_vector(C_ADDR_WIDTH - 1 downto 0) := (others => '0');
--signal crnt_start_address_d1        : std_logic_vector(C_ADDR_WIDTH - 1 downto 0) := (others => '0');
--signal crnt_start_address_d2        : std_logic_vector(C_ADDR_WIDTH - 1 downto 0) := (others => '0');

signal frame_number_index           : integer := 0;
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

frame_number_index  <= to_integer(unsigned(frame_number));

crnt_start_address_i <= start_address_vid(frame_number_index);

-- Pipe line for fmax (dble to allow for adjustments later if need be)
-----REG_ADDR_OUT : process(prmry_aclk)
-----    begin
-----        if(prmry_aclk'EVENT and prmry_aclk = '1')then
-----            if(prmry_resetn = '0')then
-----                crnt_start_address_d1   <= (others => '0');
-----                crnt_start_address_d2   <= (others => '0');
-----            else
-----                crnt_start_address_d1   <= crnt_start_address_i;
-----                crnt_start_address_d2   <= crnt_start_address_d1;
-----            end if;
-----        end if;
-----    end process REG_ADDR_OUT;
-----

------crnt_start_address <= crnt_start_address_d2;
crnt_start_address <= crnt_start_address_i;

end implementation;



-------------------------------------------------------------------------------
-- axi_vdma_vidreg_module
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_vidreg_module.vhd
--
-- Description:     This entity is the top level for the dual register blocks,
--                  i.e. video register set and sg register set and provides
--                  indication of valid parameters.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_vidreg_module is
    generic(
        C_INCLUDE_SG              : integer range 0 to 1        := 1        ;
            -- Include or Exclude Scatter Gather Engine
            -- 0 = Exclude Scatter Gather Engine (Enables Register Direct Mode)
            -- 1 = Include Scatter Gather Engine

        C_NUM_FSTORES             : integer range 1 to 32       := 1        ;
            -- Number of Frame Stores

        -----------------------------------------------------------------------
        C_DYNAMIC_RESOLUTION      : integer range 0 to 1      	:= 1	    ;
            -- Run time configuration of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 0 = Halt VDMA before writing new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 1 = Run time register configuration for new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE.
        -----------------------------------------------------------------------




        C_ADDR_WIDTH              : integer range 32 to 32      := 32       ;
            -- Start Address Width

        C_SELECT_XPM              : integer    := 1;
        C_FAMILY                  : string            		:= "virtex7"
            -- Target FPGA Device Family


    );
    port (
        prmry_aclk                  : in  std_logic                         ;       --
        prmry_resetn                : in  std_logic                         ;       --
                                                                                    --
                                                                                    --
        -- Register update control                                                  --
        run_stop                    : in  std_logic                         ;       --
        dmasr_halt                  : in  std_logic                         ;       --
        ftch_idle                   : in  std_logic                         ;       --
        tailpntr_updated            : in  std_logic                         ;       --
        frame_number                : in  std_logic_vector                          --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;       --
        num_fstore_minus1           : in  std_logic_vector                          --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;       --
                                                                                    --
        -- Register swap control/status                                             --
        frame_sync                  : in  std_logic                         ;       --
        ftch_complete               : in  std_logic                         ;       --
        ftch_complete_clr           : out std_logic                         ;       --
        parameter_update            : out std_logic                         ;       --
        video_prmtrs_valid          : out std_logic                         ;       --
        prmtr_update_complete       : out std_logic                         ;       -- CR605424
                                                                                    --
        -- Register Direct Mode Video Parameter In                                  --
        reg_module_vsize            : in  std_logic_vector                          --
                                        (VSIZE_DWIDTH-1 downto 0)           ;       --
        reg_module_hsize            : in  std_logic_vector                          --
                                        (HSIZE_DWIDTH-1 downto 0)           ;       --
        reg_module_stride           : in  std_logic_vector                          --
                                        (STRIDE_DWIDTH-1 downto 0)          ;       --
        reg_module_frmdly           : in  std_logic_vector                          --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;       --
        reg_module_strt_addr        : in STARTADDR_ARRAY_TYPE                       --
                                        (0 to C_NUM_FSTORES - 1)            ;       --
                                                                                    --
        -- Descriptor data/control from sg interface                                --
        desc_data_wren              : in  std_logic                         ;       --
                                                                                    --
        desc_strtaddress            : in  std_logic_vector                          --
                                        (C_ADDR_WIDTH-1 downto 0)           ;       --
        desc_vsize                  : in  std_logic_vector                          --
                                        (VSIZE_DWIDTH-1 downto 0)           ;       --
        desc_hsize                  : in  std_logic_vector                          --
                                        (HSIZE_DWIDTH-1 downto 0)           ;       --
        desc_stride                 : in  std_logic_vector                          --
                                        (STRIDE_DWIDTH-1 downto 0)          ;       --
        desc_frmdly                 : in  std_logic_vector                          --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;       --
                                                                                    --
        -- Scatter Gather register Bank                                             --
        crnt_vsize                  : out std_logic_vector                          --
                                        (VSIZE_DWIDTH-1 downto 0)           ;       --
        crnt_hsize                  : out std_logic_vector                          --
                                        (HSIZE_DWIDTH-1 downto 0)           ;       --
        crnt_stride                 : out std_logic_vector                          --
                                        (STRIDE_DWIDTH-1 downto 0)          ;       --
        crnt_frmdly                 : out std_logic_vector                          --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;       --
        crnt_start_address          : out std_logic_vector                          --
                                        (C_ADDR_WIDTH - 1 downto 0)                 --
    );
end axi_vdma_vidreg_module;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_vidreg_module is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Control
signal video_parameter_updt     : std_logic := '0';
signal video_prmtrs_valid_i     : std_logic := '0';
signal ftch_complete_clr_i      : std_logic := '0';
signal run_stop_re              : std_logic := '0';
signal run_stop_d1              : std_logic := '0';
signal video_reg_updated        : std_logic := '0';
signal video_reg_update         : std_logic := '0';
signal update_complete          : std_logic := '0';

-- Scatter Gather Side Video Register Bank
--signal vsize_sg                 : std_logic_vector(VSIZE_DWIDTH-1 downto 0)    := (others => '0');
--signal hsize_sg                 : std_logic_vector(HSIZE_DWIDTH-1 downto 0)    := (others => '0');
--signal stride_sg                : std_logic_vector(STRIDE_DWIDTH-1 downto 0)   := (others => '0');
--signal frmdly_sg                : std_logic_vector(FRMDLY_DWIDTH-1 downto 0)   := (others => '0');
signal start_address_vid        : STARTADDR_ARRAY_TYPE(0 to C_NUM_FSTORES - 1);
--signal start_address_sg         : STARTADDR_ARRAY_TYPE(0 to C_NUM_FSTORES - 1);


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin



-- If Scatter Gather engine is included then instantiate SG register block
GEN_SG_REGISTER : if C_INCLUDE_SG = 1 generate
begin

    -- Flag for updating video parameters on descriptor fetch
    -- Used to enable vsize, hsize, stride, frmdly update on first desc
    -- fetchted
    REG_UPDATE_VIDEO_PRMTRS : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                    video_parameter_updt <= '0';
                -- if new tailpointer and sg fetch engine idle or if new start then
                -- set flag to capture video parameters
                elsif((tailpntr_updated = '1' and ftch_idle = '1') or run_stop_re = '1')then
                    video_parameter_updt <= '1';
                -- clear flag when parameters written to video_register module.
                elsif(desc_data_wren = '1')then
                    video_parameter_updt <= '0';
                end if;
            end if;
        end process REG_UPDATE_VIDEO_PRMTRS;


    -- Register run stop to generate rising edge pulse
    -- Used to force start address counter reset on shutdown
    REG_RUN_STOP : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    run_stop_d1 <= '0';
                else
                    run_stop_d1 <= run_stop;
                end if;
            end if;
        end process REG_RUN_STOP;

        run_stop_re <= run_stop and not run_stop_d1;

    -- Scatter Gather Start Address Register Block (LUTRAM)
    SG_ADDREG_I : entity  axi_vdma_v6_3_10.axi_vdma_sgregister
        generic map(
            C_NUM_FSTORES               => C_NUM_FSTORES                        ,
            C_ADDR_WIDTH                => C_ADDR_WIDTH                         ,
            C_SELECT_XPM                => C_SELECT_XPM                         ,
            C_FAMILY                    => C_FAMILY
        )
        port map (
            prmry_aclk               => prmry_aclk                              ,
            prmry_resetn             => prmry_resetn                            ,

            -- Update Control
            video_reg_update            => video_reg_update                     ,
            video_parameter_updt        => video_parameter_updt                 ,
            video_parameter_valid       => video_prmtrs_valid_i                 ,
            dmasr_halt                  => dmasr_halt                           ,
            strt_addr_clr               => run_stop_re                          ,
            desc_data_wren              => desc_data_wren                       ,
            frame_number                => frame_number                         ,
            ftch_complete               => ftch_complete                        ,
            ftch_complete_clr           => ftch_complete_clr_i                  ,
            update_complete             => update_complete                      ,
            num_fstore_minus1           => num_fstore_minus1                    , -- CR607089

            -- Video Start Address / Parameters In from Scatter Gather Engine
            desc_vsize                  => desc_vsize                           ,
            desc_hsize                  => desc_hsize                           ,
            desc_stride                 => desc_stride                          ,
            desc_frmdly                 => desc_frmdly                          ,
            desc_strtaddress            => desc_strtaddress                     ,

            -- Video Start Address / Parameters Out to DMA Controller
            crnt_vsize                  => crnt_vsize                           ,
            crnt_hsize                  => crnt_hsize                           ,
            crnt_stride                 => crnt_stride                          ,
            crnt_frmdly                 => crnt_frmdly                          ,
            crnt_start_address          => crnt_start_address
        );

    -- Generate logic to transfer sg bank to vid bank of registers
    -- transfer on frame sync if sg engine fetch is complete
    --video_reg_update <= '1' when (frame_sync = '1' and ftch_complete = '1')
    --                          or (video_prmtrs_valid_i = '0' and ftch_complete = '1')
    --               else '0';
    video_reg_update <= '1' when (frame_sync = '1' and update_complete = '1')
                              or (video_prmtrs_valid_i = '0' and update_complete = '1')
                   else '0';

    -- CR605424
    -- Pass up to sts_mngr when update is finally complete
    -- This is used for initial fsync generation for Free Run mode
    prmtr_update_complete   <= update_complete;

    -- Indicate valid parameters on fsync and video registers updated.
    REG_VIDPRMTR_VALID : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- reset or channel halt will clear video parameters
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                    video_prmtrs_valid_i    <= '0';
                    ftch_complete_clr_i     <= '0';
                -- Frame sync and video parameter have been updated,then flag video parameters
                -- valid
                --elsif(frame_sync = '1' and ftch_complete = '1')then
                elsif(frame_sync = '1' and update_complete = '1')then
                    video_prmtrs_valid_i    <= '1';
                    ftch_complete_clr_i     <= '1';
                else
                    video_prmtrs_valid_i    <= video_prmtrs_valid_i;
                    ftch_complete_clr_i     <= '0';
                end if;
            end if;
        end process REG_VIDPRMTR_VALID;

    -- When video register block update drive out parameter update flag
    -- for generation of ****_prmtr_update output
    parameter_update <= ftch_complete_clr_i;

    -- Clear fetch flag in sg interface
    ftch_complete_clr <= ftch_complete_clr_i;

    -- Drive out flag to sm and frame counter that valid video
    -- parameters have been loaded.
    video_prmtrs_valid  <= video_prmtrs_valid_i;

end generate GEN_SG_REGISTER;


-- If Scatter Gather engine is excluded then instantiate register direct block
GEN_REGISTER_DIRECT : if C_INCLUDE_SG = 0 generate
begin

  GEN_REGDIRECT_DRES : if C_DYNAMIC_RESOLUTION = 1 generate

   begin

    ftch_complete_clr <= '0'; -- Not Used in Register Direct Mode

    -- Register Direct Mode - Video Register Block
-------    REGDIR_REGBLOCK_I : entity  axi_vdma_v6_3_10.axi_vdma_vregister
-------        generic map(
-------            C_NUM_FSTORES               => C_NUM_FSTORES                        ,
-------            C_ADDR_WIDTH                => C_ADDR_WIDTH
-------
-------        )
-------        port map(
-------            prmry_aclk                  => prmry_aclk                           ,
-------            prmry_resetn                => prmry_resetn                         ,
-------
-------            -- Video Register Update control
-------            video_reg_update            => ftch_complete                        ,
-------
-------            dmasr_halt                  => dmasr_halt                           ,
-------
-------            -- Scatter Gather register Bank
-------            vsize_sg                    => reg_module_vsize                     ,
-------            hsize_sg                    => reg_module_hsize                     ,
-------            stride_sg                   => reg_module_stride                    ,
-------            frmdly_sg                   => reg_module_frmdly                    ,
-------            start_address_sg            => reg_module_strt_addr                 ,
-------
-------            -- Video Register Bank
-------            vsize_vid                   => vsize_sg                             ,
-------            hsize_vid                   => hsize_sg                             ,
-------            stride_vid                  => stride_sg                            ,
-------            frmdly_vid                  => frmdly_sg                            ,
-------            start_address_vid           => start_address_sg
-------        );
-------
    -- Flag when video parameters/start address have been updated.
    -- Assert on sg engine fetch or register update is complete
    REG_PRE_VIDREG_UPDT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear flag on reset, or halt
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                    video_reg_updated       <= '0';

                elsif(video_reg_updated = '1' and frame_sync = '1')then
                    video_reg_updated       <= '0';

                -- video parameter from register module updated to
                -- pre-video register block
                elsif(ftch_complete = '1')then			-- in RegDirect mode ftch_complete = writing VSIZE register.
                    video_reg_updated       <= '1';
                end if;
            end if;
        end process REG_PRE_VIDREG_UPDT;

    -- Generate logic to transfer sg bank to vid bank of registers
    -- transfer on frame sync if sg engine fetch is complete
    video_reg_update <= '1' when (frame_sync = '1' and video_reg_updated = '1')
                              or (video_prmtrs_valid_i = '0' and video_reg_updated = '1')
                   else '0';

    -- CR605424
    -- Pass up to sts_mngr when update is finally complete
    -- This is used for initial fsync generation for Free Run mode
    prmtr_update_complete   <= video_reg_updated;

    -- Indicate valid parameters on fsync and video registers updated.
    REG_VIDPRMTR_VALID : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- reset or channel halt will clear video parameters
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                    video_prmtrs_valid_i    <= '0';
                    parameter_update        <= '0';
                -- Frame sync and video parameter have been updated,then flag video parameters
                -- valid
                -- CR583673 - Fixes wrong hsize and frmdly values being registered on first frame
                --elsif(frame_sync = '1' and (ftch_complete = '1' or video_reg_updated = '1'))then
                elsif(frame_sync = '1' and video_reg_updated = '1')then
                    video_prmtrs_valid_i    <= '1';
                    parameter_update        <= '1';
                else
                    video_prmtrs_valid_i    <= video_prmtrs_valid_i;
                    parameter_update        <= '0';
                end if;
            end if;
        end process REG_VIDPRMTR_VALID;

    -- Drive out flag to sm and frame counter that valid video
    -- parameters have been loaded.
    video_prmtrs_valid  <= video_prmtrs_valid_i;


    -- Video Register Block
    VIDREGISTER_I : entity  axi_vdma_v6_3_10.axi_vdma_vregister
        generic map(
            C_NUM_FSTORES               => C_NUM_FSTORES                        ,
            C_ADDR_WIDTH                => C_ADDR_WIDTH

        )
        port map(
            prmry_aclk                  => prmry_aclk                           ,
            prmry_resetn               => prmry_resetn                        ,

            -- Video Register Update control
            video_reg_update            => video_reg_update                     ,

            dmasr_halt                  => dmasr_halt                           ,

            -- Scatter Gather register Bank
--            vsize_sg                    => vsize_sg                             ,
--            hsize_sg                    => hsize_sg                             ,
--            stride_sg                   => stride_sg                            ,
--            frmdly_sg                   => frmdly_sg                            ,
--            start_address_sg            => start_address_sg                     ,

            vsize_sg                    => reg_module_vsize                     ,
            hsize_sg                    => reg_module_hsize                     ,
            stride_sg                   => reg_module_stride                    ,
            frmdly_sg                   => reg_module_frmdly                    ,
            start_address_sg            => reg_module_strt_addr                 ,




            -- Video Register Bank
            vsize_vid                   => crnt_vsize                           ,
            hsize_vid                   => crnt_hsize                           ,
            stride_vid                  => crnt_stride                          ,
            frmdly_vid                  => crnt_frmdly                          ,
            start_address_vid           => start_address_vid

        );

    -- Video Start Address MUX
    VIDADDR_MUX_I : entity  axi_vdma_v6_3_10.axi_vdma_vaddrreg_mux
        generic map(
            C_NUM_FSTORES               => C_NUM_FSTORES                        ,
            C_ADDR_WIDTH                => C_ADDR_WIDTH
        )
        port map(
            prmry_aclk                  => prmry_aclk                           ,
            prmry_resetn               => prmry_resetn                          ,

            -- Current Frame Number
            frame_number                => frame_number                         ,
            start_address_vid           => start_address_vid                    ,
            crnt_start_address          => crnt_start_address
        );

  end generate GEN_REGDIRECT_DRES;


  GEN_REGDIRECT_NO_DRES : if C_DYNAMIC_RESOLUTION = 0 generate

   begin

    ftch_complete_clr <= '0'; -- Not Used in Register Direct Mode

    -- Flag when video parameters/start address have been updated.
    -- Assert on sg engine fetch or register update is complete
    REG_PRE_VIDREG_UPDT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear flag on reset, or halt
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                    video_reg_updated       <= '0';

                elsif(video_reg_updated = '1' and frame_sync = '1')then
                    video_reg_updated       <= '0';

                -- video parameter from register module updated to
                -- pre-video register block
                elsif(ftch_complete = '1')then			-- in RegDirect mode ftch_complete = writing VSIZE register.
                    video_reg_updated       <= '1';
                end if;
            end if;
        end process REG_PRE_VIDREG_UPDT;

    -- CR605424
    -- Pass up to sts_mngr when update is finally complete
    -- This is used for initial fsync generation for Free Run mode
    prmtr_update_complete   <= video_reg_updated;

    -- Indicate valid parameters on fsync and video registers updated.
    REG_VIDPRMTR_VALID : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- reset or channel halt will clear video parameters
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                    video_prmtrs_valid_i    <= '0';
                    parameter_update        <= '0';
                -- Frame sync and video parameter have been updated,then flag video parameters
                -- valid
                -- CR583673 - Fixes wrong hsize and frmdly values being registered on first frame
                --elsif(frame_sync = '1' and (ftch_complete = '1' or video_reg_updated = '1'))then
                elsif(frame_sync = '1' and video_reg_updated = '1')then
                    video_prmtrs_valid_i    <= '1';
                    parameter_update        <= '1';
                else
                    video_prmtrs_valid_i    <= video_prmtrs_valid_i;
                    parameter_update        <= '0';
                end if;
            end if;
        end process REG_VIDPRMTR_VALID;

    -- Drive out flag to sm and frame counter that valid video
    -- parameters have been loaded.
    video_prmtrs_valid  <= video_prmtrs_valid_i;



crnt_vsize 		<= reg_module_vsize;
crnt_hsize 		<= reg_module_hsize;
crnt_stride 		<= reg_module_stride;
crnt_frmdly 		<= reg_module_frmdly;

-- Generate C_NUM_FSTORE start address registeres
GEN_START_ADDR_REG : for i in 0 to C_NUM_FSTORES-1 generate
begin

start_address_vid(i) 	<= reg_module_strt_addr(i);

end generate GEN_START_ADDR_REG;

    -- Video Start Address MUX
    VIDADDR_MUX_I : entity  axi_vdma_v6_3_10.axi_vdma_vaddrreg_mux
        generic map(
            C_NUM_FSTORES               => C_NUM_FSTORES                        ,
            C_ADDR_WIDTH                => C_ADDR_WIDTH
        )
        port map(
            prmry_aclk                  => prmry_aclk                           ,
            prmry_resetn               => prmry_resetn                          ,

            -- Current Frame Number
            frame_number                => frame_number                         ,
            start_address_vid           => start_address_vid                    ,
            crnt_start_address          => crnt_start_address
        );

  end generate GEN_REGDIRECT_NO_DRES;



end generate GEN_REGISTER_DIRECT;




end implementation;



-------------------------------------------------------------------------------
-- axi_vdma_vidreg_module_64
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_vidreg_module_64.vhd
--
-- Description:     This entity is the top level for the dual register blocks,
--                  i.e. video register set and sg register set and provides
--                  indication of valid parameters.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module_64.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module_64.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_vidreg_module_64 is
    generic(
        C_INCLUDE_SG              : integer range 0 to 1        := 1        ;
            -- Include or Exclude Scatter Gather Engine
            -- 0 = Exclude Scatter Gather Engine (Enables Register Direct Mode)
            -- 1 = Include Scatter Gather Engine

        C_NUM_FSTORES             : integer range 1 to 32       := 1        ;
            -- Number of Frame Stores

        -----------------------------------------------------------------------
        C_DYNAMIC_RESOLUTION      : integer range 0 to 1      	:= 1	    ;
            -- Run time configuration of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 0 = Halt VDMA before writing new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 1 = Run time register configuration for new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE.
        -----------------------------------------------------------------------




        C_ADDR_WIDTH              : integer range 32 to 64      := 32       ;
            -- Start Address Width

        C_SELECT_XPM              : integer    := 1;
        C_FAMILY                  : string            		:= "virtex7"
            -- Target FPGA Device Family


    );
    port (
        prmry_aclk                  : in  std_logic                         ;       --
        prmry_resetn                : in  std_logic                         ;       --
                                                                                    --
                                                                                    --
        -- Register update control                                                  --
        run_stop                    : in  std_logic                         ;       --
        dmasr_halt                  : in  std_logic                         ;       --
        ftch_idle                   : in  std_logic                         ;       --
        tailpntr_updated            : in  std_logic                         ;       --
        frame_number                : in  std_logic_vector                          --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;       --
        num_fstore_minus1           : in  std_logic_vector                          --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;       --
                                                                                    --
        -- Register swap control/status                                             --
        frame_sync                  : in  std_logic                         ;       --
        ftch_complete               : in  std_logic                         ;       --
        ftch_complete_clr           : out std_logic                         ;       --
        parameter_update            : out std_logic                         ;       --
        video_prmtrs_valid          : out std_logic                         ;       --
        prmtr_update_complete       : out std_logic                         ;       -- 
                                                                                    --
        -- Register Direct Mode Video Parameter In                                  --
        reg_module_vsize            : in  std_logic_vector                          --
                                        (VSIZE_DWIDTH-1 downto 0)           ;       --
        reg_module_hsize            : in  std_logic_vector                          --
                                        (HSIZE_DWIDTH-1 downto 0)           ;       --
        reg_module_stride           : in  std_logic_vector                          --
                                        (STRIDE_DWIDTH-1 downto 0)          ;       --
        reg_module_frmdly           : in  std_logic_vector                          --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;       --
        reg_module_strt_addr        : in STARTADDR_ARRAY_TYPE_64                       --
                                        (0 to C_NUM_FSTORES - 1)            ;       --
                                                                                    --
        -- Descriptor data/control from sg interface                                --
        desc_data_wren              : in  std_logic                         ;       --
                                                                                    --
        desc_strtaddress            : in  std_logic_vector                          --
                                        (C_ADDR_WIDTH-1 downto 0)           ;       --
        desc_vsize                  : in  std_logic_vector                          --
                                        (VSIZE_DWIDTH-1 downto 0)           ;       --
        desc_hsize                  : in  std_logic_vector                          --
                                        (HSIZE_DWIDTH-1 downto 0)           ;       --
        desc_stride                 : in  std_logic_vector                          --
                                        (STRIDE_DWIDTH-1 downto 0)          ;       --
        desc_frmdly                 : in  std_logic_vector                          --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;       --
                                                                                    --
        -- Scatter Gather register Bank                                             --
        crnt_vsize                  : out std_logic_vector                          --
                                        (VSIZE_DWIDTH-1 downto 0)           ;       --
        crnt_hsize                  : out std_logic_vector                          --
                                        (HSIZE_DWIDTH-1 downto 0)           ;       --
        crnt_stride                 : out std_logic_vector                          --
                                        (STRIDE_DWIDTH-1 downto 0)          ;       --
        crnt_frmdly                 : out std_logic_vector                          --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;       --
        crnt_start_address          : out std_logic_vector                          --
                                        (C_ADDR_WIDTH - 1 downto 0)                 --
    );
end axi_vdma_vidreg_module_64;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_vidreg_module_64 is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Control
signal video_parameter_updt     : std_logic := '0';
signal video_prmtrs_valid_i     : std_logic := '0';
signal ftch_complete_clr_i      : std_logic := '0';
signal run_stop_re              : std_logic := '0';
signal run_stop_d1              : std_logic := '0';
signal video_reg_updated        : std_logic := '0';
signal video_reg_update         : std_logic := '0';
signal update_complete          : std_logic := '0';

-- Scatter Gather Side Video Register Bank
--signal vsize_sg                 : std_logic_vector(VSIZE_DWIDTH-1 downto 0)    := (others => '0');
--signal hsize_sg                 : std_logic_vector(HSIZE_DWIDTH-1 downto 0)    := (others => '0');
--signal stride_sg                : std_logic_vector(STRIDE_DWIDTH-1 downto 0)   := (others => '0');
--signal frmdly_sg                : std_logic_vector(FRMDLY_DWIDTH-1 downto 0)   := (others => '0');
signal start_address_vid        : STARTADDR_ARRAY_TYPE_64(0 to C_NUM_FSTORES - 1);
--signal start_address_sg         : STARTADDR_ARRAY_TYPE(0 to C_NUM_FSTORES - 1);


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin



-- If Scatter Gather engine is included then instantiate SG register block
GEN_SG_REGISTER : if C_INCLUDE_SG = 1 generate
begin

    -- Flag for updating video parameters on descriptor fetch
    -- Used to enable vsize, hsize, stride, frmdly update on first desc
    -- fetchted
    REG_UPDATE_VIDEO_PRMTRS : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                    video_parameter_updt <= '0';
                -- if new tailpointer and sg fetch engine idle or if new start then
                -- set flag to capture video parameters
                elsif((tailpntr_updated = '1' and ftch_idle = '1') or run_stop_re = '1')then
                    video_parameter_updt <= '1';
                -- clear flag when parameters written to video_register module.
                elsif(desc_data_wren = '1')then
                    video_parameter_updt <= '0';
                end if;
            end if;
        end process REG_UPDATE_VIDEO_PRMTRS;


    -- Register run stop to generate rising edge pulse
    -- Used to force start address counter reset on shutdown
    REG_RUN_STOP : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    run_stop_d1 <= '0';
                else
                    run_stop_d1 <= run_stop;
                end if;
            end if;
        end process REG_RUN_STOP;

        run_stop_re <= run_stop and not run_stop_d1;

    -- Scatter Gather Start Address Register Block (LUTRAM)
    SG_ADDREG_I : entity  axi_vdma_v6_3_10.axi_vdma_sgregister
        generic map(
            C_NUM_FSTORES               => C_NUM_FSTORES                        ,
            C_ADDR_WIDTH                => C_ADDR_WIDTH                         ,
            C_SELECT_XPM                => C_SELECT_XPM                         ,
            C_FAMILY                    => C_FAMILY
        )
        port map (
            prmry_aclk               => prmry_aclk                              ,
            prmry_resetn             => prmry_resetn                            ,

            -- Update Control
            video_reg_update            => video_reg_update                     ,
            video_parameter_updt        => video_parameter_updt                 ,
            video_parameter_valid       => video_prmtrs_valid_i                 ,
            dmasr_halt                  => dmasr_halt                           ,
            strt_addr_clr               => run_stop_re                          ,
            desc_data_wren              => desc_data_wren                       ,
            frame_number                => frame_number                         ,
            ftch_complete               => ftch_complete                        ,
            ftch_complete_clr           => ftch_complete_clr_i                  ,
            update_complete             => update_complete                      ,
            num_fstore_minus1           => num_fstore_minus1                    , -- 

            -- Video Start Address / Parameters In from Scatter Gather Engine
            desc_vsize                  => desc_vsize                           ,
            desc_hsize                  => desc_hsize                           ,
            desc_stride                 => desc_stride                          ,
            desc_frmdly                 => desc_frmdly                          ,
            desc_strtaddress            => desc_strtaddress                     ,

            -- Video Start Address / Parameters Out to DMA Controller
            crnt_vsize                  => crnt_vsize                           ,
            crnt_hsize                  => crnt_hsize                           ,
            crnt_stride                 => crnt_stride                          ,
            crnt_frmdly                 => crnt_frmdly                          ,
            crnt_start_address          => crnt_start_address
        );

    -- Generate logic to transfer sg bank to vid bank of registers
    -- transfer on frame sync if sg engine fetch is complete
    --video_reg_update <= '1' when (frame_sync = '1' and ftch_complete = '1')
    --                          or (video_prmtrs_valid_i = '0' and ftch_complete = '1')
    --               else '0';
    video_reg_update <= '1' when (frame_sync = '1' and update_complete = '1')
                              or (video_prmtrs_valid_i = '0' and update_complete = '1')
                   else '0';

    -- 
    -- Pass up to sts_mngr when update is finally complete
    -- This is used for initial fsync generation for Free Run mode
    prmtr_update_complete   <= update_complete;

    -- Indicate valid parameters on fsync and video registers updated.
    REG_VIDPRMTR_VALID : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- reset or channel halt will clear video parameters
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                    video_prmtrs_valid_i    <= '0';
                    ftch_complete_clr_i     <= '0';
                -- Frame sync and video parameter have been updated,then flag video parameters
                -- valid
                --elsif(frame_sync = '1' and ftch_complete = '1')then
                elsif(frame_sync = '1' and update_complete = '1')then
                    video_prmtrs_valid_i    <= '1';
                    ftch_complete_clr_i     <= '1';
                else
                    video_prmtrs_valid_i    <= video_prmtrs_valid_i;
                    ftch_complete_clr_i     <= '0';
                end if;
            end if;
        end process REG_VIDPRMTR_VALID;

    -- When video register block update drive out parameter update flag
    -- for generation of ****_prmtr_update output
    parameter_update <= ftch_complete_clr_i;

    -- Clear fetch flag in sg interface
    ftch_complete_clr <= ftch_complete_clr_i;

    -- Drive out flag to sm and frame counter that valid video
    -- parameters have been loaded.
    video_prmtrs_valid  <= video_prmtrs_valid_i;

end generate GEN_SG_REGISTER;


-- If Scatter Gather engine is excluded then instantiate register direct block
GEN_REGISTER_DIRECT : if C_INCLUDE_SG = 0 generate
begin

  GEN_REGDIRECT_DRES : if C_DYNAMIC_RESOLUTION = 1 generate

   begin

    ftch_complete_clr <= '0'; -- Not Used in Register Direct Mode

    -- Register Direct Mode - Video Register Block
-------    REGDIR_REGBLOCK_I : entity  axi_vdma_v6_3_10.axi_vdma_vregister
-------        generic map(
-------            C_NUM_FSTORES               => C_NUM_FSTORES                        ,
-------            C_ADDR_WIDTH                => C_ADDR_WIDTH
-------
-------        )
-------        port map(
-------            prmry_aclk                  => prmry_aclk                           ,
-------            prmry_resetn                => prmry_resetn                         ,
-------
-------            -- Video Register Update control
-------            video_reg_update            => ftch_complete                        ,
-------
-------            dmasr_halt                  => dmasr_halt                           ,
-------
-------            -- Scatter Gather register Bank
-------            vsize_sg                    => reg_module_vsize                     ,
-------            hsize_sg                    => reg_module_hsize                     ,
-------            stride_sg                   => reg_module_stride                    ,
-------            frmdly_sg                   => reg_module_frmdly                    ,
-------            start_address_sg            => reg_module_strt_addr                 ,
-------
-------            -- Video Register Bank
-------            vsize_vid                   => vsize_sg                             ,
-------            hsize_vid                   => hsize_sg                             ,
-------            stride_vid                  => stride_sg                            ,
-------            frmdly_vid                  => frmdly_sg                            ,
-------            start_address_vid           => start_address_sg
-------        );
-------
    -- Flag when video parameters/start address have been updated.
    -- Assert on sg engine fetch or register update is complete
    REG_PRE_VIDREG_UPDT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear flag on reset, or halt
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                    video_reg_updated       <= '0';

                elsif(video_reg_updated = '1' and frame_sync = '1')then
                    video_reg_updated       <= '0';

                -- video parameter from register module updated to
                -- pre-video register block
                elsif(ftch_complete = '1')then			-- in RegDirect mode ftch_complete = writing VSIZE register.
                    video_reg_updated       <= '1';
                end if;
            end if;
        end process REG_PRE_VIDREG_UPDT;

    -- Generate logic to transfer sg bank to vid bank of registers
    -- transfer on frame sync if sg engine fetch is complete
    video_reg_update <= '1' when (frame_sync = '1' and video_reg_updated = '1')
                              or (video_prmtrs_valid_i = '0' and video_reg_updated = '1')
                   else '0';

    -- 
    -- Pass up to sts_mngr when update is finally complete
    -- This is used for initial fsync generation for Free Run mode
    prmtr_update_complete   <= video_reg_updated;

    -- Indicate valid parameters on fsync and video registers updated.
    REG_VIDPRMTR_VALID : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- reset or channel halt will clear video parameters
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                    video_prmtrs_valid_i    <= '0';
                    parameter_update        <= '0';
                -- Frame sync and video parameter have been updated,then flag video parameters
                -- valid
                -- 
                --elsif(frame_sync = '1' and (ftch_complete = '1' or video_reg_updated = '1'))then
                elsif(frame_sync = '1' and video_reg_updated = '1')then
                    video_prmtrs_valid_i    <= '1';
                    parameter_update        <= '1';
                else
                    video_prmtrs_valid_i    <= video_prmtrs_valid_i;
                    parameter_update        <= '0';
                end if;
            end if;
        end process REG_VIDPRMTR_VALID;

    -- Drive out flag to sm and frame counter that valid video
    -- parameters have been loaded.
    video_prmtrs_valid  <= video_prmtrs_valid_i;


    -- Video Register Block
    VIDREGISTER_I : entity  axi_vdma_v6_3_10.axi_vdma_vregister_64
        generic map(
            C_NUM_FSTORES               => C_NUM_FSTORES                        ,
            C_ADDR_WIDTH                => C_ADDR_WIDTH

        )
        port map(
            prmry_aclk                  => prmry_aclk                           ,
            prmry_resetn               => prmry_resetn                        ,

            -- Video Register Update control
            video_reg_update            => video_reg_update                     ,

            dmasr_halt                  => dmasr_halt                           ,

            -- Scatter Gather register Bank
--            vsize_sg                    => vsize_sg                             ,
--            hsize_sg                    => hsize_sg                             ,
--            stride_sg                   => stride_sg                            ,
--            frmdly_sg                   => frmdly_sg                            ,
--            start_address_sg            => start_address_sg                     ,

            vsize_sg                    => reg_module_vsize                     ,
            hsize_sg                    => reg_module_hsize                     ,
            stride_sg                   => reg_module_stride                    ,
            frmdly_sg                   => reg_module_frmdly                    ,
            start_address_sg            => reg_module_strt_addr                 ,




            -- Video Register Bank
            vsize_vid                   => crnt_vsize                           ,
            hsize_vid                   => crnt_hsize                           ,
            stride_vid                  => crnt_stride                          ,
            frmdly_vid                  => crnt_frmdly                          ,
            start_address_vid           => start_address_vid

        );

    -- Video Start Address MUX
    VIDADDR_MUX_I : entity  axi_vdma_v6_3_10.axi_vdma_vaddrreg_mux_64
        generic map(
            C_NUM_FSTORES               => C_NUM_FSTORES                        ,
            C_ADDR_WIDTH                => C_ADDR_WIDTH
        )
        port map(
            prmry_aclk                  => prmry_aclk                           ,
            prmry_resetn               => prmry_resetn                          ,

            -- Current Frame Number
            frame_number                => frame_number                         ,
            start_address_vid           => start_address_vid                    ,
            crnt_start_address          => crnt_start_address
        );

  end generate GEN_REGDIRECT_DRES;


  GEN_REGDIRECT_NO_DRES : if C_DYNAMIC_RESOLUTION = 0 generate

   begin

    ftch_complete_clr <= '0'; -- Not Used in Register Direct Mode

    -- Flag when video parameters/start address have been updated.
    -- Assert on sg engine fetch or register update is complete
    REG_PRE_VIDREG_UPDT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear flag on reset, or halt
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                    video_reg_updated       <= '0';

                elsif(video_reg_updated = '1' and frame_sync = '1')then
                    video_reg_updated       <= '0';

                -- video parameter from register module updated to
                -- pre-video register block
                elsif(ftch_complete = '1')then			-- in RegDirect mode ftch_complete = writing VSIZE register.
                    video_reg_updated       <= '1';
                end if;
            end if;
        end process REG_PRE_VIDREG_UPDT;

    -- 
    -- Pass up to sts_mngr when update is finally complete
    -- This is used for initial fsync generation for Free Run mode
    prmtr_update_complete   <= video_reg_updated;

    -- Indicate valid parameters on fsync and video registers updated.
    REG_VIDPRMTR_VALID : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- reset or channel halt will clear video parameters
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                    video_prmtrs_valid_i    <= '0';
                    parameter_update        <= '0';
                -- Frame sync and video parameter have been updated,then flag video parameters
                -- valid
                -- 
                --elsif(frame_sync = '1' and (ftch_complete = '1' or video_reg_updated = '1'))then
                elsif(frame_sync = '1' and video_reg_updated = '1')then
                    video_prmtrs_valid_i    <= '1';
                    parameter_update        <= '1';
                else
                    video_prmtrs_valid_i    <= video_prmtrs_valid_i;
                    parameter_update        <= '0';
                end if;
            end if;
        end process REG_VIDPRMTR_VALID;

    -- Drive out flag to sm and frame counter that valid video
    -- parameters have been loaded.
    video_prmtrs_valid  <= video_prmtrs_valid_i;



crnt_vsize 		<= reg_module_vsize;
crnt_hsize 		<= reg_module_hsize;
crnt_stride 		<= reg_module_stride;
crnt_frmdly 		<= reg_module_frmdly;

-- Generate C_NUM_FSTORE start address registeres
GEN_START_ADDR_REG : for i in 0 to C_NUM_FSTORES-1 generate
begin

start_address_vid(i) 	<= reg_module_strt_addr(i);

end generate GEN_START_ADDR_REG;

    -- Video Start Address MUX
    VIDADDR_MUX_I : entity  axi_vdma_v6_3_10.axi_vdma_vaddrreg_mux_64
        generic map(
            C_NUM_FSTORES               => C_NUM_FSTORES                        ,
            C_ADDR_WIDTH                => C_ADDR_WIDTH
        )
        port map(
            prmry_aclk                  => prmry_aclk                           ,
            prmry_resetn               => prmry_resetn                          ,

            -- Current Frame Number
            frame_number                => frame_number                         ,
            start_address_vid           => start_address_vid                    ,
            crnt_start_address          => crnt_start_address
        );

  end generate GEN_REGDIRECT_NO_DRES;



end generate GEN_REGISTER_DIRECT;




end implementation;



-------------------------------------------------------------------------------
-- axi_vdma_genlock_mux
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_genlock_mux.vhd
--
-- Description:     This entity encompasses the Gen Lock Mux.  This entity
--                  rips frame_ptr_in bus based on master in control selection.
--                  MUX size based on number of masters parameter.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_genlock_mux is
    generic(
        C_GENLOCK_NUM_MASTERS   	: integer range 1 to 16     := 1                    ;
            -- Number of Gen-Lock masters capable of controlling Gen-Lock Slave

        C_INTERNAL_GENLOCK_ENABLE   	: integer range 0 to 1  := 0
            -- Enable internal genlock bus
            -- 0 = disable internal genlock bus
            -- 1 = enable internal genlock bus
    );
    port (

        prmry_aclk              : in std_logic                                      ;   --
        prmry_resetn            : in std_logic                                      ;   --
                                                                                        --
        mstr_in_control         : in std_logic_vector(3 downto 0)                   ;   --
        genlock_select          : in std_logic                                      ;   --
                                                                                        --
        internal_frame_ptr_in   : in  std_logic_vector                                  --
                                    (NUM_FRM_STORE_WIDTH-1 downto 0)                ;   --
        frame_ptr_in            : in std_logic_vector                                   --
                                    ((C_GENLOCK_NUM_MASTERS                             --
                                    *NUM_FRM_STORE_WIDTH)-1 downto 0)               ;   --
                                                                                        --
        frame_ptr_out           : out std_logic_vector                                  --
                                    (NUM_FRM_STORE_WIDTH-1 downto 0)                    --
    );
end axi_vdma_genlock_mux;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_genlock_mux is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal frame_ptr2use        : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0)  := (others => '0');
signal mstr_selected        : std_logic_vector(3 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

-- Register frame pointer out
REG_POINTER_OUT : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                frame_ptr_out <= (others => '0');

            else
                frame_ptr_out <= frame_ptr2use;
            end if;
        end if;
    end process REG_POINTER_OUT;

-- If internal genlock NOT selected or enabled then set to DMACR pointer ref
-- else if internal genlock is enabled and selected then set to master 0
mstr_selected <= mstr_in_control when genlock_select = '0' or C_INTERNAL_GENLOCK_ENABLE = 0
            else MSTR0;


-- 16 Master Frame Pointer In to Slave Pointer To Use Out
GEN_16_MASTERS : if C_GENLOCK_NUM_MASTERS = 16 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

                when MSTR3 =>
                    frame_ptr2use <= frame_ptr_in(MSTR3_HI_INDEX downto MSTR3_LO_INDEX);

                when MSTR4 =>
                    frame_ptr2use <= frame_ptr_in(MSTR4_HI_INDEX downto MSTR4_LO_INDEX);

                when MSTR5 =>
                    frame_ptr2use <= frame_ptr_in(MSTR5_HI_INDEX downto MSTR5_LO_INDEX);

                when MSTR6 =>
                    frame_ptr2use <= frame_ptr_in(MSTR6_HI_INDEX downto MSTR6_LO_INDEX);

                when MSTR7 =>
                    frame_ptr2use <= frame_ptr_in(MSTR7_HI_INDEX downto MSTR7_LO_INDEX);

                when MSTR8 =>
                    frame_ptr2use <= frame_ptr_in(MSTR8_HI_INDEX downto MSTR8_LO_INDEX);

                when MSTR9 =>
                    frame_ptr2use <= frame_ptr_in(MSTR9_HI_INDEX downto MSTR9_LO_INDEX);

                when MSTR10 =>
                    frame_ptr2use <= frame_ptr_in(MSTR10_HI_INDEX downto MSTR10_LO_INDEX);

                when MSTR11 =>
                    frame_ptr2use <= frame_ptr_in(MSTR11_HI_INDEX downto MSTR11_LO_INDEX);

                when MSTR12 =>
                    frame_ptr2use <= frame_ptr_in(MSTR12_HI_INDEX downto MSTR12_LO_INDEX);

                when MSTR13 =>
                    frame_ptr2use <= frame_ptr_in(MSTR13_HI_INDEX downto MSTR13_LO_INDEX);

                when MSTR14 =>
                    frame_ptr2use <= frame_ptr_in(MSTR14_HI_INDEX downto MSTR14_LO_INDEX);

                when MSTR15 =>
                    frame_ptr2use <= frame_ptr_in(MSTR15_HI_INDEX downto MSTR15_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on

            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_16_MASTERS;

-- 15 Master Frame Pointer In to Slave Pointer To Use Out
GEN_15_MASTERS : if C_GENLOCK_NUM_MASTERS = 15 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

                when MSTR3 =>
                    frame_ptr2use <= frame_ptr_in(MSTR3_HI_INDEX downto MSTR3_LO_INDEX);

                when MSTR4 =>
                    frame_ptr2use <= frame_ptr_in(MSTR4_HI_INDEX downto MSTR4_LO_INDEX);

                when MSTR5 =>
                    frame_ptr2use <= frame_ptr_in(MSTR5_HI_INDEX downto MSTR5_LO_INDEX);

                when MSTR6 =>
                    frame_ptr2use <= frame_ptr_in(MSTR6_HI_INDEX downto MSTR6_LO_INDEX);

                when MSTR7 =>
                    frame_ptr2use <= frame_ptr_in(MSTR7_HI_INDEX downto MSTR7_LO_INDEX);

                when MSTR8 =>
                    frame_ptr2use <= frame_ptr_in(MSTR8_HI_INDEX downto MSTR8_LO_INDEX);

                when MSTR9 =>
                    frame_ptr2use <= frame_ptr_in(MSTR9_HI_INDEX downto MSTR9_LO_INDEX);

                when MSTR10 =>
                    frame_ptr2use <= frame_ptr_in(MSTR10_HI_INDEX downto MSTR10_LO_INDEX);

                when MSTR11 =>
                    frame_ptr2use <= frame_ptr_in(MSTR11_HI_INDEX downto MSTR11_LO_INDEX);

                when MSTR12 =>
                    frame_ptr2use <= frame_ptr_in(MSTR12_HI_INDEX downto MSTR12_LO_INDEX);

                when MSTR13 =>
                    frame_ptr2use <= frame_ptr_in(MSTR13_HI_INDEX downto MSTR13_LO_INDEX);

                when MSTR14 =>
                    frame_ptr2use <= frame_ptr_in(MSTR14_HI_INDEX downto MSTR14_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on

            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_15_MASTERS;

-- 14 Master Frame Pointer In to Slave Pointer To Use Out
GEN_14_MASTERS : if C_GENLOCK_NUM_MASTERS = 14 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

                when MSTR3 =>
                    frame_ptr2use <= frame_ptr_in(MSTR3_HI_INDEX downto MSTR3_LO_INDEX);

                when MSTR4 =>
                    frame_ptr2use <= frame_ptr_in(MSTR4_HI_INDEX downto MSTR4_LO_INDEX);

                when MSTR5 =>
                    frame_ptr2use <= frame_ptr_in(MSTR5_HI_INDEX downto MSTR5_LO_INDEX);

                when MSTR6 =>
                    frame_ptr2use <= frame_ptr_in(MSTR6_HI_INDEX downto MSTR6_LO_INDEX);

                when MSTR7 =>
                    frame_ptr2use <= frame_ptr_in(MSTR7_HI_INDEX downto MSTR7_LO_INDEX);

                when MSTR8 =>
                    frame_ptr2use <= frame_ptr_in(MSTR8_HI_INDEX downto MSTR8_LO_INDEX);

                when MSTR9 =>
                    frame_ptr2use <= frame_ptr_in(MSTR9_HI_INDEX downto MSTR9_LO_INDEX);

                when MSTR10 =>
                    frame_ptr2use <= frame_ptr_in(MSTR10_HI_INDEX downto MSTR10_LO_INDEX);

                when MSTR11 =>
                    frame_ptr2use <= frame_ptr_in(MSTR11_HI_INDEX downto MSTR11_LO_INDEX);

                when MSTR12 =>
                    frame_ptr2use <= frame_ptr_in(MSTR12_HI_INDEX downto MSTR12_LO_INDEX);

                when MSTR13 =>
                    frame_ptr2use <= frame_ptr_in(MSTR13_HI_INDEX downto MSTR13_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on

            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_14_MASTERS;

-- 13 Master Frame Pointer In to Slave Pointer To Use Out
GEN_13_MASTERS : if C_GENLOCK_NUM_MASTERS = 13 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

                when MSTR3 =>
                    frame_ptr2use <= frame_ptr_in(MSTR3_HI_INDEX downto MSTR3_LO_INDEX);

                when MSTR4 =>
                    frame_ptr2use <= frame_ptr_in(MSTR4_HI_INDEX downto MSTR4_LO_INDEX);

                when MSTR5 =>
                    frame_ptr2use <= frame_ptr_in(MSTR5_HI_INDEX downto MSTR5_LO_INDEX);

                when MSTR6 =>
                    frame_ptr2use <= frame_ptr_in(MSTR6_HI_INDEX downto MSTR6_LO_INDEX);

                when MSTR7 =>
                    frame_ptr2use <= frame_ptr_in(MSTR7_HI_INDEX downto MSTR7_LO_INDEX);

                when MSTR8 =>
                    frame_ptr2use <= frame_ptr_in(MSTR8_HI_INDEX downto MSTR8_LO_INDEX);

                when MSTR9 =>
                    frame_ptr2use <= frame_ptr_in(MSTR9_HI_INDEX downto MSTR9_LO_INDEX);

                when MSTR10 =>
                    frame_ptr2use <= frame_ptr_in(MSTR10_HI_INDEX downto MSTR10_LO_INDEX);

                when MSTR11 =>
                    frame_ptr2use <= frame_ptr_in(MSTR11_HI_INDEX downto MSTR11_LO_INDEX);

                when MSTR12 =>
                    frame_ptr2use <= frame_ptr_in(MSTR12_HI_INDEX downto MSTR12_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on

            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_13_MASTERS;


-- 12 Master Frame Pointer In to Slave Pointer To Use Out
GEN_12_MASTERS : if C_GENLOCK_NUM_MASTERS = 12 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

                when MSTR3 =>
                    frame_ptr2use <= frame_ptr_in(MSTR3_HI_INDEX downto MSTR3_LO_INDEX);

                when MSTR4 =>
                    frame_ptr2use <= frame_ptr_in(MSTR4_HI_INDEX downto MSTR4_LO_INDEX);

                when MSTR5 =>
                    frame_ptr2use <= frame_ptr_in(MSTR5_HI_INDEX downto MSTR5_LO_INDEX);

                when MSTR6 =>
                    frame_ptr2use <= frame_ptr_in(MSTR6_HI_INDEX downto MSTR6_LO_INDEX);

                when MSTR7 =>
                    frame_ptr2use <= frame_ptr_in(MSTR7_HI_INDEX downto MSTR7_LO_INDEX);

                when MSTR8 =>
                    frame_ptr2use <= frame_ptr_in(MSTR8_HI_INDEX downto MSTR8_LO_INDEX);

                when MSTR9 =>
                    frame_ptr2use <= frame_ptr_in(MSTR9_HI_INDEX downto MSTR9_LO_INDEX);

                when MSTR10 =>
                    frame_ptr2use <= frame_ptr_in(MSTR10_HI_INDEX downto MSTR10_LO_INDEX);

                when MSTR11 =>
                    frame_ptr2use <= frame_ptr_in(MSTR11_HI_INDEX downto MSTR11_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on

            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_12_MASTERS;

-- 11 Master Frame Pointer In to Slave Pointer To Use Out
GEN_11_MASTERS : if C_GENLOCK_NUM_MASTERS = 11 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

                when MSTR3 =>
                    frame_ptr2use <= frame_ptr_in(MSTR3_HI_INDEX downto MSTR3_LO_INDEX);

                when MSTR4 =>
                    frame_ptr2use <= frame_ptr_in(MSTR4_HI_INDEX downto MSTR4_LO_INDEX);

                when MSTR5 =>
                    frame_ptr2use <= frame_ptr_in(MSTR5_HI_INDEX downto MSTR5_LO_INDEX);

                when MSTR6 =>
                    frame_ptr2use <= frame_ptr_in(MSTR6_HI_INDEX downto MSTR6_LO_INDEX);

                when MSTR7 =>
                    frame_ptr2use <= frame_ptr_in(MSTR7_HI_INDEX downto MSTR7_LO_INDEX);

                when MSTR8 =>
                    frame_ptr2use <= frame_ptr_in(MSTR8_HI_INDEX downto MSTR8_LO_INDEX);

                when MSTR9 =>
                    frame_ptr2use <= frame_ptr_in(MSTR9_HI_INDEX downto MSTR9_LO_INDEX);

                when MSTR10 =>
                    frame_ptr2use <= frame_ptr_in(MSTR10_HI_INDEX downto MSTR10_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on

            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_11_MASTERS;

-- 10 Master Frame Pointer In to Slave Pointer To Use Out
GEN_10_MASTERS : if C_GENLOCK_NUM_MASTERS = 10 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

                when MSTR3 =>
                    frame_ptr2use <= frame_ptr_in(MSTR3_HI_INDEX downto MSTR3_LO_INDEX);

                when MSTR4 =>
                    frame_ptr2use <= frame_ptr_in(MSTR4_HI_INDEX downto MSTR4_LO_INDEX);

                when MSTR5 =>
                    frame_ptr2use <= frame_ptr_in(MSTR5_HI_INDEX downto MSTR5_LO_INDEX);

                when MSTR6 =>
                    frame_ptr2use <= frame_ptr_in(MSTR6_HI_INDEX downto MSTR6_LO_INDEX);

                when MSTR7 =>
                    frame_ptr2use <= frame_ptr_in(MSTR7_HI_INDEX downto MSTR7_LO_INDEX);

                when MSTR8 =>
                    frame_ptr2use <= frame_ptr_in(MSTR8_HI_INDEX downto MSTR8_LO_INDEX);

                when MSTR9 =>
                    frame_ptr2use <= frame_ptr_in(MSTR9_HI_INDEX downto MSTR9_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on

            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_10_MASTERS;

-- 9 Master Frame Pointer In to Slave Pointer To Use Out
GEN_9_MASTERS : if C_GENLOCK_NUM_MASTERS = 9 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

                when MSTR3 =>
                    frame_ptr2use <= frame_ptr_in(MSTR3_HI_INDEX downto MSTR3_LO_INDEX);

                when MSTR4 =>
                    frame_ptr2use <= frame_ptr_in(MSTR4_HI_INDEX downto MSTR4_LO_INDEX);

                when MSTR5 =>
                    frame_ptr2use <= frame_ptr_in(MSTR5_HI_INDEX downto MSTR5_LO_INDEX);

                when MSTR6 =>
                    frame_ptr2use <= frame_ptr_in(MSTR6_HI_INDEX downto MSTR6_LO_INDEX);

                when MSTR7 =>
                    frame_ptr2use <= frame_ptr_in(MSTR7_HI_INDEX downto MSTR7_LO_INDEX);

                when MSTR8 =>
                    frame_ptr2use <= frame_ptr_in(MSTR8_HI_INDEX downto MSTR8_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on

            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_9_MASTERS;

-- 8 Master Frame Pointer In to Slave Pointer To Use Out
GEN_8_MASTERS : if C_GENLOCK_NUM_MASTERS = 8 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

                when MSTR3 =>
                    frame_ptr2use <= frame_ptr_in(MSTR3_HI_INDEX downto MSTR3_LO_INDEX);

                when MSTR4 =>
                    frame_ptr2use <= frame_ptr_in(MSTR4_HI_INDEX downto MSTR4_LO_INDEX);

                when MSTR5 =>
                    frame_ptr2use <= frame_ptr_in(MSTR5_HI_INDEX downto MSTR5_LO_INDEX);

                when MSTR6 =>
                    frame_ptr2use <= frame_ptr_in(MSTR6_HI_INDEX downto MSTR6_LO_INDEX);

                when MSTR7 =>
                    frame_ptr2use <= frame_ptr_in(MSTR7_HI_INDEX downto MSTR7_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on

            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_8_MASTERS;

-- 7 Master Frame Pointer In to Slave Pointer To Use Out
GEN_7_MASTERS : if C_GENLOCK_NUM_MASTERS = 7 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

                when MSTR3 =>
                    frame_ptr2use <= frame_ptr_in(MSTR3_HI_INDEX downto MSTR3_LO_INDEX);

                when MSTR4 =>
                    frame_ptr2use <= frame_ptr_in(MSTR4_HI_INDEX downto MSTR4_LO_INDEX);

                when MSTR5 =>
                    frame_ptr2use <= frame_ptr_in(MSTR5_HI_INDEX downto MSTR5_LO_INDEX);

                when MSTR6 =>
                    frame_ptr2use <= frame_ptr_in(MSTR6_HI_INDEX downto MSTR6_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on

            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_7_MASTERS;

-- 6 Master Frame Pointer In to Slave Pointer To Use Out
GEN_6_MASTERS : if C_GENLOCK_NUM_MASTERS = 6 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

                when MSTR3 =>
                    frame_ptr2use <= frame_ptr_in(MSTR3_HI_INDEX downto MSTR3_LO_INDEX);

                when MSTR4 =>
                    frame_ptr2use <= frame_ptr_in(MSTR4_HI_INDEX downto MSTR4_LO_INDEX);

                when MSTR5 =>
                    frame_ptr2use <= frame_ptr_in(MSTR5_HI_INDEX downto MSTR5_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on

            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_6_MASTERS;

-- 5 Master Frame Pointer In to Slave Pointer To Use Out
GEN_5_MASTERS : if C_GENLOCK_NUM_MASTERS = 5 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

                when MSTR3 =>
                    frame_ptr2use <= frame_ptr_in(MSTR3_HI_INDEX downto MSTR3_LO_INDEX);

                when MSTR4 =>
                    frame_ptr2use <= frame_ptr_in(MSTR4_HI_INDEX downto MSTR4_LO_INDEX);


    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on
            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_5_MASTERS;

-- 4 Master Frame Pointer In to Slave Pointer To Use Out
GEN_4_MASTERS : if C_GENLOCK_NUM_MASTERS = 4 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

                when MSTR3 =>
                    frame_ptr2use <= frame_ptr_in(MSTR3_HI_INDEX downto MSTR3_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on
            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_4_MASTERS;

-- 3 Master Frame Pointer In to Slave Pointer To Use Out
GEN_3_MASTERS : if C_GENLOCK_NUM_MASTERS = 3 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

                when MSTR2 =>
                    frame_ptr2use <= frame_ptr_in(MSTR2_HI_INDEX downto MSTR2_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on
            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_3_MASTERS;

-- 2 Master Frame Pointer In to Slave Pointer To Use Out
GEN_2_MASTERS : if C_GENLOCK_NUM_MASTERS = 2 generate
begin
    MASTER_CONTROL_MUX : process(mstr_selected, frame_ptr_in, genlock_select, internal_frame_ptr_in)
        begin
            case mstr_selected is
                when MSTR0 =>
                    -- If internal genlock bus included and dmacr.genlock_select=1
                    -- then route internal genlock bus as frame pointer to use
                    if(C_INTERNAL_GENLOCK_ENABLE = 1 and  genlock_select = '1')then
                        frame_ptr2use <= internal_frame_ptr_in;
                    else
                        frame_ptr2use <= frame_ptr_in(MSTR0_HI_INDEX downto MSTR0_LO_INDEX);
                    end if;

                when MSTR1 =>
                    frame_ptr2use <= frame_ptr_in(MSTR1_HI_INDEX downto MSTR1_LO_INDEX);

    -- coverage off

                when others =>
                    frame_ptr2use <= (others => '0');
    -- coverage on
            end case;
        end process MASTER_CONTROL_MUX;
end generate GEN_2_MASTERS;

-- 1 Master Frame Pointer In to Slave Pointer To Use Out
GEN_1_MASTERS : if C_GENLOCK_NUM_MASTERS = 1 generate
begin


--    GEN_MUX_FOR_INTERNAL : if C_INTERNAL_GENLOCK_ENABLE = 1 generate
--    begin
--    -- If internal genlock bus included and dmacr.genlock_select=1
--    -- then route internal genlock bus as frame pointer to use
--        MASTER_CONTROL_MUX : process(frame_ptr_in,internal_frame_ptr_in,genlock_select)
--            begin
--                if(genlock_select = '0')then
--                    frame_ptr2use <= frame_ptr_in;
--                else
--                    frame_ptr2use <= internal_frame_ptr_in;
--                end if;
--            end process MASTER_CONTROL_MUX;
--
--    end generate GEN_MUX_FOR_INTERNAL;
    GEN_MUX_FOR_INTERNAL : if C_INTERNAL_GENLOCK_ENABLE = 1 generate
    begin
                       frame_ptr2use <= internal_frame_ptr_in;

    end generate GEN_MUX_FOR_INTERNAL;

    GEN_MUX_FOR_NO_INTERNAL : if C_INTERNAL_GENLOCK_ENABLE = 0 generate
    begin
        frame_ptr2use <= frame_ptr_in;
    end generate GEN_MUX_FOR_NO_INTERNAL;

end generate GEN_1_MASTERS;

end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_greycoder
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_greycoder.vhd
--
-- Description:     This entity encompasses the grey encoder/decoder  for Gen-
--                  Lock operation.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_greycoder is
    generic(
        C_DWIDTH                    : integer range 1 to 16       := 1
    );
    port (
        -- Grey Encode                                                               --
        binary_in                   : in  std_logic_vector(C_DWIDTH-1 downto 0) ;    --
        grey_out                    : out std_logic_vector(C_DWIDTH-1 downto 0) ;    --
                                                                                     --
        -- Grey Decode                                                               --
        grey_in                     : in  std_logic_vector(C_DWIDTH-1 downto 0) ;    --
        binary_out                  : out std_logic_vector(C_DWIDTH-1 downto 0)      --
    );
end axi_vdma_greycoder;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_greycoder is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------

signal binary_out_i     : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

-------------------------------------------------------------------------------
-- Binary to Grey Encoder
-- Example: DWIDTH = 4
-- Grey(3) = Binary(3)
-- Grey(2) = Binary(3) xor Binary(2)
-- Grey(1) = Binary(2) xor Binary(1)
-- Grey(0) = Binary(1) xor Binary(0)
-------------------------------------------------------------------------------
GREY_ENCODE : process(binary_in)
    begin
        -- MSB Grey Code Bit = MSB Binary Bit
        grey_out(C_DWIDTH - 1) <= binary_in(C_DWIDTH - 1);

        for i in C_DWIDTH - 2 downto 0 loop
            grey_out(i) <= binary_in(i+1) xor binary_in(i);
        end loop;
    end process GREY_ENCODE;


-------------------------------------------------------------------------------
-- Grey to Binary Decoder
-- Example: DWIDTH = 4
-- Binary(3) = Grey(3)
-- Binary(2) = Grey(3) xor Grey(2)
-- Binary(1) = Grey(3) xor Grey(2) xor Grey(1)
-- Binary(0) = Grey(3) xor Grey(2) xor Grey(1) xor Grey(0)
-------------------------------------------------------------------------------
GREY_DECODE : process(grey_in)
    variable binary_acc   : std_logic_vector(C_DWIDTH - 1 downto 0) := (others => '0');
    begin
        -- Default to zero
        binary_acc      := (others => '0');
        binary_out_i    <= (others => '0');

        -- MSB Binary Bit = MSB Grey Bit
        binary_acc(C_DWIDTH - 1) := grey_in(C_DWIDTH - 1);

        for i in C_DWIDTH - 2 downto 0 loop
            -- Start with MSB of Grey In
            binary_acc(i) := grey_in(C_DWIDTH - 1);

            -- Then xor with each bit down to the bit of interest
            for j in C_DWIDTH - 2 downto i loop

                binary_acc(i) := binary_acc(i) xor grey_in(j);

            end loop;

        end loop;

        binary_out_i <= binary_acc;

    end process GREY_DECODE;

binary_out <= binary_out_i;

end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_genlock_mngr
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_vdma_genlock_mngr.vhd
--
-- Description:     This entity encompasses the Gen Lock Manager
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;
use lib_pkg_v1_0_2.lib_pkg.max2;

-------------------------------------------------------------------------------
entity  axi_vdma_genlock_mngr is
    generic(
        C_GENLOCK_MODE          	: integer range 0 to 3      := 0                ;
            -- Specifies Gen-Lock Mode of operation
            -- 0 = Master - Channel configured to be Gen-Lock Master
            -- 1 = Slave - Channel configured to be Gen-Lock Slave

        C_GENLOCK_NUM_MASTERS   	: integer range 1 to 16     := 1                ;
            -- Number of Gen-Lock masters capable of controlling Gen-Lock Slave

        C_INTERNAL_GENLOCK_ENABLE   	: integer range 0 to 1  := 0                ;
            -- Enable internal genlock bus
            -- 0 = disable internal genlock bus
            -- 1 = enable internal genlock bus

        C_NUM_FSTORES           	: integer range 1 to 32     := 5
            -- Number of Frame Stores
    );
    port (

        -- Secondary Clock Domain
        prmry_aclk              : in  std_logic                                     ;       --
        prmry_resetn            : in  std_logic                                     ;       --
                                                                                            --
        -- Dynamic Frame Store Support                                                      --
        num_frame_store         : in  std_logic_vector                                      --
                                    (NUM_FRM_STORE_WIDTH-1 downto 0)                ;       --
        num_fstore_minus1       : in  std_logic_vector                                      --
                                    (FRAME_NUMBER_WIDTH-1 downto 0)                 ;       --
                                                                                            --
        -- Gen-Lock Slave Signals                                                           --
        mstr_in_control         : in  std_logic_vector(3 downto 0)                  ;       --
        genlock_select          : in  std_logic                                     ;       --
        frame_ptr_in            : in  std_logic_vector                                      --
                                    ((C_GENLOCK_NUM_MASTERS                                 --
                                    *NUM_FRM_STORE_WIDTH)-1 downto 0)               ;       --
        internal_frame_ptr_in   : in  std_logic_vector                                      --
                                    (NUM_FRM_STORE_WIDTH-1 downto 0)                ;       --
        slv_frame_ref_out       : out std_logic_vector                                      --
                                    (FRAME_NUMBER_WIDTH-1 downto 0)                 ;       --
        fsize_mismatch_err_flag : in std_logic                                      ;               
                                                                                            --
        -- Gen-Lock Master Signals                                                          --
        dmasr_halt              : in  std_logic                                     ;       --
        circular_prk_mode       : in  std_logic                                     ;       --
        mstr_frame_update       : in  std_logic                                     ;       --
        mstr_frame_ref_in       : in  std_logic_vector                                      --
                                    (FRAME_NUMBER_WIDTH-1 downto 0)                 ;       --
        mstrfrm_tstsync_out     : out std_logic                                     ;       --
        frame_ptr_out           : out std_logic_vector                                      --
                                    (NUM_FRM_STORE_WIDTH-1 downto 0)                        --
    );
end axi_vdma_genlock_mngr;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_genlock_mngr is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- Zero vector for tying off unused inputs
constant ZERO_VALUE         	: std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0) := (others => '0');

-- Number of bits to analyze for grey code enconding and decoding
 constant GREY_NUM_BITS   	: integer := max2(1,clog2(C_NUM_FSTORES));


-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Slave only signals
signal grey_frame_ptr           : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0)  := (others => '0');
signal grey_frmstr_adjusted     : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0)  := (others => '0');
signal partial_frame_ptr        : std_logic_vector(GREY_NUM_BITS-1 downto 0)        := (others => '0');
signal padded_partial_frame_ptr : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)   := (others => '0');

-- Master and Slave signals
signal s_binary_frame_ptr      : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)   := (others => '0');
signal ds_binary_frame_ptr      : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)   := (others => '0');
signal dm_binary_frame_ptr      : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)   := (others => '0');
signal binary_frame_ptr         : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)   := (others => '0');
signal raw_frame_ptr            : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)   := (others => '0');
signal rvc_frame_ref_in         : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)   := (others => '0');
signal dm_inv_raw_frame_ptr     : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)   := (others => '0');
signal s_inv_raw_frame_ptr     : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)   := (others => '0');
signal ds_inv_raw_frame_ptr     : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)   := (others => '0');
signal inv_raw_frame_ptr        : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)   := (others => '0');
signal reg_raw_frame_ptr        : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)   := (others => '0');
signal grey_frame_ptr_out       : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)   := (others => '0');
signal s_frame_ptr_out          : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0)  := (others => '0');
signal num_fstore_equal_one     : std_logic := '0';

signal dm_mstr_reverse_order    : std_logic := '0';
signal dm_mstr_reverse_order_d1 : std_logic := '0';
signal s_mstr_reverse_order    : std_logic := '0';
signal ds_mstr_reverse_order    : std_logic := '0';
signal s_mstr_reverse_order_d1 : std_logic := '0';
signal ds_mstr_reverse_order_d1 : std_logic := '0';
signal mstr_reverse_order       : std_logic := '0';
signal mstr_reverse_order_d1    : std_logic := '0';
signal mstr_reverse_order_d2    : std_logic := '0';

-- Test signals
signal mstrfrm_tstsync_d1       : std_logic := '0';
signal mstrfrm_tstsync_d2       : std_logic := '0';
signal mstrfrm_tstsync_d3       : std_logic := '0';
signal mstrfrm_tstsync_d4       : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

-- Number of fstore value set in register is 0x01.
num_fstore_equal_one <= '1' when num_fstore_minus1 = ZERO_VALUE(FRAME_NUMBER_WIDTH-1 downto 0)
                   else '0';



-------------------------------------------------------------------------------
-- Generate genlock decoding logic for slave
-------------------------------------------------------------------------------
GENLOCK_FOR_SLAVE : if C_GENLOCK_MODE = 1 generate
begin


-----------------------------------------------------------------------------------------------------------------------------------
    --Output GenLock Slave's working frame number in grey
-----------------------------------------------------------------------------------------------------------------------------------

    -- Create flag to indicate when to reverse frame order for genlock output
    -- 0= normal frame order, 1= reverse frame order
    RVRS_ORDER_FLAG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                --if(prmry_resetn = '0' )then
                    mstr_reverse_order  <= '1';

                -- On update if at frame 0 then toggle reverse order flag.
                -- Do not toggle flag if in park mode.
                elsif(fsize_mismatch_err_flag = '0' and mstr_frame_update = '1' and mstr_frame_ref_in = num_fstore_minus1
                and circular_prk_mode = '1')then
                    mstr_reverse_order  <=  not mstr_reverse_order; -- toggle reverse flag

                end if;
            end if;
        end process RVRS_ORDER_FLAG;

    -- Register reverse flag twice to align flag with phase 4 grey encoded tag
    -- process
    REG_DELAY_FLAG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    mstr_reverse_order_d1 <= '1';
                    mstr_reverse_order_d2 <= '1';
                else
                    mstr_reverse_order_d1 <= mstr_reverse_order;
                    mstr_reverse_order_d2 <= mstr_reverse_order_d1;
                end if;
            end if;
        end process REG_DELAY_FLAG;

    -- For FSTORE > 1 then gray coding is needed for proper clock crossing
    -- in Gen-Lock slave. (added generate for fstores > 1)
    GEN_FSTORES_GRTR_ONE : if C_NUM_FSTORES > 1 generate
    begin
        ---------------------------------------------------------------------------
        -- Phase 1: Based on reverse order flag convert master frame in into a
        -- reverse order frame number (i.e. 3,2,1,0)
        -- or normal order (i.e. 0,1,2,3)
        ---------------------------------------------------------------------------

        --rvc_frame_ref_in <= std_logic_vector((C_NUM_FSTORES - 1) - unsigned(mstr_frame_ref_in));
        rvc_frame_ref_in <= std_logic_vector(unsigned(num_fstore_minus1) - unsigned(mstr_frame_ref_in));

        FRAME_CONVERT_P1 : process(mstr_reverse_order,mstr_frame_ref_in,rvc_frame_ref_in,num_fstore_equal_one)
            begin
                if(mstr_reverse_order = '1' and num_fstore_equal_one = '0')then
                    raw_frame_ptr <= rvc_frame_ref_in;
                else
                    raw_frame_ptr <= mstr_frame_ref_in;
                end if;
            end process FRAME_CONVERT_P1;

        -- Register to break long timing paths
        REG_P1 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        reg_raw_frame_ptr <= (others => '0');
                    else
                        reg_raw_frame_ptr <= raw_frame_ptr;
                    end if;
                end if;
            end process REG_P1;


        ---------------------------------------------------------------------------
        -- Phase 2: Partial Invert of raw frame pointer (invert only the
        -- log2(C_NUM_FSTORE) bits
        -- GREY_NUM_BITS = 1 which is C_NUM_FSTORE = 1 to 2     then invert 1 LSB
        -- GREY_NUM_BITS = 2 which is C_NUM_FSTORE = 3 to 4,    then invert 2 LSBs
        -- GREY_NUM_BITS = 3 which is C_NUM_FSTORE = 5 to 8,    then invert 3 LSBs
        -- GREY_NUM_BITS = 4 which is C_NUM_FSTORE = 9 to 16,   then invert 4 LSBs
        -- GREY_NUM_BITS = 5 which is C_NUM_FSTORE = 17 to 32,  then invert 5 LSBs (all bits)
        ---------------------------------------------------------------------------
        -- - shifted FSTORE 2 to the correct inverse
        PARTIAL_NOT_P2 : process(num_frame_store,reg_raw_frame_ptr)
            begin
                case num_frame_store is
                    -- Number of Frame Stores =  1 and 2
                    when "000001" | "000010" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores =  3 and 4
                    when "000011" | "000100" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores =  5, 6, 7, and 8
                    when "000101" | "000110" | "000111" | "001000" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= not reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores = 9 to 16
                    when "001001" | "001010" | "001011" | "001100" | "001101"
                       | "001110" | "001111" | "010000" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= not reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= not reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores = 17 to 32
                    when others =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= not reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= not reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= not reg_raw_frame_ptr(4);
                end case;
            end process PARTIAL_NOT_P2;


        -- Register pratial not to break timing paths
        REG_P2 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        binary_frame_ptr <= (others => '0');
                    else
                        binary_frame_ptr <= inv_raw_frame_ptr;
                    end if;
                end if;
            end process REG_P2;


        ---------------------------------------------------------------------------
        -- Phase 3 : Grey Encode
        -- Encode binary coded frame pointer
        ---------------------------------------------------------------------------
        GREY_CODER_I : entity  axi_vdma_v6_3_10.axi_vdma_greycoder
            generic map(
                C_DWIDTH                    => FRAME_NUMBER_WIDTH
            )
            port map(
                -- Grey Encode
                binary_in                   => binary_frame_ptr             ,
                grey_out                    => grey_frame_ptr_out           ,

                -- Grey Decode
                grey_in                     => ZERO_VALUE(FRAME_NUMBER_WIDTH-1 downto 0)       ,
                binary_out                  => open
            );


        ---------------------------------------------------------------------------
        -- Phase 4 : Tag Grey Encoded Pointer
        -- Tag grey code with the inverse of the reverse flag.  This provides
        -- two sets of grey codes representing 2 passes through frame buffer.
        ---------------------------------------------------------------------------



        -- If C_NUM_FSTORES is 17 to 32 then all 5 bits are used of frame number therefore
        -- no need to pad grey encoded result
        GEN_EQL_5_BITS : if GREY_NUM_BITS = 5 generate
        begin

            -- 
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is

                        -- Number of Frame Stores = 1
                        when "000001" =>
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 2
                        when "000010" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 3 and 4
                        when "000011" | "000100" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 5 to 8
                        when "000101" | "000110" | "000111" | "001000" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 9 to 16
                        when "001001" | "001010" | "001011" | "001100" | "001101"
                           | "001110" | "001111" | "010000" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= grey_frame_ptr_out(3);
                            s_frame_ptr_out(4)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 17 to 32
                        when others =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= grey_frame_ptr_out(3);
                            s_frame_ptr_out(4)  <= grey_frame_ptr_out(4);
                            s_frame_ptr_out(5)  <= not mstr_reverse_order_d2;
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_5_BITS;


        -- If C_NUM_FSTORES is 8 to 16 then all 4 bits are used of frame number therefore
        -- no need to pad grey encoded result
        GEN_EQL_4_BITS : if GREY_NUM_BITS = 4 generate
        begin

            -- 
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000010" => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000011" | "000100" => -- 3 and 4
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000101" | "000110" | "000111" | "001000" => -- 5, 6, 7, and 8
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- 9 to 16
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= grey_frame_ptr_out(3);
                            s_frame_ptr_out(4)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_4_BITS;



        -- C_NUM_FSTORES = 4 to 7
        GEN_EQL_3_BITS : if GREY_NUM_BITS = 3 generate
        begin
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000010" => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000011" | "000100" => -- 3 and 4
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- 5 to 7
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_3_BITS;

        -- C_NUM_FSTORES = 3
        GEN_EQL_2_BITS : if GREY_NUM_BITS = 2 generate
        begin
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000010" => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- Number of Frame Stores = 3
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_2_BITS;

        -- C_NUM_FSTORES = 2
        GEN_EQL_1_BITS : if GREY_NUM_BITS = 1 generate
        begin
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_1_BITS;

    end generate GEN_FSTORES_GRTR_ONE;

    -- 
    -- For FSTORE = 1 then gray coding is not needed.  Simply
    -- pass the reverse order flag out.
    -- (added generate for fstores = 1)
    GEN_FSTORES_EQL_ONE : if C_NUM_FSTORES = 1 generate
    begin

        s_frame_ptr_out <= "00000" & not(mstr_reverse_order_d2);


    end generate GEN_FSTORES_EQL_ONE;

    -- Register Master Frame Pointer Out
    REG_FRAME_PTR_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    frame_ptr_out <= (others => '0');
                else
                    frame_ptr_out <= s_frame_ptr_out;
                end if;
            end if;
        end process REG_FRAME_PTR_OUT;








-------------------------------------------------------------------------------------------------------------------


    -- Mux frame pointer in from Master based on master in control
    GENLOCK_MUX_I : entity  axi_vdma_v6_3_10.axi_vdma_genlock_mux
        generic map(
            C_GENLOCK_NUM_MASTERS       => C_GENLOCK_NUM_MASTERS    ,
            C_INTERNAL_GENLOCK_ENABLE   => C_INTERNAL_GENLOCK_ENABLE
        )
        port map(

            prmry_aclk              => prmry_aclk                   ,
            prmry_resetn            => prmry_resetn                 ,

            mstr_in_control         => mstr_in_control              ,
            genlock_select          => genlock_select               ,
            internal_frame_ptr_in   => internal_frame_ptr_in        ,
            frame_ptr_in            => frame_ptr_in                 ,
            frame_ptr_out           => grey_frame_ptr
        );

    ---------------------------------------------------------------------------
    -- Phase 1:
    -- Decode Grey coded frame pointer
    ---------------------------------------------------------------------------
    ADJUST_4_FRM_STRS : process(num_frame_store,grey_frame_ptr)
        begin
            case num_frame_store is
                -- Number of Frame Stores = 1 and 2
                when "000001" | "000010" =>
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= '0';
                    grey_frmstr_adjusted(2) <= '0';
                    grey_frmstr_adjusted(3) <= '0';
                    grey_frmstr_adjusted(4) <= '0';
                    grey_frmstr_adjusted(5) <= '0';

                -- Number of Frame Stores = 3 and 4
                when "000011" | "000100" =>
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= grey_frame_ptr(1);
                    grey_frmstr_adjusted(2) <= '0';
                    grey_frmstr_adjusted(3) <= '0';
                    grey_frmstr_adjusted(4) <= '0';
                    grey_frmstr_adjusted(5) <= '0';

                -- Number of Frame Stores = 5, 6, 7, and 8
                when "000101" | "000110" | "000111" | "001000" =>
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= grey_frame_ptr(1);
                    grey_frmstr_adjusted(2) <= grey_frame_ptr(2);
                    grey_frmstr_adjusted(3) <= '0';
                    grey_frmstr_adjusted(4) <= '0';
                    grey_frmstr_adjusted(5) <= '0';

                -- Number of Frame Stores = 9 to 16
                when "001001" | "001010" | "001011" | "001100" | "001101"
                   | "001110" | "001111" | "010000" =>
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= grey_frame_ptr(1);
                    grey_frmstr_adjusted(2) <= grey_frame_ptr(2);
                    grey_frmstr_adjusted(3) <= grey_frame_ptr(3);
                    grey_frmstr_adjusted(4) <= '0';
                    grey_frmstr_adjusted(5) <= '0';

                -- Number of Frame Stores =  17 to 32
                when others => -- 17 to 32
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= grey_frame_ptr(1);
                    grey_frmstr_adjusted(2) <= grey_frame_ptr(2);
                    grey_frmstr_adjusted(3) <= grey_frame_ptr(3);
                    grey_frmstr_adjusted(4) <= grey_frame_ptr(4);
                    grey_frmstr_adjusted(5) <= '0';

            end case;
        end process ADJUST_4_FRM_STRS;

    S_GREY_CODER_I : entity  axi_vdma_v6_3_10.axi_vdma_greycoder
        generic map(
            C_DWIDTH                    => GREY_NUM_BITS
        )
        port map(
            -- Grey Encode
            binary_in                   => ZERO_VALUE(GREY_NUM_BITS - 1 downto 0)       ,
            grey_out                    => open             ,

            -- Grey Decode
            grey_in                     => grey_frmstr_adjusted(GREY_NUM_BITS - 1 downto 0)    ,
            binary_out                  => partial_frame_ptr
        );

    ---------------------------------------------------------------------------
    -- Phase 2:
    -- Invert partial frame pointer and pad to full frame pointer width
    ---------------------------------------------------------------------------
    -- FSTORES = 1 or 2 therefore pad decoded frame pointer with 4 bits
    -- shifted FSTORE 2 case to the correct padding location
    GEN_FSTORES_12 : if C_NUM_FSTORES = 1 or C_NUM_FSTORES = 2 generate
    begin
        padded_partial_frame_ptr <= "0000" & partial_frame_ptr;
    end generate GEN_FSTORES_12;

    -- FSTORES = 3 or 4 therefore pad decoded frame pointer with 3 bits
    GEN_FSTORES_34 : if C_NUM_FSTORES > 2 and C_NUM_FSTORES < 5 generate
    begin
        padded_partial_frame_ptr <= "000" & partial_frame_ptr;
    end generate GEN_FSTORES_34;

    -- FSTORES = 5,6,7 or 8 therefore pad decoded frame pointer with 2 bit
    GEN_FSTORES_5678 : if C_NUM_FSTORES > 4 and C_NUM_FSTORES < 9 generate
    begin
        padded_partial_frame_ptr <= "00" & partial_frame_ptr;
    end generate GEN_FSTORES_5678;

    -- FSTORES = 9 to 16 therefore pad decoded frame pointer with 1 bit
    GEN_FSTORES_9TO16 : if C_NUM_FSTORES > 8 and C_NUM_FSTORES < 17 generate
    begin
        padded_partial_frame_ptr <= '0' & partial_frame_ptr;
    end generate GEN_FSTORES_9TO16;

    -- FSTORES > 16 therefore no need to pad decoded frame pointer
    GEN_FSTORES_17NUP : if C_NUM_FSTORES > 16 generate
    begin
        padded_partial_frame_ptr <= partial_frame_ptr;
    end generate GEN_FSTORES_17NUP;

    -- - fixed wrong signal in sensitivity list.
    -- - shifted FSTORE 2 to the correct inverse
    S_PARTIAL_NOT_P2 : process(num_frame_store,padded_partial_frame_ptr)
        begin
            case num_frame_store is
                -- Number of Frame Stores = 1 and 2
                when "000001" | "000010" =>
                    s_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    s_inv_raw_frame_ptr(1) <= '0';
                    s_inv_raw_frame_ptr(2) <= '0';
                    s_inv_raw_frame_ptr(3) <= '0';
                    s_inv_raw_frame_ptr(4) <= '0';

                -- Number of Frame Stores = 3 and 4
                when "000011" | "000100" =>
                    s_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    s_inv_raw_frame_ptr(1) <= not padded_partial_frame_ptr(1);
                    s_inv_raw_frame_ptr(2) <= '0';
                    s_inv_raw_frame_ptr(3) <= '0';
                    s_inv_raw_frame_ptr(4) <= '0';
                -- Number of Frame Stores = 5 to 8
                when "000101" | "000110" | "000111" | "001000" =>
                    s_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    s_inv_raw_frame_ptr(1) <= not padded_partial_frame_ptr(1);
                    s_inv_raw_frame_ptr(2) <= not padded_partial_frame_ptr(2);
                    s_inv_raw_frame_ptr(3) <= '0';
                    s_inv_raw_frame_ptr(4) <= '0';

                -- Number of Frame Stores = 9 to 16
                when "001001" | "001010" | "001011" | "001100" | "001101"
                   | "001110" | "001111" | "010000" =>
                    s_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    s_inv_raw_frame_ptr(1) <= not padded_partial_frame_ptr(1);
                    s_inv_raw_frame_ptr(2) <= not padded_partial_frame_ptr(2);
                    s_inv_raw_frame_ptr(3) <= not padded_partial_frame_ptr(3);
                    s_inv_raw_frame_ptr(4) <= '0';

                when others => -- 17 to 32
                    s_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    s_inv_raw_frame_ptr(1) <= not padded_partial_frame_ptr(1);
                    s_inv_raw_frame_ptr(2) <= not padded_partial_frame_ptr(2);
                    s_inv_raw_frame_ptr(3) <= not padded_partial_frame_ptr(3);
                    s_inv_raw_frame_ptr(4) <= not padded_partial_frame_ptr(4);

            end case;
        end process S_PARTIAL_NOT_P2;

    -- Register to break long timing paths
    S_REG_P2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    s_binary_frame_ptr <= (others => '0');
                else
                    s_binary_frame_ptr <= s_inv_raw_frame_ptr;
                end if;
            end if;
        end process S_REG_P2;


    ---------------------------------------------------------------------------
    -- Phase 3:
    -- Convert to frame pointer (i.e. reverse if need or pass through)
    ---------------------------------------------------------------------------
    -- Reverse order indication
    -- 1 = frame order reversed, 0 = frame order normal
    --mstr_reverse_order  <= not grey_frame_ptr(GREY_NUM_BITS);
    REVERSE_INDICATOR : process(num_frame_store,grey_frame_ptr)
        begin
            case num_frame_store is
                -- Number of Frame Stores = 1
                when "000001" =>
                    s_mstr_reverse_order   <= not grey_frame_ptr(0);

                -- Number of Frame Stores = 2
                when "000010" =>
                    s_mstr_reverse_order   <= not grey_frame_ptr(1);

                -- Number of Frame Stores = 3 and 4
                when "000011" | "000100" =>
                    s_mstr_reverse_order   <= not grey_frame_ptr(2);

                -- Number of Frame Stores = 5, 6, 7, and 8
                when "000101" | "000110" | "000111" | "001000" =>
                    s_mstr_reverse_order   <= not grey_frame_ptr(3);

                -- Number of Frame Stores = 9 to 16
                when "001001" | "001010" | "001011" | "001100" | "001101"
                   | "001110" | "001111" | "010000" =>
                    s_mstr_reverse_order   <= not grey_frame_ptr(4);

                -- Number of Frame Stores = 16 to 32
                when others =>
                    s_mstr_reverse_order   <= not grey_frame_ptr(5);

            end case;
        end process REVERSE_INDICATOR;

    -- Register reverse flag to align flag with phase 3 process
    S_REG_DELAY_FLAG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    s_mstr_reverse_order_d1 <= '1';
                else
                    s_mstr_reverse_order_d1 <= s_mstr_reverse_order;
                end if;
            end if;
        end process S_REG_DELAY_FLAG;

    FRAME_CONVERT_P3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    slv_frame_ref_out <= (others => '0');

                -- reverse order frames (reverse the frame)
                elsif(s_mstr_reverse_order_d1='1' and num_fstore_equal_one = '0')then
                    slv_frame_ref_out <= std_logic_vector(unsigned(num_fstore_minus1) - unsigned(s_binary_frame_ptr));

                -- reverse order frames with only 1 frame store (reverse the frame)
                --  - If 1 fstore then frame is always just 0
                elsif(num_fstore_equal_one = '1')then
                    slv_frame_ref_out <= (others => '0');

                -- forward order frame (simply pass through)
                else
                    slv_frame_ref_out <= s_binary_frame_ptr;
                end if;
            end if;
        end process FRAME_CONVERT_P3;

    mstrfrm_tstsync_out <= '0'; -- Not used for slaves

end generate GENLOCK_FOR_SLAVE;


-------------------------------------------------------------------------------
-- Generate genlock decoding logic for master
-------------------------------------------------------------------------------
GENLOCK_FOR_MASTER : if C_GENLOCK_MODE = 0 generate
begin

    -- Only used for slave mode
    slv_frame_ref_out <= (others => '0');

    -- Create flag to indicate when to reverse frame order for genlock output
    -- 0= normal frame order, 1= reverse frame order
    RVRS_ORDER_FLAG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                --if(prmry_resetn = '0' )then
                    mstr_reverse_order  <= '1';

                -- On update if at frame 0 then toggle reverse order flag.
                -- Do not toggle flag if in park mode.
                elsif(fsize_mismatch_err_flag = '0' and mstr_frame_update = '1' and mstr_frame_ref_in = num_fstore_minus1
                and circular_prk_mode = '1')then
                    mstr_reverse_order  <=  not mstr_reverse_order; -- toggle reverse flag

                end if;
            end if;
        end process RVRS_ORDER_FLAG;

    -- Register reverse flag twice to align flag with phase 4 grey encoded tag
    -- process
    REG_DELAY_FLAG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    mstr_reverse_order_d1 <= '1';
                    mstr_reverse_order_d2 <= '1';
                else
                    mstr_reverse_order_d1 <= mstr_reverse_order;
                    mstr_reverse_order_d2 <= mstr_reverse_order_d1;
                end if;
            end if;
        end process REG_DELAY_FLAG;

    -- For FSTORE > 1 then gray coding is needed for proper clock crossing
    -- in Gen-Lock slave. (added generate for fstores > 1)
    GEN_FSTORES_GRTR_ONE : if C_NUM_FSTORES > 1 generate
    begin
        ---------------------------------------------------------------------------
        -- Phase 1: Based on reverse order flag convert master frame in into a
        -- reverse order frame number (i.e. 3,2,1,0)
        -- or normal order (i.e. 0,1,2,3)
        ---------------------------------------------------------------------------

        --rvc_frame_ref_in <= std_logic_vector((C_NUM_FSTORES - 1) - unsigned(mstr_frame_ref_in));
        rvc_frame_ref_in <= std_logic_vector(unsigned(num_fstore_minus1) - unsigned(mstr_frame_ref_in));

        FRAME_CONVERT_P1 : process(mstr_reverse_order,mstr_frame_ref_in,rvc_frame_ref_in,num_fstore_equal_one)
            begin
                if(mstr_reverse_order = '1' and num_fstore_equal_one = '0')then
                    raw_frame_ptr <= rvc_frame_ref_in;
                else
                    raw_frame_ptr <= mstr_frame_ref_in;
                end if;
            end process FRAME_CONVERT_P1;

        -- Register to break long timing paths
        REG_P1 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        reg_raw_frame_ptr <= (others => '0');
                    else
                        reg_raw_frame_ptr <= raw_frame_ptr;
                    end if;
                end if;
            end process REG_P1;


        ---------------------------------------------------------------------------
        -- Phase 2: Partial Invert of raw frame pointer (invert only the
        -- log2(C_NUM_FSTORE) bits
        -- GREY_NUM_BITS = 1 which is C_NUM_FSTORE = 1 to 2     then invert 1 LSB
        -- GREY_NUM_BITS = 2 which is C_NUM_FSTORE = 3 to 4,    then invert 2 LSBs
        -- GREY_NUM_BITS = 3 which is C_NUM_FSTORE = 5 to 8,    then invert 3 LSBs
        -- GREY_NUM_BITS = 4 which is C_NUM_FSTORE = 9 to 16,   then invert 4 LSBs
        -- GREY_NUM_BITS = 5 which is C_NUM_FSTORE = 17 to 32,  then invert 5 LSBs (all bits)
        ---------------------------------------------------------------------------
        --  - shifted FSTORE 2 to the correct inverse
        PARTIAL_NOT_P2 : process(num_frame_store,reg_raw_frame_ptr)
            begin
                case num_frame_store is
                    -- Number of Frame Stores =  1 and 2
                    when "000001" | "000010" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores =  3 and 4
                    when "000011" | "000100" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores =  5, 6, 7, and 8
                    when "000101" | "000110" | "000111" | "001000" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= not reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores = 9 to 16
                    when "001001" | "001010" | "001011" | "001100" | "001101"
                       | "001110" | "001111" | "010000" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= not reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= not reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores = 17 to 32
                    when others =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= not reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= not reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= not reg_raw_frame_ptr(4);
                end case;
            end process PARTIAL_NOT_P2;


        -- Register pratial not to break timing paths
        REG_P2 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        binary_frame_ptr <= (others => '0');
                    else
                        binary_frame_ptr <= inv_raw_frame_ptr;
                    end if;
                end if;
            end process REG_P2;


        ---------------------------------------------------------------------------
        -- Phase 3 : Grey Encode
        -- Encode binary coded frame pointer
        ---------------------------------------------------------------------------
        GREY_CODER_I : entity  axi_vdma_v6_3_10.axi_vdma_greycoder
            generic map(
                C_DWIDTH                    => FRAME_NUMBER_WIDTH
            )
            port map(
                -- Grey Encode
                binary_in                   => binary_frame_ptr             ,
                grey_out                    => grey_frame_ptr_out           ,

                -- Grey Decode
                grey_in                     => ZERO_VALUE(FRAME_NUMBER_WIDTH-1 downto 0)       ,
                binary_out                  => open
            );

        ---------------------------------------------------------------------------
        -- Phase 4 : Tag Grey Encoded Pointer
        -- Tag grey code with the inverse of the reverse flag.  This provides
        -- two sets of grey codes representing 2 passes through frame buffer.
        ---------------------------------------------------------------------------



        -- If C_NUM_FSTORES is 17 to 32 then all 5 bits are used of frame number therefore
        -- no need to pad grey encoded result
        GEN_EQL_5_BITS : if GREY_NUM_BITS = 5 generate
        begin

            -- 
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is

                        -- Number of Frame Stores = 1
                        when "000001" =>
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 2
                        when "000010" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 3 and 4
                        when "000011" | "000100" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 5 to 8
                        when "000101" | "000110" | "000111" | "001000" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 9 to 16
                        when "001001" | "001010" | "001011" | "001100" | "001101"
                           | "001110" | "001111" | "010000" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= grey_frame_ptr_out(3);
                            s_frame_ptr_out(4)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 17 to 32
                        when others =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= grey_frame_ptr_out(3);
                            s_frame_ptr_out(4)  <= grey_frame_ptr_out(4);
                            s_frame_ptr_out(5)  <= not mstr_reverse_order_d2;
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_5_BITS;


        -- If C_NUM_FSTORES is 8 to 16 then all 4 bits are used of frame number therefore
        -- no need to pad grey encoded result
        GEN_EQL_4_BITS : if GREY_NUM_BITS = 4 generate
        begin

            -- 
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000010" => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000011" | "000100" => -- 3 and 4
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000101" | "000110" | "000111" | "001000" => -- 5, 6, 7, and 8
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- 9 to 16
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= grey_frame_ptr_out(3);
                            s_frame_ptr_out(4)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_4_BITS;



        -- C_NUM_FSTORES = 4 to 7
        GEN_EQL_3_BITS : if GREY_NUM_BITS = 3 generate
        begin
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000010" => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000011" | "000100" => -- 3 and 4
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- 5 to 7
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_3_BITS;

        -- C_NUM_FSTORES = 3
        GEN_EQL_2_BITS : if GREY_NUM_BITS = 2 generate
        begin
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000010" => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- Number of Frame Stores = 3
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_2_BITS;

        -- C_NUM_FSTORES = 2
        GEN_EQL_1_BITS : if GREY_NUM_BITS = 1 generate
        begin
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_1_BITS;

    end generate GEN_FSTORES_GRTR_ONE;

    -- 
    -- For FSTORE = 1 then gray coding is not needed.  Simply
    -- pass the reverse order flag out.
    -- (- added generate for fstores = 1)
    GEN_FSTORES_EQL_ONE : if C_NUM_FSTORES = 1 generate
    begin

        s_frame_ptr_out <= "00000" & not(mstr_reverse_order_d2);


    end generate GEN_FSTORES_EQL_ONE;

    -- Register Master Frame Pointer Out
    REG_FRAME_PTR_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    frame_ptr_out <= (others => '0');
                else
                    frame_ptr_out <= s_frame_ptr_out;
                end if;
            end if;
        end process REG_FRAME_PTR_OUT;


    --*********************************************************************
    --** TEST VECTOR SIGNALS - For Xilinx Internal Testing Only
    --*********************************************************************
    -- Coverage Off
    REG_SCNDRY_TSTSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    mstrfrm_tstsync_d1 <= '0';
                    mstrfrm_tstsync_d2 <= '0';
                    mstrfrm_tstsync_d3 <= '0';
                    mstrfrm_tstsync_d4 <= '0';
                else
                    mstrfrm_tstsync_d1 <= mstr_frame_update;
                    mstrfrm_tstsync_d2 <= mstrfrm_tstsync_d1;
                    mstrfrm_tstsync_d3 <= mstrfrm_tstsync_d2;
                    mstrfrm_tstsync_d4 <= mstrfrm_tstsync_d3;
                end if;
            end if;
        end process REG_SCNDRY_TSTSYNC_OUT;

    mstrfrm_tstsync_out <= mstrfrm_tstsync_d4;
    -- Coverage On
    --*********************************************************************
    --** END TEST SECTION
    --*********************************************************************

end generate GENLOCK_FOR_MASTER;

-------------------------------------------------------------------------------
-- Generate genlock decoding logic for master
-------------------------------------------------------------------------------
DYNAMIC_GENLOCK_FOR_MASTER : if C_GENLOCK_MODE = 2 generate
begin


----------------------------------------------------------------------------------------------------------
--un-greying Dynamic slave's (internal or external) frame number 
----------------------------------------------------------------------------------------------------------


    -- Mux frame pointer in from Master based on master in control
    GENLOCK_MUX_I : entity  axi_vdma_v6_3_10.axi_vdma_genlock_mux
        generic map(
            C_GENLOCK_NUM_MASTERS       => C_GENLOCK_NUM_MASTERS    ,
            C_INTERNAL_GENLOCK_ENABLE   => C_INTERNAL_GENLOCK_ENABLE
        )
        port map(

            prmry_aclk              => prmry_aclk                   ,
            prmry_resetn            => prmry_resetn                 ,

            mstr_in_control         => mstr_in_control              ,
            genlock_select          => genlock_select               ,
            internal_frame_ptr_in   => internal_frame_ptr_in        ,
            frame_ptr_in            => frame_ptr_in                 ,
            frame_ptr_out           => grey_frame_ptr
        );

    ---------------------------------------------------------------------------
    -- Phase 1:
    -- Decode Grey coded frame pointer
    ---------------------------------------------------------------------------
    ADJUST_4_FRM_STRS : process(num_frame_store,grey_frame_ptr)
        begin
            case num_frame_store is
                -- Number of Frame Stores = 1 and 2
                when "000001" | "000010" =>
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= '0';
                    grey_frmstr_adjusted(2) <= '0';
                    grey_frmstr_adjusted(3) <= '0';
                    grey_frmstr_adjusted(4) <= '0';
                    grey_frmstr_adjusted(5) <= '0';

                -- Number of Frame Stores = 3 and 4
                when "000011" | "000100" =>
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= grey_frame_ptr(1);
                    grey_frmstr_adjusted(2) <= '0';
                    grey_frmstr_adjusted(3) <= '0';
                    grey_frmstr_adjusted(4) <= '0';
                    grey_frmstr_adjusted(5) <= '0';

                -- Number of Frame Stores = 5, 6, 7, and 8
                when "000101" | "000110" | "000111" | "001000" =>
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= grey_frame_ptr(1);
                    grey_frmstr_adjusted(2) <= grey_frame_ptr(2);
                    grey_frmstr_adjusted(3) <= '0';
                    grey_frmstr_adjusted(4) <= '0';
                    grey_frmstr_adjusted(5) <= '0';

                -- Number of Frame Stores = 9 to 16
                when "001001" | "001010" | "001011" | "001100" | "001101"
                   | "001110" | "001111" | "010000" =>
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= grey_frame_ptr(1);
                    grey_frmstr_adjusted(2) <= grey_frame_ptr(2);
                    grey_frmstr_adjusted(3) <= grey_frame_ptr(3);
                    grey_frmstr_adjusted(4) <= '0';
                    grey_frmstr_adjusted(5) <= '0';

                -- Number of Frame Stores =  17 to 32
                when others => -- 17 to 32
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= grey_frame_ptr(1);
                    grey_frmstr_adjusted(2) <= grey_frame_ptr(2);
                    grey_frmstr_adjusted(3) <= grey_frame_ptr(3);
                    grey_frmstr_adjusted(4) <= grey_frame_ptr(4);
                    grey_frmstr_adjusted(5) <= '0';

            end case;
        end process ADJUST_4_FRM_STRS;

    GREY_CODER_I : entity  axi_vdma_v6_3_10.axi_vdma_greycoder
        generic map(
            C_DWIDTH                    => GREY_NUM_BITS
        )
        port map(
            -- Grey Encode
            binary_in                   => ZERO_VALUE(GREY_NUM_BITS - 1 downto 0)       ,
            grey_out                    => open             ,

            -- Grey Decode
            grey_in                     => grey_frmstr_adjusted(GREY_NUM_BITS - 1 downto 0)    ,
            binary_out                  => partial_frame_ptr
        );

    ---------------------------------------------------------------------------
    -- Phase 2:
    -- Invert partial frame pointer and pad to full frame pointer width
    ---------------------------------------------------------------------------
    -- FSTORES = 1 or 2 therefore pad decoded frame pointer with 4 bits
    --  shifted FSTORE 2 case to the correct padding location
    GEN_FSTORES_12 : if C_NUM_FSTORES = 1 or C_NUM_FSTORES = 2 generate
    begin
        padded_partial_frame_ptr <= "0000" & partial_frame_ptr;
    end generate GEN_FSTORES_12;

    -- FSTORES = 3 or 4 therefore pad decoded frame pointer with 3 bits
    GEN_FSTORES_34 : if C_NUM_FSTORES > 2 and C_NUM_FSTORES < 5 generate
    begin
        padded_partial_frame_ptr <= "000" & partial_frame_ptr;
    end generate GEN_FSTORES_34;

    -- FSTORES = 5,6,7 or 8 therefore pad decoded frame pointer with 2 bit
    GEN_FSTORES_5678 : if C_NUM_FSTORES > 4 and C_NUM_FSTORES < 9 generate
    begin
        padded_partial_frame_ptr <= "00" & partial_frame_ptr;
    end generate GEN_FSTORES_5678;

    -- FSTORES = 9 to 16 therefore pad decoded frame pointer with 1 bit
    GEN_FSTORES_9TO16 : if C_NUM_FSTORES > 8 and C_NUM_FSTORES < 17 generate
    begin
        padded_partial_frame_ptr <= '0' & partial_frame_ptr;
    end generate GEN_FSTORES_9TO16;

    -- FSTORES > 16 therefore no need to pad decoded frame pointer
    GEN_FSTORES_17NUP : if C_NUM_FSTORES > 16 generate
    begin
        padded_partial_frame_ptr <= partial_frame_ptr;
    end generate GEN_FSTORES_17NUP;

    -- - fixed wrong signal in sensitivity list.
    -- - shifted FSTORE 2 to the correct inverse
    DM_PARTIAL_NOT_P2 : process(num_frame_store,padded_partial_frame_ptr)
        begin
            case num_frame_store is
                -- Number of Frame Stores = 1 and 2
                when "000001" | "000010" =>
                    dm_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    dm_inv_raw_frame_ptr(1) <= '0';
                    dm_inv_raw_frame_ptr(2) <= '0';
                    dm_inv_raw_frame_ptr(3) <= '0';
                    dm_inv_raw_frame_ptr(4) <= '0';

                -- Number of Frame Stores = 3 and 4
                when "000011" | "000100" =>
                    dm_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    dm_inv_raw_frame_ptr(1) <= not padded_partial_frame_ptr(1);
                    dm_inv_raw_frame_ptr(2) <= '0';
                    dm_inv_raw_frame_ptr(3) <= '0';
                    dm_inv_raw_frame_ptr(4) <= '0';
                -- Number of Frame Stores = 5 to 8
                when "000101" | "000110" | "000111" | "001000" =>
                    dm_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    dm_inv_raw_frame_ptr(1) <= not padded_partial_frame_ptr(1);
                    dm_inv_raw_frame_ptr(2) <= not padded_partial_frame_ptr(2);
                    dm_inv_raw_frame_ptr(3) <= '0';
                    dm_inv_raw_frame_ptr(4) <= '0';

                -- Number of Frame Stores = 9 to 16
                when "001001" | "001010" | "001011" | "001100" | "001101"
                   | "001110" | "001111" | "010000" =>
                    dm_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    dm_inv_raw_frame_ptr(1) <= not padded_partial_frame_ptr(1);
                    dm_inv_raw_frame_ptr(2) <= not padded_partial_frame_ptr(2);
                    dm_inv_raw_frame_ptr(3) <= not padded_partial_frame_ptr(3);
                    dm_inv_raw_frame_ptr(4) <= '0';

                when others => -- 17 to 32
                    dm_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    dm_inv_raw_frame_ptr(1) <= not padded_partial_frame_ptr(1);
                    dm_inv_raw_frame_ptr(2) <= not padded_partial_frame_ptr(2);
                    dm_inv_raw_frame_ptr(3) <= not padded_partial_frame_ptr(3);
                    dm_inv_raw_frame_ptr(4) <= not padded_partial_frame_ptr(4);

            end case;
        end process DM_PARTIAL_NOT_P2;

    -- Register to break long timing paths
    DM_REG_P2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    dm_binary_frame_ptr <= (others => '0');
                else
                    dm_binary_frame_ptr <= dm_inv_raw_frame_ptr;
                end if;
            end if;
        end process DM_REG_P2;


    ---------------------------------------------------------------------------
    -- Phase 3:
    -- Convert to frame pointer (i.e. reverse if need or pass through)
    ---------------------------------------------------------------------------
    -- Reverse order indication
    -- 1 = frame order reversed, 0 = frame order normal
    --mstr_reverse_order  <= not grey_frame_ptr(GREY_NUM_BITS);
    DM_REVERSE_INDICATOR : process(num_frame_store,grey_frame_ptr)
        begin
            case num_frame_store is
                -- Number of Frame Stores = 1
                when "000001" =>
                    dm_mstr_reverse_order   <= not grey_frame_ptr(0);

                -- Number of Frame Stores = 2
                when "000010" =>
                    dm_mstr_reverse_order   <= not grey_frame_ptr(1);

                -- Number of Frame Stores = 3 and 4
                when "000011" | "000100" =>
                    dm_mstr_reverse_order   <= not grey_frame_ptr(2);

                -- Number of Frame Stores = 5, 6, 7, and 8
                when "000101" | "000110" | "000111" | "001000" =>
                    dm_mstr_reverse_order   <= not grey_frame_ptr(3);

                -- Number of Frame Stores = 9 to 16
                when "001001" | "001010" | "001011" | "001100" | "001101"
                   | "001110" | "001111" | "010000" =>
                    dm_mstr_reverse_order   <= not grey_frame_ptr(4);

                -- Number of Frame Stores = 16 to 32
                when others =>
                    dm_mstr_reverse_order   <= not grey_frame_ptr(5);

            end case;
        end process DM_REVERSE_INDICATOR;

    -- Register reverse flag to align flag with phase 3 process
    DM_REG_DELAY_FLAG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    dm_mstr_reverse_order_d1 <= '1';
                else
                    dm_mstr_reverse_order_d1 <= dm_mstr_reverse_order;
                end if;
            end if;
        end process DM_REG_DELAY_FLAG;

    DM_FRAME_CONVERT_P3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    slv_frame_ref_out <= (others => '0');

                -- reverse order frames (reverse the frame)
                elsif(dm_mstr_reverse_order_d1='1' and num_fstore_equal_one = '0')then
                    slv_frame_ref_out <= std_logic_vector(unsigned(num_fstore_minus1) - unsigned(dm_binary_frame_ptr));

                -- reverse order frames with only 1 frame store (reverse the frame)
                -- - If 1 fstore then frame is always just 0
                elsif(num_fstore_equal_one = '1')then
                    slv_frame_ref_out <= (others => '0');

                -- forward order frame (simply pass through)
                else
                    slv_frame_ref_out <= dm_binary_frame_ptr;
                end if;
            end if;
        end process DM_FRAME_CONVERT_P3;
-----------------------------------------------------------------------------------------------------------
--grey frame number out for dynamic genlock master
-----------------------------------------------------------------------------------------------------------
    -- Create flag to indicate when to reverse frame order for genlock output
    -- 0= normal frame order, 1= reverse frame order
    RVRS_ORDER_FLAG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                --if(prmry_resetn = '0' )then
                    mstr_reverse_order  <= '1';

                -- On update if at frame 0 then toggle reverse order flag.
                -- Do not toggle flag if in park mode.
                elsif(fsize_mismatch_err_flag = '0' and mstr_frame_update = '1' and mstr_frame_ref_in = num_fstore_minus1
                and circular_prk_mode = '1')then
                    mstr_reverse_order  <=  not mstr_reverse_order; -- toggle reverse flag

                end if;
            end if;
        end process RVRS_ORDER_FLAG;

    -- Register reverse flag twice to align flag with phase 4 grey encoded tag
    -- process
    REG_DELAY_FLAG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    mstr_reverse_order_d1 <= '1';
                    mstr_reverse_order_d2 <= '1';
                else
                    mstr_reverse_order_d1 <= mstr_reverse_order;
                    mstr_reverse_order_d2 <= mstr_reverse_order_d1;
                end if;
            end if;
        end process REG_DELAY_FLAG;

    -- For FSTORE > 1 then gray coding is needed for proper clock crossing
    -- in Gen-Lock slave. ( - added generate for fstores > 1)
    GEN_FSTORES_GRTR_ONE : if C_NUM_FSTORES > 1 generate
    begin
        ---------------------------------------------------------------------------
        -- Phase 1: Based on reverse order flag convert master frame in into a
        -- reverse order frame number (i.e. 3,2,1,0)
        -- or normal order (i.e. 0,1,2,3)
        ---------------------------------------------------------------------------

        --rvc_frame_ref_in <= std_logic_vector((C_NUM_FSTORES - 1) - unsigned(mstr_frame_ref_in));
        rvc_frame_ref_in <= std_logic_vector(unsigned(num_fstore_minus1) - unsigned(mstr_frame_ref_in));

        FRAME_CONVERT_P1 : process(mstr_reverse_order,mstr_frame_ref_in,rvc_frame_ref_in,num_fstore_equal_one)
            begin
                if(mstr_reverse_order = '1' and num_fstore_equal_one = '0')then
                    raw_frame_ptr <= rvc_frame_ref_in;
                else
                    raw_frame_ptr <= mstr_frame_ref_in;
                end if;
            end process FRAME_CONVERT_P1;

        -- Register to break long timing paths
        REG_P1 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        reg_raw_frame_ptr <= (others => '0');
                    else
                        reg_raw_frame_ptr <= raw_frame_ptr;
                    end if;
                end if;
            end process REG_P1;


        ---------------------------------------------------------------------------
        -- Phase 2: Partial Invert of raw frame pointer (invert only the
        -- log2(C_NUM_FSTORE) bits
        -- GREY_NUM_BITS = 1 which is C_NUM_FSTORE = 1 to 2     then invert 1 LSB
        -- GREY_NUM_BITS = 2 which is C_NUM_FSTORE = 3 to 4,    then invert 2 LSBs
        -- GREY_NUM_BITS = 3 which is C_NUM_FSTORE = 5 to 8,    then invert 3 LSBs
        -- GREY_NUM_BITS = 4 which is C_NUM_FSTORE = 9 to 16,   then invert 4 LSBs
        -- GREY_NUM_BITS = 5 which is C_NUM_FSTORE = 17 to 32,  then invert 5 LSBs (all bits)
        ---------------------------------------------------------------------------
        --  - shifted FSTORE 2 to the correct inverse
        PARTIAL_NOT_P2 : process(num_frame_store,reg_raw_frame_ptr)
            begin
                case num_frame_store is
                    -- Number of Frame Stores =  1 and 2
                    when "000001" | "000010" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores =  3 and 4
                    when "000011" | "000100" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores =  5, 6, 7, and 8
                    when "000101" | "000110" | "000111" | "001000" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= not reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores = 9 to 16
                    when "001001" | "001010" | "001011" | "001100" | "001101"
                       | "001110" | "001111" | "010000" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= not reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= not reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores = 17 to 32
                    when others =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= not reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= not reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= not reg_raw_frame_ptr(4);
                end case;
            end process PARTIAL_NOT_P2;


        -- Register pratial not to break timing paths
        REG_P2 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        binary_frame_ptr <= (others => '0');
                    else
                        binary_frame_ptr <= inv_raw_frame_ptr;
                    end if;
                end if;
            end process REG_P2;


        ---------------------------------------------------------------------------
        -- Phase 3 : Grey Encode
        -- Encode binary coded frame pointer
        ---------------------------------------------------------------------------
        GREY_CODER_I : entity  axi_vdma_v6_3_10.axi_vdma_greycoder
            generic map(
                C_DWIDTH                    => FRAME_NUMBER_WIDTH
            )
            port map(
                -- Grey Encode
                binary_in                   => binary_frame_ptr             ,
                grey_out                    => grey_frame_ptr_out           ,

                -- Grey Decode
                grey_in                     => ZERO_VALUE(FRAME_NUMBER_WIDTH-1 downto 0)       ,
                binary_out                  => open
            );

        ---------------------------------------------------------------------------
        -- Phase 4 : Tag Grey Encoded Pointer
        -- Tag grey code with the inverse of the reverse flag.  This provides
        -- two sets of grey codes representing 2 passes through frame buffer.
        ---------------------------------------------------------------------------



        -- If C_NUM_FSTORES is 17 to 32 then all 5 bits are used of frame number therefore
        -- no need to pad grey encoded result
        GEN_EQL_5_BITS : if GREY_NUM_BITS = 5 generate
        begin

            --
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is

                        -- Number of Frame Stores = 1
                        when "000001" =>
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 2
                        when "000010" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 3 and 4
                        when "000011" | "000100" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 5 to 8
                        when "000101" | "000110" | "000111" | "001000" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 9 to 16
                        when "001001" | "001010" | "001011" | "001100" | "001101"
                           | "001110" | "001111" | "010000" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= grey_frame_ptr_out(3);
                            s_frame_ptr_out(4)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 17 to 32
                        when others =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= grey_frame_ptr_out(3);
                            s_frame_ptr_out(4)  <= grey_frame_ptr_out(4);
                            s_frame_ptr_out(5)  <= not mstr_reverse_order_d2;
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_5_BITS;


        -- If C_NUM_FSTORES is 8 to 16 then all 4 bits are used of frame number therefore
        -- no need to pad grey encoded result
        GEN_EQL_4_BITS : if GREY_NUM_BITS = 4 generate
        begin

            -- 
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000010" => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000011" | "000100" => -- 3 and 4
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000101" | "000110" | "000111" | "001000" => -- 5, 6, 7, and 8
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- 9 to 16
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= grey_frame_ptr_out(3);
                            s_frame_ptr_out(4)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_4_BITS;



        -- C_NUM_FSTORES = 4 to 7
        GEN_EQL_3_BITS : if GREY_NUM_BITS = 3 generate
        begin
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000010" => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000011" | "000100" => -- 3 and 4
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- 5 to 7
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_3_BITS;

        -- C_NUM_FSTORES = 3
        GEN_EQL_2_BITS : if GREY_NUM_BITS = 2 generate
        begin
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000010" => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- Number of Frame Stores = 3
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_2_BITS;

        -- C_NUM_FSTORES = 2
        GEN_EQL_1_BITS : if GREY_NUM_BITS = 1 generate
        begin
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_1_BITS;

    end generate GEN_FSTORES_GRTR_ONE;

    -- 
    -- For FSTORE = 1 then gray coding is not needed.  Simply
    -- pass the reverse order flag out.
    -- (- added generate for fstores = 1)
    GEN_FSTORES_EQL_ONE : if C_NUM_FSTORES = 1 generate
    begin

        s_frame_ptr_out <= "00000" & not(mstr_reverse_order_d2);


    end generate GEN_FSTORES_EQL_ONE;

    -- Register Master Frame Pointer Out
    REG_FRAME_PTR_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    frame_ptr_out <= (others => '0');
                else
                    frame_ptr_out <= s_frame_ptr_out;
                end if;
            end if;
        end process REG_FRAME_PTR_OUT;


    --*********************************************************************
    --** TEST VECTOR SIGNALS - For Xilinx Internal Testing Only
    --*********************************************************************
    -- Coverage Off
    REG_SCNDRY_TSTSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    mstrfrm_tstsync_d1 <= '0';
                    mstrfrm_tstsync_d2 <= '0';
                    mstrfrm_tstsync_d3 <= '0';
                    mstrfrm_tstsync_d4 <= '0';
                else
                    mstrfrm_tstsync_d1 <= mstr_frame_update;
                    mstrfrm_tstsync_d2 <= mstrfrm_tstsync_d1;
                    mstrfrm_tstsync_d3 <= mstrfrm_tstsync_d2;
                    mstrfrm_tstsync_d4 <= mstrfrm_tstsync_d3;
                end if;
            end if;
        end process REG_SCNDRY_TSTSYNC_OUT;

    mstrfrm_tstsync_out <= mstrfrm_tstsync_d4;
    -- Coverage On
    --*********************************************************************
    --** END TEST SECTION
    --*********************************************************************

end generate DYNAMIC_GENLOCK_FOR_MASTER;




-------------------------------------------------------------------------------
-- Generate genlock decoding logic for Dynamic slave
-------------------------------------------------------------------------------
DYNAMIC_GENLOCK_FOR_SLAVE : if C_GENLOCK_MODE = 3 generate
begin


    -- Mux frame pointer in from Master based on master in control
    GENLOCK_MUX_I : entity  axi_vdma_v6_3_10.axi_vdma_genlock_mux
        generic map(
            C_GENLOCK_NUM_MASTERS       => C_GENLOCK_NUM_MASTERS    ,
            C_INTERNAL_GENLOCK_ENABLE   => C_INTERNAL_GENLOCK_ENABLE
        )
        port map(

            prmry_aclk              => prmry_aclk                   ,
            prmry_resetn            => prmry_resetn                 ,

            mstr_in_control         => mstr_in_control              ,
            genlock_select          => genlock_select               ,
            internal_frame_ptr_in   => internal_frame_ptr_in        ,
            frame_ptr_in            => frame_ptr_in                 ,
            frame_ptr_out           => grey_frame_ptr
        );

    ---------------------------------------------------------------------------
    -- Phase 1:
    -- Decode Grey coded frame pointer
    ---------------------------------------------------------------------------
    ADJUST_4_FRM_STRS : process(num_frame_store,grey_frame_ptr)
        begin
            case num_frame_store is
                -- Number of Frame Stores = 1 and 2
                when "000001" | "000010" =>
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= '0';
                    grey_frmstr_adjusted(2) <= '0';
                    grey_frmstr_adjusted(3) <= '0';
                    grey_frmstr_adjusted(4) <= '0';
                    grey_frmstr_adjusted(5) <= '0';

                -- Number of Frame Stores = 3 and 4
                when "000011" | "000100" =>
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= grey_frame_ptr(1);
                    grey_frmstr_adjusted(2) <= '0';
                    grey_frmstr_adjusted(3) <= '0';
                    grey_frmstr_adjusted(4) <= '0';
                    grey_frmstr_adjusted(5) <= '0';

                -- Number of Frame Stores = 5, 6, 7, and 8
                when "000101" | "000110" | "000111" | "001000" =>
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= grey_frame_ptr(1);
                    grey_frmstr_adjusted(2) <= grey_frame_ptr(2);
                    grey_frmstr_adjusted(3) <= '0';
                    grey_frmstr_adjusted(4) <= '0';
                    grey_frmstr_adjusted(5) <= '0';

                -- Number of Frame Stores = 9 to 16
                when "001001" | "001010" | "001011" | "001100" | "001101"
                   | "001110" | "001111" | "010000" =>
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= grey_frame_ptr(1);
                    grey_frmstr_adjusted(2) <= grey_frame_ptr(2);
                    grey_frmstr_adjusted(3) <= grey_frame_ptr(3);
                    grey_frmstr_adjusted(4) <= '0';
                    grey_frmstr_adjusted(5) <= '0';

                -- Number of Frame Stores =  17 to 32
                when others => -- 17 to 32
                    grey_frmstr_adjusted(0) <= grey_frame_ptr(0);
                    grey_frmstr_adjusted(1) <= grey_frame_ptr(1);
                    grey_frmstr_adjusted(2) <= grey_frame_ptr(2);
                    grey_frmstr_adjusted(3) <= grey_frame_ptr(3);
                    grey_frmstr_adjusted(4) <= grey_frame_ptr(4);
                    grey_frmstr_adjusted(5) <= '0';

            end case;
        end process ADJUST_4_FRM_STRS;

    GREY_CODER_I : entity  axi_vdma_v6_3_10.axi_vdma_greycoder
        generic map(
            C_DWIDTH                    => GREY_NUM_BITS
        )
        port map(
            -- Grey Encode
            binary_in                   => ZERO_VALUE(GREY_NUM_BITS - 1 downto 0)       ,
            grey_out                    => open             ,

            -- Grey Decode
            grey_in                     => grey_frmstr_adjusted(GREY_NUM_BITS - 1 downto 0)    ,
            binary_out                  => partial_frame_ptr
        );

    ---------------------------------------------------------------------------
    -- Phase 2:
    -- Invert partial frame pointer and pad to full frame pointer width
    ---------------------------------------------------------------------------
    -- FSTORES = 1 or 2 therefore pad decoded frame pointer with 4 bits
    --  shifted FSTORE 2 case to the correct padding location
    GEN_FSTORES_12 : if C_NUM_FSTORES = 1 or C_NUM_FSTORES = 2 generate
    begin
        padded_partial_frame_ptr <= "0000" & partial_frame_ptr;
    end generate GEN_FSTORES_12;

    -- FSTORES = 3 or 4 therefore pad decoded frame pointer with 3 bits
    GEN_FSTORES_34 : if C_NUM_FSTORES > 2 and C_NUM_FSTORES < 5 generate
    begin
        padded_partial_frame_ptr <= "000" & partial_frame_ptr;
    end generate GEN_FSTORES_34;

    -- FSTORES = 5,6,7 or 8 therefore pad decoded frame pointer with 2 bit
    GEN_FSTORES_5678 : if C_NUM_FSTORES > 4 and C_NUM_FSTORES < 9 generate
    begin
        padded_partial_frame_ptr <= "00" & partial_frame_ptr;
    end generate GEN_FSTORES_5678;

    -- FSTORES = 9 to 16 therefore pad decoded frame pointer with 1 bit
    GEN_FSTORES_9TO16 : if C_NUM_FSTORES > 8 and C_NUM_FSTORES < 17 generate
    begin
        padded_partial_frame_ptr <= '0' & partial_frame_ptr;
    end generate GEN_FSTORES_9TO16;

    -- FSTORES > 16 therefore no need to pad decoded frame pointer
    GEN_FSTORES_17NUP : if C_NUM_FSTORES > 16 generate
    begin
        padded_partial_frame_ptr <= partial_frame_ptr;
    end generate GEN_FSTORES_17NUP;

    -- - fixed wrong signal in sensitivity list.
    -- - shifted FSTORE 2 to the correct inverse
    DS_PARTIAL_NOT_P2 : process(num_frame_store,padded_partial_frame_ptr)
        begin
            case num_frame_store is
                -- Number of Frame Stores = 1 and 2
                when "000001" | "000010" =>
                    ds_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    ds_inv_raw_frame_ptr(1) <= '0';
                    ds_inv_raw_frame_ptr(2) <= '0';
                    ds_inv_raw_frame_ptr(3) <= '0';
                    ds_inv_raw_frame_ptr(4) <= '0';

                -- Number of Frame Stores = 3 and 4
                when "000011" | "000100" =>
                    ds_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    ds_inv_raw_frame_ptr(1) <= not padded_partial_frame_ptr(1);
                    ds_inv_raw_frame_ptr(2) <= '0';
                    ds_inv_raw_frame_ptr(3) <= '0';
                    ds_inv_raw_frame_ptr(4) <= '0';
                -- Number of Frame Stores = 5 to 8
                when "000101" | "000110" | "000111" | "001000" =>
                    ds_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    ds_inv_raw_frame_ptr(1) <= not padded_partial_frame_ptr(1);
                    ds_inv_raw_frame_ptr(2) <= not padded_partial_frame_ptr(2);
                    ds_inv_raw_frame_ptr(3) <= '0';
                    ds_inv_raw_frame_ptr(4) <= '0';

                -- Number of Frame Stores = 9 to 16
                when "001001" | "001010" | "001011" | "001100" | "001101"
                   | "001110" | "001111" | "010000" =>
                    ds_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    ds_inv_raw_frame_ptr(1) <= not padded_partial_frame_ptr(1);
                    ds_inv_raw_frame_ptr(2) <= not padded_partial_frame_ptr(2);
                    ds_inv_raw_frame_ptr(3) <= not padded_partial_frame_ptr(3);
                    ds_inv_raw_frame_ptr(4) <= '0';

                when others => -- 17 to 32
                    ds_inv_raw_frame_ptr(0) <= not padded_partial_frame_ptr(0);
                    ds_inv_raw_frame_ptr(1) <= not padded_partial_frame_ptr(1);
                    ds_inv_raw_frame_ptr(2) <= not padded_partial_frame_ptr(2);
                    ds_inv_raw_frame_ptr(3) <= not padded_partial_frame_ptr(3);
                    ds_inv_raw_frame_ptr(4) <= not padded_partial_frame_ptr(4);

            end case;
        end process DS_PARTIAL_NOT_P2;

    -- Register to break long timing paths
    DS_REG_P2 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    ds_binary_frame_ptr <= (others => '0');
                else
                    ds_binary_frame_ptr <= ds_inv_raw_frame_ptr;
                end if;
            end if;
        end process DS_REG_P2;


    ---------------------------------------------------------------------------
    -- Phase 3:
    -- Convert to frame pointer (i.e. reverse if need or pass through)
    ---------------------------------------------------------------------------
    -- Reverse order indication
    -- 1 = frame order reversed, 0 = frame order normal
    --mstr_reverse_order  <= not grey_frame_ptr(GREY_NUM_BITS);
    DS_REVERSE_INDICATOR : process(num_frame_store,grey_frame_ptr)
        begin
            case num_frame_store is
                -- Number of Frame Stores = 1
                when "000001" =>
                    ds_mstr_reverse_order   <= not grey_frame_ptr(0);

                -- Number of Frame Stores = 2
                when "000010" =>
                    ds_mstr_reverse_order   <= not grey_frame_ptr(1);

                -- Number of Frame Stores = 3 and 4
                when "000011" | "000100" =>
                    ds_mstr_reverse_order   <= not grey_frame_ptr(2);

                -- Number of Frame Stores = 5, 6, 7, and 8
                when "000101" | "000110" | "000111" | "001000" =>
                    ds_mstr_reverse_order   <= not grey_frame_ptr(3);

                -- Number of Frame Stores = 9 to 16
                when "001001" | "001010" | "001011" | "001100" | "001101"
                   | "001110" | "001111" | "010000" =>
                    ds_mstr_reverse_order   <= not grey_frame_ptr(4);

                -- Number of Frame Stores = 16 to 32
                when others =>
                    ds_mstr_reverse_order   <= not grey_frame_ptr(5);

            end case;
        end process DS_REVERSE_INDICATOR;

    -- Register reverse flag to align flag with phase 3 process
    DS_REG_DELAY_FLAG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    ds_mstr_reverse_order_d1 <= '1';
                else
                    ds_mstr_reverse_order_d1 <= ds_mstr_reverse_order;
                end if;
            end if;
        end process DS_REG_DELAY_FLAG;

    DS_FRAME_CONVERT_P3 : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    slv_frame_ref_out <= (others => '0');

                -- reverse order frames (reverse the frame)
                elsif(ds_mstr_reverse_order_d1='1' and num_fstore_equal_one = '0')then
                    slv_frame_ref_out <= std_logic_vector(unsigned(num_fstore_minus1) - unsigned(ds_binary_frame_ptr));

                -- reverse order frames with only 1 frame store (reverse the frame)
                --  - If 1 fstore then frame is always just 0
                elsif(num_fstore_equal_one = '1')then
                    slv_frame_ref_out <= (others => '0');

                -- forward order frame (simply pass through)
                else
                    slv_frame_ref_out <= ds_binary_frame_ptr;
                end if;
            end if;
        end process DS_FRAME_CONVERT_P3;



-----------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------
    --Output Dynamic GenLock Slave's working frame number in grey
-----------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------

    -- Create flag to indicate when to reverse frame order for genlock output
    -- 0= normal frame order, 1= reverse frame order
    RVRS_ORDER_FLAG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' or dmasr_halt = '1')then
                --if(prmry_resetn = '0' )then
                    mstr_reverse_order  <= '1';

                -- On update if at frame 0 then toggle reverse order flag.
                -- Do not toggle flag if in park mode.
                elsif(fsize_mismatch_err_flag = '0' and mstr_frame_update = '1' and mstr_frame_ref_in = num_fstore_minus1
                and circular_prk_mode = '1')then
                    mstr_reverse_order  <=  not mstr_reverse_order; -- toggle reverse flag

                end if;
            end if;
        end process RVRS_ORDER_FLAG;

    -- Register reverse flag twice to align flag with phase 4 grey encoded tag
    -- process
    DS2_REG_DELAY_FLAG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    mstr_reverse_order_d1 <= '1';
                    mstr_reverse_order_d2 <= '1';
                else
                    mstr_reverse_order_d1 <= mstr_reverse_order;
                    mstr_reverse_order_d2 <= mstr_reverse_order_d1;
                end if;
            end if;
        end process DS2_REG_DELAY_FLAG;

    -- For FSTORE > 1 then gray coding is needed for proper clock crossing
    -- in Gen-Lock slave. ( - added generate for fstores > 1)
    GEN_FSTORES_GRTR_ONE : if C_NUM_FSTORES > 1 generate
    begin
        ---------------------------------------------------------------------------
        -- Phase 1: Based on reverse order flag convert master frame in into a
        -- reverse order frame number (i.e. 3,2,1,0)
        -- or normal order (i.e. 0,1,2,3)
        ---------------------------------------------------------------------------

        --rvc_frame_ref_in <= std_logic_vector((C_NUM_FSTORES - 1) - unsigned(mstr_frame_ref_in));
        rvc_frame_ref_in <= std_logic_vector(unsigned(num_fstore_minus1) - unsigned(mstr_frame_ref_in));

        FRAME_CONVERT_P1 : process(mstr_reverse_order,mstr_frame_ref_in,rvc_frame_ref_in,num_fstore_equal_one)
            begin
                if(mstr_reverse_order = '1' and num_fstore_equal_one = '0')then
                    raw_frame_ptr <= rvc_frame_ref_in;
                else
                    raw_frame_ptr <= mstr_frame_ref_in;
                end if;
            end process FRAME_CONVERT_P1;

        -- Register to break long timing paths
        REG_P1 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        reg_raw_frame_ptr <= (others => '0');
                    else
                        reg_raw_frame_ptr <= raw_frame_ptr;
                    end if;
                end if;
            end process REG_P1;


        ---------------------------------------------------------------------------
        -- Phase 2: Partial Invert of raw frame pointer (invert only the
        -- log2(C_NUM_FSTORE) bits
        -- GREY_NUM_BITS = 1 which is C_NUM_FSTORE = 1 to 2     then invert 1 LSB
        -- GREY_NUM_BITS = 2 which is C_NUM_FSTORE = 3 to 4,    then invert 2 LSBs
        -- GREY_NUM_BITS = 3 which is C_NUM_FSTORE = 5 to 8,    then invert 3 LSBs
        -- GREY_NUM_BITS = 4 which is C_NUM_FSTORE = 9 to 16,   then invert 4 LSBs
        -- GREY_NUM_BITS = 5 which is C_NUM_FSTORE = 17 to 32,  then invert 5 LSBs (all bits)
        ---------------------------------------------------------------------------
        --  - shifted FSTORE 2 to the correct inverse
        PARTIAL_NOT_P2 : process(num_frame_store,reg_raw_frame_ptr)
            begin
                case num_frame_store is
                    -- Number of Frame Stores =  1 and 2
                    when "000001" | "000010" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores =  3 and 4
                    when "000011" | "000100" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores =  5, 6, 7, and 8
                    when "000101" | "000110" | "000111" | "001000" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= not reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores = 9 to 16
                    when "001001" | "001010" | "001011" | "001100" | "001101"
                       | "001110" | "001111" | "010000" =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= not reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= not reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= reg_raw_frame_ptr(4);

                    -- Number of Frame Stores = 17 to 32
                    when others =>
                        inv_raw_frame_ptr(0) <= not reg_raw_frame_ptr(0);
                        inv_raw_frame_ptr(1) <= not reg_raw_frame_ptr(1);
                        inv_raw_frame_ptr(2) <= not reg_raw_frame_ptr(2);
                        inv_raw_frame_ptr(3) <= not reg_raw_frame_ptr(3);
                        inv_raw_frame_ptr(4) <= not reg_raw_frame_ptr(4);
                end case;
            end process PARTIAL_NOT_P2;


        -- Register pratial not to break timing paths
        REG_P2 : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        binary_frame_ptr <= (others => '0');
                    else
                        binary_frame_ptr <= inv_raw_frame_ptr;
                    end if;
                end if;
            end process REG_P2;


        ---------------------------------------------------------------------------
        -- Phase 3 : Grey Encode
        -- Encode binary coded frame pointer
        ---------------------------------------------------------------------------
        GREY_CODER_I : entity  axi_vdma_v6_3_10.axi_vdma_greycoder
            generic map(
                C_DWIDTH                    => FRAME_NUMBER_WIDTH
            )
            port map(
                -- Grey Encode
                binary_in                   => binary_frame_ptr             ,
                grey_out                    => grey_frame_ptr_out           ,

                -- Grey Decode
                grey_in                     => ZERO_VALUE(FRAME_NUMBER_WIDTH-1 downto 0)       ,
                binary_out                  => open
            );


        ---------------------------------------------------------------------------
        -- Phase 4 : Tag Grey Encoded Pointer
        -- Tag grey code with the inverse of the reverse flag.  This provides
        -- two sets of grey codes representing 2 passes through frame buffer.
        ---------------------------------------------------------------------------



        -- If C_NUM_FSTORES is 17 to 32 then all 5 bits are used of frame number therefore
        -- no need to pad grey encoded result
        GEN_EQL_5_BITS : if GREY_NUM_BITS = 5 generate
        begin

            -- 
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is

                        -- Number of Frame Stores = 1
                        when "000001" =>
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 2
                        when "000010" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 3 and 4
                        when "000011" | "000100" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 5 to 8
                        when "000101" | "000110" | "000111" | "001000" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 9 to 16
                        when "001001" | "001010" | "001011" | "001100" | "001101"
                           | "001110" | "001111" | "010000" =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= grey_frame_ptr_out(3);
                            s_frame_ptr_out(4)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(5)  <= '0';

                        -- Number of Frame Stores = 17 to 32
                        when others =>
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= grey_frame_ptr_out(3);
                            s_frame_ptr_out(4)  <= grey_frame_ptr_out(4);
                            s_frame_ptr_out(5)  <= not mstr_reverse_order_d2;
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_5_BITS;


        -- If C_NUM_FSTORES is 8 to 16 then all 4 bits are used of frame number therefore
        -- no need to pad grey encoded result
        GEN_EQL_4_BITS : if GREY_NUM_BITS = 4 generate
        begin

            -- 
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000010" => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000011" | "000100" => -- 3 and 4
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000101" | "000110" | "000111" | "001000" => -- 5, 6, 7, and 8
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- 9 to 16
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= grey_frame_ptr_out(3);
                            s_frame_ptr_out(4)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_4_BITS;



        -- C_NUM_FSTORES = 4 to 7
        GEN_EQL_3_BITS : if GREY_NUM_BITS = 3 generate
        begin
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000010" => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000011" | "000100" => -- 3 and 4
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- 5 to 7
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= grey_frame_ptr_out(2);
                            s_frame_ptr_out(3)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_3_BITS;

        -- C_NUM_FSTORES = 3
        GEN_EQL_2_BITS : if GREY_NUM_BITS = 2 generate
        begin
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when "000010" => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- Number of Frame Stores = 3
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= grey_frame_ptr_out(1);
                            s_frame_ptr_out(2)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_2_BITS;

        -- C_NUM_FSTORES = 2
        GEN_EQL_1_BITS : if GREY_NUM_BITS = 1 generate
        begin
            S_FRM_PTR_OUT_PROCESS : process(num_frame_store,grey_frame_ptr_out,mstr_reverse_order_d2)
                begin
                    case num_frame_store is
                        when "000001" => -- Number of Frame Stores = 1
                            s_frame_ptr_out(0)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(1)  <= '0';
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                        when others => -- Number of Frame Stores = 2
                            s_frame_ptr_out(0)  <= grey_frame_ptr_out(0);
                            s_frame_ptr_out(1)  <= not mstr_reverse_order_d2;
                            s_frame_ptr_out(2)  <= '0';
                            s_frame_ptr_out(3)  <= '0';
                            s_frame_ptr_out(4)  <= '0';
                            s_frame_ptr_out(5)  <= '0';
                    end case;
                end process S_FRM_PTR_OUT_PROCESS;

        end generate GEN_EQL_1_BITS;

    end generate GEN_FSTORES_GRTR_ONE;

    -- 
    -- For FSTORE = 1 then gray coding is not needed.  Simply
    -- pass the reverse order flag out.
    -- ( - added generate for fstores = 1)
    GEN_FSTORES_EQL_ONE : if C_NUM_FSTORES = 1 generate
    begin

        s_frame_ptr_out <= "00000" & not(mstr_reverse_order_d2);


    end generate GEN_FSTORES_EQL_ONE;

    -- Register Master Frame Pointer Out
    REG_FRAME_PTR_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    frame_ptr_out <= (others => '0');
                else
                    frame_ptr_out <= s_frame_ptr_out;
                end if;
            end if;
        end process REG_FRAME_PTR_OUT;


    --*********************************************************************
    --** TEST VECTOR SIGNALS - For Xilinx Internal Testing Only
    --*********************************************************************
    -- Coverage Off
    REG_SCNDRY_TSTSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    mstrfrm_tstsync_d1 <= '0';
                    mstrfrm_tstsync_d2 <= '0';
                    mstrfrm_tstsync_d3 <= '0';
                    mstrfrm_tstsync_d4 <= '0';
                else
                    mstrfrm_tstsync_d1 <= mstr_frame_update;
                    mstrfrm_tstsync_d2 <= mstrfrm_tstsync_d1;
                    mstrfrm_tstsync_d3 <= mstrfrm_tstsync_d2;
                    mstrfrm_tstsync_d4 <= mstrfrm_tstsync_d3;
                end if;
            end if;
        end process REG_SCNDRY_TSTSYNC_OUT;

    mstrfrm_tstsync_out <= mstrfrm_tstsync_d4;
    -- Coverage On
    --*********************************************************************
    --** END TEST SECTION
    --*********************************************************************


end generate DYNAMIC_GENLOCK_FOR_SLAVE;



end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_sg_if
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_sg_if.vhd
-- Description: This entity is the Scatter Gather Interface for Descriptor
--              Fetches.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;


-------------------------------------------------------------------------------
entity  axi_vdma_sg_if is
    generic (

        -----------------------------------------------------------------------
        -- Scatter Gather Parameters
        -----------------------------------------------------------------------

        C_M_AXIS_SG_TDATA_WIDTH         : integer range 32 to 32        := 32   ;
            -- AXI Master Stream in for descriptor fetch

        C_M_AXI_SG_ADDR_WIDTH           : integer range 32 to 64        := 32   ;
            -- Master AXI Memory Map Data Width for Scatter Gather R/W Port

        C_M_AXI_ADDR_WIDTH              : integer range 32 to 64        := 32
            -- Master AXI Memory Map Address Width
    );
    port (

        prmry_aclk              : in  std_logic                             ;       --
        prmry_resetn            : in  std_logic                             ;       --
                                                                                    --
        dmasr_halt              : in  std_logic                             ;       --
        ftch_idle               : in  std_logic                             ;       --
        ftch_complete_clr       : in  std_logic                             ;       --
        ftch_complete           : out std_logic                             ;       --
                                                                                    --
        -- SG Descriptor Fetch AXI Stream In                                        --
        m_axis_ftch_tdata       : in  std_logic_vector                              --
                                    (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)    ;       --
        m_axis_ftch_tvalid      : in  std_logic                             ;       --
        m_axis_ftch_tready      : out std_logic                             ;       --
        m_axis_ftch_tlast       : in  std_logic                             ;       --
                                                                                    --
        -- Descriptor Field Output                                                  --
        new_curdesc             : out std_logic_vector                              --
                                    (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)      ;       --
        new_curdesc_wren        : out std_logic                             ;       --
                                                                                    --
                                                                                    --
        desc_data_wren          : out std_logic                             ;       --
                                                                                    --
        desc_strtaddress        : out std_logic_vector                              --
                                    (C_M_AXI_ADDR_WIDTH-1 downto 0)         ;       --
        desc_vsize              : out std_logic_vector                              --
                                    (VSIZE_DWIDTH-1 downto 0)               ;       --
        desc_hsize              : out std_logic_vector                              --
                                    (HSIZE_DWIDTH-1 downto 0)               ;       --
        desc_stride             : out std_logic_vector                              --
                                    (STRIDE_DWIDTH-1 downto 0)              ;       --
        desc_frmdly             : out std_logic_vector                              --
                                    (FRMDLY_DWIDTH-1 downto 0)                      --
    );

end axi_vdma_sg_if;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_sg_if is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal ftch_shftenbl            : std_logic := '0';
signal ftch_tready              : std_logic := '0';
signal desc_fetch_done_i        : std_logic := '0';

signal desc_reg6                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg5                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg4                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg3                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg2                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg1                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg0                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');

signal desc_curdesc_lsb         : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_curdesc_msb         : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_strtaddr_lsb        : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_strtaddr_msb        : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');

signal desc_data_wren_i         : std_logic := '0';

signal ftch_idle_d1             : std_logic := '0';
signal ftch_idle_re             : std_logic := '0';
signal ftch_complete_i          : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

-- Generate rising edge of ftch idle
REG_FETCH_IDLE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                ftch_idle_d1 <= '1';
            else
                ftch_idle_d1 <= ftch_idle;
            end if;
        end if;
    end process REG_FETCH_IDLE;

ftch_idle_re <= ftch_idle and not ftch_idle_d1;


DESC_FTCH_CMPLT : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or dmasr_halt = '1')then
                ftch_complete_i <= '0';

            -- SG Engine not going idle and commanded to clear flag
            elsif(ftch_idle_re = '0' and ftch_complete_clr = '1')then
                ftch_complete_i <= '0';

            -- On SG Engine going idle flag descriptor fetches as complete
            elsif(ftch_idle_re = '1')then
                ftch_complete_i <= '1';
            end if;
        end if;
    end process DESC_FTCH_CMPLT;

ftch_complete <= ftch_complete_i;

-- Drive fetch request done on tlast
desc_fetch_done_i       <= m_axis_ftch_tlast
                          and m_axis_ftch_tvalid
                          and ftch_tready;

-- Shift in data from SG engine if tvalid and fetch request
ftch_shftenbl           <= m_axis_ftch_tvalid
                          and ftch_tready
                          and not desc_data_wren_i;

-- Passed curdes write out to register module
new_curdesc_wren        <= desc_data_wren_i;

-- Drive ready if NOT writing video xfer paramters
-- and if not already fetched set of video paramerters/start addresses
ftch_tready             <= not desc_data_wren_i and not ftch_complete_i;

-- Drive ready out to SG Engine
m_axis_ftch_tready      <= ftch_tready;

-------------------------------------------------------------------------------
-- Large shift register to bring in descriptor fields
-------------------------------------------------------------------------------
DESC_WRD_PROCESS : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                desc_reg6     <= (others => '0');
                desc_reg5     <= (others => '0');
                desc_reg4     <= (others => '0');
                desc_reg3     <= (others => '0');
                desc_reg2     <= (others => '0');
                desc_reg1     <= (others => '0');
                desc_reg0     <= (others => '0');
            -- Shift if enabled or if doing and overlay
            elsif(ftch_shftenbl = '1')then
                desc_reg6       <= m_axis_ftch_tdata;
                desc_reg5       <= desc_reg6;
                desc_reg4       <= desc_reg5;
                desc_reg3       <= desc_reg4;
                desc_reg2       <= desc_reg3;
                desc_reg1       <= desc_reg2;
                desc_reg0       <= desc_reg1;
            end if;
        end if;
    end process DESC_WRD_PROCESS;

desc_curdesc_lsb   <= desc_reg0;
desc_curdesc_msb   <= desc_reg1;
desc_strtaddr_lsb  <= desc_reg2;
desc_strtaddr_msb  <= desc_reg3;

desc_vsize         <= desc_reg4(DESC_WRD4_VSIZE_MSB_BIT  downto DESC_WRD4_VSIZE_LSB_BIT);
desc_hsize         <= desc_reg5(DESC_WRD5_HSIZE_MSB_BIT  downto DESC_WRD5_HSIZE_LSB_BIT);
desc_stride        <= desc_reg6(DESC_WRD6_STRIDE_MSB_BIT downto DESC_WRD6_STRIDE_LSB_BIT);
desc_frmdly        <= desc_reg6(DESC_WRD6_FRMDLY_MSB_BIT downto DESC_WRD6_FRMDLY_LSB_BIT);

-------------------------------------------------------------------------------
-- BUFFER ADDRESS
-------------------------------------------------------------------------------
-- If 64 bit addressing then concatinate msb to lsb
GEN_NEW_64BIT_BUFADDR : if C_M_AXI_ADDR_WIDTH = 64 generate
    desc_strtaddress <= desc_strtaddr_msb & desc_strtaddr_lsb;
end generate GEN_NEW_64BIT_BUFADDR;

-- If 32 bit addressing then simply pass lsb out
GEN_NEW_32BIT_BUFADDR : if C_M_AXI_ADDR_WIDTH = 32 generate
    desc_strtaddress <= desc_strtaddr_lsb;
end generate GEN_NEW_32BIT_BUFADDR;

-------------------------------------------------------------------------------
-- NEW CURRENT DESCRIPTOR
-------------------------------------------------------------------------------
-- If 64 bit addressing then concatinate msb to lsb
GEN_NEW_64BIT_CURDESC : if C_M_AXI_SG_ADDR_WIDTH = 64 generate
    new_curdesc <= desc_curdesc_msb & desc_curdesc_lsb;
end generate GEN_NEW_64BIT_CURDESC;

-- If 32 bit addressing then simply pass lsb out
GEN_NEW_32BIT_CURDESC : if C_M_AXI_SG_ADDR_WIDTH = 32 generate
    new_curdesc <= desc_curdesc_lsb;
end generate GEN_NEW_32BIT_CURDESC;

-- Write new descriptor data out on last
REG_DESCDATA_WREN : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                desc_data_wren_i <= '0';
            -- Write new desc data on fetch done
            elsif(desc_fetch_done_i = '1')then
                desc_data_wren_i <= '1';
            else
                desc_data_wren_i <= '0';
            end if;
        end if;
    end process REG_DESCDATA_WREN;

desc_data_wren  <= desc_data_wren_i;


end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_sm
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_sm.vhd
-- Description: This entity contains the DMA Controller State Machine and
--              manages primary data transfers.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

library lib_cdc_v1_0_2;
library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;
use lib_pkg_v1_0_2.lib_pkg.max2;


-------------------------------------------------------------------------------
entity  axi_vdma_sm is
    generic (
        C_INCLUDE_SF                : integer range 0 to 1      := 0;
            -- Include or exclude store and forward module
            -- 0 = excluded
            -- 1 = included

        C_USE_FSYNC                 : integer range 0 to 1      := 0;                       -- 
            -- Specifies VDMA operation synchronized to frame sync input
            -- 0 = Free running
            -- 1 = Fsync synchronous

        C_ENABLE_FLUSH_ON_FSYNC     : integer range 0 to 1      := 0;                       -- 
            -- Specifies VDMA Flush on Frame sync enabled
            -- 0 = Disabled
            -- 1 = Enabled

        C_M_AXI_ADDR_WIDTH          : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for MM2S Read Port

        C_EXTEND_DM_COMMAND         : integer range 0 to 1      := 0;
            -- Extend datamover command by padding BTT with 1's for
            -- indeterminate BTT mode

        C_PRMY_CMDFIFO_DEPTH        : integer range 1 to 16     := 1;
            -- Depth of DataMover command FIFO
    
        C_PRMRY_IS_ACLK_ASYNC       : integer range 0 to 1      := 0 ;

        C_S2MM_SOF_ENABLE           : integer range 0 to 1      := 0;
        C_MM2S_SOF_ENABLE           : integer range 0 to 1      := 0;
        C_ENABLE_VERT_FLIP          : integer range 0 to 1      := 0;            


        C_INCLUDE_MM2S              : integer range 0 to 1      := 1;
            -- Include or exclude MM2S primary data path
            -- 0 = Exclude MM2S primary data path
            -- 1 = Include MM2S primary data path

        C_INCLUDE_S2MM              : integer range 0 to 1      := 1
            -- Include or exclude S2MM primary data path
            -- 0 = Exclude S2MM primary data path
            -- 1 = Include S2MM primary data path

);
    port (
        prmry_aclk                  : in  std_logic                         ;               --
        prmry_resetn                : in  std_logic                         ;               --
 
        scndry_aclk                 : in  std_logic                             ;       --
        scndry_resetn               : in  std_logic                             ;       --
                                                                                           --
        -- Control and Status                                                               --
        frame_sync                  : in  std_logic                         ;               --
        video_prmtrs_valid          : in  std_logic                         ;               --
        packet_sof                  : in  std_logic                         ;               --
        run_stop                    : in  std_logic                         ;               --
        stop                        : in  std_logic                         ;               --
        halt                        : in  std_logic                         ;               --
                                                                                            --
        -- sm status                                                                        --
        cmnd_idle                   : out std_logic                         ;               --
        sts_idle                    : out std_logic                         ;               --
        zero_size_err               : out std_logic                         ;               -- 
        fsize_mismatch_err_flag     : out std_logic                         ;               -- 
        fsize_mismatch_err          : out std_logic                         ;               -- 
        s2mm_fsize_mismatch_err_s   : out std_logic                         ;               -- 

        mm2s_fsize_mismatch_err_s   : in std_logic                         ;            
        mm2s_fsize_mismatch_err_m   : in std_logic                         ;            
        all_lines_xfred             : in  std_logic                         ;               -- 
        all_lasts_rcvd              : in  std_logic                         ;               --                                                                                             --
        s2mm_strm_all_lines_rcvd    : in  std_logic                         ;               --
        drop_fsync_d_pulse_gen_fsize_less_err              : in  std_logic                         ;               --


        s2mm_fsync_core             : in  std_logic                         ;       
        s2mm_fsync_out_m            : in  std_logic                         ;       
        mm2s_fsync_out_m            : in  std_logic                         ;       



        -- DataMover Command                                                                --
        cmnd_wr                     : out std_logic                         ;               --
        cmnd_data                   : out std_logic_vector                                  --
                                        ((C_M_AXI_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);   --
        cmnd_pending                : in std_logic                          ;               --
        sts_received                : in std_logic                          ;               --
        -- Vertical Flip                                                                --
        vflip_sm                  : in  std_logic                             ;       --
                                                                                            --
        -- Descriptor Fields                                                                --
        crnt_start_address          : in  std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0);  --
                                                                                            --
        crnt_vsize                  : in  std_logic_vector                                  --
                                        (VSIZE_DWIDTH-1 downto 0)           ;               --
        crnt_hsize                  : in  std_logic_vector                                  --
                                        (HSIZE_DWIDTH-1 downto 0)           ;               --
        crnt_stride                 : in  std_logic_vector                                  --
                                        (STRIDE_DWIDTH-1 downto 0)                          --
    );

end axi_vdma_sm;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_sm is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- DataMover Command Destination Stream Offset
constant CMD_DSA       : std_logic_vector(5 downto 0)  := (others => '0');
-- DataMover Cmnd Reserved Bits
constant CMD_RSVD      : std_logic_vector(
                                DATAMOVER_CMD_RSVMSB_BOFST + C_M_AXI_ADDR_WIDTH downto
                                DATAMOVER_CMD_RSVLSB_BOFST + C_M_AXI_ADDR_WIDTH)
                                := (others => '0');

-- Queued commands counter width
constant COUNTER_WIDTH      : integer := 8;
-- Queued commands zero count
constant ZERO_COUNT         : std_logic_vector(COUNTER_WIDTH - 1 downto 0)
                                := (others => '0');

constant PAD_VALUE          : std_logic_vector(22 - HSIZE_DWIDTH downto 0)
                                := (others => '0');

constant ONES_PAD_VALUE     : std_logic_vector(22 - HSIZE_DWIDTH downto 0)
                                := (others => '1');

constant ZERO_VCOUNT        : std_logic_vector(VSIZE_DWIDTH-1 downto 0)
                                := (others => '0');

constant EXTND_STRIDE_PAD   : std_logic_vector((C_M_AXI_ADDR_WIDTH - STRIDE_DWIDTH) - 1 downto 0)
                                := (others => '0');

-- Zero HSIZE Constant for error check
constant ZERO_HSIZE         : std_logic_vector(HSIZE_DWIDTH-1 downto 0) := (others => '0');
-- Zero VSIZE Constant for error check
constant ZERO_VSIZE         : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
type SG_STATE_TYPE      is (
                                IDLE,
                                WAIT_PIPE1,
                                WAIT_PIPE2,
                                CALC_CMD_ADDR,
                                EXECUTE_XFER,
                                CHECK_DONE
                                );

signal dmacntrl_cs                  : SG_STATE_TYPE;
signal dmacntrl_ns                  : SG_STATE_TYPE;

-- State Machine Signals
signal calc_new_addr            : std_logic := '0';
signal load_new_addr            : std_logic := '0';
signal write_cmnd_cmb           : std_logic := '0';
signal cmnd_wr_i                : std_logic := '0';
signal cmnd_idle_i              : std_logic := '0';

-- address calc signals
signal extend_crnt_stride       : std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0)
                                    := (others => '0');
signal dm_address               : std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0)
                                    := (others => '0');
signal vert_count               : std_logic_vector(VSIZE_DWIDTH - 1 downto 0)
                                    := (others => '0');
signal horz_count               : std_logic_vector(HSIZE_DWIDTH - 1 downto 0)
                                    := (others => '0');

signal cmnds_queued             : std_logic_vector(COUNTER_WIDTH - 1 downto 0) := (others => '0');
signal count_incr               : std_logic := '0';
signal count_decr               : std_logic := '0';

signal frame_sync_d1            : std_logic := '0';
signal frame_sync_d2            : std_logic := '0';
signal frame_sync_d3            : std_logic := '0';
signal frame_sync_reg           : std_logic := '0';

signal axis_data_available      : std_logic := '0';
signal zero_vsize_err           : std_logic := '0'; -- 
signal zero_hsize_err           : std_logic := '0'; -- 
signal xfers_done               : std_logic := '0'; -- 

signal all_lines_xfred_d1       : std_logic := '0';
signal all_lines_xfred_fe       : std_logic := '0';
signal xfred_started            : std_logic := '0';
signal mm2s_fsize_mismatch_err_int            	: std_logic := '0';
signal fsize_mismatch_err_int            	: std_logic := '0';
signal fsize_mismatch_err_flag_int            	: std_logic := '0';
signal fsize_mismatch_err_flag_int_d1           : std_logic := '0';
signal fsize_mismatch_err_flag_int_d2           : std_logic := '0';

signal vflip_address             : std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0)
                                    := (others => '0');
signal init_address             : std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0)
                                    := (others => '0');



-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

cmnd_wr     <= cmnd_wr_i;
cmnd_idle   <= cmnd_idle_i;



REG_FRAME_SYCN : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                frame_sync_d1   <= '0';
                frame_sync_d2   <= '0';
                frame_sync_d3   <= '0';
                frame_sync_reg  <= '0';
            else
                frame_sync_d1   <= frame_sync;
                frame_sync_d2   <= frame_sync_d1;
                frame_sync_d3   <= frame_sync_d2;
                frame_sync_reg  <= frame_sync_d3;
            end if;
        end if;
    end process REG_FRAME_SYCN;

-------------------------------------------------------------------------------
-- Stream Data Started
-- On S2MM, this is used to prevent issuing CMDs to DataMover until axi_stream
-- data is present on the S2MM interface.  This prevents write requests
-- from being issued out to axi_interconnect when no data available to write.
-------------------------------------------------------------------------------
GEN_NO_STORE_AND_FORWARD : if C_INCLUDE_SF = 0 generate
begin
    STM_DATA_PROCESS : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    axis_data_available <= '0';
                elsif(cmnd_idle_i = '1' and run_stop = '0')then
                    axis_data_available <= '0';
                -- Set if sof detected on axi stream
                elsif(packet_sof = '1')then
                    axis_data_available <= '1';

                -- New set of video parameters, therefore clear flag
                -- New s2mm packets for new parameters must come after
                -- sync.
                elsif(frame_sync = '1' )then
                    axis_data_available <= '0';
                end if;
            end if;
        end process STM_DATA_PROCESS;
end generate GEN_NO_STORE_AND_FORWARD;

-- with store and forward then store-and-forward logic will
-- regulate datamover requests.
GEN_STORE_AND_FORWARD : if C_INCLUDE_SF = 1 generate
begin
    axis_data_available <= '1';
end generate GEN_STORE_AND_FORWARD;

-------------------------------------------------------------------------------
-- Transfer State Machine
-------------------------------------------------------------------------------
DMA_CNTRL_MACHINE : process(dmacntrl_cs,
                           frame_sync_reg,
                           video_prmtrs_valid,
                           cmnd_pending,
                           run_stop,fsize_mismatch_err_flag_int_d2,
                           stop,
                           halt,
                           vert_count,
                           axis_data_available)      -- 

    begin

        -- Default signal assignment
        calc_new_addr           <= '0';
        load_new_addr           <= '0';

        write_cmnd_cmb          <= '0';
        cmnd_idle_i             <= '0';
        dmacntrl_ns             <= dmacntrl_cs;

        case dmacntrl_cs is

            -------------------------------------------------------------------
            when IDLE =>
                -- If video parameters are valid and at frame sync and no errors
                -- then start
                if( video_prmtrs_valid = '1' and frame_sync_reg = '1'
                and stop = '0' and halt = '0' and run_stop = '1' and fsize_mismatch_err_flag_int_d2 = '0') then
                    dmacntrl_ns     <= WAIT_PIPE1;
                else
                    cmnd_idle_i     <= '1';
                end if;

            -------------------------------------------------------------------
            -- pipeline delay for valid address from vidreg_module
            when WAIT_PIPE1 =>
                -- 
                -- pipeline delays when in frame count enable mode
                -- 
                --if(stop = '1' or halt = '1' or run_stop = '0')then
                if(stop = '1' or halt = '1' or run_stop = '0' or frame_sync_reg='1' or fsize_mismatch_err_flag_int_d2 = '1')then
                    dmacntrl_ns     <= IDLE;
                else
                    dmacntrl_ns     <= WAIT_PIPE2;
                end if;

            -------------------------------------------------------------------
            -- pipeline delay for valid address from vidreg_module
            when WAIT_PIPE2 =>
                -- 
                -- pipeline delays when in frame count enable mode
                -- 
                --if(stop = '1' or halt = '1' or run_stop = '0')then
                if(stop = '1' or halt = '1' or run_stop = '0' or frame_sync_reg='1' or fsize_mismatch_err_flag_int_d2 = '1')then
                    dmacntrl_ns     <= IDLE;
                else
                    load_new_addr   <= '1';
                    dmacntrl_ns     <= EXECUTE_XFER;
                end if;

            -------------------------------------------------------------------
            when CALC_CMD_ADDR =>
                -- 
                --if(stop = '1' or halt = '1')then
                if(stop = '1' or halt = '1' or frame_sync_reg='1' or fsize_mismatch_err_flag_int_d2 = '1')then
                    dmacntrl_ns     <= IDLE;
                else
                    calc_new_addr   <= '1';
                    dmacntrl_ns     <= EXECUTE_XFER;
                end if;

            -------------------------------------------------------------------
            when EXECUTE_XFER =>
                -- error detected
                -- 
                --if(stop = '1' or halt = '1'
                --or zero_hsize_err = '1' or zero_vsize_err = '1')then  -- 
                if(stop = '1' or halt = '1' or frame_sync_reg='1' or fsize_mismatch_err_flag_int_d2 = '1') then -- 
                    dmacntrl_ns     <= IDLE;
                -- Write another command if there is not one already pending
                -- and data available on stream (used for s2mm only)
                elsif(cmnd_pending = '0'
                and axis_data_available = '1')then
                    write_cmnd_cmb  <= '1';
                    dmacntrl_ns     <= CHECK_DONE;
                else
                    dmacntrl_ns     <= EXECUTE_XFER;
                end if;

            -------------------------------------------------------------------
            when CHECK_DONE =>
                -- VSIZE commands issued to datamover then done
                -- 
                --if(vert_count = ZERO_VCOUNT or stop = '1' or halt = '1')then
                if(vert_count = ZERO_VCOUNT or stop = '1'
                or halt = '1' or frame_sync_reg='1' or fsize_mismatch_err_flag_int_d2 = '1')then
                    dmacntrl_ns         <= IDLE;
                else
                    dmacntrl_ns         <= CALC_CMD_ADDR;
                end if;


            -------------------------------------------------------------------
    -- coverage off
            when others =>
                dmacntrl_ns <= IDLE;
    -- coverage on

        end case;
    end process DMA_CNTRL_MACHINE;

-------------------------------------------------------------------------------
-- register state machine states
-------------------------------------------------------------------------------
REGISTER_STATE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dmacntrl_cs     <= IDLE;
            else
                dmacntrl_cs     <= dmacntrl_ns;
            end if;
        end if;
    end process REGISTER_STATE;

-------------------------------------------------------------------------------
-- Stride Holding Register
-------------------------------------------------------------------------------
----STRIDE_REGISTER : process(prmry_aclk)
----    begin
----        if(prmry_aclk'EVENT and prmry_aclk = '1')then
----            if(prmry_resetn = '0')then
----                extend_crnt_stride <= (others => '0');
----
----            elsif(load_new_addr = '1')then
----                -- 0 extend stride to match addr width
----                extend_crnt_stride <= EXTND_STRIDE_PAD & crnt_stride;
----            end if;
----        end if;
----    end process STRIDE_REGISTER;

                extend_crnt_stride <= EXTND_STRIDE_PAD & crnt_stride;


VFLIP_EN : if C_ENABLE_VERT_FLIP = 1 generate
begin



VFLIP_MM2S : if C_INCLUDE_MM2S = 1 generate
begin


ADDRESS_CALC : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dm_address <= (others => '0');

            elsif(load_new_addr = '1')then
                dm_address <= crnt_start_address;

            elsif(calc_new_addr = '1')then
                dm_address <= std_logic_vector(unsigned(dm_address) + unsigned(extend_crnt_stride));

            end if;
        end if;
    end process ADDRESS_CALC;


end generate VFLIP_MM2S;

VFLIP_S2MM : if (C_INCLUDE_S2MM = 1 ) generate

vflip_address <= std_logic_vector( unsigned(crnt_start_address) + resize( ((unsigned(crnt_vsize)-1) * (unsigned(extend_crnt_stride)) ),C_M_AXI_ADDR_WIDTH) );


init_address  <= vflip_address when vflip_sm = '1' 
          else crnt_start_address;



ADDRESS_CALC : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dm_address <= (others => '0');

            elsif(load_new_addr = '1')then
                dm_address <= init_address ;

            elsif(calc_new_addr = '1' and vflip_sm = '1')then
                dm_address <= std_logic_vector(unsigned(dm_address) - unsigned(extend_crnt_stride));
            elsif(calc_new_addr = '1' and vflip_sm = '0')then
                dm_address <= std_logic_vector(unsigned(dm_address) + unsigned(extend_crnt_stride));

            end if;
        end if;
    end process ADDRESS_CALC;


end generate VFLIP_S2MM;


end generate VFLIP_EN;


VFLIP_DISABLE : if C_ENABLE_VERT_FLIP = 0  generate
begin


-------------------------------------------------------------------------------
-- Command Address Calculator
-------------------------------------------------------------------------------
ADDRESS_CALC : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                dm_address <= (others => '0');

            elsif(load_new_addr = '1')then
                dm_address <= crnt_start_address;

            elsif(calc_new_addr = '1')then
                dm_address <= std_logic_vector(unsigned(dm_address) + unsigned(extend_crnt_stride));

            end if;
        end if;
    end process ADDRESS_CALC;

end generate VFLIP_DISABLE;
-------------------------------------------------------------------------------
-- Vertical Line Counter
-------------------------------------------------------------------------------
VERT_COUNTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                vert_count <= (others => '0');
            elsif(load_new_addr = '1')then
                vert_count <= crnt_vsize;
            elsif(write_cmnd_cmb = '1')then
                vert_count <= std_logic_vector(unsigned(vert_count) - 1);
            end if;
        end if;
    end process VERT_COUNTER;

-------------------------------------------------------------------------------
-- Horizontal Holding Register
-------------------------------------------------------------------------------
----HORZ_REGISTER : process(prmry_aclk)
----    begin
----        if(prmry_aclk'EVENT and prmry_aclk = '1')then
----            if(prmry_resetn = '0')then
----                horz_count <= (others => '0');
----            elsif(load_new_addr = '1')then
----                horz_count <= crnt_hsize;
----            end if;
----        end if;
----    end process HORZ_REGISTER;

                horz_count <= crnt_hsize;

-------------------------------------------------------------------------------
-- HSIZE Zero Error
-- If hsize is set to zero on address load then flag an internal error
-- 
-------------------------------------------------------------------------------
CHECK_ZERO_HSIZE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                zero_hsize_err  <= '0';
            elsif(load_new_addr = '1' and crnt_hsize = ZERO_HSIZE)then
                zero_hsize_err  <= '1';
            else
                zero_hsize_err  <= '0'; -- 
            end if;
        end if;
    end process CHECK_ZERO_HSIZE;

-------------------------------------------------------------------------------
-- VSIZE Zero Error
-- If vsize is set to zero on address load then flag an internal error
-- 
-------------------------------------------------------------------------------
CHECK_ZERO_VSIZE : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                zero_vsize_err  <= '0';
            elsif(load_new_addr = '1' and crnt_vsize = ZERO_VSIZE)then
                zero_vsize_err  <= '1';
            else
                zero_vsize_err  <= '0'; -- 
            end if;
        end if;
    end process CHECK_ZERO_VSIZE;

-- Drive out for register status bit setting
zero_size_err <= zero_vsize_err or zero_hsize_err;



-- For MM2S and for S2MM when not in Store-And-Forward Mode
GEN_NORMAL_DM_COMMAND : if C_EXTEND_DM_COMMAND = 0 generate
begin
    -------------------------------------------------------------------------------
    -- Build DataMover command
    -------------------------------------------------------------------------------
    -- When command by sm, drive command to cmdsts_if
    GEN_DATAMOVER_CMND : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    cmnd_wr_i  <= '0';
                    cmnd_data  <= (others => '0');

                -- Fetch SM issued a command write
                --
                -- Note: change to mode where EOF generates IOC interrupt as
                -- opposed to a IOC bit in the descriptor negated need for an
                -- EOF and IOC tag.  Given time, these two bits could be combined
                -- into 1.  Associated logic in SG engine would also need to be
                -- modified as well as in sg_if.
                elsif(write_cmnd_cmb = '1')then
                    cmnd_wr_i  <= '1';
                    cmnd_data  <=  CMD_RSVD
                                        -- Command Tag
                                        & '0'
                                        & '0'
                                        & '1'           -- modified for video
                                        & '1'           -- not used by video
                                        -- Command
                                        & dm_address    -- Calculate address
                                        & '1'           -- CMD DRR modified for video
                                        & '1'           -- CMD EOF modified for video
                                        & CMD_DSA       -- No Destination stream offset
                                        & '1'           -- Type no longer used
                                        & PAD_VALUE
                                        & horz_count;

                else
                    cmnd_wr_i  <= '0';

                end if;
            end if;
        end process GEN_DATAMOVER_CMND;
end generate GEN_NORMAL_DM_COMMAND;

-- For S2MM in Store-And-Forward Mode and DRE turned off
-- Need to set the BTT to a greater value than hsize.  This will allow
-- the indeterminate BTT mode of the datamover to not generate a bus error
-- on overflow when the hsize values are not stream data width aligned
GEN_EXTENDED_DM_COMMAND : if C_EXTEND_DM_COMMAND = 1 generate
begin
    -------------------------------------------------------------------------------
    -- Build DataMover command
    -------------------------------------------------------------------------------
    -- When command by sm, drive command to cmdsts_if
    GEN_DATAMOVER_CMND : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    cmnd_wr_i  <= '0';
                    cmnd_data  <= (others => '0');

                -- Fetch SM issued a command write
                --
                -- Note: change to mode where EOF generates IOC interrupt as
                -- opposed to a IOC bit in the descriptor negated need for an
                -- EOF and IOC tag.  Given time, these two bits could be combined
                -- into 1.  Associated logic in SG engine would also need to be
                -- modified as well as in sg_if.
                elsif(write_cmnd_cmb = '1')then
                    cmnd_wr_i  <= '1';
                    cmnd_data  <=  CMD_RSVD
                                        -- Command Tag
                                        & '0'
                                        & '0'
                                        & '1'           -- modified for video
                                        & '1'           -- not used by video
                                        -- Command
                                        & dm_address    -- Calculate address
                                        & '1'           -- CMD DRR modified for video
                                        & '1'           -- CMD EOF modified for video
                                        & CMD_DSA       -- No Destination stream offset
                                        & '1'           -- Type no longer used
                                        & ONES_PAD_VALUE -- pad with 1's - want greater than hsize btt
                                        & horz_count;

                else
                    cmnd_wr_i  <= '0';

                end if;
            end if;
        end process GEN_DATAMOVER_CMND;
end generate GEN_EXTENDED_DM_COMMAND;

-------------------------------------------------------------------------------
-- Counter for keepting track of pending commands/status in primary datamover
-- Use this to determine if primary datamover for mm2s is Idle.
-------------------------------------------------------------------------------
-- increment with each command written
count_incr  <= '1' when cmnd_wr_i = '1' and sts_received = '0'
          else '0';

-- decrement with each status received
count_decr  <= '1' when cmnd_wr_i = '0' and sts_received = '1'
          else '0';

-- count number of queued commands to keep track of what datamover is still
-- working on
CMD2STS_COUNTER : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or stop = '1' or halt = '1')then
                cmnds_queued <= (others => '0');
            elsif(count_incr = '1')then
                cmnds_queued <= std_logic_vector(unsigned(cmnds_queued(COUNTER_WIDTH - 1 downto 0)) + 1);
            elsif(count_decr = '1')then
                cmnds_queued <= std_logic_vector(unsigned(cmnds_queued(COUNTER_WIDTH - 1 downto 0)) - 1);
            end if;
        end if;
    end process CMD2STS_COUNTER;

-- Indicate status is idle when no cmnd/sts queued
sts_idle <= '1' when  cmnds_queued = ZERO_COUNT and xfers_done = '1'
            else '0';

-- 
-- For store-and-foward need to keep track of when
-- AXIS stream is actually complete (For MM2S)
GEN_DONE_FOR_SNF : if C_INCLUDE_SF = 1 generate
begin
    -- In free run then condition xfers done with a indication
    -- transfers have started.  This fixes issue with double
    -- frame sync.
    GEN_FOR_FREE_RUN : if C_USE_FSYNC = 0 generate
    begin
        REG_ALLL_XFRED : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        all_lines_xfred_d1 <= '0';
                    else
                        all_lines_xfred_d1 <= all_lines_xfred;
                    end if;
                end if;
            end process REG_ALLL_XFRED;

        all_lines_xfred_fe <= not all_lines_xfred and all_lines_xfred_d1;

        -- Flag when a transfer as started
        REG_XFRED_STARTED : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    -- at start want to be able to gen first fsync so
                    -- intially set flag to 1 so sts_idle will assert
                    -- gen first fsync
                    if(prmry_resetn = '0' or run_stop = '0')then
                        xfred_started <= '1';
                    -- when running then utilize frame_sync to clear flag
                    elsif(frame_sync = '1')then
                        xfred_started <= '0';
                    -- set flag whith each falling edge
                    elsif(all_lines_xfred_fe='1')then
                        xfred_started <= '1';
                    end if;
                end if;
            end process REG_XFRED_STARTED;

    end generate GEN_FOR_FREE_RUN;

    -- Not in free run so logic not needed
    GEN_FOR_XTERN_FSYNC : if C_USE_FSYNC = 1 generate
    begin
        xfred_started <= '1';
    end generate GEN_FOR_XTERN_FSYNC;


    xfers_done <= '1' when (xfred_started='1' and all_lines_xfred = '1')
                            or stop = '1'
                            or halt = '1'
                            or run_stop = '0' --
             else '0';

end generate GEN_DONE_FOR_SNF;

-- If store-and-foward off then do not need to keep track
GEN_DONE_NO_SNF : if C_INCLUDE_SF = 0 generate
begin
    xfers_done <= '1';
end generate GEN_DONE_NO_SNF;


-------------------------------------------------------------------------------
-- Frame Size MisMatch (
-------------------------------------------------------------------------------

-- Frame size mismatch for external frame sync
GEN_FSIZE_MISMATCH : if C_USE_FSYNC = 1 generate
begin

GEN_S2MM_MISMATCH_NON_FLUSH : if C_INCLUDE_S2MM = 1 and  C_ENABLE_FLUSH_ON_FSYNC = 0 generate
begin

    -- Frame Size Mismatch Detection - Frame size mismatch error detection to detect when
    -- VDMA channel configured for more lines than what could fit in a frame.
    FSIZE_MISMATCH : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    fsize_mismatch_err_int <= '0';
                -- frame sync occurred when not all lines transferred
--                elsif(frame_sync = '1' and all_lines_xfred = '0')then
                elsif(frame_sync = '1' and all_lasts_rcvd = '0')then
                    fsize_mismatch_err_int <= '1';
                else
                    fsize_mismatch_err_int <= '0';
                end if;
            end if;
        end process FSIZE_MISMATCH;

    fsize_mismatch_err_flag_int_d2 <= '0';
    s2mm_fsize_mismatch_err_s           <= '0';
end generate GEN_S2MM_MISMATCH_NON_FLUSH;



GEN_S2MM_MISMATCH_FLUSH_NON_SOF : if C_INCLUDE_S2MM = 1 and  C_ENABLE_FLUSH_ON_FSYNC = 1 and  C_S2MM_SOF_ENABLE = 0 generate
begin

    -- Frame Size Mismatch Detection - Frame size mismatch error detection to detect when
    -- VDMA channel configured for more lines than what could fit in a frame.
    FSIZE_MISMATCH : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    fsize_mismatch_err_int <= '0';
                -- frame sync occurred when not all lines transferred
--                elsif(frame_sync = '1' and all_lines_xfred = '0')then
                elsif(frame_sync = '1' and all_lasts_rcvd = '0')then
                    fsize_mismatch_err_int <= '1';
                else
                    fsize_mismatch_err_int <= '0';
                end if;
            end if;
        end process FSIZE_MISMATCH;

    fsize_mismatch_err_flag_int_d2 <= '0';
    s2mm_fsize_mismatch_err_s           <= '0';
end generate GEN_S2MM_MISMATCH_FLUSH_NON_SOF;


GEN_S2MM_MISMATCH_FLUSH_SOF : if C_INCLUDE_S2MM = 1  and  C_ENABLE_FLUSH_ON_FSYNC = 1 and  C_S2MM_SOF_ENABLE = 1 generate


constant ZERO_VALUE_VECT            		: std_logic_vector(255 downto 0) := (others => '0');


signal s2mm_fsync_out_m_d1            		: std_logic := '0';
signal fsize_mismatch_err_s1            	: std_logic := '0';
signal fsize_mismatch_err_s            		: std_logic := '0';
signal drop_fsync_d_pulse_gen_fsize_less_err_d1 : std_logic := '0';

begin

    -- Frame Size Mismatch Detection - Frame size mismatch error detection to detect when
    -- VDMA channel configured for more lines than what could fit in a frame.
    FSIZE_MISMATCH_STRM_FLUSH_SOF : process(scndry_aclk)
        begin
            if(scndry_aclk'EVENT and scndry_aclk='1')then
                if(scndry_resetn = '0')then
                    fsize_mismatch_err_s1 <= '0';
                -- frame sync occurred when not all lines transferred
--                elsif(frame_sync = '1' and all_lines_xfred = '0')then
                --elsif(s2mm_fsync_core = '1'  and (s2mm_strm_all_lines_rcvd = '0' or drop_fsync_d_pulse_gen_fsize_less_err = '1'))then
                elsif(s2mm_fsync_core = '1'  and s2mm_strm_all_lines_rcvd = '0')then
                    fsize_mismatch_err_s1 <= '1';
                else
                    fsize_mismatch_err_s1 <= '0';
                end if;
            end if;
        end process FSIZE_MISMATCH_STRM_FLUSH_SOF;


D1_DROP_DELAY_FSYNC : process(scndry_aclk)
    begin
        if(scndry_aclk'EVENT and scndry_aclk = '1')then
            if(scndry_resetn = '0')then
                drop_fsync_d_pulse_gen_fsize_less_err_d1  <= '0';
            else
                drop_fsync_d_pulse_gen_fsize_less_err_d1  <= drop_fsync_d_pulse_gen_fsize_less_err;
            end if;
        end if;
    end process D1_DROP_DELAY_FSYNC;



    fsize_mismatch_err_s                <= fsize_mismatch_err_s1 or drop_fsync_d_pulse_gen_fsize_less_err_d1 ;



    s2mm_fsize_mismatch_err_s           <= fsize_mismatch_err_s;


GEN_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin


----    FSIZE_MISMATCH_CDC_I_FLUSH_SOF : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_PULSE_S_P_OPEN_ENDED                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => prmry_aclk                               ,
----            prmry_resetn            => prmry_resetn                             ,
----            scndry_aclk             => scndry_aclk                              ,
----            scndry_resetn           => scndry_resetn                            ,
----            scndry_in               => fsize_mismatch_err_s                                      ,   -- Not Used
----            prmry_out               => fsize_mismatch_err_int                                     ,   -- Not Used
----            prmry_in                => '0'                         ,
----            scndry_out              =>  open                         ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE_VECT(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----

FSIZE_MISMATCH_CDC_I_FLUSH_SOF : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => scndry_aclk,
        prmry_resetn               => scndry_resetn, 
        prmry_in                   => fsize_mismatch_err_s, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => prmry_aclk, 
        scndry_resetn              => prmry_resetn,
        scndry_out                 => fsize_mismatch_err_int,
        scndry_vect_out            => open
    );



end generate GEN_FOR_ASYNC;
GEN_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin
    fsize_mismatch_err_int           <= fsize_mismatch_err_s;

end generate GEN_FOR_SYNC;

					
		D1_S2MM_FSYNC_OUT_M : process(prmry_aclk)
		    begin
		        if(prmry_aclk'EVENT and prmry_aclk = '1')then
		            if(prmry_resetn = '0')then
		                s2mm_fsync_out_m_d1  <= '0';
		            else
		                s2mm_fsync_out_m_d1  <= s2mm_fsync_out_m;
		            end if;
		        end if;
		    end process D1_S2MM_FSYNC_OUT_M;
		
	
		FSIZE_LESS_ERR_FLAG : process(prmry_aclk)
		    begin
		        if(prmry_aclk'EVENT and prmry_aclk = '1')then
		            if(prmry_resetn = '0' or s2mm_fsync_out_m_d1 = '1')then
		                fsize_mismatch_err_flag_int  <= '0';
		            elsif(fsize_mismatch_err_int = '1')then
		                fsize_mismatch_err_flag_int  <= '1';
		            end if;
		        end if;
		    end process FSIZE_LESS_ERR_FLAG;
		
				


    fsize_mismatch_err_flag_int_d2  <= fsize_mismatch_err_flag_int or fsize_mismatch_err_int;


end generate GEN_S2MM_MISMATCH_FLUSH_SOF;




GEN_MM2S_MISMATCH_NO_FLUSH_SOF : if (C_INCLUDE_MM2S = 1  and (C_ENABLE_FLUSH_ON_FSYNC = 0 or C_MM2S_SOF_ENABLE  = 0)) generate
begin


    -- Frame Size Mismatch Detection - Frame size mismatch error detection to detect when
    -- VDMA channel configured for more lines than what could fit in a frame.
    FSIZE_MISMATCH : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk='1')then
                if(prmry_resetn = '0')then
                    mm2s_fsize_mismatch_err_int <= '0';
                -- frame sync occurred when not all lines transferred
                elsif(frame_sync = '1' and all_lines_xfred = '0')then
                    mm2s_fsize_mismatch_err_int <= '1';
                else
                    mm2s_fsize_mismatch_err_int <= '0';
                end if;
            end if;
        end process FSIZE_MISMATCH;


    s2mm_fsize_mismatch_err_s           <= '0';
fsize_mismatch_err_flag_int_d2 	<= '0';
fsize_mismatch_err_int 		<= mm2s_fsize_mismatch_err_int;

end generate GEN_MM2S_MISMATCH_NO_FLUSH_SOF;


GEN_MM2S_MISMATCH_FLUSH_SOF : if (C_INCLUDE_MM2S = 1  and (C_ENABLE_FLUSH_ON_FSYNC = 1 and C_MM2S_SOF_ENABLE  = 1)) generate

signal mm2s_fsync_out_m_d1            : std_logic := '0';

begin

fsize_mismatch_err_int 		<= mm2s_fsize_mismatch_err_m;




				
		D1_MM2S_FSYNC_OUT_M : process(prmry_aclk)
		    begin
		        if(prmry_aclk'EVENT and prmry_aclk = '1')then
		            if(prmry_resetn = '0')then
		                mm2s_fsync_out_m_d1  <= '0';
		            else
		                mm2s_fsync_out_m_d1  <= mm2s_fsync_out_m;
		            end if;
		        end if;
		    end process D1_MM2S_FSYNC_OUT_M;
		

		MM2S_FSIZE_LESS_ERR_FLAG : process(prmry_aclk)
		    begin
		        if(prmry_aclk'EVENT and prmry_aclk = '1')then
		            if(prmry_resetn = '0' or mm2s_fsync_out_m_d1 = '1')then
		                fsize_mismatch_err_flag_int_d1  <= '0';
		            elsif(mm2s_fsize_mismatch_err_m = '1')then
		                fsize_mismatch_err_flag_int_d1  <= '1';
		            end if;
		        end if;
		    end process MM2S_FSIZE_LESS_ERR_FLAG;

    fsize_mismatch_err_flag_int_d2  <= fsize_mismatch_err_flag_int_d1 or mm2s_fsize_mismatch_err_m;
    s2mm_fsize_mismatch_err_s           <= '0';

end generate GEN_MM2S_MISMATCH_FLUSH_SOF;


end generate GEN_FSIZE_MISMATCH;

-- No frame size mismatch if in free run mode
GEN_NO_FSIZE_MISMATCH : if C_USE_FSYNC = 0 generate
begin
    fsize_mismatch_err_int <= '0';
    fsize_mismatch_err_flag_int_d2 <= '0';
    s2mm_fsize_mismatch_err_s           <= '0';
end generate GEN_NO_FSIZE_MISMATCH;
fsize_mismatch_err_flag <= fsize_mismatch_err_flag_int_d2;
fsize_mismatch_err <= fsize_mismatch_err_int;
end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_cmdsts_if
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_vdma_cmdsts_if.vhd
-- Description: This entity is the descriptor fetch command and status inteface
--              for the Scatter Gather Engine AXI DataMover.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_cmdsts_if is
    generic (
        C_M_AXI_ADDR_WIDTH       	: integer range 32 to 64       := 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_DM_STATUS_WIDTH               : integer               := 8;
            
            -- DataMover status width - is based on mode of operation

        C_INCLUDE_MM2S                  : integer range 0 to 1      := 1;


        C_INCLUDE_S2MM                  : integer range 0 to 1      := 1;
        --C_ENABLE_DEBUG_INFO             : string := "1111111111111111";		-- 1 to 16 -- 
        --C_ENABLE_DEBUG_INFO             : bit_vector(15 downto 0) 	:= (others => '1');		--15 downto 0  -- 
        C_ENABLE_DEBUG_ALL       : integer range 0 to 1      	:= 1;
            -- Setting this make core backward compatible to 2012.4 version in terms of ports and registers

        C_ENABLE_DEBUG_INFO_0       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 0
        C_ENABLE_DEBUG_INFO_1       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 1
        C_ENABLE_DEBUG_INFO_2       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 2
        C_ENABLE_DEBUG_INFO_3       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 3
        C_ENABLE_DEBUG_INFO_4       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 4
        C_ENABLE_DEBUG_INFO_5       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 5
        C_ENABLE_DEBUG_INFO_6       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 6
        C_ENABLE_DEBUG_INFO_7       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 7
        C_ENABLE_DEBUG_INFO_8       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 8
        C_ENABLE_DEBUG_INFO_9       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 9
        C_ENABLE_DEBUG_INFO_10      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 10
        C_ENABLE_DEBUG_INFO_11      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 11
        C_ENABLE_DEBUG_INFO_12      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 12
        C_ENABLE_DEBUG_INFO_13      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 13
        C_ENABLE_DEBUG_INFO_14      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 14
        C_ENABLE_DEBUG_INFO_15      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 15

        C_ENABLE_FLUSH_ON_FSYNC     	: integer range 0 to 1      := 0                            
            -- Specifies VDMA Flush on Frame sync enabled
            -- 0 = Disabled
            -- 1 = Enabled

    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        prmry_aclk              : in  std_logic                             ;                   --
        prmry_resetn            : in  std_logic                             ;                   --
                                                                                                --
        -- Command write interface from mm2s sm                                                 --
        cmnd_wr                 : in  std_logic                             ;                   --
        cmnd_data               : in  std_logic_vector                                          --
                                    ((C_M_AXI_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);           --
        cmnd_pending            : out std_logic                             ;                   --
        sts_received            : out std_logic                             ;                   --
        halt                    : in  std_logic                             ;                   -- 
        stop                    : in  std_logic                             ;                   --
        crnt_hsize              : in  std_logic_vector                                          --
                                    (HSIZE_DWIDTH-1 downto 0)               ;                   --
        dmasr_halt              : in  std_logic                             ;                   --
                                                                                                --
        -- User Command Interface Ports (AXI Stream)                                            --
        s_axis_cmd_tvalid       : out std_logic                             ;                   --
        s_axis_cmd_tready       : in  std_logic                             ;                   --
        s_axis_cmd_tdata        : out std_logic_vector                                          --
                                    ((C_M_AXI_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);           --
                                                                                                --
        -- User Status Interface Ports (AXI Stream)                                             --
        m_axis_sts_tvalid       : in  std_logic                             ;                   --
        m_axis_sts_tready       : out std_logic                             ;                   --
        m_axis_sts_tdata        : in  std_logic_vector                                          --
                                    (C_DM_STATUS_WIDTH-1 downto 0)          ;                   -- 
        m_axis_sts_tkeep        : in  std_logic_vector                                          --
                                    ((C_DM_STATUS_WIDTH/8)-1  downto 0)     ;                   -- 

    s2mm_fsize_more_or_sof_late : in  std_logic                         ;       --
      s2mm_dmasr_lsize_less_err : in  std_logic                         ;       --
                                                                                                --
        -- Zero Hsize and/or Vsize. mapped here to combine with interr                          --
        zero_size_err           : in  std_logic                             ;                   -- 
        -- Frame Mismatch. mapped here to combine with interr                                   --
        fsize_mismatch_err      : in  std_logic                             ;                   -- 
        lsize_mismatch_err      : out std_logic                             ;                   -- 
        lsize_more_mismatch_err : out std_logic                             ;                   -- 
       
        capture_hsize_at_uf_err :  out std_logic_vector(15 downto 0) ;
                                                                                         --
        -- Datamover status                                                                     --
        err                     : in  std_logic                             ;                   --
        done                    : out std_logic                             ;                   --
        err_o                   : out std_logic                             ;                   --
        interr_minus_frame_errors                  : out std_logic                             ;                   --
        interr                  : out std_logic                             ;                   --
        slverr                  : out std_logic                             ;                   --
        decerr                  : out std_logic                             ;                   --
        tag                     : out std_logic_vector(3 downto 0)                              --

    );

end axi_vdma_cmdsts_if;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_cmdsts_if is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- Bytes received MSB index bit
constant BRCVD_MSB_BIT 			: integer := (C_DM_STATUS_WIDTH - 2);
-- Bytes received LSB index bit
constant BRCVD_LSB_BIT 			: integer := (C_DM_STATUS_WIDTH - 2) - (BUFFER_LENGTH_WIDTH - 1);

constant PAD_HSIZE     			: std_logic_vector(22 - HSIZE_DWIDTH downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal sts_tready           		: std_logic := '0';
signal slverr_i             		: std_logic := '0';
signal decerr_i             		: std_logic := '0';
signal interr_i             		: std_logic := '0';
signal err_i              		: std_logic := '0';
signal err_or             		: std_logic := '0';
signal uf_err             		: std_logic := '0';
signal of_err             		: std_logic := '0';
signal undrflo_err   			: std_logic := '0';
signal ovrflo_err   			: std_logic := '0';
signal ext_crnt_hsize       		: std_logic_vector(22 downto 0) := (others => '0');
signal s2mm_dmasr_lsize_less_err_d1     : std_logic := '0';
signal s2mm_dmasr_lsize_less_err_fe     : std_logic := '0';


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

slverr <= slverr_i;
decerr <= decerr_i;

interr_minus_frame_errors <= interr_i or zero_size_err;

interr <= interr_i or zero_size_err
                   or fsize_mismatch_err
		   or s2mm_fsize_more_or_sof_late	;                       -- 


-- Asserted with each valid status
sts_received <= m_axis_sts_tvalid and sts_tready;

-------------------------------------------------------------------------------
-- DataMover Command Interface
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-- When command by fetch sm, drive descriptor fetch command to data mover.
-- Hold until data mover indicates ready.
-------------------------------------------------------------------------------
GEN_DATAMOVER_CMND : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or dmasr_halt = '1')then
                s_axis_cmd_tvalid  <= '0';
                s_axis_cmd_tdata   <= (others => '0');
                cmnd_pending       <= '0';
            -- New command write and not flagged as stale descriptor
            elsif(cmnd_wr = '1')then
                s_axis_cmd_tvalid  <= '1';
                s_axis_cmd_tdata   <= cmnd_data;
                cmnd_pending       <= '1';
            -- Clear flags when command excepted by datamover or halt issued to datamover and command is pending (
            elsif(s_axis_cmd_tready = '1'or halt = '1')then
                s_axis_cmd_tvalid  <= '0';
                s_axis_cmd_tdata   <= (others => '0');
                cmnd_pending       <= '0';

            end if;
        end if;
    end process GEN_DATAMOVER_CMND;

-------------------------------------------------------------------------------
-- DataMover Status Interface
-------------------------------------------------------------------------------
-- Drive ready low during reset to indicate not ready
REG_STS_READY : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                sts_tready <= '0';
            else
                sts_tready <= '1';
            end if;
        end if;
    end process REG_STS_READY;

-- Pass to DataMover
m_axis_sts_tready <= sts_tready;

-------------------------------------------------------------------------------
-- Log status bits out of data mover.
-------------------------------------------------------------------------------
DATAMOVER_STS : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                done       <= '0';
                slverr_i   <= '0';
                decerr_i   <= '0';
                interr_i   <= '0';
                tag        <= (others => '0');
            -- Status valid, therefore capture status
            elsif(m_axis_sts_tvalid = '1')then
                done       <= m_axis_sts_tdata(DATAMOVER_STS_CMDDONE_BIT);
                slverr_i   <= m_axis_sts_tdata(DATAMOVER_STS_SLVERR_BIT);
                decerr_i   <= m_axis_sts_tdata(DATAMOVER_STS_DECERR_BIT);
                interr_i   <= m_axis_sts_tdata(DATAMOVER_STS_INTERR_BIT);
                tag        <= m_axis_sts_tdata(DATAMOVER_STS_TAGMSB_BIT downto DATAMOVER_STS_TAGLSB_BIT);
            else
                done       <= '0';
                slverr_i   <= '0';
                decerr_i   <= '0';
                interr_i   <= '0';
                tag        <= (others => '0');
            end if;
        end if;
    end process DATAMOVER_STS;


-------------------------------------------------------------------------------
-- Line MisMatch Detection (Datamover underflow or overflow)
-------------------------------------------------------------------------------
-- Status is for MM2S or S2MM with Store and Forward turned OFF
-- therefore Datamover detects overflow and underflow
GEN_STS_EQL_TO_8 : if C_DM_STATUS_WIDTH = 8 generate
begin
    of_err            	<= '0';
    uf_err            	<= '0';
    undrflo_err  	<= '0';
    ovrflo_err  	<= '0';

    lsize_mismatch_err  	<= '0';
    lsize_more_mismatch_err  	<= '0';

    capture_hsize_at_uf_err   	<= (others => '0');


end generate GEN_STS_EQL_TO_8;

-- Status is for S2MM with Store and Forward turned OON (i.e. Indeterimate BTT mode)
-- therefore need to detect overflow and underflow here
GEN_STS_GRTR_THAN_8 : if C_DM_STATUS_WIDTH > 8 generate
begin

    -- Pad current hsize up to the full 23 bit BTT
    ext_crnt_hsize <= PAD_HSIZE & crnt_hsize;

    -- 
    uf_err <= '1' when m_axis_sts_tvalid = '1'
                   and  (ext_crnt_hsize /= m_axis_sts_tdata(BRCVD_MSB_BIT      -- Underflow
                                                 downto BRCVD_LSB_BIT))
           else '0';

    of_err <= '1' when m_axis_sts_tvalid = '1'
                   and  (ext_crnt_hsize = m_axis_sts_tdata(BRCVD_MSB_BIT      
                                                 downto BRCVD_LSB_BIT))
                   and  (m_axis_sts_tdata(DATAMOVER_STS_TLAST_BIT) = '0')      -- Overflow
           else '0';



GEN_CAPTURE_HSIZE_AT_LSIZE_LESS_ERR : if (C_INCLUDE_S2MM = 1  and (C_ENABLE_DEBUG_INFO_12 = 1 or C_ENABLE_DEBUG_ALL = 1)) generate
begin



S2MM_DMASR_BIT8_D1 : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                s2mm_dmasr_lsize_less_err_d1 <= '0';
            else
                s2mm_dmasr_lsize_less_err_d1 <= s2mm_dmasr_lsize_less_err;
            end if;
        end if;
    end process S2MM_DMASR_BIT8_D1;


s2mm_dmasr_lsize_less_err_fe <= s2mm_dmasr_lsize_less_err_d1 and not s2mm_dmasr_lsize_less_err;


    REG_HSIZE_AT_LSIZE_LESS_ERR : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' or s2mm_dmasr_lsize_less_err_fe = '1')then
			
			capture_hsize_at_uf_err   <= (others => '0');

		elsif (( m_axis_sts_tvalid = '1' and (ext_crnt_hsize /= m_axis_sts_tdata(BRCVD_MSB_BIT downto BRCVD_LSB_BIT))) and s2mm_dmasr_lsize_less_err = '0')then

			capture_hsize_at_uf_err   <= m_axis_sts_tdata(23 downto 8);

            	end if;
            end if;
        end process REG_HSIZE_AT_LSIZE_LESS_ERR;

end generate GEN_CAPTURE_HSIZE_AT_LSIZE_LESS_ERR;


GEN_NO_CAPTURE_HSIZE_AT_LSIZE_LESS_ERR : if (C_INCLUDE_S2MM = 0 or (C_ENABLE_DEBUG_INFO_12 = 0 and C_ENABLE_DEBUG_ALL = 0)) generate
begin

		capture_hsize_at_uf_err   <= (others => '0');

end generate GEN_NO_CAPTURE_HSIZE_AT_LSIZE_LESS_ERR;




    -- 
    -- Register and hold error
    -- 

    REG_UF_ERR : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    undrflo_err <= '0';
                -- set on underflow or overflow
                -- qualify with error already being set because on
                -- datamover shut down the byte count in the rcved status is
                -- invalid.
                -- need to qualify overflow with datamover halt
                elsif(uf_err = '1' and err_i = '0' and stop = '0' and halt = '0')then
                    undrflo_err <= '1';
                else                                            -- 
                    undrflo_err <= '0';                  -- 
                end if;
            end if;
        end process REG_UF_ERR;

    REG_OF_ERR : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    ovrflo_err <= '0';
                -- set on underflow or overflow
                -- qualify with error already being set because on
                -- datamover shut down the byte count in the rcved status is
                -- invalid.
                -- need to qualify overflow with datamover halt
                elsif(of_err = '1' and err_i = '0' and stop = '0' and halt = '0')then
                    ovrflo_err <= '1';
                else                                            -- 
                    ovrflo_err <= '0';                  -- 
                end if;
            end if;
        end process REG_OF_ERR;





    -- 
    -- pass underflow/overflow to line size mismatch for use
    -- in genlock repeat frame logic
    lsize_mismatch_err 		<= undrflo_err;
    lsize_more_mismatch_err 	<= ovrflo_err;

end generate GEN_STS_GRTR_THAN_8;

-------------------------------------------------------------------------------
-- Register global error from data mover.
-------------------------------------------------------------------------------
-- Flush On Frame Sync disabled therefore...
-- Halt channel on all errors.  Done by OR'ing all errors and using
-- to set err_i which is used in axi_vdma_mngr to assert stop.  Stop
-- will shut down channel. (
GEN_ERR_FOR_NO_FLUSH : if C_ENABLE_FLUSH_ON_FSYNC = 0 generate
begin
    err_or <= slverr_i            -- From DataMover
             or decerr_i            -- From DataMover
             or interr_i            -- From DataMover
             or zero_size_err       -- From axi_vdma_sm
             or fsize_mismatch_err;  -- From axi_vdma_sm (

end generate GEN_ERR_FOR_NO_FLUSH;

-- Flush On Frame Sync enabled therefore...
-- Halt channel on all errors except underflow and overflow (line size mismatch)
-- and frame size mismatch errors.  Shutdown is accomplished by OR'ing select errors
-- and using to set err_i which is used in axi_vdma_mngr to assert stop.  Stop
-- will shut down channel. (
GEN_ERR_FOR_FLUSH : if C_ENABLE_FLUSH_ON_FSYNC = 1 generate
begin
    err_or <= slverr_i            -- From DataMover
             or decerr_i            -- From DataMover
             or interr_i            -- From DataMover
             or zero_size_err;      -- From axi_vdma_sm

end generate GEN_ERR_FOR_FLUSH;

-- Log errors into a global error output
ERR_PROCESS : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                err_i <= '0';
            -- If Datamover issues error on the transfer or if a stale descriptor is
            -- detected when in tailpointer mode then issue an error
            elsif(err_or = '1')then
                err_i <= '1';
            end if;
        end if;
    end process ERR_PROCESS;
---- 
err_o <= err_i;

end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_sts_mngr
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_vdma_sts_mngr.vhd
-- Description: This entity mangages 'halt' and 'idle' status
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_sts_mngr is
    port (
        -- system signals
        prmry_aclk                  : in  std_logic                         ;   --
        prmry_resetn                : in  std_logic                         ;   --
                                                                                --
        -- dma control and sg engine status signals                             --
        run_stop                    : in  std_logic                         ;   --
        regdir_idle                 : in  std_logic                         ;   --
        ftch_idle                   : in  std_logic                         ;   --
        cmnd_idle                   : in  std_logic                         ;   --
        sts_idle                    : in  std_logic                         ;   --
        line_buffer_empty           : in  std_logic                         ;   --
        dwidth_fifo_pipe_empty      : in  std_logic                         ;   --
        video_prmtrs_valid          : in  std_logic                         ;   --
        prmtr_update_complete       : in  std_logic                         ;   --CR605424
                                                                                --
        -- stop and halt control/status                                         --
        stop                        : in  std_logic                         ;   --
        halt                        : in  std_logic                         ;   -- CR 625278
        halt_cmplt                  : in  std_logic                         ;   --
                                                                                --
        -- system state and control                                             --
        all_idle                    : out std_logic                         ;   --
        ftchcmdsts_idle             : out std_logic                         ;   --
        cmdsts_idle                 : out std_logic                         ;   --
        halted_clr                  : out std_logic                         ;   --
        halted_set                  : out std_logic                         ;   --
        idle_set                    : out std_logic                         ;   --
        idle_clr                    : out std_logic                             --

    );

end axi_vdma_sts_mngr;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_sts_mngr is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal all_is_idle          : std_logic := '0';
signal ftch_idle_d1         : std_logic := '0';
signal ftch_idle_re         : std_logic := '0';
signal ftch_idle_fe         : std_logic := '0';
signal datamover_idle       : std_logic := '0';
--signal cmdstsfifo_idle      : std_logic := '0';
signal halted_set_i         : std_logic := '0';
--signal datamover_idle_i     : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

-- CR573389 - modified all_idle output to look at sg engine ftch idle only
-- if video parameters are NOT valid, else ignore ftchidle.  this fixes
-- issue of xfer pausing while descriptors are being fetched.
-- all_idle only used for frame sync determination
ALL_IDLE_PROCESS : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                all_idle <= '1';

            -- Qualify all idle with sg engine fetch idle when
            -- no video parameters are valid
            elsif(video_prmtrs_valid = '0')then
                all_idle <= ftch_idle
                                and cmnd_idle
                                and sts_idle
                                and line_buffer_empty
				and dwidth_fifo_pipe_empty
                                and regdir_idle                             -- Reg Direct idle (for fsync only)
                                and prmtr_update_complete;                  -- CR605424 idle needs to account for lutram copy

            -- Otherwise if we have valid video parameters then do
            -- not stall transfers in free-run mode due to sg engine fetches
            else
                all_idle <= cmnd_idle
                                and sts_idle
				and dwidth_fifo_pipe_empty
                                and line_buffer_empty;
            end if;
        end if;
    end process ALL_IDLE_PROCESS;


-- Idle for soft_reset determination
-- Note Line buffer is not looked at because do not want to stall soft reset if external
-- stream target does not accept data from line buffer.
ftchcmdsts_idle <= ftch_idle
                  and cmnd_idle
                  and sts_idle;

-- Command/Status Idle (Used for s2mm linebuffer reset qualification on shut down)
cmdsts_idle <= cmnd_idle
            and sts_idle;


-------------------------------------------------------------------------------
-- For data mover halting look at halt complete to determine when halt
-- is done and datamover has completly halted.  If datamover not being
-- halted then can ignore flag thus simply flag as idle.
-------------------------------------------------------------------------------
-- CR 625278
--datamover_idle  <= '1' when (stop = '1' and halt_cmplt = '1')
--                         or (stop = '0')
--                   else '0';
--
-- Need to sample and hold for cases when user clears run/stop starting
-- a shutdown phase, then an error occurs (stop=1) causing a second
-- shutdown phase to start.  previous the halt complete was missed by datamove_idle
-- because stop asserted after the halt complete asserted due to the first
-- shutdown phase.
DATAMOVER_IDLE_PROCESS : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                datamover_idle <= '0';
            -- if dm being halted and halt is completed then
            -- set and hold datamover idle.
            elsif(halt = '1' and halt_cmplt = '1')then
                datamover_idle <= '1';

            -- clear datamove_idle if running and dm not
            -- being halted.
            elsif(halt = '0' and run_stop = '1')then
                datamover_idle <= '0';

            end if;
        end if;
    end process DATAMOVER_IDLE_PROCESS;


-------------------------------------------------------------------------------
-- Set halt bit if run/stop cleared and all processes are idle
-------------------------------------------------------------------------------
-- Everything is idle when everything is idle used for setting halt flag.
all_is_idle <=  ftch_idle
            and cmnd_idle
            and sts_idle
   	    and dwidth_fifo_pipe_empty
            and line_buffer_empty;

HALT_PROCESS : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                halted_set_i <= '0';

            -- DMACR.Run/Stop is cleared, all processes are idle, datamover halt cmplted
            elsif(run_stop = '0' and all_is_idle = '1' and datamover_idle = '1')then
                halted_set_i <= '1';
            else
                halted_set_i <= '0';
            end if;
        end if;
    end process HALT_PROCESS;

halted_set  <= halted_set_i;

-------------------------------------------------------------------------------
-- Clear halt bit if run/stop is set and SG engine begins to fetch descriptors
-------------------------------------------------------------------------------
NOT_HALTED_PROCESS : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                halted_clr <= '0';
            elsif(run_stop = '1')then
                halted_clr <= '1';
            else
                halted_clr <= '0';
            end if;
        end if;
    end process NOT_HALTED_PROCESS;

-------------------------------------------------------------------------------
-- Register ALL is Idle to create rising and falling edges on idle flag
-------------------------------------------------------------------------------
IDLE_REG_PROCESS : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                ftch_idle_d1 <= '0';
            else
                ftch_idle_d1 <= ftch_idle;
            end if;
        end if;
    end process IDLE_REG_PROCESS;

ftch_idle_re  <= ftch_idle and not ftch_idle_d1;
ftch_idle_fe  <= not ftch_idle and ftch_idle_d1;

-- Set or Clear IDLE bit in DMASR
idle_set <= ftch_idle_re and run_stop;
idle_clr <= ftch_idle_fe;


end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_mngr
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_mngr.vhd
-- Description: This entity is the top level entity for the AXI VDMA Controller
--              manager.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_mngr is
    generic(
        C_PRMRY_IS_ACLK_ASYNC           : integer range 0 to 1      	:= 0;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.

        C_PRMY_CMDFIFO_DEPTH        	: integer range 1 to 16        	:= 1;
            -- Depth of DataMover command FIFO

        C_INCLUDE_SF                	: integer range 0 to 1 		:= 0;
            -- Include or exclude store and forward module
            -- 0 = excluded
            -- 1 = included

        C_USE_FSYNC                     : integer range 0 to 1      	:= 0;
            -- Specifies DMA oeration synchronized to frame sync input
            -- 0 = Free running
            -- 1 = Fsync synchronous
        --C_ENABLE_DEBUG_INFO             : string := "1111111111111111";		-- 1 to 16 -- 
        --C_ENABLE_DEBUG_INFO             : bit_vector(15 downto 0) 	:= (others => '1');		--15 downto 0  -- 

        C_ENABLE_DEBUG_ALL       : integer range 0 to 1      	:= 1;
            -- Setting this make core backward compatible to 2012.4 version in terms of ports and registers
        C_ENABLE_DEBUG_INFO_0       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 0
        C_ENABLE_DEBUG_INFO_1       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 1
        C_ENABLE_DEBUG_INFO_2       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 2
        C_ENABLE_DEBUG_INFO_3       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 3
        C_ENABLE_DEBUG_INFO_4       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 4
        C_ENABLE_DEBUG_INFO_5       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 5
        C_ENABLE_DEBUG_INFO_6       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 6
        C_ENABLE_DEBUG_INFO_7       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 7
        C_ENABLE_DEBUG_INFO_8       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 8
        C_ENABLE_DEBUG_INFO_9       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 9
        C_ENABLE_DEBUG_INFO_10      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 10
        C_ENABLE_DEBUG_INFO_11      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 11
        C_ENABLE_DEBUG_INFO_12      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 12
        C_ENABLE_DEBUG_INFO_13      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 13
        C_ENABLE_DEBUG_INFO_14      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 14
        C_ENABLE_DEBUG_INFO_15      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 15


        C_ENABLE_VERT_FLIP              : integer range 0 to 1          := 0;            


        C_ENABLE_FLUSH_ON_FSYNC     	: integer range 0 to 1          := 0;           -- 
            -- Specifies VDMA Flush on Frame sync enabled
            -- 0 = Disabled
            -- 1 = Enabled

        C_NUM_FSTORES               	: integer range 1 to 32         := 1;
            -- Number of Frame Stores

        C_GENLOCK_MODE              	: integer range 0 to 3          := 0;
            -- Specifies Gen-Lock Mode of operation
            -- 0 = Master - Channel configured to be Gen-Lock Master
            -- 1 = Slave - Channel configured to be Gen-Lock Slave

        C_GENLOCK_NUM_MASTERS       	: integer range 1 to 16         := 1;
            -- Number of Gen-Lock masters capable of controlling Gen-Lock Slave

        --C_GENLOCK_REPEAT_EN        	: integer range 0 to 1      	:= 0;                -- 
            -- In flush on frame sync mode specifies whether frame number
            -- will increment on error'ed frame or repeat error'ed frame
            -- 0 = increment frame
            -- 1 = repeat frame

        -----------------------------------------------------------------------
        C_DYNAMIC_RESOLUTION           : integer range 0 to 1      	:= 1;
            -- Run time configuration of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 0 = Halt VDMA before writing new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 1 = Run time register configuration for new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE.
        -----------------------------------------------------------------------

        C_INTERNAL_GENLOCK_ENABLE   	: integer range 0 to 1          := 0;
            -- Enable internal genlock bus
            -- 0 = disable internal genlock bus
            -- 1 = enable internal genlock bus

        C_EXTEND_DM_COMMAND         	: integer range 0 to 1          := 0;
            -- Extend datamover command by padding BTT with 1's for
            -- indeterminate BTT mode

        -----------------------------------------------------------------------
        -- Scatter Gather Parameters
        -----------------------------------------------------------------------
        C_INCLUDE_SG              : integer range 0 to 1        	:= 1        ;
            -- Include or Exclude Scatter Gather Engine
            -- 0 = Exclude Scatter Gather Engine (Enables Register Direct Mode)
            -- 1 = Include Scatter Gather Engine

        C_M_AXI_SG_ADDR_WIDTH           : integer range 32 to 64    	:= 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_M_AXIS_SG_TDATA_WIDTH         : integer range 32 to 32    	:= 32;
            -- AXI Master Stream in for descriptor fetch

        -----------------------------------------------------------------------
        -- Memory Map Parameters
        -----------------------------------------------------------------------
        C_M_AXI_ADDR_WIDTH              : integer range 32 to 64    	:= 32;
            -- Master AXI Memory Map Address Width for Read Port

        C_DM_STATUS_WIDTH               : integer                   	:= 8 ;
            -- 
            -- DataMover status width - is based on mode of operation

        C_S2MM_SOF_ENABLE                : integer range 0 to 1        	:= 0;
        C_MM2S_SOF_ENABLE                : integer range 0 to 1        	:= 0;

        C_INCLUDE_MM2S                  : integer range 0 to 1      	:= 1;
            -- Include or exclude MM2S primary data path
            -- 0 = Exclude MM2S primary data path
            -- 1 = Include MM2S primary data path

        C_INCLUDE_S2MM                  : integer range 0 to 1      	:= 1;
            -- Include or exclude S2MM primary data path
            -- 0 = Exclude S2MM primary data path
            -- 1 = Include S2MM primary data path
        C_SELECT_XPM                    : integer                       := 1;
        C_FAMILY                        : string                    	:= "virtex7"
            -- Target FPGA Device Family
    );
    port (

        -- Secondary Clock and Reset
        prmry_aclk                  : in  std_logic                         ;               --
        prmry_resetn                : in  std_logic                         ;               --
        soft_reset                  : in  std_logic                         ;               --
 

        scndry_aclk                 : in  std_logic                             ;       --
        scndry_resetn               : in  std_logic                             ;       --
        vflip_mngr                  : in  std_logic                             ;       --
                                                                                        --
                                                                                           --
        -- Control and Status                                                               --
        run_stop                    : in  std_logic                         ;               --
        dmasr_halt                  : in  std_logic                         ;               --
        dmacr_repeat_en             : in  std_logic                         ;               --
        sync_enable                 : in  std_logic                         ;               --
        regdir_idle                 : in  std_logic                         ;               --
        ftch_idle                   : in  std_logic                         ;               --
        halt                        : in  std_logic                         ;               --
        halt_cmplt                  : in  std_logic                         ;               --
        halted_clr                  : out std_logic                         ;               --
        halted_set                  : out std_logic                         ;               --
        idle_set                    : out std_logic                         ;               --
        idle_clr                    : out std_logic                         ;               --
        chnl_current_frame          : out std_logic_vector
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        genlock_pair_frame          : out std_logic_vector
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --


        frame_number                : out std_logic_vector
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        new_curdesc                 : out std_logic_vector                                  --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0);                 --
        new_curdesc_wren            : out std_logic                         ;               --
        stop                        : out std_logic                         ;               --
        all_idle                    : out std_logic                         ;               --
        cmdsts_idle                 : out std_logic                         ;               --
        ftchcmdsts_idle             : out std_logic                         ;               --
        fsize_mismatch_err_flag     : out std_logic                         ;               -- 
        fsize_mismatch_err          : out std_logic                         ;               -- 
        lsize_mismatch_err          : out std_logic                         ;               -- 
        lsize_more_mismatch_err     : out std_logic                         ;               -- 
        s2mm_fsize_mismatch_err_s   : out std_logic                         ;               -- 

        mm2s_fsize_mismatch_err_s   : in std_logic                         ;               -- 
        mm2s_fsize_mismatch_err_m   : in std_logic                         ;               -- 
                                                                                            --
        -- Register direct support                                                          --
        prmtr_updt_complete         : in  std_logic                         ;               --
        reg_module_vsize            : in  std_logic_vector                                  --
                                        (VSIZE_DWIDTH-1 downto 0)           ;               --
        reg_module_hsize            : in  std_logic_vector                                  --
                                        (HSIZE_DWIDTH-1 downto 0)           ;               --
        reg_module_stride           : in  std_logic_vector                                  --
                                        (STRIDE_DWIDTH-1 downto 0)          ;               --
        reg_module_frmdly           : in  std_logic_vector                                  --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;               --
        reg_module_strt_addr        : in STARTADDR_ARRAY_TYPE                               --
                                        (0 to C_NUM_FSTORES - 1)            ;               --
        mstr_pntr_ref               : in  std_logic_vector(3 downto 0)      ;               -- (master in control)
        genlock_select              : in  std_logic                         ;               --
        frame_ptr_ref               : in  std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        frame_ptr_in                : in std_logic_vector                                   --
                                        ((C_GENLOCK_NUM_MASTERS                             --
                                        *NUM_FRM_STORE_WIDTH)-1 downto 0)   ;               --
        frame_ptr_out               : out std_logic_vector                                  --
                                        (NUM_FRM_STORE_WIDTH-1 downto 0)    ;               --
        internal_frame_ptr_in       : in  std_logic_vector                                  --
                                        (NUM_FRM_STORE_WIDTH-1 downto 0)    ;               --
                                                                                            --
        update_frmstore             : out std_logic                         ;               -- 
        frmstr_err_addr             : out std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               -- 
        valid_frame_sync            : out std_logic                         ;               --
        valid_frame_sync_cmb        : out std_logic                         ;               --
        valid_video_prmtrs          : out std_logic                         ;               --
        parameter_update            : out std_logic                         ;               --
        tailpntr_updated            : in  std_logic                         ;               --
        frame_sync                  : in  std_logic                         ;               --
        circular_prk_mode           : in  std_logic                         ;               --
        line_buffer_empty           : in  std_logic                         ;               --
        dwidth_fifo_pipe_empty           : in  std_logic                         ;               --
        crnt_vsize                  : out std_logic_vector                                  --
                                        (VSIZE_DWIDTH-1 downto 0)           ;               -- 
        num_frame_store             : in  std_logic_vector                                  --
                                        (NUM_FRM_STORE_WIDTH-1 downto 0)    ;               --
        all_lines_xfred             : in  std_logic                         ;               -- 
        all_lasts_rcvd              : in  std_logic                         ;               --
        s2mm_strm_all_lines_rcvd              : in  std_logic                         ;               --
        drop_fsync_d_pulse_gen_fsize_less_err              : in  std_logic                         ;               --
        s2mm_fsize_more_or_sof_late : in  std_logic                         ;       --

        s2mm_dmasr_lsize_less_err   : in  std_logic                         ;       --

        s2mm_fsync_core             : in  std_logic                         ;       
        s2mm_fsync_out_m            : in  std_logic                         ;       
        mm2s_fsync_out_m            : in  std_logic                         ;       
       
	capture_hsize_at_uf_err     :  out std_logic_vector(15 downto 0) ;
  
        -- Test Vector signals                                                              --
        tstvect_err                 : out std_logic                         ;               --
        tstvect_fsync               : out std_logic                         ;               --
        tstvect_frame               : out std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        tstvect_frm_ptr_out         : out std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        mstrfrm_tstsync_out         : out std_logic                         ;               --
                                                                                            --
        -- AXI Stream Signals                                                               --
        packet_sof                  : in  std_logic                         ;               --
                                                                                            --
        -- Primary DMA Errors                                                               --
        dma_interr_set_minus_frame_errors              : out std_logic                         ;               --
        dma_interr_set              : out std_logic                         ;               --
        dma_slverr_set              : out std_logic                         ;               --
        dma_decerr_set              : out std_logic                         ;               --
                                                                                            --
        -- SG Descriptor Fetch AXI Stream In                                                --
        m_axis_ftch_tdata           : in  std_logic_vector                                  --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) ;              --
        m_axis_ftch_tvalid          : in  std_logic                         ;               --
        m_axis_ftch_tready          : out std_logic                         ;               --
        m_axis_ftch_tlast           : in  std_logic                         ;               --
                                                                                            --
        -- User Command Interface Ports (AXI Stream)                                        --
        s_axis_cmd_tvalid           : out std_logic                         ;               --
        s_axis_cmd_tready           : in  std_logic                         ;               --
        s_axis_cmd_tdata            : out std_logic_vector                                  --
                                        ((C_M_AXI_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);   --
                                                                                            --
        -- User Status Interface Ports (AXI Stream)                                         --
        m_axis_sts_tvalid           : in  std_logic                         ;               --
        m_axis_sts_tready           : out std_logic                         ;               --
        m_axis_sts_tdata            : in  std_logic_vector                                  --
                                        (C_DM_STATUS_WIDTH-1 downto 0);                     -- 
        m_axis_sts_tkeep            : in  std_logic_vector                                  --
                                        ((C_DM_STATUS_WIDTH/8)-1  downto 0) ;               -- 
        err                         : in  std_logic                         ;               --
                                                                                            --
        ftch_err                    : in  std_logic                                         --
    );

end axi_vdma_mngr;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_mngr is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- Zero vector for tying off unused inputs
constant ZERO_VALUE         	: std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0) := (others => '0');


-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Primary DataMover Command signals
signal cmnd_wr                  : std_logic := '0';
signal cmnd_data                : std_logic_vector
                                            ((C_M_AXI_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0) := (others => '0');
signal cmnd_pending             : std_logic := '0';
signal sts_received             : std_logic := '0';

-- Primary DataMover Status signals
signal done                     : std_logic := '0';
signal stop_i                   : std_logic := '0';
signal interr                   : std_logic := '0';
signal interr_minus_frame_errors                   : std_logic := '0';
signal slverr                   : std_logic := '0';
signal decerr                   : std_logic := '0';
signal tag                      : std_logic_vector(3 downto 0) := (others => '0');
signal dma_err                	: std_logic := '0';
--signal error                    : std_logic := '0';
signal zero_size_err            : std_logic := '0';
signal fsize_mismatch_err_i     : std_logic := '0'; -- 
signal lsize_mismatch_err_i     : std_logic := '0'; -- 
signal lsize_more_mismatch_err_i       : std_logic := '0'; -- 
signal cmnd_idle                : std_logic := '0';
signal sts_idle                 : std_logic := '0';
signal ftch_complete            : std_logic := '0';
signal ftch_complete_clr        : std_logic := '0';
signal video_prmtrs_valid       : std_logic := '0';
signal prmtr_update_complete    : std_logic := '0'; -- 

--Descriptor video xfer parameters
signal desc_data_wren           : std_logic := '0';
signal desc_strtaddress         : std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0)  	:= (others => '0');
signal desc_vsize               : std_logic_vector(VSIZE_DWIDTH-1 downto 0)   		:= (others => '0');
signal desc_hsize               : std_logic_vector(HSIZE_DWIDTH-1 downto 0)   		:= (others => '0');
signal desc_stride              : std_logic_vector(STRIDE_DWIDTH-1 downto 0)  		:= (others => '0');
signal desc_frmdly              : std_logic_vector(FRMDLY_DWIDTH-1 downto 0)  		:= (others => '0');


-- Scatter Gather register Bank
signal crnt_vsize_i             : std_logic_vector(VSIZE_DWIDTH-1 downto 0)   		:= (others => '0'); -- 
signal crnt_hsize               : std_logic_vector(HSIZE_DWIDTH-1 downto 0)   		:= (others => '0');
signal crnt_stride              : std_logic_vector(STRIDE_DWIDTH-1 downto 0)  		:= (others => '0');
signal crnt_frmdly              : std_logic_vector(FRMDLY_DWIDTH-1 downto 0)  		:= (others => '0');
signal crnt_start_address       : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0)	:= (others => '0');


signal frame_number_i           : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  	:= (others => '0');
signal mstr_frame_ref_in        : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  	:= (others => '0');
signal slv_frame_ref_out        : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  	:= (others => '0');
signal valid_frame_sync_i       : std_logic := '0';
signal valid_frame_sync_d2      : std_logic := '0';
signal initial_frame            : std_logic := '0';
signal tstvect_fsync_d1         : std_logic := '0';
signal tstvect_fsync_d2         : std_logic := '0';
signal repeat_frame             : std_logic := '0'; -- 
signal repeat_frame_nmbr        : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  	:= (others => '0'); -- 
signal s_h_frame_number         : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  	:= (others => '0'); -- 
signal dm_prev_frame_number     : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  	:= (others => '0'); -- 
signal all_idle_d1              : std_logic := '0'; -- 
signal all_idle_re              : std_logic := '0'; -- 
signal all_idle_i               : std_logic := '0'; -- 
signal late_idle                : std_logic := '0'; -- 

signal frame_sync_d1            : std_logic := '0';
signal frame_sync_d2            : std_logic := '0';

signal err_d1                 	: std_logic := '0';



-- Dynamic frame store support
signal num_fstore_minus1_cmb    : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0) 	:= (others => '0');
signal num_fstore_minus1        : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal num_fstore_equal_one     : std_logic 						:= '0';
signal fsize_mismatch_err_flag_i     : std_logic 					:= '0';
signal flag_to_repeat_after_fsize_less_err     : std_logic 				:= '0'; 

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

fsize_mismatch_err_flag      <= fsize_mismatch_err_flag_i ;




-- Number of fstore value set in register is 0x01.
num_fstore_equal_one <= '1' when num_fstore_minus1 = ZERO_VALUE(FRAME_NUMBER_WIDTH-1 downto 0)
                   else '0';



-- Pass errors to register module
dma_interr_set      <= interr ;
dma_interr_set_minus_frame_errors      <= interr_minus_frame_errors ;
dma_slverr_set      <= slverr ;
dma_decerr_set      <= decerr ;

-- Route out to map to reset module for halt/recover of datamover
fsize_mismatch_err  <= fsize_mismatch_err_i;    -- 
lsize_mismatch_err  <= lsize_mismatch_err_i;    -- 
lsize_more_mismatch_err  <= lsize_more_mismatch_err_i;    -- 

-- Pass current vertical size out for line tracking in linebuffers
crnt_vsize          <= crnt_vsize_i; -- 

-- Pass out to allow masking of fsync_out when parameters are not valid.
valid_video_prmtrs  <= video_prmtrs_valid;

all_idle            <= all_idle_i;  -- 

--*****************************************************************************
-- Frame sync for incrementing frame_number.  This sync is qualified with
-- video parameter valid to prevent incrementing frame_number on first frame.
-- So valid_frame_sync will assert after first frame and then every frame
-- after that.
--*****************************************************************************
-- Qualify frame sync with valid parameters to allow for
-- clean video startup
valid_frame_sync_i <= frame_sync and video_prmtrs_valid;

--*****************************************************************************
-- Frame Sync For Masking FSync OUT when shutting down channel for
-- FrmCntEn Mode and frame count reached. (cannot move in time)
--*****************************************************************************
-- Pass combinatorial version for frame_count enable masking in axi_vdma_fsync_gen.
valid_frame_sync_cmb    <= valid_frame_sync_i;


--*****************************************************************************
-- INTIAL Frame Flag
-- Used to keep frame_number at Zero for intial frame
--*****************************************************************************

-- Flag used for intializing frame number to 0.  Will
-- hold frame number at 0 until a valid frame sync
-- occurs.
REG_INITIAL_FRAME_FLAG : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or dmasr_halt = '1')then
                initial_frame  <= '0';
            elsif(frame_sync = '1')then
                initial_frame  <= '1';
            end if;
        end if;
    end process REG_INITIAL_FRAME_FLAG;


--*****************************************************************************
-- Frame Store Error Address (
--  Frame number currently being operated on from a memory map perspective.
--  Needed because axi stream can complete significanly prior to memory map
--  completion on S2MM writes allowing for an external fsync to be seen before
--  all status is returned from datamover.  This memory mapped based frame
--  number allows the correct frame store pointer to be updated to the
--  PARK_PTR_REF register during error events.
--*****************************************************************************
GEN_FRMSTORE_EXTFSYNC : if C_USE_FSYNC = 1 generate
begin
    -- Register all idle to generate re pulse for error frame store process
    REG_IDLE_RE : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' )then
                    all_idle_d1 <= '0';
                else
                    all_idle_d1 <= all_idle_i;
                end if;
            end if;
        end process REG_IDLE_RE;

        all_idle_re <= all_idle_i and not all_idle_d1;

    -- Case 2: Fsync asserts before Idle
    -- If this case and not case 3 (below) then do not sample
    -- frame_number but use s_h_frame_number.
    LATE_IDLE_CASE : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' or all_idle_re = '1' or video_prmtrs_valid = '0')then
                    late_idle <= '0';
                elsif(frame_sync = '1' and all_idle_i = '0')then
                    late_idle <= '1';
                end if;
            end if;
        end process LATE_IDLE_CASE;

    -- Sample and hold frame number for special "late idle" case
    -- i.e. when memory map write does not complete before external
    -- fsync in asserts
    S_H_FRAME : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    s_h_frame_number <= (others => '0');
                elsif(frame_sync = '1')then
                    s_h_frame_number <= frame_number_i;
                end if;
            end if;
        end process S_H_FRAME;

    -- Sample current frame.  If normal fsync to idle relationship
    -- then pass frame_number.  If idle occurs after fsync then
    -- pass sample-n-held frame number.
----    REG_FRMSTORE_FRAME : process(prmry_aclk)
----        begin
----            if(prmry_aclk'EVENT and prmry_aclk = '1')then
----                -- Reset on reset and also on error delayed 1 to prevent re-assertion on transient
----                -- conditions causing wrong error frame to be logged.
----                --if(prmry_resetn = '0' or zero_size_err_d1 = '1')then
----                if(prmry_resetn = '0')then
----                    frmstr_err_addr <= (others => '0');
----                    update_frmstore   <= '0';
----
----                -- On frame size mismatch, late idle will be asserted and need
----                -- to latch in last frame (i.e. sample and held frame) into
----                -- the frame store register.
----                elsif(late_idle = '1' and fsize_mismatch_err_i = '1')then
----                    frmstr_err_addr <= s_h_frame_number;
----                    update_frmstore   <= '1';
----
----                -- 
----                -- needed because these two errors are detected at the completion
----                -- of a frame
----                --elsif(zero_size_err_re = '1')then
----                elsif(zero_size_err = '1' or fsize_mismatch_err_i = '1')then
----                    frmstr_err_addr <= frame_number_i;
----                    update_frmstore   <= '1';
----
----                -- Not in Park mode and Idle occurs after fsync therefore
----                -- pass sample-n-held frm number
----                -- 
----                --elsif(late_idle = '1' and all_idle_re = '1')then
----                elsif(late_idle = '1' and all_idle_re = '1' and circular_prk_mode = '1')then
----                    frmstr_err_addr <= s_h_frame_number;
----                    update_frmstore   <= '1';
----
----                -- On idle assertion latch current frame number
----                -- 
----                --elsif(all_idle_re = '1')then
----                elsif(all_idle_re = '1' or circular_prk_mode = '0')then
----                    frmstr_err_addr <= frame_number_i;
----                    update_frmstore   <= '1';
----                --else
----                --    update_frmstore   <= '0';
----                end if;
----            end if;
----        end process REG_FRMSTORE_FRAME;

    frmstr_err_addr <= frame_number_i;
    update_frmstore   <= '1';
end generate GEN_FRMSTORE_EXTFSYNC;

-- If configured for internal fsync then can simply pass
-- frame number to framestore value.
GEN_FRMSTORE_INTFSYNC : if C_USE_FSYNC = 0 generate
begin
    frmstr_err_addr <= frame_number_i;
    update_frmstore   <= '1';
    s_h_frame_number <= (others => '0');
end generate GEN_FRMSTORE_INTFSYNC;


--*****************************************************************************
-- Dynamic Frame Store Support
--*****************************************************************************
-- One less than setting of number of frame stores.  Use for reverse
-- flag toggle
num_fstore_minus1_cmb <= std_logic_vector(unsigned(num_frame_store) - 1);

REG_NUM_FSTR_MINUS1 : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                num_fstore_minus1 <= (others =>'0');
            else
                num_fstore_minus1 <= num_fstore_minus1_cmb(FRAME_NUMBER_WIDTH-1 downto 0);
            end if;
        end if;
    end process REG_NUM_FSTR_MINUS1;
--*****************************************************************************
-- Dynamic GenLock Slave Mode
--*****************************************************************************


-- Frame counter for Dynamic GenLock Slave Mode


DYNAMIC_SLAVE_MODE_FRAME_CNT : if C_GENLOCK_MODE = 3 generate
signal reg_frame_number_ds    : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  := (others => '0');
signal rst_to_frame_zero        : std_logic := '0';
signal valid_frame_sync_d1      : std_logic := '0';
--signal valid_frame_sync_d2      : std_logic := '0';
begin

	flag_to_repeat_after_fsize_less_err  <= '0';
    -- Register qualified frame sync (i.e. valid parameters and frame_sync)
    -- for use in IOC Threshold count wr to hold counter at intial
    -- value until after first frame.  This is done in axi_vdma_reg_module.vhd
    DS_REG_VALID_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    valid_frame_sync    <= '0';
                    valid_frame_sync_d1 <= '0';
                    valid_frame_sync_d2 <= '0';
                else
                    valid_frame_sync_d1 <= valid_frame_sync_i;
                    valid_frame_sync_d2 <= valid_frame_sync_d1;
                    valid_frame_sync    <= valid_frame_sync_d2;
                end if;
            end if;
        end process DS_REG_VALID_FSYNC_OUT;

    -- Frame sync for test vector, delay counter, and threshold counter
    -- Register test vector signals out.  Also used for
    -- delay timer and threshold counter.
    -- Mask with valid video parameters to prevent delay counter
    -- from counting at start up for external fsyncs that can
    -- be coming in long before starting.
    -- Note: tstvect_fsync output needs to be aligned exactly
    -- with valid_frame_sync output for use in register module to
    -- reset threshold counter on first frame but not on subsequent
    -- frames.
    -- coverage off
    DS_PROCESS_TSTVECTOR_REG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    tstvect_fsync_d1    <= '0';
                    tstvect_fsync_d2    <= '0';
                    tstvect_fsync       <= '0';
                else
                    tstvect_fsync_d1    <= frame_sync;
                    tstvect_fsync_d2    <= tstvect_fsync_d1;
                    tstvect_fsync       <= tstvect_fsync_d2
                                            and video_prmtrs_valid;

                end if;
            end if;
        end process DS_PROCESS_TSTVECTOR_REG;
    -- coverage on

    -- Pass frame number out for test vector
    -- used in verification only
    
--tstvect_frame   <= frame_number_i;

    -- coverage off
    DS_TSTVECT_FRM_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frame <= (others => '0');
                    	elsif (dmasr_halt = '0') then
            			tstvect_frame <= frame_number_i;
                    	--else 
            		--	tstvect_frame <= tstvect_frame;
                    	end if;
                    end if;

        end process DS_TSTVECT_FRM_OUT;

    -- coverage on

    -- Calculate frame to work on based on frame delay
    DS_GEN_FSTORE_GRTR_ONE : if C_NUM_FSTORES > 1 generate
    begin

        -- Register to break long timing paths
        DS_REG_EXT_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        reg_frame_number_ds <= (others => '0');
                    else 
                        reg_frame_number_ds <= slv_frame_ref_out;
                    end if;
                end if;
            end process DS_REG_EXT_FRM_NUMBER;

    end generate DS_GEN_FSTORE_GRTR_ONE;

    DS_GEN_FSTORE_EQL_ONE : if C_NUM_FSTORES = 1 generate
    begin
        reg_frame_number_ds <= slv_frame_ref_out;

    end generate DS_GEN_FSTORE_EQL_ONE;

    --*************************************************************************
    --** VERIFICATION ONLY RTL
    --*************************************************************************
    -- coverage off
   -- TSTVECT_FTPTR_OUT : process(reg_frame_number_ds)
    DS_TSTVECT_FTPTR_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frm_ptr_out <= (others => '0');
                    	elsif (dmasr_halt = '0') then
            			tstvect_frm_ptr_out <= reg_frame_number_ds(FRAME_NUMBER_WIDTH-1 downto 0);
			--else 
				--tstvect_frm_ptr_out <= tstvect_frm_ptr_out;
                    	end if;
                    end if;

        end process DS_TSTVECT_FTPTR_OUT;

    -- coverage on
    --*************************************************************************
    --** END VERIFICATION ONLY RTL
    --*************************************************************************

    -------------------------------------------------------------------------------
    -- Include State Machine and support logic
    -------------------------------------------------------------------------------
    rst_to_frame_zero <= '1' when (dmasr_halt = '1')
                               or (initial_frame = '0' and sync_enable = '0' and circular_prk_mode = '1')
                    else '0';

    -- 
    -- Delay fsync 2 pipeline stages to allow crnt_frmdly to propogate to
    -- the correct value for frame_number_i sampling for genlock slave mode
    DS_REG_DELAY_FSYNC : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    frame_sync_d1 <= '0';
                    frame_sync_d2 <= '0';
                else
                    frame_sync_d1 <= frame_sync;
                    frame_sync_d2 <= frame_sync_d1;
                end if;
            end if;
        end process DS_REG_DELAY_FSYNC;

    -- Frame Number generation
    DS_REG_FRAME_COUNT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear at reset or stopped or first valid fsync not occured
                if(prmry_resetn = '0' or rst_to_frame_zero = '1')then
                    frame_number_i <= (others => '0');

                -- GenLock Mode and Not in Park Mode (i.e. in tail ptr mode)
                -- elsif(valid_frame_sync_i = '1' and sync_enable = '1' and circular_prk_mode = '1')then
                -- latch with frame_sync when doing gen lock to proper capture initial frame ptr in.
                -- 
                --elsif(frame_sync = '1' and sync_enable = '1' and circular_prk_mode = '1')then
 
               --elsif(frame_sync_d2 = '1' and sync_enable = '1' and circular_prk_mode = '1')then



                --elsif(fsize_mismatch_err_flag_i= '1')then
                elsif(flag_to_repeat_after_fsize_less_err= '1')then
                        frame_number_i <= frame_number_i;



                elsif(valid_frame_sync_d2 = '1' and sync_enable = '1' and circular_prk_mode = '1')then
                        frame_number_i <= reg_frame_number_ds(FRAME_NUMBER_WIDTH-1 downto 0);

                -- Otherwise all other changes are on frame sync boudnary.
                elsif(valid_frame_sync_d2 = '1')then
                    -- If Park is enabled
                    if(circular_prk_mode = '0')then
                        frame_number_i  <= frame_ptr_ref;
                    -- Frame count reached terminal count therefore roll count over
                    --elsif(frame_number_i = FRAME_NUMBER_TC)then
                    elsif(frame_number_i = num_fstore_minus1)then
                        frame_number_i <= (others => '0');
                    -- Increment frame count with each sync if valid prmtr values
                    -- stored.
                    else
                        frame_number_i <= std_logic_vector(unsigned(frame_number_i) + 1);
                    end if;

                end if;
            end if;
        end process DS_REG_FRAME_COUNT;

    frame_number <= frame_number_i;


--pass Dynamic Genlock Slave's current working frame number for grey encoding and then output

mstr_frame_ref_in <= frame_number_i;


        REG_CURR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        chnl_current_frame <= (others => '0');
                    else 
                        chnl_current_frame <= frame_number_i;
                    end if;
                end if;
            end process REG_CURR_FRM_NUMBER;

----chnl_current_frame <= frame_number_i;
----genlock_pair_frame <= slv_frame_ref_out;

        REG_PAIR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        genlock_pair_frame <= (others => '0');
                    else 
                        genlock_pair_frame <= slv_frame_ref_out;
                    end if;
                end if;
            end process REG_PAIR_FRM_NUMBER;


end generate DYNAMIC_SLAVE_MODE_FRAME_CNT;





--*****************************************************************************
-- GEN-LOCK Slave Mode
--*****************************************************************************
-- Frame counter for Gen-Lock Slave Mode
SLAVE_MODE_FRAME_CNT : if C_GENLOCK_MODE = 1 generate
constant ONE_FSTORE             : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0)
                                    := std_logic_vector(to_unsigned(1,NUM_FRM_STORE_WIDTH));
signal ext_frame_number_grtr    : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal ext_frame_number_lesr    : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal reg_frame_number_grtr    : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal reg_frame_number_lesr    : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal ext_slv_frmref           : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal ext_crnt_frmdly          : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal ext_num_fstore           : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal rst_to_frame_zero        : std_logic := '0';
signal valid_frame_sync_d1      : std_logic := '0';
--signal valid_frame_sync_d2      : std_logic := '0';
begin
	flag_to_repeat_after_fsize_less_err  <= '0';

    -- Register qualified frame sync (i.e. valid parameters and frame_sync)
    -- for use in IOC Threshold count wr to hold counter at intial
    -- value until after first frame.  This is done in axi_vdma_reg_module.vhd
    S_REG_VALID_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    valid_frame_sync    <= '0';
                    valid_frame_sync_d1 <= '0';
                    valid_frame_sync_d2 <= '0';
                else
                    valid_frame_sync_d1 <= valid_frame_sync_i;
                    valid_frame_sync_d2 <= valid_frame_sync_d1;
                    valid_frame_sync    <= valid_frame_sync_d2;
                end if;
            end if;
        end process S_REG_VALID_FSYNC_OUT;

    -- Frame sync for test vector, delay counter, and threshold counter
    -- Register test vector signals out.  Also used for
    -- delay timer and threshold counter.
    -- Mask with valid video parameters to prevent delay counter
    -- from counting at start up for external fsyncs that can
    -- be coming in long before starting.
    -- Note: tstvect_fsync output needs to be aligned exactly
    -- with valid_frame_sync output for use in register module to
    -- reset threshold counter on first frame but not on subsequent
    -- frames.
    S_PROCESS_TSTVECTOR_REG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    tstvect_fsync_d1    <= '0';
                    tstvect_fsync_d2    <= '0';
                    tstvect_fsync       <= '0';
                else
                    tstvect_fsync_d1    <= frame_sync;
                    tstvect_fsync_d2    <= tstvect_fsync_d1;
                    tstvect_fsync       <= tstvect_fsync_d2
                                            and video_prmtrs_valid;

                end if;
            end if;
        end process S_PROCESS_TSTVECTOR_REG;

    -- Pass frame number out for test vector
    -- used in verification only
    --tstvect_frame   <= frame_number_i;
    -- coverage off
    S_TSTVECT_FRM_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frame <= (others => '0');
                    	elsif (dmasr_halt = '0') then
            			tstvect_frame <= frame_number_i;
                    	--else 
            		--	tstvect_frame <= tstvect_frame;
                    	end if;
                    end if;

        end process S_TSTVECT_FRM_OUT;
    -- coverage on



    -- Calculate frame to work on based on frame delay
    GEN_FSTORE_GRTR_ONE : if C_NUM_FSTORES > 1 generate
    begin
        -- Extend unsigned vectors by 1 bit to allow for
        -- carry out during addition.
        --ext_slv_frmref  <= '0' & slv_frame_ref_out;
        --ext_crnt_frmdly <= '0' & crnt_frmdly;
        ext_slv_frmref  <= "00" & slv_frame_ref_out;
        ext_crnt_frmdly <= "00" & crnt_frmdly;
        ext_num_fstore  <= '0' & num_frame_store;

        -- Calculate for when frame delay less than or equal to slave frame ref. This is
        -- normal operation where a simple subtraction of frame delay from slave frame ref
        -- will work.
        ext_frame_number_lesr <= std_logic_vector(unsigned(ext_slv_frmref)
                                                    - unsigned(ext_crnt_frmdly));

        -- Calculate for when frame delay greater than slave frame ref.  This is roll-over
        -- point, i.e. if slave frame ref = 0 then you want frame number to be C_NUM_FSTORES-1
        -- This can be calculated with (C_NUM_FSTORES + Slave Frame Ref) - Frame Delay
        --ext_frame_number_grtr  <= std_logic_vector( (C_NUM_FSTORES + unsigned(ext_slv_frmref))
        --                                            - unsigned(ext_crnt_frmdly));
        ext_frame_number_grtr  <= std_logic_vector( (unsigned(ext_num_fstore) + unsigned(ext_slv_frmref))
                                                    - unsigned(ext_crnt_frmdly));


        -- Register to break long timing paths
        REG_EXT_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        reg_frame_number_grtr <= (others => '0');
                        reg_frame_number_lesr <= (others => '0');

                    -- If frame stores set to 1 then simply pass unmodified version
                    -- through
                    elsif(num_frame_store = ONE_FSTORE)then
                        reg_frame_number_grtr <= ext_slv_frmref;
                        reg_frame_number_lesr <= ext_slv_frmref;

                    else
                        reg_frame_number_grtr <= ext_frame_number_grtr;
                        reg_frame_number_lesr <= ext_frame_number_lesr;
                    end if;
                end if;
            end process REG_EXT_FRM_NUMBER;

    end generate GEN_FSTORE_GRTR_ONE;

    -- For frame stores = 1 then frame delay has no meaning.
    GEN_FSTORE_EQL_ONE : if C_NUM_FSTORES = 1 generate
    begin
        reg_frame_number_grtr <= ext_slv_frmref;
        reg_frame_number_lesr <= ext_slv_frmref;

    end generate GEN_FSTORE_EQL_ONE;

    --*************************************************************************
    --** VERIFICATION ONLY RTL
    --*************************************************************************
    -- coverage off
----    TSTVECT_FTPTR_OUT : process(crnt_frmdly,
----                                slv_frame_ref_out,
----                                reg_frame_number_lesr,
----                                reg_frame_number_grtr)
----        begin
----            if(crnt_frmdly <= slv_frame_ref_out)then
----                tstvect_frm_ptr_out <= reg_frame_number_lesr(FRAME_NUMBER_WIDTH-1 downto 0);
----            else
----                tstvect_frm_ptr_out <= reg_frame_number_grtr(FRAME_NUMBER_WIDTH-1 downto 0);
----            end if;
----        end process TSTVECT_FTPTR_OUT;


    S_TSTVECT_FTPTR_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frm_ptr_out <= (others => '0');
                    	elsif (dmasr_halt = '0') then
		            if(crnt_frmdly <= slv_frame_ref_out)then
		                tstvect_frm_ptr_out <= reg_frame_number_lesr(FRAME_NUMBER_WIDTH-1 downto 0);
		            else
		                tstvect_frm_ptr_out <= reg_frame_number_grtr(FRAME_NUMBER_WIDTH-1 downto 0);
		            end if;
			--else 
				--tstvect_frm_ptr_out <= tstvect_frm_ptr_out;
                    	end if;
                    end if;

        end process S_TSTVECT_FTPTR_OUT;



    -- coverage on
    --*************************************************************************
    --** END VERIFICATION ONLY RTL
    --*************************************************************************

    -------------------------------------------------------------------------------
    -- Include State Machine and support logic
    -------------------------------------------------------------------------------
    rst_to_frame_zero <= '1' when (dmasr_halt = '1')
                               or (initial_frame = '0' and sync_enable = '0' and circular_prk_mode = '1')
                    else '0';

    -- 
    -- Delay fsync 2 pipeline stages to allow crnt_frmdly to propogate to
    -- the correct value for frame_number_i sampling for genlock slave mode
    REG_DELAY_FSYNC : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    frame_sync_d1 <= '0';
                    frame_sync_d2 <= '0';
                else
                    frame_sync_d1 <= frame_sync;
                    frame_sync_d2 <= frame_sync_d1;
                end if;
            end if;
        end process REG_DELAY_FSYNC;

    -- Frame Number generation
    REG_FRAME_COUNT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear at reset or stopped or first valid fsync not occured
                if(prmry_resetn = '0' or rst_to_frame_zero = '1')then
                    frame_number_i <= (others => '0');

                -- GenLock Mode and Not in Park Mode (i.e. in tail ptr mode)
                -- elsif(valid_frame_sync_i = '1' and sync_enable = '1' and circular_prk_mode = '1')then
                -- latch with frame_sync when doing gen lock to proper capture initial frame ptr in.
                -- 
                --elsif(frame_sync = '1' and sync_enable = '1' and circular_prk_mode = '1')then


                --elsif(fsize_mismatch_err_flag_i= '1')then
                elsif(flag_to_repeat_after_fsize_less_err= '1')then
                        frame_number_i <= frame_number_i;


                elsif(frame_sync_d2 = '1' and sync_enable = '1' and circular_prk_mode = '1')then
                    -- If frame delay less than or equal slave frame reference
                    -- then simply subtract
                    if(crnt_frmdly <= slv_frame_ref_out)then
                        frame_number_i <= reg_frame_number_lesr(FRAME_NUMBER_WIDTH-1 downto 0);
                    else
                        frame_number_i <= reg_frame_number_grtr(FRAME_NUMBER_WIDTH-1 downto 0);
                    end if;

                -- Otherwise all other changes are on frame sync boudnary.
                elsif(valid_frame_sync_d2 = '1')then
                    -- If Park is enabled
                    if(circular_prk_mode = '0')then
                        frame_number_i  <= frame_ptr_ref;
                    -- Frame count reached terminal count therefore roll count over
                    --elsif(frame_number_i = FRAME_NUMBER_TC)then
                    elsif(frame_number_i = num_fstore_minus1)then
                        frame_number_i <= (others => '0');
                    -- Increment frame count with each sync if valid prmtr values
                    -- stored.
                    else
                        frame_number_i <= std_logic_vector(unsigned(frame_number_i) + 1);
                    end if;

                end if;
            end if;
        end process REG_FRAME_COUNT;

    frame_number <= frame_number_i;

    
--pass Genlock Slave's current working frame number for grey encoding and then output -- 
--mstr_frame_ref_in <= (others =>  '0'); -- Not Used in Slave Mode

mstr_frame_ref_in <= frame_number_i;   -- 





        REG_CURR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        chnl_current_frame <= (others => '0');
                    else 
                        chnl_current_frame <= frame_number_i;
                    end if;
                end if;
            end process REG_CURR_FRM_NUMBER;

----chnl_current_frame <= frame_number_i;
----genlock_pair_frame <= slv_frame_ref_out;

        REG_PAIR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        genlock_pair_frame <= (others => '0');
                    else 
                        genlock_pair_frame <= slv_frame_ref_out;
                    end if;
                end if;
            end process REG_PAIR_FRM_NUMBER;



end generate SLAVE_MODE_FRAME_CNT;

--*****************************************************************************
-- Dynamic GenLock Master Mode
--*****************************************************************************
-- Frame counter for Gen-Lock Master Mode
DYNAMIC_MASTER_MODE_FRAME_CNT : if C_GENLOCK_MODE = 2 generate
signal valid_frame_sync_d1      		 : std_logic := '0';
--signal flag_to_repeat_after_fsize_less_err     : std_logic := '0'; 
--signal valid_frame_sync_d2      : std_logic := '0';
begin


    -- Register qualified frame sync (i.e. valid parameters and frame_sync)
    -- for use in IOC Threshold count wr to hold counter at intial
    -- value until after first frame.  This is done in axi_vdma_reg_module.vhd
    DM_REG_VALID_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    valid_frame_sync    <= '0';
                    valid_frame_sync_d1 <= '0';
                    valid_frame_sync_d2 <= '0';
                else
                    valid_frame_sync_d1 <= valid_frame_sync_i;
                    valid_frame_sync_d2 <= valid_frame_sync_d1;
                    valid_frame_sync    <= valid_frame_sync_d2;
                end if;
            end if;
        end process DM_REG_VALID_FSYNC_OUT;

    -- Frame sync for test vector, delay counter, and threshold counter
    -- Register test vector signals out.  Also used for
    -- delay timer and threshold counter.
 ----   DM_PROCESS_TSTVECTOR_REG : process(prmry_aclk)
 ----       begin
 ----           if(prmry_aclk'EVENT and prmry_aclk = '1')then
 ----               if(prmry_resetn = '0')then
 ----                   tstvect_fsync_d1<= '0';
 ----                   tstvect_fsync_d2<= '0';
 ----                   tstvect_frame   <= (others => '0');
 ----               else
 ----                   tstvect_fsync_d1<= frame_sync;
 ----                   tstvect_fsync_d2<= tstvect_fsync_d1;
 ----                   tstvect_frame   <= frame_number_i;
 ----               end if;
 ----           end if;
 ----       end process DM_PROCESS_TSTVECTOR_REG;
    -- coverage off
    DM_PROCESS_TSTVECTOR_REG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    tstvect_fsync_d1    <= '0';
                    tstvect_fsync_d2    <= '0';
                    tstvect_fsync       <= '0';
                else
                    tstvect_fsync_d1    <= frame_sync;
                    tstvect_fsync_d2    <= tstvect_fsync_d1;
                    tstvect_fsync       <= tstvect_fsync_d2
                                            and video_prmtrs_valid;

                end if;
            end if;
        end process DM_PROCESS_TSTVECTOR_REG;
    DM_TSTVECT_FRM_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frame <= (others => '0');
                    	elsif (dmasr_halt = '0') then
            			tstvect_frame <= frame_number_i;
                    	--else 
            		--	tstvect_frame <= tstvect_frame;
                    	end if;
                    end if;

        end process DM_TSTVECT_FRM_OUT;
    -- coverage on


    -- Mask with valid video parameters to prevent delay counter
    -- from counting at start up for external fsyncs that can
    -- be coming in long before starting.
    -- video_prmtrs_valid asserts on clock cycle following assertion
    -- of frame_sync, thus pipeline delay to create tstvect_fsync_d1
    -- is required to assert first fsync for first valid frame
    -- Note: tstvect_fsync output needs to be aligned exactly
    -- with valid_frame_sync output for use in register module to
    -- reset threshold counter on first frame but not on subsequent
    -- frames.
    --tstvect_fsync <= tstvect_fsync_d1 and video_prmtrs_valid;
    --tstvect_fsync <= tstvect_fsync_d2 and video_prmtrs_valid;

    DM_GEN_FSTORE_GRTR_TWO : if C_NUM_FSTORES > 2 generate
    begin
    -------------------------------------------------------------------------------
    -- Include State Machine and support logic
    -------------------------------------------------------------------------------
    -- Frame Number generation
    DM_REG_FRAME_COUNT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear at reset or stopped or first valid fsync not occured
                if(prmry_resetn = '0' or dmasr_halt = '1'
                or (circular_prk_mode = '1' and initial_frame = '0') or num_fstore_equal_one = '1')then

                    frame_number_i <= (others => '0');
                -- If Park is enabled then on frame sync transision to
                -- frame pointer reference.



                --elsif(fsize_mismatch_err_flag_i= '1')then
                elsif(flag_to_repeat_after_fsize_less_err= '1')then
                        frame_number_i <= frame_number_i;




                elsif(valid_frame_sync_d2 = '1' and circular_prk_mode = '0')then
                    frame_number_i <= frame_ptr_ref;
------------------------------------------------------------------------------------------------------------
                -- On Repeat Frame simply hold current frame number (
                --elsif(repeat_frame = '1')then
                elsif(repeat_frame = '1' and dmacr_repeat_en = '1')then
                    frame_number_i <= repeat_frame_nmbr;
------------------------------------------------------------------------------------------------------------
                -- Frame count reached terminal count therefore roll count over
                --elsif(valid_frame_sync_i = '1' and frame_number_i = FRAME_NUMBER_TC)then
                elsif(valid_frame_sync_d2 = '1'  and sync_enable = '1' and frame_number_i = num_fstore_minus1 and (slv_frame_ref_out /= "00000"))then
                    frame_number_i <= (others => '0');
  
                elsif(valid_frame_sync_d2 = '1'  and sync_enable = '1' and frame_number_i = num_fstore_minus1 and (slv_frame_ref_out = "00000"))then
                    frame_number_i <= "00001";
                elsif(valid_frame_sync_d2 = '1'  and sync_enable = '1' and slv_frame_ref_out = num_fstore_minus1 and (frame_number_i = std_logic_vector(unsigned(slv_frame_ref_out) - 1)))then
                    frame_number_i <= (others => '0');

                elsif(valid_frame_sync_d2 = '1'  and sync_enable = '1' and (slv_frame_ref_out /= num_fstore_minus1) and (slv_frame_ref_out /= "00000") and (frame_number_i = std_logic_vector(unsigned(slv_frame_ref_out) - 1)))then
                    frame_number_i <= std_logic_vector(unsigned(frame_number_i) + 2);
                -- Increment frame count with each sync if valid prmtr values
                -- stored.


                elsif(valid_frame_sync_d2 = '1' and frame_number_i = num_fstore_minus1)then
                    frame_number_i <= (others => '0');


                elsif(valid_frame_sync_d2 = '1')then
                    frame_number_i <= std_logic_vector(unsigned(frame_number_i) + 1);
                end if;
            end if;
        end process DM_REG_FRAME_COUNT;
    end generate DM_GEN_FSTORE_GRTR_TWO;



   DM_GEN_FSTORES_EQL_TWO : if C_NUM_FSTORES = 2 generate
   begin
    -------------------------------------------------------------------------------
    -- Include State Machine and support logic
    -------------------------------------------------------------------------------
    -- Frame Number generation
    DM_REG_FRAME_COUNT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear at reset or stopped or first valid fsync not occured
                if(prmry_resetn = '0' or dmasr_halt = '1'
                or (circular_prk_mode = '1' and initial_frame = '0') or num_fstore_equal_one = '1')then

                    frame_number_i <= (others => '0');
                -- If Park is enabled then on frame sync transision to
                -- frame pointer reference.



                --elsif(fsize_mismatch_err_flag_i= '1')then
                elsif(flag_to_repeat_after_fsize_less_err= '1')then
                        frame_number_i <= frame_number_i;




                elsif(valid_frame_sync_d2 = '1' and circular_prk_mode = '0')then
                    frame_number_i <= frame_ptr_ref;
------------------------------------------------------------------------------------------------------------
                -- On Repeat Frame simply hold current frame number (
                --elsif(repeat_frame = '1')then
                elsif(repeat_frame = '1' and dmacr_repeat_en = '1')then
                    frame_number_i <= repeat_frame_nmbr;
------------------------------------------------------------------------------------------------------------
                -- Frame count reached terminal count therefore roll count over
                --elsif(valid_frame_sync_i = '1' and frame_number_i = FRAME_NUMBER_TC)then
                elsif(valid_frame_sync_d2 = '1' and sync_enable = '1' and (frame_number_i = "00001") and (slv_frame_ref_out = "00001"))then
                    frame_number_i <= (others => '0');
  
                elsif(valid_frame_sync_d2 = '1' and sync_enable = '1' and (frame_number_i = "00001") and (slv_frame_ref_out = "00000"))then
                    frame_number_i <= "00001";
                elsif(valid_frame_sync_d2 = '1' and sync_enable = '1' and (frame_number_i = "00000") and (slv_frame_ref_out = "00001"))then
                    frame_number_i <= (others => '0');

                elsif(valid_frame_sync_d2 = '1' and sync_enable = '1' and (frame_number_i = "00000") and (slv_frame_ref_out = "00000"))then
                    frame_number_i <="00001" ;


                elsif(valid_frame_sync_d2 = '1' and frame_number_i = "00001")then
                    frame_number_i <= (others => '0');


                elsif(valid_frame_sync_d2 = '1' and frame_number_i = "00000")then
                    frame_number_i <="00001" ;
                end if;
            end if;
        end process DM_REG_FRAME_COUNT;



   end generate DM_GEN_FSTORES_EQL_TWO;




   DM_GEN_FSTORES_EQL_ONE : if C_NUM_FSTORES = 1 generate
   begin

                    frame_number_i <= (others => '0');


   end generate DM_GEN_FSTORES_EQL_ONE;

    DM_GEN_REPEAT_FRM_FSIZE_LESS_ERR_SOF : if C_MM2S_SOF_ENABLE = 1 or C_S2MM_SOF_ENABLE = 1 generate
    begin

		DM_REPEAT_EN_FSIZE_LESS_ERR_FLAG : process(prmry_aclk)
		    begin
		        if(prmry_aclk'EVENT and prmry_aclk = '1')then
		            if(prmry_resetn = '0' or valid_frame_sync_d2 = '1')then
		                flag_to_repeat_after_fsize_less_err  <= '0';
		            elsif(fsize_mismatch_err_i = '1')then
		                flag_to_repeat_after_fsize_less_err  <= '1';
		            end if;
		        end if;
		    end process DM_REPEAT_EN_FSIZE_LESS_ERR_FLAG;
    end generate DM_GEN_REPEAT_FRM_FSIZE_LESS_ERR_SOF;
		
    DM_GEN_REPEAT_FRM_FSIZE_LESS_ERR_NO_SOF : if C_MM2S_SOF_ENABLE = 0 and C_S2MM_SOF_ENABLE = 0 generate
    begin

			       flag_to_repeat_after_fsize_less_err  <= '0';
		            
    end generate DM_GEN_REPEAT_FRM_FSIZE_LESS_ERR_NO_SOF;
		



    -- If flush on frame sync enabled and genlock repeat frame enabled
    -- then repeat errored frame on next frame sync. (
--    DM_GEN_REPEAT_FRM_LOGIC : if C_GENLOCK_REPEAT_EN = 1 and C_ENABLE_FLUSH_ON_FSYNC = 1 generate
--    begin


        DM_REPEAT_FRAME_PROCESS : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    ----if(prmry_resetn = '0' or valid_frame_sync_d2 = '1')then
                    if(prmry_resetn = '0' or (valid_frame_sync_d2 = '1' and flag_to_repeat_after_fsize_less_err = '0'))then
                        repeat_frame_nmbr <= (others => '0');
                        repeat_frame <= '0';

                    -- Frame size mismatch
                    elsif(fsize_mismatch_err_i='1' or flag_to_repeat_after_fsize_less_err = '1')then
                        repeat_frame_nmbr <= s_h_frame_number;
                        repeat_frame      <= '1';

                    -- Line size mismatch
                    elsif(lsize_mismatch_err_i='1' or lsize_more_mismatch_err_i ='1')then
                        repeat_frame_nmbr <= frame_number_i;
                        repeat_frame      <= '1';

                    end if;
                end if;
            end process DM_REPEAT_FRAME_PROCESS;
--    end generate DM_GEN_REPEAT_FRM_LOGIC;





----    -- Not in flush on frame sync mode or repeat frame not enabled (
----    DM_GEN_NO_REPEAT_FRM_LOGIC : if C_GENLOCK_REPEAT_EN = 0 or C_ENABLE_FLUSH_ON_FSYNC = 0 generate
----    begin
----        -- never repeat frame
----        repeat_frame        <= '0';
----        repeat_frame_nmbr   <= (others => '0');
----
----    end generate DM_GEN_NO_REPEAT_FRM_LOGIC;

    -- Pass Frame sync to video
    mstr_frame_ref_in <= dm_prev_frame_number;

    -- Pass frame number out to register module
    frame_number <= frame_number_i;

    -- Drive test vector to zero for GenLock master mode
    --tstvect_frm_ptr_out <= (others => '0');
    -- Drive test vector for Dynamic GenLock master mode
    --tstvect_frm_ptr_out <= slv_frame_ref_out;

    -- coverage off
   -- TSTVECT_FTPTR_OUT : process(reg_frame_number_ds)
    DM_TSTVECT_FTPTR_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frm_ptr_out <= (others => '0');
                    	elsif (dmasr_halt = '0') then
    				tstvect_frm_ptr_out <= slv_frame_ref_out;
			--else 
				--tstvect_frm_ptr_out <= tstvect_frm_ptr_out;
                    	end if;
                    end if;

        end process DM_TSTVECT_FTPTR_OUT;

    -- coverage on


    DM_PREV_FRAME : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    dm_prev_frame_number <= (others => '0');
                --elsif(valid_frame_sync_d2 = '1'and repeat_frame = '0' and fsize_mismatch_err_flag_i = '0')then
                ----elsif(valid_frame_sync_d2 = '1'and repeat_frame = '0' and flag_to_repeat_after_fsize_less_err = '0')then
                elsif(valid_frame_sync_d2 = '1'and  (dmacr_repeat_en = '0' or repeat_frame = '0') and flag_to_repeat_after_fsize_less_err = '0')then
                    dm_prev_frame_number <= frame_number_i;
                end if;
            end if;
        end process DM_PREV_FRAME;




        REG_CURR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        chnl_current_frame <= (others => '0');
                    else 
                        chnl_current_frame <= frame_number_i;
                    end if;
                end if;
            end process REG_CURR_FRM_NUMBER;

----chnl_current_frame <= frame_number_i;
----genlock_pair_frame <= slv_frame_ref_out;

        REG_PAIR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        genlock_pair_frame <= (others => '0');
                    else 
                        genlock_pair_frame <= slv_frame_ref_out;
                    end if;
                end if;
            end process REG_PAIR_FRM_NUMBER;



end generate DYNAMIC_MASTER_MODE_FRAME_CNT;

--*****************************************************************************
-- GEN-LOCK MASTER Mode
--*****************************************************************************
-- Frame counter for Gen-Lock Master Mode
MASTER_MODE_FRAME_CNT : if C_GENLOCK_MODE = 0 generate
signal valid_frame_sync_d1      		 : std_logic := '0';
--signal flag_to_repeat_after_fsize_less_err     : std_logic := '0'; 
--signal valid_frame_sync_d2      : std_logic := '0';
begin


    -- Register qualified frame sync (i.e. valid parameters and frame_sync)
    -- for use in IOC Threshold count wr to hold counter at intial
    -- value until after first frame.  This is done in axi_vdma_reg_module.vhd

    M_REG_VALID_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    valid_frame_sync    <= '0';
                    valid_frame_sync_d1 <= '0';
                    valid_frame_sync_d2 <= '0';
                else
                    valid_frame_sync_d1 <= valid_frame_sync_i;
                    valid_frame_sync_d2 <= valid_frame_sync_d1;
                    valid_frame_sync    <= valid_frame_sync_d2;
                end if;
            end if;
        end process M_REG_VALID_FSYNC_OUT;




----    REG_VALID_FSYNC_OUT : process(prmry_aclk)
----        begin
----            if(prmry_aclk'EVENT and prmry_aclk = '1')then
----                if(prmry_resetn = '0')then
----                    valid_frame_sync <= '0';
----                else
----                    valid_frame_sync    <= valid_frame_sync_i;
----                end if;
----            end if;
----        end process REG_VALID_FSYNC_OUT;

    -- Frame sync for test vector, delay counter, and threshold counter
    -- Register test vector signals out.  Also used for
    -- delay timer and threshold counter.
----    PROCESS_TSTVECTOR_REG : process(prmry_aclk)
----        begin
----            if(prmry_aclk'EVENT and prmry_aclk = '1')then
----                if(prmry_resetn = '0')then
----                    tstvect_fsync_d1<= '0';
----                    tstvect_frame   <= (others => '0');
----                else
----                    tstvect_fsync_d1<= frame_sync;
----                    tstvect_frame   <= frame_number_i;
----                end if;
----            end if;
----        end process PROCESS_TSTVECTOR_REG;
    -- coverage off
    M_TSTVECT_FRM_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frame <= (others => '0');
                    	elsif (dmasr_halt = '0') then
            			tstvect_frame <= frame_number_i;
                    	--else 
            		--	tstvect_frame <= tstvect_frame;
                    	end if;
                    end if;

        end process M_TSTVECT_FRM_OUT;

    M_PROCESS_TSTVECTOR_REG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    tstvect_fsync_d1    <= '0';
                    tstvect_fsync_d2    <= '0';
                    tstvect_fsync       <= '0';
                else
                    tstvect_fsync_d1    <= frame_sync;
                    tstvect_fsync_d2    <= tstvect_fsync_d1;
                    tstvect_fsync       <= tstvect_fsync_d2
                                            and video_prmtrs_valid;

                end if;
            end if;
        end process M_PROCESS_TSTVECTOR_REG;
    -- coverage on



    -- Mask with valid video parameters to prevent delay counter
    -- from counting at start up for external fsyncs that can
    -- be coming in long before starting.
    -- video_prmtrs_valid asserts on clock cycle following assertion
    -- of frame_sync, thus pipeline delay to create tstvect_fsync_d1
    -- is required to assert first fsync for first valid frame
    -- Note: tstvect_fsync output needs to be aligned exactly
    -- with valid_frame_sync output for use in register module to
    -- reset threshold counter on first frame but not on subsequent
    -- frames.
    --tstvect_fsync <= tstvect_fsync_d1 and video_prmtrs_valid;

    -------------------------------------------------------------------------------
    -- Include State Machine and support logic
    -------------------------------------------------------------------------------
    -- Frame Number generation
    REG_FRAME_COUNT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear at reset or stopped or first valid fsync not occured
                if(prmry_resetn = '0' or dmasr_halt = '1'
                or (circular_prk_mode = '1' and initial_frame = '0'))then

                    frame_number_i <= (others => '0');
                -- If Park is enabled then on frame sync transision to
                -- frame pointer reference.


                --elsif(fsize_mismatch_err_flag_i= '1')then
                elsif(flag_to_repeat_after_fsize_less_err= '1')then
                        frame_number_i <= frame_number_i;



                elsif(valid_frame_sync_d2 = '1' and circular_prk_mode = '0')then
                    frame_number_i <= frame_ptr_ref;

                -- On Repeat Frame simply hold current frame number (
                --elsif(repeat_frame = '1')then
                elsif(repeat_frame = '1' and dmacr_repeat_en = '1')then
                    frame_number_i <= repeat_frame_nmbr;

                -- Frame count reached terminal count therefore roll count over
                --elsif(valid_frame_sync_i = '1' and frame_number_i = FRAME_NUMBER_TC)then
                elsif(valid_frame_sync_d2 = '1' and frame_number_i = num_fstore_minus1)then
                    frame_number_i <= (others => '0');

                -- Increment frame count with each sync if valid prmtr values
                -- stored.
                elsif(valid_frame_sync_d2 = '1' and video_prmtrs_valid = '1')then
                    frame_number_i <= std_logic_vector(unsigned(frame_number_i) + 1);
                end if;
            end if;
        end process REG_FRAME_COUNT;




    GEN_REPEAT_FRM_FSIZE_LESS_ERR_SOF : if C_MM2S_SOF_ENABLE = 1 or C_S2MM_SOF_ENABLE = 1 generate
    begin

		REPEAT_EN_FSIZE_LESS_ERR_FLAG : process(prmry_aclk)
		    begin
		        if(prmry_aclk'EVENT and prmry_aclk = '1')then
		            if(prmry_resetn = '0' or valid_frame_sync_d2 = '1')then
		                flag_to_repeat_after_fsize_less_err  <= '0';
		            elsif(fsize_mismatch_err_i = '1')then
		                flag_to_repeat_after_fsize_less_err  <= '1';
		            end if;
		        end if;
		    end process REPEAT_EN_FSIZE_LESS_ERR_FLAG;
    end generate GEN_REPEAT_FRM_FSIZE_LESS_ERR_SOF;
		
    GEN_REPEAT_FRM_FSIZE_LESS_ERR_NO_SOF : if C_MM2S_SOF_ENABLE = 0 and C_S2MM_SOF_ENABLE = 0 generate
    begin

			       flag_to_repeat_after_fsize_less_err  <= '0';
		            
    end generate GEN_REPEAT_FRM_FSIZE_LESS_ERR_NO_SOF;
		






    -- If flush on frame sync enabled and genlock repeat frame enabled
    -- then repeat errored frame on next frame sync. (
   -- GEN_REPEAT_FRM_LOGIC : if C_GENLOCK_REPEAT_EN = 1 and C_ENABLE_FLUSH_ON_FSYNC = 1 generate
   -- begin


        REPEAT_FRAME_PROCESS : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    ----if(prmry_resetn = '0' or valid_frame_sync_d2 = '1')then
                    if(prmry_resetn = '0' or (valid_frame_sync_d2 = '1' and flag_to_repeat_after_fsize_less_err = '0'))then
                        repeat_frame_nmbr <= (others => '0');
                        repeat_frame <= '0';

                    -- Frame size mismatch
                    --elsif(fsize_mismatch_err_i='1')then
                    elsif(fsize_mismatch_err_i='1' or flag_to_repeat_after_fsize_less_err='1')then
                        repeat_frame_nmbr <= s_h_frame_number;
                        repeat_frame      <= '1';

                    -- Line size mismatch
                    elsif(lsize_mismatch_err_i='1' or lsize_more_mismatch_err_i ='1')then
                        repeat_frame_nmbr <= frame_number_i;
                        repeat_frame      <= '1';

                    end if;
                end if;
            end process REPEAT_FRAME_PROCESS;
    --end generate GEN_REPEAT_FRM_LOGIC;





----    -- Not in flush on frame sync mode or repeat frame not enabled (
----    GEN_NO_REPEAT_FRM_LOGIC : if C_GENLOCK_REPEAT_EN = 0 or C_ENABLE_FLUSH_ON_FSYNC = 0 generate
----    begin
----        -- never repeat frame
----        repeat_frame        <= '0';
----        repeat_frame_nmbr   <= (others => '0');
----
----    end generate GEN_NO_REPEAT_FRM_LOGIC;

    -- Pass Frame sync to video
    mstr_frame_ref_in <= frame_number_i;

    -- Pass frame number out to register module
    frame_number <= frame_number_i;

    -- Drive test vector to zero for master mode
    tstvect_frm_ptr_out <= (others => '0');

----chnl_current_frame <= frame_number_i;




        REG_CURR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        chnl_current_frame <= (others => '0');
                    else 
                        chnl_current_frame <= frame_number_i;
                    end if;
                end if;
            end process REG_CURR_FRM_NUMBER;

----chnl_current_frame <= frame_number_i;

    genlock_pair_frame <= (others => '0');




end generate MASTER_MODE_FRAME_CNT;

--*****************************************************************************
-- Error Handling
-- For graceful shut down logic
--*****************************************************************************
-- Clear run/stop and stop state machines due to errors or soft reset
-- Error based on datamover error report or sg fetch error
-- SG fetch error included because need to shut down because data maybe corrupt
-- therefor do not want to issue the xfer command to primary datamover
-- Added run_stop to assertion for when run_stop is de-asserted in middle of video
-- frame need to halt datamover to clear out potential pending commands.
stop_i    <= dma_err         -- DMAIntErr, DMADecErr, DMASlvErr, ZeroSize, possibly Frame/Line Mismatch
          or ftch_err         -- SGDecErr, SGSlvErr
          or soft_reset;        -- Soft Reset issued

-- Reg stop out
REG_STOP_OUT : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                stop       <= '0';
            else
                stop       <= stop_i;
            end if;
        end if;
    end process REG_STOP_OUT;

-- For verification only - drive error detection
-- out to test vector port, will be stripped during build
-- (Broke up in order to capture all errors regardless of
-- flush on frame sync mode)
-- coverage off
REG_DELAY_ERR : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                err_d1        <= '0';
                tstvect_err   <= '0';
            else
                err_d1        <= slverr       -- DMASlvErr
                                or decerr       -- DMADecErr
                                or interr       -- DMAIntErr, ZeroSize, Frame
				or lsize_mismatch_err_i			-- Line Mismatch
				or lsize_more_mismatch_err_i		-- Line Mismatch
                                or ftch_err;  -- SGSlvErr, SGDecErr

                tstvect_err   <= err_d1;
            end if;
        end if;
    end process REG_DELAY_ERR;
-- coverage on


--*****************************************************************************
-- DMA Control
--*****************************************************************************

---------------------------------------------------------------------------
-- Primary DMA Controller State Machine
---------------------------------------------------------------------------
I_SM : entity  axi_vdma_v6_3_10.axi_vdma_sm
    generic map(
        C_M_AXI_ADDR_WIDTH              => C_M_AXI_ADDR_WIDTH           ,
        C_INCLUDE_SF                    => C_INCLUDE_SF                 ,
        C_USE_FSYNC                     => C_USE_FSYNC                  ,   -- 
        C_ENABLE_FLUSH_ON_FSYNC         => C_ENABLE_FLUSH_ON_FSYNC      ,   -- 
        C_EXTEND_DM_COMMAND             => C_EXTEND_DM_COMMAND          ,
        C_PRMY_CMDFIFO_DEPTH            => C_PRMY_CMDFIFO_DEPTH         ,
        C_MM2S_SOF_ENABLE               => C_MM2S_SOF_ENABLE               ,
        C_S2MM_SOF_ENABLE               => C_S2MM_SOF_ENABLE               ,
        C_PRMRY_IS_ACLK_ASYNC           => C_PRMRY_IS_ACLK_ASYNC               ,
        C_INCLUDE_MM2S                  => C_INCLUDE_MM2S               ,
        C_ENABLE_VERT_FLIP              => C_ENABLE_VERT_FLIP             ,
        C_INCLUDE_S2MM                  => C_INCLUDE_S2MM
    )
    port map(
        prmry_aclk                      => prmry_aclk                   ,
        prmry_resetn                    => prmry_resetn                 ,
  
          scndry_aclk                 => scndry_aclk                 ,
          scndry_resetn               => scndry_resetn                 ,

        -- AXI Stream Qualifiers
        packet_sof                      => packet_sof                   ,

        -- Raw fsync (must use unqualified frame sync for proper sm operation)
        frame_sync                      => frame_sync                   ,

        -- Valid video parameter available
        video_prmtrs_valid              => video_prmtrs_valid           ,

        -- Control and Status
        run_stop                        => run_stop                     ,
        cmnd_idle                       => cmnd_idle                    ,
        sts_idle                        => sts_idle                     ,
        stop                            => stop_i                       ,
        halt                            => halt                         ,
        zero_size_err                   => zero_size_err                ,
        mm2s_fsync_out_m            	=> mm2s_fsync_out_m                  ,
        s2mm_fsync_out_m            	=> s2mm_fsync_out_m                  ,
        mm2s_fsize_mismatch_err_s       => mm2s_fsize_mismatch_err_s         ,   
        mm2s_fsize_mismatch_err_m       => mm2s_fsize_mismatch_err_m         ,   
        s2mm_fsize_mismatch_err_s       => s2mm_fsize_mismatch_err_s         ,   
        fsize_mismatch_err_flag         => fsize_mismatch_err_flag_i         ,   
        fsize_mismatch_err              => fsize_mismatch_err_i         ,   -- 
        all_lines_xfred                 => all_lines_xfred              ,   -- 

        all_lasts_rcvd                  => all_lasts_rcvd             ,   
drop_fsync_d_pulse_gen_fsize_less_err   => drop_fsync_d_pulse_gen_fsize_less_err                      ,
      	s2mm_strm_all_lines_rcvd    	=> s2mm_strm_all_lines_rcvd	,	--      : out std_logic;
      	s2mm_fsync_core    		=> s2mm_fsync_core	,	--      : out std_logic;
 
       -- DataMover Command/Status
        cmnd_wr                         => cmnd_wr                      ,
        cmnd_data                       => cmnd_data                    ,
        cmnd_pending                    => cmnd_pending                 ,
        sts_received                    => sts_received                 ,
        
        -- Vertical Flip
        vflip_sm                        => vflip_mngr                 ,

        -- Descriptor Fields
        crnt_start_address              => crnt_start_address           ,
        crnt_vsize                      => crnt_vsize_i                 ,   -- 
        crnt_hsize                      => crnt_hsize                   ,
        crnt_stride                     => crnt_stride

    );

-- If Scatter Gather engine is included then instantiate scatter gather
-- interface
GEN_SG_INTERFACE : if C_INCLUDE_SG = 1 generate
begin
    ---------------------------------------------------------------------------
    -- Scatter Gather State Machine
    ---------------------------------------------------------------------------
    I_SG_IF : entity  axi_vdma_v6_3_10.axi_vdma_sg_if
        generic map(

            -------------------------------------------------------------------
            -- Scatter Gather Parameters
            -------------------------------------------------------------------
            C_M_AXIS_SG_TDATA_WIDTH         => C_M_AXIS_SG_TDATA_WIDTH      ,
            C_M_AXI_SG_ADDR_WIDTH           => C_M_AXI_SG_ADDR_WIDTH        ,
            C_M_AXI_ADDR_WIDTH              => C_M_AXI_ADDR_WIDTH
        )
        port map(

            prmry_aclk                      => prmry_aclk                   ,
            prmry_resetn                    => prmry_resetn                 ,

            dmasr_halt                      => dmasr_halt                   ,
            ftch_idle                       => ftch_idle                    ,
            ftch_complete                   => ftch_complete                ,
            ftch_complete_clr               => ftch_complete_clr            ,

            -- SG Descriptor Fetch AXI Stream In
            m_axis_ftch_tdata               => m_axis_ftch_tdata            ,
            m_axis_ftch_tvalid              => m_axis_ftch_tvalid           ,
            m_axis_ftch_tready              => m_axis_ftch_tready           ,
            m_axis_ftch_tlast               => m_axis_ftch_tlast            ,

            -- Descriptor Field Output
            new_curdesc                     => new_curdesc                  ,
            new_curdesc_wren                => new_curdesc_wren             ,

            desc_data_wren                  => desc_data_wren               ,
            desc_strtaddress                => desc_strtaddress             ,
            desc_vsize                      => desc_vsize                   ,
            desc_hsize                      => desc_hsize                   ,
            desc_stride                     => desc_stride                  ,
            desc_frmdly                     => desc_frmdly

        );
end generate GEN_SG_INTERFACE;

-- If Scatter Gather engine is excluded then tie off unused signals
GEN_NO_SG_INTERFACE : if C_INCLUDE_SG = 0 generate
begin
    -- Map update complete to ftch_complete signal for proper
    -- video paramter transfer from axi_lite registers to video registers
    ftch_complete           <= prmtr_updt_complete;

    -- Signals not need for register direct mode
    m_axis_ftch_tready     <= '0';
    new_curdesc            <= (others => '0');
    new_curdesc_wren       <= '0';
    desc_data_wren         <= '0';
    desc_strtaddress       <= (others => '0');
    desc_vsize             <= (others => '0');
    desc_hsize             <= (others => '0');
    desc_stride            <= (others => '0');
    desc_frmdly            <= (others => '0');

end generate GEN_NO_SG_INTERFACE;

-------------------------------------------------------------------------------
-- Primary DataMover command status interface
-------------------------------------------------------------------------------
I_CMDSTS : entity  axi_vdma_v6_3_10.axi_vdma_cmdsts_if
    generic map(
        C_M_AXI_ADDR_WIDTH              => C_M_AXI_ADDR_WIDTH           ,
        C_DM_STATUS_WIDTH               => C_DM_STATUS_WIDTH            ,
        C_INCLUDE_MM2S                  => C_INCLUDE_MM2S               ,
        --C_ENABLE_DEBUG_INFO             => C_ENABLE_DEBUG_INFO             ,
        C_ENABLE_DEBUG_ALL      => C_ENABLE_DEBUG_ALL             ,
            C_ENABLE_DEBUG_INFO_0       => C_ENABLE_DEBUG_INFO_0             ,
            C_ENABLE_DEBUG_INFO_1       => C_ENABLE_DEBUG_INFO_1             ,
            C_ENABLE_DEBUG_INFO_2       => C_ENABLE_DEBUG_INFO_2             ,
            C_ENABLE_DEBUG_INFO_3       => C_ENABLE_DEBUG_INFO_3             ,
            C_ENABLE_DEBUG_INFO_4       => C_ENABLE_DEBUG_INFO_4             ,
            C_ENABLE_DEBUG_INFO_5       => C_ENABLE_DEBUG_INFO_5             ,
            C_ENABLE_DEBUG_INFO_6       => C_ENABLE_DEBUG_INFO_6             ,
            C_ENABLE_DEBUG_INFO_7       => C_ENABLE_DEBUG_INFO_7             ,
            C_ENABLE_DEBUG_INFO_8       => C_ENABLE_DEBUG_INFO_8             ,
            C_ENABLE_DEBUG_INFO_9       => C_ENABLE_DEBUG_INFO_9             ,
            C_ENABLE_DEBUG_INFO_10      => C_ENABLE_DEBUG_INFO_10             ,
            C_ENABLE_DEBUG_INFO_11      => C_ENABLE_DEBUG_INFO_11             ,
            C_ENABLE_DEBUG_INFO_12      => C_ENABLE_DEBUG_INFO_12             ,
            C_ENABLE_DEBUG_INFO_13      => C_ENABLE_DEBUG_INFO_13             ,
            C_ENABLE_DEBUG_INFO_14      => C_ENABLE_DEBUG_INFO_14             ,
            C_ENABLE_DEBUG_INFO_15      => C_ENABLE_DEBUG_INFO_15             ,

        C_INCLUDE_S2MM                  => C_INCLUDE_S2MM,
        C_ENABLE_FLUSH_ON_FSYNC         => C_ENABLE_FLUSH_ON_FSYNC
    )
    port map(
        prmry_aclk                      => prmry_aclk                   ,
        prmry_resetn                    => prmry_resetn                 ,

        -- Fetch command write interface from sm
        cmnd_wr                         => cmnd_wr                      ,
        cmnd_data                       => cmnd_data                    ,
        cmnd_pending                    => cmnd_pending                 ,
        sts_received                    => sts_received                 ,
        crnt_hsize                      => crnt_hsize                   ,
        stop                            => stop_i                       ,
        halt                            => halt                         ,   -- 
        dmasr_halt                      => dmasr_halt                   ,

        -- User Command Interface Ports (AXI Stream)
        s_axis_cmd_tvalid               => s_axis_cmd_tvalid            ,
        s_axis_cmd_tready               => s_axis_cmd_tready            ,
        s_axis_cmd_tdata                => s_axis_cmd_tdata             ,

        -- User Status Interface Ports (AXI Stream)
        m_axis_sts_tvalid               => m_axis_sts_tvalid            ,
        m_axis_sts_tready               => m_axis_sts_tready            ,
        m_axis_sts_tdata                => m_axis_sts_tdata             ,
        m_axis_sts_tkeep                => m_axis_sts_tkeep             ,
 
           s2mm_fsize_more_or_sof_late => s2mm_fsize_more_or_sof_late          ,   

        s2mm_dmasr_lsize_less_err                   => s2mm_dmasr_lsize_less_err                ,
        -- Zero Hsize and/or Vsize. mapped here to combine with interr
        zero_size_err                   => zero_size_err                ,
        -- Frame Mismatch. mapped here to combine with interr
        fsize_mismatch_err              => fsize_mismatch_err_i         ,   -- 
        lsize_mismatch_err              => lsize_mismatch_err_i           ,   -- 
        lsize_more_mismatch_err              => lsize_more_mismatch_err_i           ,   -- 

        capture_hsize_at_uf_err              => capture_hsize_at_uf_err           ,   
        -- Primary DataMover Status
        err                             => err                          ,
        done                            => done                         ,
        err_o                           => dma_err                    ,
        interr_minus_frame_errors                          => interr_minus_frame_errors                       ,
        interr                          => interr                       ,
        slverr                          => slverr                       ,
        decerr                          => decerr                       ,
        tag                             => tag                             -- Not used
    );

---------------------------------------------------------------------------
-- Halt / Idle Status Manager
---------------------------------------------------------------------------
I_STS_MNGR : entity  axi_vdma_v6_3_10.axi_vdma_sts_mngr
    port map(
        prmry_aclk                      => prmry_aclk                   ,
        prmry_resetn                    => prmry_resetn                 ,

        -- dma control and sg engine status signals
        run_stop                        => run_stop                     ,
        regdir_idle                     => regdir_idle                  ,
        ftch_idle                       => ftch_idle                    ,
        cmnd_idle                       => cmnd_idle                    ,
        sts_idle                        => sts_idle                     ,
        line_buffer_empty               => line_buffer_empty            ,
        dwidth_fifo_pipe_empty               => dwidth_fifo_pipe_empty            ,
        video_prmtrs_valid              => video_prmtrs_valid           ,
        prmtr_update_complete           => prmtr_update_complete        , -- 

        -- stop and halt control/status
        stop                            => stop_i                       ,
        halt                            => halt                         , -- 
        halt_cmplt                      => halt_cmplt                   ,

        -- system state and control
        all_idle                        => all_idle_i                   ,
        ftchcmdsts_idle                 => ftchcmdsts_idle              ,
        cmdsts_idle                     => cmdsts_idle                  ,
        halted_clr                      => halted_clr                   ,
        halted_set                      => halted_set                   ,
        idle_set                        => idle_set                     ,
        idle_clr                        => idle_clr
    );

---------------------------------------------------------------------------
-- Video Register Bank
---------------------------------------------------------------------------
VIDEO_REG_I : entity  axi_vdma_v6_3_10.axi_vdma_vidreg_module
    generic map(
        C_INCLUDE_SG                    => C_INCLUDE_SG                 ,
        C_NUM_FSTORES                   => C_NUM_FSTORES                ,
        C_DYNAMIC_RESOLUTION            => C_DYNAMIC_RESOLUTION                ,
        C_ADDR_WIDTH                    => C_M_AXI_ADDR_WIDTH           ,
        C_SELECT_XPM                    => C_SELECT_XPM                 ,
        C_FAMILY                        => C_FAMILY
    )
    port map(
        prmry_aclk                      => prmry_aclk                   ,
        prmry_resetn                    => prmry_resetn                 ,

        -- Register update control
        ftch_complete                   => ftch_complete                ,
        ftch_complete_clr               => ftch_complete_clr            ,
        parameter_update                => parameter_update             ,
        video_prmtrs_valid              => video_prmtrs_valid           ,
        prmtr_update_complete           => prmtr_update_complete        , -- 
        num_fstore_minus1               => num_fstore_minus1            , -- 

        -- Register swap control/status
        frame_sync                      => frame_sync                   ,
        run_stop                        => run_stop                     ,
        dmasr_halt                      => dmasr_halt                   ,
        ftch_idle                       => ftch_idle                    ,
        tailpntr_updated                => tailpntr_updated             ,
        frame_number                    => frame_number_i               ,

        -- Register Direct Mode Video Parameter In
        reg_module_vsize                => reg_module_vsize             ,
        reg_module_hsize                => reg_module_hsize             ,
        reg_module_stride               => reg_module_stride            ,
        reg_module_frmdly               => reg_module_frmdly            ,
        reg_module_strt_addr            => reg_module_strt_addr         ,

        -- Descriptor data/control from sg interface
        desc_data_wren                  => desc_data_wren               ,
        desc_strtaddress                => desc_strtaddress             ,
        desc_vsize                      => desc_vsize                   ,
        desc_hsize                      => desc_hsize                   ,
        desc_stride                     => desc_stride                  ,
        desc_frmdly                     => desc_frmdly                  ,

        -- Scatter Gather register Bank
        --crnt_vsize                      => crnt_vsize                 ,   -- 
        crnt_vsize                      => crnt_vsize_i                 ,   -- 
        crnt_hsize                      => crnt_hsize                   ,
        crnt_stride                     => crnt_stride                  ,
        crnt_frmdly                     => crnt_frmdly                  ,
        crnt_start_address              => crnt_start_address
    );

---------------------------------------------------------------------------
-- Gen Lock
---------------------------------------------------------------------------
VIDEO_GENLOCK_I : entity axi_vdma_v6_3_10.axi_vdma_genlock_mngr
    generic map(
        C_GENLOCK_MODE                  => C_GENLOCK_MODE               ,
        C_GENLOCK_NUM_MASTERS           => C_GENLOCK_NUM_MASTERS        ,
        C_INTERNAL_GENLOCK_ENABLE       => C_INTERNAL_GENLOCK_ENABLE    ,
        C_NUM_FSTORES                   => C_NUM_FSTORES
    )
    port map(

        -- Secondary Clock Domain
        prmry_aclk                      => prmry_aclk                   ,
        prmry_resetn                    => prmry_resetn                 ,

        -- Dynamic Frame Store Support
        num_frame_store                 => num_frame_store              ,
        num_fstore_minus1               => num_fstore_minus1            ,

        -- Gen-Lock Slave Signals
        mstr_in_control                 => mstr_pntr_ref                ,
        genlock_select                  => genlock_select               ,
        frame_ptr_in                    => frame_ptr_in                 ,
        internal_frame_ptr_in           => internal_frame_ptr_in        ,
        slv_frame_ref_out               => slv_frame_ref_out            ,

        -- Gen-Lock Master Signals
        dmasr_halt                      => dmasr_halt                   ,
        circular_prk_mode               => circular_prk_mode            ,
        fsize_mismatch_err_flag         => fsize_mismatch_err_flag_i         ,   
        mstr_frame_update               => valid_frame_sync_d2           ,
        mstr_frame_ref_in               => mstr_frame_ref_in            ,
        mstrfrm_tstsync_out             => mstrfrm_tstsync_out          ,
        frame_ptr_out                   => frame_ptr_out
    );


end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_mngr_64
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma_mngr_64.vhd
-- Description: This entity is the top level entity for the AXI VDMA Controller
--              manager.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr_64.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr_64.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_vdma_mngr_64 is
    generic(
        C_PRMRY_IS_ACLK_ASYNC           : integer range 0 to 1      	:= 0;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.

        C_PRMY_CMDFIFO_DEPTH        	: integer range 1 to 16        	:= 1;
            -- Depth of DataMover command FIFO

        C_INCLUDE_SF                	: integer range 0 to 1 		:= 0;
            -- Include or exclude store and forward module
            -- 0 = excluded
            -- 1 = included

        C_USE_FSYNC                     : integer range 0 to 1      	:= 0;
            -- Specifies DMA oeration synchronized to frame sync input
            -- 0 = Free running
            -- 1 = Fsync synchronous
        --C_ENABLE_DEBUG_INFO             : string := "1111111111111111";		-- 1 to 16 -- 
        --C_ENABLE_DEBUG_INFO             : bit_vector(15 downto 0) 	:= (others => '1');		--15 downto 0  -- 

        C_ENABLE_DEBUG_ALL       : integer range 0 to 1      	:= 1;
            -- Setting this make core backward compatible to 2012.4 version in terms of ports and registers
        C_ENABLE_DEBUG_INFO_0       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 0
        C_ENABLE_DEBUG_INFO_1       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 1
        C_ENABLE_DEBUG_INFO_2       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 2
        C_ENABLE_DEBUG_INFO_3       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 3
        C_ENABLE_DEBUG_INFO_4       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 4
        C_ENABLE_DEBUG_INFO_5       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 5
        C_ENABLE_DEBUG_INFO_6       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 6
        C_ENABLE_DEBUG_INFO_7       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 7
        C_ENABLE_DEBUG_INFO_8       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 8
        C_ENABLE_DEBUG_INFO_9       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 9
        C_ENABLE_DEBUG_INFO_10      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 10
        C_ENABLE_DEBUG_INFO_11      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 11
        C_ENABLE_DEBUG_INFO_12      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 12
        C_ENABLE_DEBUG_INFO_13      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 13
        C_ENABLE_DEBUG_INFO_14      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 14
        C_ENABLE_DEBUG_INFO_15      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 15

        C_ENABLE_VERT_FLIP              : integer range 0 to 1          := 0;            

        C_ENABLE_FLUSH_ON_FSYNC     	: integer range 0 to 1          := 0;           -- 
            -- Specifies VDMA Flush on Frame sync enabled
            -- 0 = Disabled
            -- 1 = Enabled

        C_NUM_FSTORES               	: integer range 1 to 32         := 1;
            -- Number of Frame Stores

        C_GENLOCK_MODE              	: integer range 0 to 3          := 0;
            -- Specifies Gen-Lock Mode of operation
            -- 0 = Master - Channel configured to be Gen-Lock Master
            -- 1 = Slave - Channel configured to be Gen-Lock Slave

        C_GENLOCK_NUM_MASTERS       	: integer range 1 to 16         := 1;
            -- Number of Gen-Lock masters capable of controlling Gen-Lock Slave

        --C_GENLOCK_REPEAT_EN        	: integer range 0 to 1      	:= 0;                -- 
            -- In flush on frame sync mode specifies whether frame number
            -- will increment on error'ed frame or repeat error'ed frame
            -- 0 = increment frame
            -- 1 = repeat frame

        -----------------------------------------------------------------------
        C_DYNAMIC_RESOLUTION           : integer range 0 to 1      	:= 1;
            -- Run time configuration of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 0 = Halt VDMA before writing new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 1 = Run time register configuration for new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE.
        -----------------------------------------------------------------------

        C_INTERNAL_GENLOCK_ENABLE   	: integer range 0 to 1          := 0;
            -- Enable internal genlock bus
            -- 0 = disable internal genlock bus
            -- 1 = enable internal genlock bus

        C_EXTEND_DM_COMMAND         	: integer range 0 to 1          := 0;
            -- Extend datamover command by padding BTT with 1's for
            -- indeterminate BTT mode

        -----------------------------------------------------------------------
        -- Scatter Gather Parameters
        -----------------------------------------------------------------------
        C_INCLUDE_SG              : integer range 0 to 1        	:= 1        ;
            -- Include or Exclude Scatter Gather Engine
            -- 0 = Exclude Scatter Gather Engine (Enables Register Direct Mode)
            -- 1 = Include Scatter Gather Engine

        C_M_AXI_SG_ADDR_WIDTH           : integer range 32 to 64    	:= 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_M_AXIS_SG_TDATA_WIDTH         : integer range 32 to 32    	:= 32;
            -- AXI Master Stream in for descriptor fetch

        -----------------------------------------------------------------------
        -- Memory Map Parameters
        -----------------------------------------------------------------------
        C_M_AXI_ADDR_WIDTH              : integer range 32 to 64    	:= 32;
            -- Master AXI Memory Map Address Width for Read Port

        C_DM_STATUS_WIDTH               : integer                   	:= 8 ;
            -- 
            -- DataMover status width - is based on mode of operation

        C_S2MM_SOF_ENABLE                : integer range 0 to 1        	:= 0;
        C_MM2S_SOF_ENABLE                : integer range 0 to 1        	:= 0;

        C_INCLUDE_MM2S                  : integer range 0 to 1      	:= 1;
            -- Include or exclude MM2S primary data path
            -- 0 = Exclude MM2S primary data path
            -- 1 = Include MM2S primary data path

        C_INCLUDE_S2MM                  : integer range 0 to 1      	:= 1;
            -- Include or exclude S2MM primary data path
            -- 0 = Exclude S2MM primary data path
            -- 1 = Include S2MM primary data path

        C_SELECT_XPM                    : integer                       := 1;
        C_FAMILY                        : string                    	:= "virtex7"
            -- Target FPGA Device Family
    );
    port (

        -- Secondary Clock and Reset
        prmry_aclk                  : in  std_logic                         ;               --
        prmry_resetn                : in  std_logic                         ;               --
        soft_reset                  : in  std_logic                         ;               --
 

        scndry_aclk                 : in  std_logic                             ;       --
        scndry_resetn               : in  std_logic                             ;       --
        vflip_mngr                  : in  std_logic                             ;       --
                                                                                        --
                                                                                           --
        -- Control and Status                                                               --
        run_stop                    : in  std_logic                         ;               --
        dmasr_halt                  : in  std_logic                         ;               --
        dmacr_repeat_en             : in  std_logic                         ;               --
        sync_enable                 : in  std_logic                         ;               --
        regdir_idle                 : in  std_logic                         ;               --
        ftch_idle                   : in  std_logic                         ;               --
        halt                        : in  std_logic                         ;               --
        halt_cmplt                  : in  std_logic                         ;               --
        halted_clr                  : out std_logic                         ;               --
        halted_set                  : out std_logic                         ;               --
        idle_set                    : out std_logic                         ;               --
        idle_clr                    : out std_logic                         ;               --
        chnl_current_frame          : out std_logic_vector
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        genlock_pair_frame          : out std_logic_vector
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --


        frame_number                : out std_logic_vector
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        new_curdesc                 : out std_logic_vector                                  --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0);                 --
        new_curdesc_wren            : out std_logic                         ;               --
        stop                        : out std_logic                         ;               --
        all_idle                    : out std_logic                         ;               --
        cmdsts_idle                 : out std_logic                         ;               --
        ftchcmdsts_idle             : out std_logic                         ;               --
        fsize_mismatch_err_flag     : out std_logic                         ;               -- 
        fsize_mismatch_err          : out std_logic                         ;               -- 
        lsize_mismatch_err          : out std_logic                         ;               -- 
        lsize_more_mismatch_err     : out std_logic                         ;               -- 
        s2mm_fsize_mismatch_err_s   : out std_logic                         ;               -- 

        mm2s_fsize_mismatch_err_s   : in std_logic                         ;               -- 
        mm2s_fsize_mismatch_err_m   : in std_logic                         ;               -- 
                                                                                            --
        -- Register direct support                                                          --
        prmtr_updt_complete         : in  std_logic                         ;               --
        reg_module_vsize            : in  std_logic_vector                                  --
                                        (VSIZE_DWIDTH-1 downto 0)           ;               --
        reg_module_hsize            : in  std_logic_vector                                  --
                                        (HSIZE_DWIDTH-1 downto 0)           ;               --
        reg_module_stride           : in  std_logic_vector                                  --
                                        (STRIDE_DWIDTH-1 downto 0)          ;               --
        reg_module_frmdly           : in  std_logic_vector                                  --
                                        (FRMDLY_DWIDTH-1 downto 0)          ;               --
        reg_module_strt_addr        : in STARTADDR_ARRAY_TYPE_64                               --
                                        (0 to C_NUM_FSTORES - 1)            ;               --
        mstr_pntr_ref               : in  std_logic_vector(3 downto 0)      ;               -- (master in control)
        genlock_select              : in  std_logic                         ;               --
        frame_ptr_ref               : in  std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        frame_ptr_in                : in std_logic_vector                                   --
                                        ((C_GENLOCK_NUM_MASTERS                             --
                                        *NUM_FRM_STORE_WIDTH)-1 downto 0)   ;               --
        frame_ptr_out               : out std_logic_vector                                  --
                                        (NUM_FRM_STORE_WIDTH-1 downto 0)    ;               --
        internal_frame_ptr_in       : in  std_logic_vector                                  --
                                        (NUM_FRM_STORE_WIDTH-1 downto 0)    ;               --
                                                                                            --
        update_frmstore             : out std_logic                         ;               -- 
        frmstr_err_addr             : out std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               -- 
        valid_frame_sync            : out std_logic                         ;               --
        valid_frame_sync_cmb        : out std_logic                         ;               --
        valid_video_prmtrs          : out std_logic                         ;               --
        parameter_update            : out std_logic                         ;               --
        tailpntr_updated            : in  std_logic                         ;               --
        frame_sync                  : in  std_logic                         ;               --
        circular_prk_mode           : in  std_logic                         ;               --
        line_buffer_empty           : in  std_logic                         ;               --
        dwidth_fifo_pipe_empty           : in  std_logic                         ;               --
        crnt_vsize                  : out std_logic_vector                                  --
                                        (VSIZE_DWIDTH-1 downto 0)           ;               -- 
        num_frame_store             : in  std_logic_vector                                  --
                                        (NUM_FRM_STORE_WIDTH-1 downto 0)    ;               --
        all_lines_xfred             : in  std_logic                         ;               -- 
        all_lasts_rcvd              : in  std_logic                         ;               --
        s2mm_strm_all_lines_rcvd              : in  std_logic                         ;               --
        drop_fsync_d_pulse_gen_fsize_less_err              : in  std_logic                         ;               --
        s2mm_fsize_more_or_sof_late : in  std_logic                         ;       --

        s2mm_dmasr_lsize_less_err   : in  std_logic                         ;       --

        s2mm_fsync_core             : in  std_logic                         ;       
        s2mm_fsync_out_m            : in  std_logic                         ;       
        mm2s_fsync_out_m            : in  std_logic                         ;       
       
	capture_hsize_at_uf_err     :  out std_logic_vector(15 downto 0) ;
  
        -- Test Vector signals                                                              --
        tstvect_err                 : out std_logic                         ;               --
        tstvect_fsync               : out std_logic                         ;               --
        tstvect_frame               : out std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        tstvect_frm_ptr_out         : out std_logic_vector                                  --
                                        (FRAME_NUMBER_WIDTH-1 downto 0)     ;               --
        mstrfrm_tstsync_out         : out std_logic                         ;               --
                                                                                            --
        -- AXI Stream Signals                                                               --
        packet_sof                  : in  std_logic                         ;               --
                                                                                            --
        -- Primary DMA Errors                                                               --
        dma_interr_set_minus_frame_errors              : out std_logic                         ;               --
        dma_interr_set              : out std_logic                         ;               --
        dma_slverr_set              : out std_logic                         ;               --
        dma_decerr_set              : out std_logic                         ;               --
                                                                                            --
        -- SG Descriptor Fetch AXI Stream In                                                --
        m_axis_ftch_tdata           : in  std_logic_vector                                  --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) ;              --
        m_axis_ftch_tvalid          : in  std_logic                         ;               --
        m_axis_ftch_tready          : out std_logic                         ;               --
        m_axis_ftch_tlast           : in  std_logic                         ;               --
                                                                                            --
        -- User Command Interface Ports (AXI Stream)                                        --
        s_axis_cmd_tvalid           : out std_logic                         ;               --
        s_axis_cmd_tready           : in  std_logic                         ;               --
        s_axis_cmd_tdata            : out std_logic_vector                                  --
                                        ((C_M_AXI_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);   --
                                                                                            --
        -- User Status Interface Ports (AXI Stream)                                         --
        m_axis_sts_tvalid           : in  std_logic                         ;               --
        m_axis_sts_tready           : out std_logic                         ;               --
        m_axis_sts_tdata            : in  std_logic_vector                                  --
                                        (C_DM_STATUS_WIDTH-1 downto 0);                     -- 
        m_axis_sts_tkeep            : in  std_logic_vector                                  --
                                        ((C_DM_STATUS_WIDTH/8)-1  downto 0) ;               -- 
        err                         : in  std_logic                         ;               --
                                                                                            --
        ftch_err                    : in  std_logic                                         --
    );

end axi_vdma_mngr_64;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_mngr_64 is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- Zero vector for tying off unused inputs
constant ZERO_VALUE         	: std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0) := (others => '0');


-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Primary DataMover Command signals
signal cmnd_wr                  : std_logic := '0';
signal cmnd_data                : std_logic_vector
                                            ((C_M_AXI_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0) := (others => '0');
signal cmnd_pending             : std_logic := '0';
signal sts_received             : std_logic := '0';

-- Primary DataMover Status signals
signal done                     : std_logic := '0';
signal stop_i                   : std_logic := '0';
signal interr                   : std_logic := '0';
signal interr_minus_frame_errors                   : std_logic := '0';
signal slverr                   : std_logic := '0';
signal decerr                   : std_logic := '0';
signal tag                      : std_logic_vector(3 downto 0) := (others => '0');
signal dma_err                	: std_logic := '0';
--signal error                    : std_logic := '0';
signal zero_size_err            : std_logic := '0';
signal fsize_mismatch_err_i     : std_logic := '0'; -- 
signal lsize_mismatch_err_i     : std_logic := '0'; -- 
signal lsize_more_mismatch_err_i       : std_logic := '0'; -- 
signal cmnd_idle                : std_logic := '0';
signal sts_idle                 : std_logic := '0';
signal ftch_complete            : std_logic := '0';
signal ftch_complete_clr        : std_logic := '0';
signal video_prmtrs_valid       : std_logic := '0';
signal prmtr_update_complete    : std_logic := '0'; -- 

--Descriptor video xfer parameters
signal desc_data_wren           : std_logic := '0';
signal desc_strtaddress         : std_logic_vector(C_M_AXI_ADDR_WIDTH-1 downto 0)  	:= (others => '0');
signal desc_vsize               : std_logic_vector(VSIZE_DWIDTH-1 downto 0)   		:= (others => '0');
signal desc_hsize               : std_logic_vector(HSIZE_DWIDTH-1 downto 0)   		:= (others => '0');
signal desc_stride              : std_logic_vector(STRIDE_DWIDTH-1 downto 0)  		:= (others => '0');
signal desc_frmdly              : std_logic_vector(FRMDLY_DWIDTH-1 downto 0)  		:= (others => '0');


-- Scatter Gather register Bank
signal crnt_vsize_i             : std_logic_vector(VSIZE_DWIDTH-1 downto 0)   		:= (others => '0'); -- 
signal crnt_hsize               : std_logic_vector(HSIZE_DWIDTH-1 downto 0)   		:= (others => '0');
signal crnt_stride              : std_logic_vector(STRIDE_DWIDTH-1 downto 0)  		:= (others => '0');
signal crnt_frmdly              : std_logic_vector(FRMDLY_DWIDTH-1 downto 0)  		:= (others => '0');
signal crnt_start_address       : std_logic_vector(C_M_AXI_ADDR_WIDTH - 1 downto 0)	:= (others => '0');


signal frame_number_i           : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  	:= (others => '0');
signal mstr_frame_ref_in        : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  	:= (others => '0');
signal slv_frame_ref_out        : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  	:= (others => '0');
signal valid_frame_sync_i       : std_logic := '0';
signal valid_frame_sync_d2      : std_logic := '0';
signal initial_frame            : std_logic := '0';
signal tstvect_fsync_d1         : std_logic := '0';
signal tstvect_fsync_d2         : std_logic := '0';
signal repeat_frame             : std_logic := '0'; -- 
signal repeat_frame_nmbr        : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  	:= (others => '0'); -- 
signal s_h_frame_number         : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  	:= (others => '0'); -- 
signal dm_prev_frame_number     : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  	:= (others => '0'); -- 
signal all_idle_d1              : std_logic := '0'; -- 
signal all_idle_re              : std_logic := '0'; -- 
signal all_idle_i               : std_logic := '0'; -- 
signal late_idle                : std_logic := '0'; -- 

signal frame_sync_d1            : std_logic := '0';
signal frame_sync_d2            : std_logic := '0';

signal err_d1                 	: std_logic := '0';



-- Dynamic frame store support
signal num_fstore_minus1_cmb    : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0) 	:= (others => '0');
signal num_fstore_minus1        : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) 	:= (others => '0');
signal num_fstore_equal_one     : std_logic 						:= '0';
signal fsize_mismatch_err_flag_i     : std_logic 					:= '0';
signal flag_to_repeat_after_fsize_less_err     : std_logic 				:= '0'; 

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

fsize_mismatch_err_flag      <= fsize_mismatch_err_flag_i ;




-- Number of fstore value set in register is 0x01.
num_fstore_equal_one <= '1' when num_fstore_minus1 = ZERO_VALUE(FRAME_NUMBER_WIDTH-1 downto 0)
                   else '0';



-- Pass errors to register module
dma_interr_set      <= interr ;
dma_interr_set_minus_frame_errors      <= interr_minus_frame_errors ;
dma_slverr_set      <= slverr ;
dma_decerr_set      <= decerr ;

-- Route out to map to reset module for halt/recover of datamover
fsize_mismatch_err  <= fsize_mismatch_err_i;    -- 
lsize_mismatch_err  <= lsize_mismatch_err_i;    -- 
lsize_more_mismatch_err  <= lsize_more_mismatch_err_i;    -- 

-- Pass current vertical size out for line tracking in linebuffers
crnt_vsize          <= crnt_vsize_i; -- 

-- Pass out to allow masking of fsync_out when parameters are not valid.
valid_video_prmtrs  <= video_prmtrs_valid;

all_idle            <= all_idle_i;  -- 

--*****************************************************************************
-- Frame sync for incrementing frame_number.  This sync is qualified with
-- video parameter valid to prevent incrementing frame_number on first frame.
-- So valid_frame_sync will assert after first frame and then every frame
-- after that.
--*****************************************************************************
-- Qualify frame sync with valid parameters to allow for
-- clean video startup
valid_frame_sync_i <= frame_sync and video_prmtrs_valid;

--*****************************************************************************
-- Frame Sync For Masking FSync OUT when shutting down channel for
-- FrmCntEn Mode and frame count reached. (cannot move in time)
--*****************************************************************************
-- Pass combinatorial version for frame_count enable masking in axi_vdma_fsync_gen.
valid_frame_sync_cmb    <= valid_frame_sync_i;


--*****************************************************************************
-- INTIAL Frame Flag
-- Used to keep frame_number at Zero for intial frame
--*****************************************************************************

-- Flag used for intializing frame number to 0.  Will
-- hold frame number at 0 until a valid frame sync
-- occurs.
REG_INITIAL_FRAME_FLAG : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0' or dmasr_halt = '1')then
                initial_frame  <= '0';
            elsif(frame_sync = '1')then
                initial_frame  <= '1';
            end if;
        end if;
    end process REG_INITIAL_FRAME_FLAG;


--*****************************************************************************
-- Frame Store Error Address (
--  Frame number currently being operated on from a memory map perspective.
--  Needed because axi stream can complete significanly prior to memory map
--  completion on S2MM writes allowing for an external fsync to be seen before
--  all status is returned from datamover.  This memory mapped based frame
--  number allows the correct frame store pointer to be updated to the
--  PARK_PTR_REF register during error events.
--*****************************************************************************
GEN_FRMSTORE_EXTFSYNC : if C_USE_FSYNC = 1 generate
begin
    -- Register all idle to generate re pulse for error frame store process
    REG_IDLE_RE : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' )then
                    all_idle_d1 <= '0';
                else
                    all_idle_d1 <= all_idle_i;
                end if;
            end if;
        end process REG_IDLE_RE;

        all_idle_re <= all_idle_i and not all_idle_d1;

    -- Case 2: Fsync asserts before Idle
    -- If this case and not case 3 (below) then do not sample
    -- frame_number but use s_h_frame_number.
    LATE_IDLE_CASE : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0' or all_idle_re = '1' or video_prmtrs_valid = '0')then
                    late_idle <= '0';
                elsif(frame_sync = '1' and all_idle_i = '0')then
                    late_idle <= '1';
                end if;
            end if;
        end process LATE_IDLE_CASE;

    -- Sample and hold frame number for special "late idle" case
    -- i.e. when memory map write does not complete before external
    -- fsync in asserts
    S_H_FRAME : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    s_h_frame_number <= (others => '0');
                elsif(frame_sync = '1')then
                    s_h_frame_number <= frame_number_i;
                end if;
            end if;
        end process S_H_FRAME;

    -- Sample current frame.  If normal fsync to idle relationship
    -- then pass frame_number.  If idle occurs after fsync then
    -- pass sample-n-held frame number.
----    REG_FRMSTORE_FRAME : process(prmry_aclk)
----        begin
----            if(prmry_aclk'EVENT and prmry_aclk = '1')then
----                -- Reset on reset and also on error delayed 1 to prevent re-assertion on transient
----                -- conditions causing wrong error frame to be logged.
----                --if(prmry_resetn = '0' or zero_size_err_d1 = '1')then
----                if(prmry_resetn = '0')then
----                    frmstr_err_addr <= (others => '0');
----                    update_frmstore   <= '0';
----
----                -- On frame size mismatch, late idle will be asserted and need
----                -- to latch in last frame (i.e. sample and held frame) into
----                -- the frame store register.
----                elsif(late_idle = '1' and fsize_mismatch_err_i = '1')then
----                    frmstr_err_addr <= s_h_frame_number;
----                    update_frmstore   <= '1';
----
----                -- 
----                -- needed because these two errors are detected at the completion
----                -- of a frame
----                --elsif(zero_size_err_re = '1')then
----                elsif(zero_size_err = '1' or fsize_mismatch_err_i = '1')then
----                    frmstr_err_addr <= frame_number_i;
----                    update_frmstore   <= '1';
----
----                -- Not in Park mode and Idle occurs after fsync therefore
----                -- pass sample-n-held frm number
----                -- 
----                --elsif(late_idle = '1' and all_idle_re = '1')then
----                elsif(late_idle = '1' and all_idle_re = '1' and circular_prk_mode = '1')then
----                    frmstr_err_addr <= s_h_frame_number;
----                    update_frmstore   <= '1';
----
----                -- On idle assertion latch current frame number
----                -- 
----                --elsif(all_idle_re = '1')then
----                elsif(all_idle_re = '1' or circular_prk_mode = '0')then
----                    frmstr_err_addr <= frame_number_i;
----                    update_frmstore   <= '1';
----                --else
----                --    update_frmstore   <= '0';
----                end if;
----            end if;
----        end process REG_FRMSTORE_FRAME;

    frmstr_err_addr <= frame_number_i;
    update_frmstore   <= '1';
end generate GEN_FRMSTORE_EXTFSYNC;

-- If configured for internal fsync then can simply pass
-- frame number to framestore value.
GEN_FRMSTORE_INTFSYNC : if C_USE_FSYNC = 0 generate
begin
    frmstr_err_addr <= frame_number_i;
    update_frmstore   <= '1';
end generate GEN_FRMSTORE_INTFSYNC;


--*****************************************************************************
-- Dynamic Frame Store Support
--*****************************************************************************
-- One less than setting of number of frame stores.  Use for reverse
-- flag toggle
num_fstore_minus1_cmb <= std_logic_vector(unsigned(num_frame_store) - 1);

REG_NUM_FSTR_MINUS1 : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                num_fstore_minus1 <= (others =>'0');
            else
                num_fstore_minus1 <= num_fstore_minus1_cmb(FRAME_NUMBER_WIDTH-1 downto 0);
            end if;
        end if;
    end process REG_NUM_FSTR_MINUS1;
--*****************************************************************************
-- Dynamic GenLock Slave Mode
--*****************************************************************************


-- Frame counter for Dynamic GenLock Slave Mode


DYNAMIC_SLAVE_MODE_FRAME_CNT : if C_GENLOCK_MODE = 3 generate
signal reg_frame_number_ds    : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0)  := (others => '0');
signal rst_to_frame_zero        : std_logic := '0';
signal valid_frame_sync_d1      : std_logic := '0';
--signal valid_frame_sync_d2      : std_logic := '0';
begin

    -- Register qualified frame sync (i.e. valid parameters and frame_sync)
    -- for use in IOC Threshold count wr to hold counter at intial
    -- value until after first frame.  This is done in axi_vdma_reg_module.vhd
    DS_REG_VALID_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    valid_frame_sync    <= '0';
                    valid_frame_sync_d1 <= '0';
                    valid_frame_sync_d2 <= '0';
                else
                    valid_frame_sync_d1 <= valid_frame_sync_i;
                    valid_frame_sync_d2 <= valid_frame_sync_d1;
                    valid_frame_sync    <= valid_frame_sync_d2;
                end if;
            end if;
        end process DS_REG_VALID_FSYNC_OUT;

    -- Frame sync for test vector, delay counter, and threshold counter
    -- Register test vector signals out.  Also used for
    -- delay timer and threshold counter.
    -- Mask with valid video parameters to prevent delay counter
    -- from counting at start up for external fsyncs that can
    -- be coming in long before starting.
    -- Note: tstvect_fsync output needs to be aligned exactly
    -- with valid_frame_sync output for use in register module to
    -- reset threshold counter on first frame but not on subsequent
    -- frames.
    -- coverage off
    DS_PROCESS_TSTVECTOR_REG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    tstvect_fsync_d1    <= '0';
                    tstvect_fsync_d2    <= '0';
                    tstvect_fsync       <= '0';
                else
                    tstvect_fsync_d1    <= frame_sync;
                    tstvect_fsync_d2    <= tstvect_fsync_d1;
                    tstvect_fsync       <= tstvect_fsync_d2
                                            and video_prmtrs_valid;

                end if;
            end if;
        end process DS_PROCESS_TSTVECTOR_REG;
    -- coverage on

    -- Pass frame number out for test vector
    -- used in verification only
    
--tstvect_frame   <= frame_number_i;

    -- coverage off
    DS_TSTVECT_FRM_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frame <= (others => '0');
                    	elsif (dmasr_halt = '0') then
            			tstvect_frame <= frame_number_i;
                    	--else 
            		--	tstvect_frame <= tstvect_frame;
                    	end if;
                    end if;

        end process DS_TSTVECT_FRM_OUT;

    -- coverage on

    -- Calculate frame to work on based on frame delay
    DS_GEN_FSTORE_GRTR_ONE : if C_NUM_FSTORES > 1 generate
    begin

        -- Register to break long timing paths
        DS_REG_EXT_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        reg_frame_number_ds <= (others => '0');
                    else 
                        reg_frame_number_ds <= slv_frame_ref_out;
                    end if;
                end if;
            end process DS_REG_EXT_FRM_NUMBER;

    end generate DS_GEN_FSTORE_GRTR_ONE;

    DS_GEN_FSTORE_EQL_ONE : if C_NUM_FSTORES = 1 generate
    begin
        reg_frame_number_ds <= slv_frame_ref_out;

    end generate DS_GEN_FSTORE_EQL_ONE;

    --*************************************************************************
    --** VERIFICATION ONLY RTL
    --*************************************************************************
    -- coverage off
   -- TSTVECT_FTPTR_OUT : process(reg_frame_number_ds)
    DS_TSTVECT_FTPTR_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frm_ptr_out <= (others => '0');
                    	elsif (dmasr_halt = '0') then
            			tstvect_frm_ptr_out <= reg_frame_number_ds(FRAME_NUMBER_WIDTH-1 downto 0);
			--else 
				--tstvect_frm_ptr_out <= tstvect_frm_ptr_out;
                    	end if;
                    end if;

        end process DS_TSTVECT_FTPTR_OUT;

    -- coverage on
    --*************************************************************************
    --** END VERIFICATION ONLY RTL
    --*************************************************************************

    -------------------------------------------------------------------------------
    -- Include State Machine and support logic
    -------------------------------------------------------------------------------
    rst_to_frame_zero <= '1' when (dmasr_halt = '1')
                               or (initial_frame = '0' and sync_enable = '0' and circular_prk_mode = '1')
                    else '0';

    -- 
    -- Delay fsync 2 pipeline stages to allow crnt_frmdly to propogate to
    -- the correct value for frame_number_i sampling for genlock slave mode
    DS_REG_DELAY_FSYNC : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    frame_sync_d1 <= '0';
                    frame_sync_d2 <= '0';
                else
                    frame_sync_d1 <= frame_sync;
                    frame_sync_d2 <= frame_sync_d1;
                end if;
            end if;
        end process DS_REG_DELAY_FSYNC;

    -- Frame Number generation
    DS_REG_FRAME_COUNT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear at reset or stopped or first valid fsync not occured
                if(prmry_resetn = '0' or rst_to_frame_zero = '1')then
                    frame_number_i <= (others => '0');

                -- GenLock Mode and Not in Park Mode (i.e. in tail ptr mode)
                -- elsif(valid_frame_sync_i = '1' and sync_enable = '1' and circular_prk_mode = '1')then
                -- latch with frame_sync when doing gen lock to proper capture initial frame ptr in.
                -- 
                --elsif(frame_sync = '1' and sync_enable = '1' and circular_prk_mode = '1')then
 
               --elsif(frame_sync_d2 = '1' and sync_enable = '1' and circular_prk_mode = '1')then



                --elsif(fsize_mismatch_err_flag_i= '1')then
                elsif(flag_to_repeat_after_fsize_less_err= '1')then
                        frame_number_i <= frame_number_i;



                elsif(valid_frame_sync_d2 = '1' and sync_enable = '1' and circular_prk_mode = '1')then
                        frame_number_i <= reg_frame_number_ds(FRAME_NUMBER_WIDTH-1 downto 0);

                -- Otherwise all other changes are on frame sync boudnary.
                elsif(valid_frame_sync_d2 = '1')then
                    -- If Park is enabled
                    if(circular_prk_mode = '0')then
                        frame_number_i  <= frame_ptr_ref;
                    -- Frame count reached terminal count therefore roll count over
                    --elsif(frame_number_i = FRAME_NUMBER_TC)then
                    elsif(frame_number_i = num_fstore_minus1)then
                        frame_number_i <= (others => '0');
                    -- Increment frame count with each sync if valid prmtr values
                    -- stored.
                    else
                        frame_number_i <= std_logic_vector(unsigned(frame_number_i) + 1);
                    end if;

                end if;
            end if;
        end process DS_REG_FRAME_COUNT;

    frame_number <= frame_number_i;


--pass Dynamic Genlock Slave's current working frame number for grey encoding and then output

mstr_frame_ref_in <= frame_number_i;


        REG_CURR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        chnl_current_frame <= (others => '0');
                    else 
                        chnl_current_frame <= frame_number_i;
                    end if;
                end if;
            end process REG_CURR_FRM_NUMBER;

----chnl_current_frame <= frame_number_i;
----genlock_pair_frame <= slv_frame_ref_out;

        REG_PAIR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        genlock_pair_frame <= (others => '0');
                    else 
                        genlock_pair_frame <= slv_frame_ref_out;
                    end if;
                end if;
            end process REG_PAIR_FRM_NUMBER;


end generate DYNAMIC_SLAVE_MODE_FRAME_CNT;





--*****************************************************************************
-- GEN-LOCK Slave Mode
--*****************************************************************************
-- Frame counter for Gen-Lock Slave Mode
SLAVE_MODE_FRAME_CNT : if C_GENLOCK_MODE = 1 generate
constant ONE_FSTORE             : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0)
                                    := std_logic_vector(to_unsigned(1,NUM_FRM_STORE_WIDTH));
signal ext_frame_number_grtr    : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal ext_frame_number_lesr    : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal reg_frame_number_grtr    : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal reg_frame_number_lesr    : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal ext_slv_frmref           : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal ext_crnt_frmdly          : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal ext_num_fstore           : std_logic_vector(NUM_FRM_STORE_WIDTH downto 0)  := (others => '0');
signal rst_to_frame_zero        : std_logic := '0';
signal valid_frame_sync_d1      : std_logic := '0';
--signal valid_frame_sync_d2      : std_logic := '0';
begin

    -- Register qualified frame sync (i.e. valid parameters and frame_sync)
    -- for use in IOC Threshold count wr to hold counter at intial
    -- value until after first frame.  This is done in axi_vdma_reg_module.vhd
    S_REG_VALID_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    valid_frame_sync    <= '0';
                    valid_frame_sync_d1 <= '0';
                    valid_frame_sync_d2 <= '0';
                else
                    valid_frame_sync_d1 <= valid_frame_sync_i;
                    valid_frame_sync_d2 <= valid_frame_sync_d1;
                    valid_frame_sync    <= valid_frame_sync_d2;
                end if;
            end if;
        end process S_REG_VALID_FSYNC_OUT;

    -- Frame sync for test vector, delay counter, and threshold counter
    -- Register test vector signals out.  Also used for
    -- delay timer and threshold counter.
    -- Mask with valid video parameters to prevent delay counter
    -- from counting at start up for external fsyncs that can
    -- be coming in long before starting.
    -- Note: tstvect_fsync output needs to be aligned exactly
    -- with valid_frame_sync output for use in register module to
    -- reset threshold counter on first frame but not on subsequent
    -- frames.
    S_PROCESS_TSTVECTOR_REG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    tstvect_fsync_d1    <= '0';
                    tstvect_fsync_d2    <= '0';
                    tstvect_fsync       <= '0';
                else
                    tstvect_fsync_d1    <= frame_sync;
                    tstvect_fsync_d2    <= tstvect_fsync_d1;
                    tstvect_fsync       <= tstvect_fsync_d2
                                            and video_prmtrs_valid;

                end if;
            end if;
        end process S_PROCESS_TSTVECTOR_REG;

    -- Pass frame number out for test vector
    -- used in verification only
    --tstvect_frame   <= frame_number_i;
    -- coverage off
    S_TSTVECT_FRM_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frame <= (others => '0');
                    	elsif (dmasr_halt = '0') then
            			tstvect_frame <= frame_number_i;
                    	--else 
            		--	tstvect_frame <= tstvect_frame;
                    	end if;
                    end if;

        end process S_TSTVECT_FRM_OUT;
    -- coverage on



    -- Calculate frame to work on based on frame delay
    GEN_FSTORE_GRTR_ONE : if C_NUM_FSTORES > 1 generate
    begin
        -- Extend unsigned vectors by 1 bit to allow for
        -- carry out during addition.
        --ext_slv_frmref  <= '0' & slv_frame_ref_out;
        --ext_crnt_frmdly <= '0' & crnt_frmdly;
        ext_slv_frmref  <= "00" & slv_frame_ref_out;
        ext_crnt_frmdly <= "00" & crnt_frmdly;
        ext_num_fstore  <= '0' & num_frame_store;

        -- Calculate for when frame delay less than or equal to slave frame ref. This is
        -- normal operation where a simple subtraction of frame delay from slave frame ref
        -- will work.
        ext_frame_number_lesr <= std_logic_vector(unsigned(ext_slv_frmref)
                                                    - unsigned(ext_crnt_frmdly));

        -- Calculate for when frame delay greater than slave frame ref.  This is roll-over
        -- point, i.e. if slave frame ref = 0 then you want frame number to be C_NUM_FSTORES-1
        -- This can be calculated with (C_NUM_FSTORES + Slave Frame Ref) - Frame Delay
        --ext_frame_number_grtr  <= std_logic_vector( (C_NUM_FSTORES + unsigned(ext_slv_frmref))
        --                                            - unsigned(ext_crnt_frmdly));
        ext_frame_number_grtr  <= std_logic_vector( (unsigned(ext_num_fstore) + unsigned(ext_slv_frmref))
                                                    - unsigned(ext_crnt_frmdly));


        -- Register to break long timing paths
        REG_EXT_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        reg_frame_number_grtr <= (others => '0');
                        reg_frame_number_lesr <= (others => '0');

                    -- If frame stores set to 1 then simply pass unmodified version
                    -- through
                    elsif(num_frame_store = ONE_FSTORE)then
                        reg_frame_number_grtr <= ext_slv_frmref;
                        reg_frame_number_lesr <= ext_slv_frmref;

                    else
                        reg_frame_number_grtr <= ext_frame_number_grtr;
                        reg_frame_number_lesr <= ext_frame_number_lesr;
                    end if;
                end if;
            end process REG_EXT_FRM_NUMBER;

    end generate GEN_FSTORE_GRTR_ONE;

    -- For frame stores = 1 then frame delay has no meaning.
    GEN_FSTORE_EQL_ONE : if C_NUM_FSTORES = 1 generate
    begin
        reg_frame_number_grtr <= ext_slv_frmref;
        reg_frame_number_lesr <= ext_slv_frmref;

    end generate GEN_FSTORE_EQL_ONE;

    --*************************************************************************
    --** VERIFICATION ONLY RTL
    --*************************************************************************
    -- coverage off
----    TSTVECT_FTPTR_OUT : process(crnt_frmdly,
----                                slv_frame_ref_out,
----                                reg_frame_number_lesr,
----                                reg_frame_number_grtr)
----        begin
----            if(crnt_frmdly <= slv_frame_ref_out)then
----                tstvect_frm_ptr_out <= reg_frame_number_lesr(FRAME_NUMBER_WIDTH-1 downto 0);
----            else
----                tstvect_frm_ptr_out <= reg_frame_number_grtr(FRAME_NUMBER_WIDTH-1 downto 0);
----            end if;
----        end process TSTVECT_FTPTR_OUT;


    S_TSTVECT_FTPTR_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frm_ptr_out <= (others => '0');
                    	elsif (dmasr_halt = '0') then
		            if(crnt_frmdly <= slv_frame_ref_out)then
		                tstvect_frm_ptr_out <= reg_frame_number_lesr(FRAME_NUMBER_WIDTH-1 downto 0);
		            else
		                tstvect_frm_ptr_out <= reg_frame_number_grtr(FRAME_NUMBER_WIDTH-1 downto 0);
		            end if;
			--else 
				--tstvect_frm_ptr_out <= tstvect_frm_ptr_out;
                    	end if;
                    end if;

        end process S_TSTVECT_FTPTR_OUT;



    -- coverage on
    --*************************************************************************
    --** END VERIFICATION ONLY RTL
    --*************************************************************************

    -------------------------------------------------------------------------------
    -- Include State Machine and support logic
    -------------------------------------------------------------------------------
    rst_to_frame_zero <= '1' when (dmasr_halt = '1')
                               or (initial_frame = '0' and sync_enable = '0' and circular_prk_mode = '1')
                    else '0';

    -- 
    -- Delay fsync 2 pipeline stages to allow crnt_frmdly to propogate to
    -- the correct value for frame_number_i sampling for genlock slave mode
    REG_DELAY_FSYNC : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    frame_sync_d1 <= '0';
                    frame_sync_d2 <= '0';
                else
                    frame_sync_d1 <= frame_sync;
                    frame_sync_d2 <= frame_sync_d1;
                end if;
            end if;
        end process REG_DELAY_FSYNC;

    -- Frame Number generation
    REG_FRAME_COUNT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear at reset or stopped or first valid fsync not occured
                if(prmry_resetn = '0' or rst_to_frame_zero = '1')then
                    frame_number_i <= (others => '0');

                -- GenLock Mode and Not in Park Mode (i.e. in tail ptr mode)
                -- elsif(valid_frame_sync_i = '1' and sync_enable = '1' and circular_prk_mode = '1')then
                -- latch with frame_sync when doing gen lock to proper capture initial frame ptr in.
                -- 
                --elsif(frame_sync = '1' and sync_enable = '1' and circular_prk_mode = '1')then


                --elsif(fsize_mismatch_err_flag_i= '1')then
                elsif(flag_to_repeat_after_fsize_less_err= '1')then
                        frame_number_i <= frame_number_i;


                elsif(frame_sync_d2 = '1' and sync_enable = '1' and circular_prk_mode = '1')then
                    -- If frame delay less than or equal slave frame reference
                    -- then simply subtract
                    if(crnt_frmdly <= slv_frame_ref_out)then
                        frame_number_i <= reg_frame_number_lesr(FRAME_NUMBER_WIDTH-1 downto 0);
                    else
                        frame_number_i <= reg_frame_number_grtr(FRAME_NUMBER_WIDTH-1 downto 0);
                    end if;

                -- Otherwise all other changes are on frame sync boudnary.
                elsif(valid_frame_sync_d2 = '1')then
                    -- If Park is enabled
                    if(circular_prk_mode = '0')then
                        frame_number_i  <= frame_ptr_ref;
                    -- Frame count reached terminal count therefore roll count over
                    --elsif(frame_number_i = FRAME_NUMBER_TC)then
                    elsif(frame_number_i = num_fstore_minus1)then
                        frame_number_i <= (others => '0');
                    -- Increment frame count with each sync if valid prmtr values
                    -- stored.
                    else
                        frame_number_i <= std_logic_vector(unsigned(frame_number_i) + 1);
                    end if;

                end if;
            end if;
        end process REG_FRAME_COUNT;

    frame_number <= frame_number_i;

    
--pass Genlock Slave's current working frame number for grey encoding and then output -- 
--mstr_frame_ref_in <= (others =>  '0'); -- Not Used in Slave Mode

mstr_frame_ref_in <= frame_number_i;   -- 





        REG_CURR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        chnl_current_frame <= (others => '0');
                    else 
                        chnl_current_frame <= frame_number_i;
                    end if;
                end if;
            end process REG_CURR_FRM_NUMBER;

----chnl_current_frame <= frame_number_i;
----genlock_pair_frame <= slv_frame_ref_out;

        REG_PAIR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        genlock_pair_frame <= (others => '0');
                    else 
                        genlock_pair_frame <= slv_frame_ref_out;
                    end if;
                end if;
            end process REG_PAIR_FRM_NUMBER;



end generate SLAVE_MODE_FRAME_CNT;

--*****************************************************************************
-- Dynamic GenLock Master Mode
--*****************************************************************************
-- Frame counter for Gen-Lock Master Mode
DYNAMIC_MASTER_MODE_FRAME_CNT : if C_GENLOCK_MODE = 2 generate
signal valid_frame_sync_d1      		 : std_logic := '0';
--signal flag_to_repeat_after_fsize_less_err     : std_logic := '0'; 
--signal valid_frame_sync_d2      : std_logic := '0';
begin


    -- Register qualified frame sync (i.e. valid parameters and frame_sync)
    -- for use in IOC Threshold count wr to hold counter at intial
    -- value until after first frame.  This is done in axi_vdma_reg_module.vhd
    DM_REG_VALID_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    valid_frame_sync    <= '0';
                    valid_frame_sync_d1 <= '0';
                    valid_frame_sync_d2 <= '0';
                else
                    valid_frame_sync_d1 <= valid_frame_sync_i;
                    valid_frame_sync_d2 <= valid_frame_sync_d1;
                    valid_frame_sync    <= valid_frame_sync_d2;
                end if;
            end if;
        end process DM_REG_VALID_FSYNC_OUT;

    -- Frame sync for test vector, delay counter, and threshold counter
    -- Register test vector signals out.  Also used for
    -- delay timer and threshold counter.
 ----   DM_PROCESS_TSTVECTOR_REG : process(prmry_aclk)
 ----       begin
 ----           if(prmry_aclk'EVENT and prmry_aclk = '1')then
 ----               if(prmry_resetn = '0')then
 ----                   tstvect_fsync_d1<= '0';
 ----                   tstvect_fsync_d2<= '0';
 ----                   tstvect_frame   <= (others => '0');
 ----               else
 ----                   tstvect_fsync_d1<= frame_sync;
 ----                   tstvect_fsync_d2<= tstvect_fsync_d1;
 ----                   tstvect_frame   <= frame_number_i;
 ----               end if;
 ----           end if;
 ----       end process DM_PROCESS_TSTVECTOR_REG;
    -- coverage off
    DM_PROCESS_TSTVECTOR_REG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    tstvect_fsync_d1    <= '0';
                    tstvect_fsync_d2    <= '0';
                    tstvect_fsync       <= '0';
                else
                    tstvect_fsync_d1    <= frame_sync;
                    tstvect_fsync_d2    <= tstvect_fsync_d1;
                    tstvect_fsync       <= tstvect_fsync_d2
                                            and video_prmtrs_valid;

                end if;
            end if;
        end process DM_PROCESS_TSTVECTOR_REG;
    DM_TSTVECT_FRM_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frame <= (others => '0');
                    	elsif (dmasr_halt = '0') then
            			tstvect_frame <= frame_number_i;
                    	--else 
            		--	tstvect_frame <= tstvect_frame;
                    	end if;
                    end if;

        end process DM_TSTVECT_FRM_OUT;
    -- coverage on


    -- Mask with valid video parameters to prevent delay counter
    -- from counting at start up for external fsyncs that can
    -- be coming in long before starting.
    -- video_prmtrs_valid asserts on clock cycle following assertion
    -- of frame_sync, thus pipeline delay to create tstvect_fsync_d1
    -- is required to assert first fsync for first valid frame
    -- Note: tstvect_fsync output needs to be aligned exactly
    -- with valid_frame_sync output for use in register module to
    -- reset threshold counter on first frame but not on subsequent
    -- frames.
    --tstvect_fsync <= tstvect_fsync_d1 and video_prmtrs_valid;
    --tstvect_fsync <= tstvect_fsync_d2 and video_prmtrs_valid;

    DM_GEN_FSTORE_GRTR_TWO : if C_NUM_FSTORES > 2 generate
    begin
    -------------------------------------------------------------------------------
    -- Include State Machine and support logic
    -------------------------------------------------------------------------------
    -- Frame Number generation
    DM_REG_FRAME_COUNT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear at reset or stopped or first valid fsync not occured
                if(prmry_resetn = '0' or dmasr_halt = '1'
                or (circular_prk_mode = '1' and initial_frame = '0') or num_fstore_equal_one = '1')then

                    frame_number_i <= (others => '0');
                -- If Park is enabled then on frame sync transision to
                -- frame pointer reference.



                --elsif(fsize_mismatch_err_flag_i= '1')then
                elsif(flag_to_repeat_after_fsize_less_err= '1')then
                        frame_number_i <= frame_number_i;




                elsif(valid_frame_sync_d2 = '1' and circular_prk_mode = '0')then
                    frame_number_i <= frame_ptr_ref;
------------------------------------------------------------------------------------------------------------
                -- On Repeat Frame simply hold current frame number (
                --elsif(repeat_frame = '1')then
                elsif(repeat_frame = '1' and dmacr_repeat_en = '1')then
                    frame_number_i <= repeat_frame_nmbr;
------------------------------------------------------------------------------------------------------------
                -- Frame count reached terminal count therefore roll count over
                --elsif(valid_frame_sync_i = '1' and frame_number_i = FRAME_NUMBER_TC)then
                elsif(valid_frame_sync_d2 = '1'  and sync_enable = '1' and frame_number_i = num_fstore_minus1 and (slv_frame_ref_out /= "00000"))then
                    frame_number_i <= (others => '0');
  
                elsif(valid_frame_sync_d2 = '1'  and sync_enable = '1' and frame_number_i = num_fstore_minus1 and (slv_frame_ref_out = "00000"))then
                    frame_number_i <= "00001";
                elsif(valid_frame_sync_d2 = '1'  and sync_enable = '1' and slv_frame_ref_out = num_fstore_minus1 and (frame_number_i = std_logic_vector(unsigned(slv_frame_ref_out) - 1)))then
                    frame_number_i <= (others => '0');

                elsif(valid_frame_sync_d2 = '1'  and sync_enable = '1' and (slv_frame_ref_out /= num_fstore_minus1) and (slv_frame_ref_out /= "00000") and (frame_number_i = std_logic_vector(unsigned(slv_frame_ref_out) - 1)))then
                    frame_number_i <= std_logic_vector(unsigned(frame_number_i) + 2);
                -- Increment frame count with each sync if valid prmtr values
                -- stored.


                elsif(valid_frame_sync_d2 = '1' and frame_number_i = num_fstore_minus1)then
                    frame_number_i <= (others => '0');


                elsif(valid_frame_sync_d2 = '1')then
                    frame_number_i <= std_logic_vector(unsigned(frame_number_i) + 1);
                end if;
            end if;
        end process DM_REG_FRAME_COUNT;
    end generate DM_GEN_FSTORE_GRTR_TWO;



   DM_GEN_FSTORES_EQL_TWO : if C_NUM_FSTORES = 2 generate
   begin
    -------------------------------------------------------------------------------
    -- Include State Machine and support logic
    -------------------------------------------------------------------------------
    -- Frame Number generation
    DM_REG_FRAME_COUNT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear at reset or stopped or first valid fsync not occured
                if(prmry_resetn = '0' or dmasr_halt = '1'
                or (circular_prk_mode = '1' and initial_frame = '0') or num_fstore_equal_one = '1')then

                    frame_number_i <= (others => '0');
                -- If Park is enabled then on frame sync transision to
                -- frame pointer reference.



                --elsif(fsize_mismatch_err_flag_i= '1')then
                elsif(flag_to_repeat_after_fsize_less_err= '1')then
                        frame_number_i <= frame_number_i;




                elsif(valid_frame_sync_d2 = '1' and circular_prk_mode = '0')then
                    frame_number_i <= frame_ptr_ref;
------------------------------------------------------------------------------------------------------------
                -- On Repeat Frame simply hold current frame number (
                --elsif(repeat_frame = '1')then
                elsif(repeat_frame = '1' and dmacr_repeat_en = '1')then
                    frame_number_i <= repeat_frame_nmbr;
------------------------------------------------------------------------------------------------------------
                -- Frame count reached terminal count therefore roll count over
                --elsif(valid_frame_sync_i = '1' and frame_number_i = FRAME_NUMBER_TC)then
                elsif(valid_frame_sync_d2 = '1' and sync_enable = '1' and (frame_number_i = "00001") and (slv_frame_ref_out = "00001"))then
                    frame_number_i <= (others => '0');
  
                elsif(valid_frame_sync_d2 = '1' and sync_enable = '1' and (frame_number_i = "00001") and (slv_frame_ref_out = "00000"))then
                    frame_number_i <= "00001";
                elsif(valid_frame_sync_d2 = '1' and sync_enable = '1' and (frame_number_i = "00000") and (slv_frame_ref_out = "00001"))then
                    frame_number_i <= (others => '0');

                elsif(valid_frame_sync_d2 = '1' and sync_enable = '1' and (frame_number_i = "00000") and (slv_frame_ref_out = "00000"))then
                    frame_number_i <="00001" ;


                elsif(valid_frame_sync_d2 = '1' and frame_number_i = "00001")then
                    frame_number_i <= (others => '0');


                elsif(valid_frame_sync_d2 = '1' and frame_number_i = "00000")then
                    frame_number_i <="00001" ;
                end if;
            end if;
        end process DM_REG_FRAME_COUNT;



   end generate DM_GEN_FSTORES_EQL_TWO;




   DM_GEN_FSTORES_EQL_ONE : if C_NUM_FSTORES = 1 generate
   begin

                    frame_number_i <= (others => '0');


   end generate DM_GEN_FSTORES_EQL_ONE;

    DM_GEN_REPEAT_FRM_FSIZE_LESS_ERR_SOF : if C_MM2S_SOF_ENABLE = 1 or C_S2MM_SOF_ENABLE = 1 generate
    begin

		DM_REPEAT_EN_FSIZE_LESS_ERR_FLAG : process(prmry_aclk)
		    begin
		        if(prmry_aclk'EVENT and prmry_aclk = '1')then
		            if(prmry_resetn = '0' or valid_frame_sync_d2 = '1')then
		                flag_to_repeat_after_fsize_less_err  <= '0';
		            elsif(fsize_mismatch_err_i = '1')then
		                flag_to_repeat_after_fsize_less_err  <= '1';
		            end if;
		        end if;
		    end process DM_REPEAT_EN_FSIZE_LESS_ERR_FLAG;
    end generate DM_GEN_REPEAT_FRM_FSIZE_LESS_ERR_SOF;
		
    DM_GEN_REPEAT_FRM_FSIZE_LESS_ERR_NO_SOF : if C_MM2S_SOF_ENABLE = 0 and C_S2MM_SOF_ENABLE = 0 generate
    begin

			       flag_to_repeat_after_fsize_less_err  <= '0';
		            
    end generate DM_GEN_REPEAT_FRM_FSIZE_LESS_ERR_NO_SOF;
		



    -- If flush on frame sync enabled and genlock repeat frame enabled
    -- then repeat errored frame on next frame sync. (
--    DM_GEN_REPEAT_FRM_LOGIC : if C_GENLOCK_REPEAT_EN = 1 and C_ENABLE_FLUSH_ON_FSYNC = 1 generate
--    begin


        DM_REPEAT_FRAME_PROCESS : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    ----if(prmry_resetn = '0' or valid_frame_sync_d2 = '1')then
                    if(prmry_resetn = '0' or (valid_frame_sync_d2 = '1' and flag_to_repeat_after_fsize_less_err = '0'))then
                        repeat_frame_nmbr <= (others => '0');
                        repeat_frame <= '0';

                    -- Frame size mismatch
                    elsif(fsize_mismatch_err_i='1' or flag_to_repeat_after_fsize_less_err = '1')then
                        repeat_frame_nmbr <= s_h_frame_number;
                        repeat_frame      <= '1';

                    -- Line size mismatch
                    elsif(lsize_mismatch_err_i='1' or lsize_more_mismatch_err_i ='1')then
                        repeat_frame_nmbr <= frame_number_i;
                        repeat_frame      <= '1';

                    end if;
                end if;
            end process DM_REPEAT_FRAME_PROCESS;
--    end generate DM_GEN_REPEAT_FRM_LOGIC;





----    -- Not in flush on frame sync mode or repeat frame not enabled (
----    DM_GEN_NO_REPEAT_FRM_LOGIC : if C_GENLOCK_REPEAT_EN = 0 or C_ENABLE_FLUSH_ON_FSYNC = 0 generate
----    begin
----        -- never repeat frame
----        repeat_frame        <= '0';
----        repeat_frame_nmbr   <= (others => '0');
----
----    end generate DM_GEN_NO_REPEAT_FRM_LOGIC;

    -- Pass Frame sync to video
    mstr_frame_ref_in <= dm_prev_frame_number;

    -- Pass frame number out to register module
    frame_number <= frame_number_i;

    -- Drive test vector to zero for GenLock master mode
    --tstvect_frm_ptr_out <= (others => '0');
    -- Drive test vector for Dynamic GenLock master mode
    --tstvect_frm_ptr_out <= slv_frame_ref_out;

    -- coverage off
   -- TSTVECT_FTPTR_OUT : process(reg_frame_number_ds)
    DM_TSTVECT_FTPTR_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frm_ptr_out <= (others => '0');
                    	elsif (dmasr_halt = '0') then
    				tstvect_frm_ptr_out <= slv_frame_ref_out;
			--else 
				--tstvect_frm_ptr_out <= tstvect_frm_ptr_out;
                    	end if;
                    end if;

        end process DM_TSTVECT_FTPTR_OUT;

    -- coverage on


    DM_PREV_FRAME : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    dm_prev_frame_number <= (others => '0');
                --elsif(valid_frame_sync_d2 = '1'and repeat_frame = '0' and fsize_mismatch_err_flag_i = '0')then
                ----elsif(valid_frame_sync_d2 = '1'and repeat_frame = '0' and flag_to_repeat_after_fsize_less_err = '0')then
                elsif(valid_frame_sync_d2 = '1'and  (dmacr_repeat_en = '0' or repeat_frame = '0') and flag_to_repeat_after_fsize_less_err = '0')then
                    dm_prev_frame_number <= frame_number_i;
                end if;
            end if;
        end process DM_PREV_FRAME;




        REG_CURR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        chnl_current_frame <= (others => '0');
                    else 
                        chnl_current_frame <= frame_number_i;
                    end if;
                end if;
            end process REG_CURR_FRM_NUMBER;

----chnl_current_frame <= frame_number_i;
----genlock_pair_frame <= slv_frame_ref_out;

        REG_PAIR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        genlock_pair_frame <= (others => '0');
                    else 
                        genlock_pair_frame <= slv_frame_ref_out;
                    end if;
                end if;
            end process REG_PAIR_FRM_NUMBER;



end generate DYNAMIC_MASTER_MODE_FRAME_CNT;

--*****************************************************************************
-- GEN-LOCK MASTER Mode
--*****************************************************************************
-- Frame counter for Gen-Lock Master Mode
MASTER_MODE_FRAME_CNT : if C_GENLOCK_MODE = 0 generate
signal valid_frame_sync_d1      		 : std_logic := '0';
--signal flag_to_repeat_after_fsize_less_err     : std_logic := '0'; 
--signal valid_frame_sync_d2      : std_logic := '0';
begin


    -- Register qualified frame sync (i.e. valid parameters and frame_sync)
    -- for use in IOC Threshold count wr to hold counter at intial
    -- value until after first frame.  This is done in axi_vdma_reg_module.vhd

    M_REG_VALID_FSYNC_OUT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    valid_frame_sync    <= '0';
                    valid_frame_sync_d1 <= '0';
                    valid_frame_sync_d2 <= '0';
                else
                    valid_frame_sync_d1 <= valid_frame_sync_i;
                    valid_frame_sync_d2 <= valid_frame_sync_d1;
                    valid_frame_sync    <= valid_frame_sync_d2;
                end if;
            end if;
        end process M_REG_VALID_FSYNC_OUT;




----    REG_VALID_FSYNC_OUT : process(prmry_aclk)
----        begin
----            if(prmry_aclk'EVENT and prmry_aclk = '1')then
----                if(prmry_resetn = '0')then
----                    valid_frame_sync <= '0';
----                else
----                    valid_frame_sync    <= valid_frame_sync_i;
----                end if;
----            end if;
----        end process REG_VALID_FSYNC_OUT;

    -- Frame sync for test vector, delay counter, and threshold counter
    -- Register test vector signals out.  Also used for
    -- delay timer and threshold counter.
----    PROCESS_TSTVECTOR_REG : process(prmry_aclk)
----        begin
----            if(prmry_aclk'EVENT and prmry_aclk = '1')then
----                if(prmry_resetn = '0')then
----                    tstvect_fsync_d1<= '0';
----                    tstvect_frame   <= (others => '0');
----                else
----                    tstvect_fsync_d1<= frame_sync;
----                    tstvect_frame   <= frame_number_i;
----                end if;
----            end if;
----        end process PROCESS_TSTVECTOR_REG;
    -- coverage off
    M_TSTVECT_FRM_OUT : process(prmry_aclk)
        begin
                    if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    	if(prmry_resetn = '0')then
                        	tstvect_frame <= (others => '0');
                    	elsif (dmasr_halt = '0') then
            			tstvect_frame <= frame_number_i;
                    	--else 
            		--	tstvect_frame <= tstvect_frame;
                    	end if;
                    end if;

        end process M_TSTVECT_FRM_OUT;

    M_PROCESS_TSTVECTOR_REG : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                if(prmry_resetn = '0')then
                    tstvect_fsync_d1    <= '0';
                    tstvect_fsync_d2    <= '0';
                    tstvect_fsync       <= '0';
                else
                    tstvect_fsync_d1    <= frame_sync;
                    tstvect_fsync_d2    <= tstvect_fsync_d1;
                    tstvect_fsync       <= tstvect_fsync_d2
                                            and video_prmtrs_valid;

                end if;
            end if;
        end process M_PROCESS_TSTVECTOR_REG;
    -- coverage on



    -- Mask with valid video parameters to prevent delay counter
    -- from counting at start up for external fsyncs that can
    -- be coming in long before starting.
    -- video_prmtrs_valid asserts on clock cycle following assertion
    -- of frame_sync, thus pipeline delay to create tstvect_fsync_d1
    -- is required to assert first fsync for first valid frame
    -- Note: tstvect_fsync output needs to be aligned exactly
    -- with valid_frame_sync output for use in register module to
    -- reset threshold counter on first frame but not on subsequent
    -- frames.
    --tstvect_fsync <= tstvect_fsync_d1 and video_prmtrs_valid;

    -------------------------------------------------------------------------------
    -- Include State Machine and support logic
    -------------------------------------------------------------------------------
    -- Frame Number generation
    REG_FRAME_COUNT : process(prmry_aclk)
        begin
            if(prmry_aclk'EVENT and prmry_aclk = '1')then
                -- Clear at reset or stopped or first valid fsync not occured
                if(prmry_resetn = '0' or dmasr_halt = '1'
                or (circular_prk_mode = '1' and initial_frame = '0'))then

                    frame_number_i <= (others => '0');
                -- If Park is enabled then on frame sync transision to
                -- frame pointer reference.


                --elsif(fsize_mismatch_err_flag_i= '1')then
                elsif(flag_to_repeat_after_fsize_less_err= '1')then
                        frame_number_i <= frame_number_i;



                elsif(valid_frame_sync_d2 = '1' and circular_prk_mode = '0')then
                    frame_number_i <= frame_ptr_ref;

                -- On Repeat Frame simply hold current frame number (
                --elsif(repeat_frame = '1')then
                elsif(repeat_frame = '1' and dmacr_repeat_en = '1')then
                    frame_number_i <= repeat_frame_nmbr;

                -- Frame count reached terminal count therefore roll count over
                --elsif(valid_frame_sync_i = '1' and frame_number_i = FRAME_NUMBER_TC)then
                elsif(valid_frame_sync_d2 = '1' and frame_number_i = num_fstore_minus1)then
                    frame_number_i <= (others => '0');

                -- Increment frame count with each sync if valid prmtr values
                -- stored.
                elsif(valid_frame_sync_d2 = '1' and video_prmtrs_valid = '1')then
                    frame_number_i <= std_logic_vector(unsigned(frame_number_i) + 1);
                end if;
            end if;
        end process REG_FRAME_COUNT;




    GEN_REPEAT_FRM_FSIZE_LESS_ERR_SOF : if C_MM2S_SOF_ENABLE = 1 or C_S2MM_SOF_ENABLE = 1 generate
    begin

		REPEAT_EN_FSIZE_LESS_ERR_FLAG : process(prmry_aclk)
		    begin
		        if(prmry_aclk'EVENT and prmry_aclk = '1')then
		            if(prmry_resetn = '0' or valid_frame_sync_d2 = '1')then
		                flag_to_repeat_after_fsize_less_err  <= '0';
		            elsif(fsize_mismatch_err_i = '1')then
		                flag_to_repeat_after_fsize_less_err  <= '1';
		            end if;
		        end if;
		    end process REPEAT_EN_FSIZE_LESS_ERR_FLAG;
    end generate GEN_REPEAT_FRM_FSIZE_LESS_ERR_SOF;
		
    GEN_REPEAT_FRM_FSIZE_LESS_ERR_NO_SOF : if C_MM2S_SOF_ENABLE = 0 and C_S2MM_SOF_ENABLE = 0 generate
    begin

			       flag_to_repeat_after_fsize_less_err  <= '0';
		            
    end generate GEN_REPEAT_FRM_FSIZE_LESS_ERR_NO_SOF;
		






    -- If flush on frame sync enabled and genlock repeat frame enabled
    -- then repeat errored frame on next frame sync. (
   -- GEN_REPEAT_FRM_LOGIC : if C_GENLOCK_REPEAT_EN = 1 and C_ENABLE_FLUSH_ON_FSYNC = 1 generate
   -- begin


        REPEAT_FRAME_PROCESS : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    ----if(prmry_resetn = '0' or valid_frame_sync_d2 = '1')then
                    if(prmry_resetn = '0' or (valid_frame_sync_d2 = '1' and flag_to_repeat_after_fsize_less_err = '0'))then
                        repeat_frame_nmbr <= (others => '0');
                        repeat_frame <= '0';

                    -- Frame size mismatch
                    --elsif(fsize_mismatch_err_i='1')then
                    elsif(fsize_mismatch_err_i='1' or flag_to_repeat_after_fsize_less_err='1')then
                        repeat_frame_nmbr <= s_h_frame_number;
                        repeat_frame      <= '1';

                    -- Line size mismatch
                    elsif(lsize_mismatch_err_i='1' or lsize_more_mismatch_err_i ='1')then
                        repeat_frame_nmbr <= frame_number_i;
                        repeat_frame      <= '1';

                    end if;
                end if;
            end process REPEAT_FRAME_PROCESS;
    --end generate GEN_REPEAT_FRM_LOGIC;





----    -- Not in flush on frame sync mode or repeat frame not enabled (
----    GEN_NO_REPEAT_FRM_LOGIC : if C_GENLOCK_REPEAT_EN = 0 or C_ENABLE_FLUSH_ON_FSYNC = 0 generate
----    begin
----        -- never repeat frame
----        repeat_frame        <= '0';
----        repeat_frame_nmbr   <= (others => '0');
----
----    end generate GEN_NO_REPEAT_FRM_LOGIC;

    -- Pass Frame sync to video
    mstr_frame_ref_in <= frame_number_i;

    -- Pass frame number out to register module
    frame_number <= frame_number_i;

    -- Drive test vector to zero for master mode
    tstvect_frm_ptr_out <= (others => '0');

----chnl_current_frame <= frame_number_i;




        REG_CURR_FRM_NUMBER : process(prmry_aclk)
            begin
                if(prmry_aclk'EVENT and prmry_aclk = '1')then
                    if(prmry_resetn = '0')then
                        chnl_current_frame <= (others => '0');
                    else 
                        chnl_current_frame <= frame_number_i;
                    end if;
                end if;
            end process REG_CURR_FRM_NUMBER;

----chnl_current_frame <= frame_number_i;

    genlock_pair_frame <= (others => '0');




end generate MASTER_MODE_FRAME_CNT;

--*****************************************************************************
-- Error Handling
-- For graceful shut down logic
--*****************************************************************************
-- Clear run/stop and stop state machines due to errors or soft reset
-- Error based on datamover error report or sg fetch error
-- SG fetch error included because need to shut down because data maybe corrupt
-- therefor do not want to issue the xfer command to primary datamover
-- Added run_stop to assertion for when run_stop is de-asserted in middle of video
-- frame need to halt datamover to clear out potential pending commands.
stop_i    <= dma_err         -- DMAIntErr, DMADecErr, DMASlvErr, ZeroSize, possibly Frame/Line Mismatch
          or ftch_err         -- SGDecErr, SGSlvErr
          or soft_reset;        -- Soft Reset issued

-- Reg stop out
REG_STOP_OUT : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                stop       <= '0';
            else
                stop       <= stop_i;
            end if;
        end if;
    end process REG_STOP_OUT;

-- For verification only - drive error detection
-- out to test vector port, will be stripped during build
-- (Broke up in order to capture all errors regardless of
-- flush on frame sync mode)
-- coverage off
REG_DELAY_ERR : process(prmry_aclk)
    begin
        if(prmry_aclk'EVENT and prmry_aclk = '1')then
            if(prmry_resetn = '0')then
                err_d1        <= '0';
                tstvect_err   <= '0';
            else
                err_d1        <= slverr       -- DMASlvErr
                                or decerr       -- DMADecErr
                                or interr       -- DMAIntErr, ZeroSize, Frame
				or lsize_mismatch_err_i			-- Line Mismatch
				or lsize_more_mismatch_err_i		-- Line Mismatch
                                or ftch_err;  -- SGSlvErr, SGDecErr

                tstvect_err   <= err_d1;
            end if;
        end if;
    end process REG_DELAY_ERR;
-- coverage on


--*****************************************************************************
-- DMA Control
--*****************************************************************************

---------------------------------------------------------------------------
-- Primary DMA Controller State Machine
---------------------------------------------------------------------------
I_SM : entity  axi_vdma_v6_3_10.axi_vdma_sm
    generic map(
        C_M_AXI_ADDR_WIDTH              => C_M_AXI_ADDR_WIDTH           ,
        C_INCLUDE_SF                    => C_INCLUDE_SF                 ,
        C_USE_FSYNC                     => C_USE_FSYNC                  ,   -- 
        C_ENABLE_FLUSH_ON_FSYNC         => C_ENABLE_FLUSH_ON_FSYNC      ,   -- 
        C_EXTEND_DM_COMMAND             => C_EXTEND_DM_COMMAND          ,
        C_PRMY_CMDFIFO_DEPTH            => C_PRMY_CMDFIFO_DEPTH         ,
        C_MM2S_SOF_ENABLE               => C_MM2S_SOF_ENABLE               ,
        C_S2MM_SOF_ENABLE               => C_S2MM_SOF_ENABLE               ,
        C_PRMRY_IS_ACLK_ASYNC           => C_PRMRY_IS_ACLK_ASYNC               ,
        C_INCLUDE_MM2S                  => C_INCLUDE_MM2S               ,
        C_ENABLE_VERT_FLIP     => C_ENABLE_VERT_FLIP             ,
        C_INCLUDE_S2MM                  => C_INCLUDE_S2MM
    )
    port map(
        prmry_aclk                      => prmry_aclk                   ,
        prmry_resetn                    => prmry_resetn                 ,
  
          scndry_aclk                 => scndry_aclk                 ,
          scndry_resetn               => scndry_resetn                 ,

        -- AXI Stream Qualifiers
        packet_sof                      => packet_sof                   ,

        -- Raw fsync (must use unqualified frame sync for proper sm operation)
        frame_sync                      => frame_sync                   ,

        -- Valid video parameter available
        video_prmtrs_valid              => video_prmtrs_valid           ,

        -- Control and Status
        run_stop                        => run_stop                     ,
        cmnd_idle                       => cmnd_idle                    ,
        sts_idle                        => sts_idle                     ,
        stop                            => stop_i                       ,
        halt                            => halt                         ,
        zero_size_err                   => zero_size_err                ,
        mm2s_fsync_out_m            	=> mm2s_fsync_out_m                  ,
        s2mm_fsync_out_m            	=> s2mm_fsync_out_m                  ,
        mm2s_fsize_mismatch_err_s       => mm2s_fsize_mismatch_err_s         ,   
        mm2s_fsize_mismatch_err_m       => mm2s_fsize_mismatch_err_m         ,   
        s2mm_fsize_mismatch_err_s       => s2mm_fsize_mismatch_err_s         ,   
        fsize_mismatch_err_flag         => fsize_mismatch_err_flag_i         ,   
        fsize_mismatch_err              => fsize_mismatch_err_i         ,   -- 
        all_lines_xfred                 => all_lines_xfred              ,   -- 

        all_lasts_rcvd                  => all_lasts_rcvd             ,   
drop_fsync_d_pulse_gen_fsize_less_err   => drop_fsync_d_pulse_gen_fsize_less_err                      ,
      	s2mm_strm_all_lines_rcvd    	=> s2mm_strm_all_lines_rcvd	,	--      : out std_logic;
      	s2mm_fsync_core    		=> s2mm_fsync_core	,	--      : out std_logic;
 
       -- DataMover Command/Status
        cmnd_wr                         => cmnd_wr                      ,
        cmnd_data                       => cmnd_data                    ,
        cmnd_pending                    => cmnd_pending                 ,
        sts_received                    => sts_received                 ,
        -- Vertical Flip
        vflip_sm                        => vflip_mngr                 ,

        -- Descriptor Fields
        crnt_start_address              => crnt_start_address           ,
        crnt_vsize                      => crnt_vsize_i                 ,   -- 
        crnt_hsize                      => crnt_hsize                   ,
        crnt_stride                     => crnt_stride

    );

-- If Scatter Gather engine is included then instantiate scatter gather
-- interface
GEN_SG_INTERFACE : if C_INCLUDE_SG = 1 generate
begin
    ---------------------------------------------------------------------------
    -- Scatter Gather State Machine
    ---------------------------------------------------------------------------
    I_SG_IF : entity  axi_vdma_v6_3_10.axi_vdma_sg_if
        generic map(

            -------------------------------------------------------------------
            -- Scatter Gather Parameters
            -------------------------------------------------------------------
            C_M_AXIS_SG_TDATA_WIDTH         => C_M_AXIS_SG_TDATA_WIDTH      ,
            C_M_AXI_SG_ADDR_WIDTH           => C_M_AXI_SG_ADDR_WIDTH        ,
            C_M_AXI_ADDR_WIDTH              => C_M_AXI_ADDR_WIDTH
        )
        port map(

            prmry_aclk                      => prmry_aclk                   ,
            prmry_resetn                    => prmry_resetn                 ,

            dmasr_halt                      => dmasr_halt                   ,
            ftch_idle                       => ftch_idle                    ,
            ftch_complete                   => ftch_complete                ,
            ftch_complete_clr               => ftch_complete_clr            ,

            -- SG Descriptor Fetch AXI Stream In
            m_axis_ftch_tdata               => m_axis_ftch_tdata            ,
            m_axis_ftch_tvalid              => m_axis_ftch_tvalid           ,
            m_axis_ftch_tready              => m_axis_ftch_tready           ,
            m_axis_ftch_tlast               => m_axis_ftch_tlast            ,

            -- Descriptor Field Output
            new_curdesc                     => new_curdesc                  ,
            new_curdesc_wren                => new_curdesc_wren             ,

            desc_data_wren                  => desc_data_wren               ,
            desc_strtaddress                => desc_strtaddress             ,
            desc_vsize                      => desc_vsize                   ,
            desc_hsize                      => desc_hsize                   ,
            desc_stride                     => desc_stride                  ,
            desc_frmdly                     => desc_frmdly

        );
end generate GEN_SG_INTERFACE;

-- If Scatter Gather engine is excluded then tie off unused signals
GEN_NO_SG_INTERFACE : if C_INCLUDE_SG = 0 generate
begin
    -- Map update complete to ftch_complete signal for proper
    -- video paramter transfer from axi_lite registers to video registers
    ftch_complete           <= prmtr_updt_complete;

    -- Signals not need for register direct mode
    m_axis_ftch_tready     <= '0';
    new_curdesc            <= (others => '0');
    new_curdesc_wren       <= '0';
    desc_data_wren         <= '0';
    desc_strtaddress       <= (others => '0');
    desc_vsize             <= (others => '0');
    desc_hsize             <= (others => '0');
    desc_stride            <= (others => '0');
    desc_frmdly            <= (others => '0');

end generate GEN_NO_SG_INTERFACE;

-------------------------------------------------------------------------------
-- Primary DataMover command status interface
-------------------------------------------------------------------------------
I_CMDSTS : entity  axi_vdma_v6_3_10.axi_vdma_cmdsts_if
    generic map(
        C_M_AXI_ADDR_WIDTH              => C_M_AXI_ADDR_WIDTH           ,
        C_DM_STATUS_WIDTH               => C_DM_STATUS_WIDTH            ,
        C_INCLUDE_MM2S                  => C_INCLUDE_MM2S               ,
        --C_ENABLE_DEBUG_INFO             => C_ENABLE_DEBUG_INFO             ,
        C_ENABLE_DEBUG_ALL      => C_ENABLE_DEBUG_ALL             ,
            C_ENABLE_DEBUG_INFO_0       => C_ENABLE_DEBUG_INFO_0             ,
            C_ENABLE_DEBUG_INFO_1       => C_ENABLE_DEBUG_INFO_1             ,
            C_ENABLE_DEBUG_INFO_2       => C_ENABLE_DEBUG_INFO_2             ,
            C_ENABLE_DEBUG_INFO_3       => C_ENABLE_DEBUG_INFO_3             ,
            C_ENABLE_DEBUG_INFO_4       => C_ENABLE_DEBUG_INFO_4             ,
            C_ENABLE_DEBUG_INFO_5       => C_ENABLE_DEBUG_INFO_5             ,
            C_ENABLE_DEBUG_INFO_6       => C_ENABLE_DEBUG_INFO_6             ,
            C_ENABLE_DEBUG_INFO_7       => C_ENABLE_DEBUG_INFO_7             ,
            C_ENABLE_DEBUG_INFO_8       => C_ENABLE_DEBUG_INFO_8             ,
            C_ENABLE_DEBUG_INFO_9       => C_ENABLE_DEBUG_INFO_9             ,
            C_ENABLE_DEBUG_INFO_10      => C_ENABLE_DEBUG_INFO_10             ,
            C_ENABLE_DEBUG_INFO_11      => C_ENABLE_DEBUG_INFO_11             ,
            C_ENABLE_DEBUG_INFO_12      => C_ENABLE_DEBUG_INFO_12             ,
            C_ENABLE_DEBUG_INFO_13      => C_ENABLE_DEBUG_INFO_13             ,
            C_ENABLE_DEBUG_INFO_14      => C_ENABLE_DEBUG_INFO_14             ,
            C_ENABLE_DEBUG_INFO_15      => C_ENABLE_DEBUG_INFO_15             ,

        C_INCLUDE_S2MM                  => C_INCLUDE_S2MM,
        C_ENABLE_FLUSH_ON_FSYNC         => C_ENABLE_FLUSH_ON_FSYNC
    )
    port map(
        prmry_aclk                      => prmry_aclk                   ,
        prmry_resetn                    => prmry_resetn                 ,

        -- Fetch command write interface from sm
        cmnd_wr                         => cmnd_wr                      ,
        cmnd_data                       => cmnd_data                    ,
        cmnd_pending                    => cmnd_pending                 ,
        sts_received                    => sts_received                 ,
        crnt_hsize                      => crnt_hsize                   ,
        stop                            => stop_i                       ,
        halt                            => halt                         ,   -- 
        dmasr_halt                      => dmasr_halt                   ,

        -- User Command Interface Ports (AXI Stream)
        s_axis_cmd_tvalid               => s_axis_cmd_tvalid            ,
        s_axis_cmd_tready               => s_axis_cmd_tready            ,
        s_axis_cmd_tdata                => s_axis_cmd_tdata             ,

        -- User Status Interface Ports (AXI Stream)
        m_axis_sts_tvalid               => m_axis_sts_tvalid            ,
        m_axis_sts_tready               => m_axis_sts_tready            ,
        m_axis_sts_tdata                => m_axis_sts_tdata             ,
        m_axis_sts_tkeep                => m_axis_sts_tkeep             ,
 
           s2mm_fsize_more_or_sof_late => s2mm_fsize_more_or_sof_late          ,   

        s2mm_dmasr_lsize_less_err                   => s2mm_dmasr_lsize_less_err                ,
        -- Zero Hsize and/or Vsize. mapped here to combine with interr
        zero_size_err                   => zero_size_err                ,
        -- Frame Mismatch. mapped here to combine with interr
        fsize_mismatch_err              => fsize_mismatch_err_i         ,   -- 
        lsize_mismatch_err              => lsize_mismatch_err_i           ,   -- 
        lsize_more_mismatch_err              => lsize_more_mismatch_err_i           ,   -- 

        capture_hsize_at_uf_err              => capture_hsize_at_uf_err           ,   
        -- Primary DataMover Status
        err                             => err                          ,
        done                            => done                         ,
        err_o                           => dma_err                    ,
        interr_minus_frame_errors                          => interr_minus_frame_errors                       ,
        interr                          => interr                       ,
        slverr                          => slverr                       ,
        decerr                          => decerr                       ,
        tag                             => tag                             -- Not used
    );

---------------------------------------------------------------------------
-- Halt / Idle Status Manager
---------------------------------------------------------------------------
I_STS_MNGR : entity  axi_vdma_v6_3_10.axi_vdma_sts_mngr
    port map(
        prmry_aclk                      => prmry_aclk                   ,
        prmry_resetn                    => prmry_resetn                 ,

        -- dma control and sg engine status signals
        run_stop                        => run_stop                     ,
        regdir_idle                     => regdir_idle                  ,
        ftch_idle                       => ftch_idle                    ,
        cmnd_idle                       => cmnd_idle                    ,
        sts_idle                        => sts_idle                     ,
        line_buffer_empty               => line_buffer_empty            ,
        dwidth_fifo_pipe_empty               => dwidth_fifo_pipe_empty            ,
        video_prmtrs_valid              => video_prmtrs_valid           ,
        prmtr_update_complete           => prmtr_update_complete        , -- 

        -- stop and halt control/status
        stop                            => stop_i                       ,
        halt                            => halt                         , -- 
        halt_cmplt                      => halt_cmplt                   ,

        -- system state and control
        all_idle                        => all_idle_i                   ,
        ftchcmdsts_idle                 => ftchcmdsts_idle              ,
        cmdsts_idle                     => cmdsts_idle                  ,
        halted_clr                      => halted_clr                   ,
        halted_set                      => halted_set                   ,
        idle_set                        => idle_set                     ,
        idle_clr                        => idle_clr
    );

---------------------------------------------------------------------------
-- Video Register Bank
---------------------------------------------------------------------------
VIDEO_REG_I : entity  axi_vdma_v6_3_10.axi_vdma_vidreg_module_64
    generic map(
        C_INCLUDE_SG                    => C_INCLUDE_SG                 ,
        C_NUM_FSTORES                   => C_NUM_FSTORES                ,
        C_DYNAMIC_RESOLUTION            => C_DYNAMIC_RESOLUTION                ,
        C_ADDR_WIDTH                    => C_M_AXI_ADDR_WIDTH           ,
        C_SELECT_XPM                    => C_SELECT_XPM                 ,
        C_FAMILY                        => C_FAMILY
    )
    port map(
        prmry_aclk                      => prmry_aclk                   ,
        prmry_resetn                    => prmry_resetn                 ,

        -- Register update control
        ftch_complete                   => ftch_complete                ,
        ftch_complete_clr               => ftch_complete_clr            ,
        parameter_update                => parameter_update             ,
        video_prmtrs_valid              => video_prmtrs_valid           ,
        prmtr_update_complete           => prmtr_update_complete        , -- 
        num_fstore_minus1               => num_fstore_minus1            , -- 

        -- Register swap control/status
        frame_sync                      => frame_sync                   ,
        run_stop                        => run_stop                     ,
        dmasr_halt                      => dmasr_halt                   ,
        ftch_idle                       => ftch_idle                    ,
        tailpntr_updated                => tailpntr_updated             ,
        frame_number                    => frame_number_i               ,

        -- Register Direct Mode Video Parameter In
        reg_module_vsize                => reg_module_vsize             ,
        reg_module_hsize                => reg_module_hsize             ,
        reg_module_stride               => reg_module_stride            ,
        reg_module_frmdly               => reg_module_frmdly            ,
        reg_module_strt_addr            => reg_module_strt_addr         ,

        -- Descriptor data/control from sg interface
        desc_data_wren                  => desc_data_wren               ,
        desc_strtaddress                => desc_strtaddress             ,
        desc_vsize                      => desc_vsize                   ,
        desc_hsize                      => desc_hsize                   ,
        desc_stride                     => desc_stride                  ,
        desc_frmdly                     => desc_frmdly                  ,

        -- Scatter Gather register Bank
        --crnt_vsize                      => crnt_vsize                 ,   -- 
        crnt_vsize                      => crnt_vsize_i                 ,   -- 
        crnt_hsize                      => crnt_hsize                   ,
        crnt_stride                     => crnt_stride                  ,
        crnt_frmdly                     => crnt_frmdly                  ,
        crnt_start_address              => crnt_start_address
    );

---------------------------------------------------------------------------
-- Gen Lock
---------------------------------------------------------------------------
VIDEO_GENLOCK_I : entity axi_vdma_v6_3_10.axi_vdma_genlock_mngr
    generic map(
        C_GENLOCK_MODE                  => C_GENLOCK_MODE               ,
        C_GENLOCK_NUM_MASTERS           => C_GENLOCK_NUM_MASTERS        ,
        C_INTERNAL_GENLOCK_ENABLE       => C_INTERNAL_GENLOCK_ENABLE    ,
        C_NUM_FSTORES                   => C_NUM_FSTORES
    )
    port map(

        -- Secondary Clock Domain
        prmry_aclk                      => prmry_aclk                   ,
        prmry_resetn                    => prmry_resetn                 ,

        -- Dynamic Frame Store Support
        num_frame_store                 => num_frame_store              ,
        num_fstore_minus1               => num_fstore_minus1            ,

        -- Gen-Lock Slave Signals
        mstr_in_control                 => mstr_pntr_ref                ,
        genlock_select                  => genlock_select               ,
        frame_ptr_in                    => frame_ptr_in                 ,
        internal_frame_ptr_in           => internal_frame_ptr_in        ,
        slv_frame_ref_out               => slv_frame_ref_out            ,

        -- Gen-Lock Master Signals
        dmasr_halt                      => dmasr_halt                   ,
        circular_prk_mode               => circular_prk_mode            ,
        fsize_mismatch_err_flag         => fsize_mismatch_err_flag_i         ,   
        mstr_frame_update               => valid_frame_sync_d2           ,
        mstr_frame_ref_in               => mstr_frame_ref_in            ,
        mstrfrm_tstsync_out             => mstrfrm_tstsync_out          ,
        frame_ptr_out                   => frame_ptr_out
    );


end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_mm2s_axis_dwidth_converter
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_vdma_mm2s_axis_dwidth_converter.vhd
-- Description: This entity is the descriptor fetch command and status inteface
--              for the Scatter Gather Engine AXI DataMover.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;


entity  axi_vdma_mm2s_axis_dwidth_converter is
     generic ( 	C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED         	: integer   			:= 32;
 		C_M_AXIS_MM2S_TDATA_WIDTH         		: integer		   	:= 32;
 		C_M_AXIS_MM2S_TDATA_WIDTH_div_by_8         	: integer 		  	:= 4;
	        C_MM2S_SOF_ENABLE               		: integer range 0 to 1      	:= 0;
        	ENABLE_FLUSH_ON_FSYNC       			: integer range 0 to 1        	:= 0      ;
 		C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED_div_by_8   : integer 		  	:= 4;
 	--	C_AXIS_SIGNAL_SET            			: integer 		  	:= 255;
 		C_AXIS_TID_WIDTH             			: integer       		:= 1;
 		C_AXIS_TDEST_WIDTH           			: integer       		:= 1;
        	C_FAMILY                     			: string        	       	:= "virtex7"  );
     port ( 
      		ACLK                         :in  std_logic;
      		ARESETN                      :in  std_logic;
      		ACLKEN                       :in  std_logic;

        	mm2s_vsize_cntr_clr_flag     : in  std_logic                         ;   
        	fsync_out                    : in  std_logic                         ;   
        	dwidth_fifo_pipe_empty       : out  std_logic                         ;   
        	all_lines_xfred_s_dwidth     : out  std_logic                         ;   
        	stop_reg             	     : in  std_logic                         ;   
        	dm_halt_reg                  : in  std_logic                         ;   
        	crnt_vsize_d2                : in  std_logic_vector(VSIZE_DWIDTH-1 downto 0)                         ;   

      		S_AXIS_TVALID                :in  std_logic;
      		S_AXIS_TREADY                :out  std_logic;
      		S_AXIS_TDATA                 :in  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED-1 downto 0);
      		S_AXIS_TSTRB                 :in  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8-1 downto 0);
      		S_AXIS_TKEEP                 :in  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8-1 downto 0);
      		S_AXIS_TLAST                 :in  std_logic;
      		S_AXIS_TID                   :in  std_logic_vector(C_AXIS_TID_WIDTH-1 downto 0);
      		S_AXIS_TDEST                 :in  std_logic_vector(C_AXIS_TDEST_WIDTH-1 downto 0);
      		S_AXIS_TUSER                 :in  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED_div_by_8-1 downto 0);
      		M_AXIS_TVALID                :out  std_logic;
      		M_AXIS_TREADY                :in   std_logic;
      		M_AXIS_TDATA                 :out  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH-1 downto 0);
      		M_AXIS_TSTRB                 :out  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH/8-1 downto 0);
      		M_AXIS_TKEEP                 :out  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH/8-1 downto 0);
      		M_AXIS_TLAST                 :out  std_logic;
      		M_AXIS_TID                   :out  std_logic_vector(C_AXIS_TID_WIDTH-1 downto 0);
      		M_AXIS_TDEST                 :out  std_logic_vector(C_AXIS_TDEST_WIDTH-1 downto 0);
      		M_AXIS_TUSER                 :out  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH_div_by_8-1 downto 0)
  );


end axi_vdma_mm2s_axis_dwidth_converter;



-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_mm2s_axis_dwidth_converter is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

constant ZERO_VALUE                 : std_logic_vector(255 downto 0)
                                        := (others => '0');
-- Constants for line tracking logic
constant VSIZE_ONE_VALUE            : std_logic_vector(VSIZE_DWIDTH-1 downto 0)
                                        := std_logic_vector(to_unsigned(1,VSIZE_DWIDTH));

constant VSIZE_ZERO_VALUE           : std_logic_vector(VSIZE_DWIDTH-1 downto 0)
                                        := (others => '0');


-------------------------------------------------------------------------------
-- Verilog module component declarations
-------------------------------------------------------------------------------

  component axi_vdma_v6_3_10_axis_dwidth_converter_v1_0_axis_dwidth_converter is
     generic ( 	C_S_AXIS_TDATA_WIDTH         	: integer   			:= 32;
 		C_M_AXIS_TDATA_WIDTH         	: integer   			:= 32;
 		C_AXIS_TID_WIDTH         	: integer       		:= 1;
 		C_AXIS_TDEST_WIDTH         	: integer       		:= 1;
 		C_S_AXIS_TUSER_WIDTH         	: integer   			:= 4;
 		C_M_AXIS_TUSER_WIDTH         	: integer   			:= 4;
 		--C_AXIS_SIGNAL_SET            	: integer   			:= 255;
        	C_FAMILY                     	: string                    	:= "virtex7"  );
     port ( 
      		ACLK                         :in  std_logic;
      		ARESETN                      :in  std_logic;
      		ACLKEN                       :in  std_logic;
      		S_AXIS_TVALID                :in  std_logic;
      		S_AXIS_TREADY                :out  std_logic;
      		S_AXIS_TDATA                 :in  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED-1 downto 0);
      		S_AXIS_TSTRB                 :in  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8-1 downto 0);
      		S_AXIS_TKEEP                 :in  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8-1 downto 0);
      		S_AXIS_TLAST                 :in  std_logic;
      		S_AXIS_TID                   :in  std_logic_vector(C_AXIS_TID_WIDTH-1 downto 0);
      		S_AXIS_TDEST                 :in  std_logic_vector(C_AXIS_TDEST_WIDTH-1 downto 0);
      		S_AXIS_TUSER                 :in  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED_div_by_8-1 downto 0);
      		M_AXIS_TVALID                :out  std_logic;
      		M_AXIS_TREADY                :in   std_logic;
      		M_AXIS_TDATA                 :out  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH-1 downto 0);
      		M_AXIS_TSTRB                 :out  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH/8-1 downto 0);
      		M_AXIS_TKEEP                 :out  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH/8-1 downto 0);
      		M_AXIS_TLAST                 :out  std_logic;
      		M_AXIS_TID                   :out  std_logic_vector(C_AXIS_TID_WIDTH-1 downto 0);
      		M_AXIS_TDEST                 :out  std_logic_vector(C_AXIS_TDEST_WIDTH-1 downto 0);
      		M_AXIS_TUSER                 :out  std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH_div_by_8-1 downto 0)
  );

  end component;
-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal M_AXIS_TREADY_D1             : std_logic := '0';
signal M_AXIS_TLAST_D1              : std_logic := '0';
signal M_AXIS_TVALID_D1             : std_logic := '0';
signal M_AXIS_TVALID_OUT            : std_logic := '0'; 
signal M_AXIS_TLAST_OUT             : std_logic := '0'; 
signal vsize_counter                : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0'); 
signal all_lines_xfred              : std_logic := '0';
--signal crnt_vsize_d2                : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');
signal decr_vcount                  : std_logic := '0';
--signal fifo_pipe_empty              : std_logic := '0'
--signal stop_reg                     : std_logic := '0'


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

    GEN_DWIDTH_NO_SOF : if ENABLE_FLUSH_ON_FSYNC = 0 or C_MM2S_SOF_ENABLE = 0 generate
    	begin

    all_lines_xfred_s_dwidth    <= all_lines_xfred;
    -- Pass out of core
    M_AXIS_TVALID   <= M_AXIS_TVALID_OUT;
    M_AXIS_TLAST    <= M_AXIS_TLAST_OUT;

    MM2S_AXIS_DWIDTH_CONVERTER_I : axi_vdma_v6_3_10_axis_dwidth_converter_v1_0_axis_dwidth_converter
     generic map( 	C_S_AXIS_TDATA_WIDTH         =>		C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED		, 
 			C_M_AXIS_TDATA_WIDTH         =>		C_M_AXIS_MM2S_TDATA_WIDTH		, 
 			C_AXIS_TID_WIDTH             =>		C_AXIS_TID_WIDTH		, 
 			C_S_AXIS_TUSER_WIDTH         =>		C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED_div_by_8		, 
 			C_M_AXIS_TUSER_WIDTH         =>		C_M_AXIS_MM2S_TDATA_WIDTH_div_by_8		, 
 			C_AXIS_TDEST_WIDTH           =>		C_AXIS_TDEST_WIDTH		, 
 			--C_AXIS_SIGNAL_SET            =>		C_AXIS_SIGNAL_SET		, 
        		C_FAMILY                     =>		C_FAMILY		   )
     port map( 
      		ACLK                         =>	ACLK                 			, 
      		ARESETN                      =>	ARESETN              			, 
      		ACLKEN                       =>	ACLKEN               			, 
      		S_AXIS_TVALID                =>	S_AXIS_TVALID        			, 
      		S_AXIS_TREADY                =>	S_AXIS_TREADY        			, 
      		S_AXIS_TDATA                 =>	S_AXIS_TDATA(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED-1 downto 0)         			, 
      		S_AXIS_TSTRB                 =>	S_AXIS_TSTRB(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8-1 downto 0)         			, 
      		S_AXIS_TKEEP                 =>	S_AXIS_TKEEP(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8-1 downto 0)         			, 
      		S_AXIS_TLAST                 =>	S_AXIS_TLAST         			, 
      		S_AXIS_TID                   =>	S_AXIS_TID(C_AXIS_TID_WIDTH-1 downto 0)           			, 
      		S_AXIS_TDEST                 =>	S_AXIS_TDEST(C_AXIS_TDEST_WIDTH-1 downto 0)         			, 
      		S_AXIS_TUSER                 =>	S_AXIS_TUSER(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED_div_by_8-1 downto 0)         			, 
      		M_AXIS_TVALID                =>	M_AXIS_TVALID_OUT        			, 
      		M_AXIS_TREADY                =>	M_AXIS_TREADY        			, 
      		M_AXIS_TDATA                 =>	M_AXIS_TDATA(C_M_AXIS_MM2S_TDATA_WIDTH-1 downto 0)         			, 
      		M_AXIS_TSTRB                 =>	M_AXIS_TSTRB(C_M_AXIS_MM2S_TDATA_WIDTH/8-1 downto 0)         			, 
      		M_AXIS_TKEEP                 =>	M_AXIS_TKEEP(C_M_AXIS_MM2S_TDATA_WIDTH/8-1 downto 0)         			, 
      		M_AXIS_TLAST                 =>	M_AXIS_TLAST_OUT         			, 
      		M_AXIS_TID                   =>	M_AXIS_TID(C_AXIS_TID_WIDTH-1 downto 0)           			, 
      		M_AXIS_TDEST                 =>	M_AXIS_TDEST(C_AXIS_TDEST_WIDTH-1 downto 0)         			, 
      		M_AXIS_TUSER                 =>	M_AXIS_TUSER(C_M_AXIS_MM2S_TDATA_WIDTH_div_by_8-1 downto 0)        			
  );


    -- Register to break long timing paths for use in
    -- transfer complete generation
    DWIDTH_REG_STRM_SIGS : process(ACLK)
        begin
            if(ACLK'EVENT and ACLK = '1')then
                if(ARESETN = '0')then
                    M_AXIS_TLAST_D1     <= '0';
                    M_AXIS_TVALID_D1    <= '0';
                    M_AXIS_TREADY_D1    <= '0';
                else
                    M_AXIS_TLAST_D1     <= M_AXIS_TLAST_OUT;
                    M_AXIS_TVALID_D1    <= M_AXIS_TVALID_OUT;
                    M_AXIS_TREADY_D1    <= M_AXIS_TREADY;
                end if;
            end if;
        end process DWIDTH_REG_STRM_SIGS;


--*****************************************************************************
--** Vertical Line Tracking 
--*****************************************************************************
-- Decrement vertical count with each accept tlast
decr_vcount <= '1' when M_AXIS_TLAST_D1 = '1'
                    and M_AXIS_TVALID_D1 = '1'
                    and M_AXIS_TREADY_D1 = '1'
          else '0';


-- Drive ready at fsync out then de-assert once all lines have
-- been accepted.
DWIDTH_VERT_COUNTER : process(ACLK)
    begin
        if(ACLK'EVENT and ACLK = '1')then
            if(ARESETN = '0' and fsync_out = '0')then
                vsize_counter       <= (others => '0');
                all_lines_xfred     <= '1';
            elsif(fsync_out = '1')then
                vsize_counter       <= crnt_vsize_d2;
                all_lines_xfred     <= '0';
            elsif(decr_vcount = '1' and vsize_counter = VSIZE_ONE_VALUE)then
                vsize_counter       <= (others => '0');
                all_lines_xfred     <= '1';

            elsif(decr_vcount = '1' and vsize_counter /= VSIZE_ZERO_VALUE)then
                vsize_counter       <= std_logic_vector(unsigned(vsize_counter) - 1);
                all_lines_xfred     <= '0';

            end if;
        end if;
    end process DWIDTH_VERT_COUNTER;

    dwidth_fifo_pipe_empty <= '1' when (all_lines_xfred = '1' and M_AXIS_TVALID_OUT = '0') -- All data for frame transmitted
                            or  dm_halt_reg = '1'                   -- Commanded to Halt
                  else '0';






     end generate GEN_DWIDTH_NO_SOF;

    GEN_DWIDTH_SOF : if  ENABLE_FLUSH_ON_FSYNC = 1  and C_MM2S_SOF_ENABLE = 1 generate
    begin



    -- Pass out of core
    M_AXIS_TVALID   <= M_AXIS_TVALID_OUT;
    M_AXIS_TLAST    <= M_AXIS_TLAST_OUT;
    all_lines_xfred_s_dwidth    <= all_lines_xfred;

    MM2S_AXIS_DWIDTH_CONVERTER_I : axi_vdma_v6_3_10_axis_dwidth_converter_v1_0_axis_dwidth_converter
     generic map( 	C_S_AXIS_TDATA_WIDTH         =>		C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED		, 
 			C_M_AXIS_TDATA_WIDTH         =>		C_M_AXIS_MM2S_TDATA_WIDTH		, 
 			C_AXIS_TID_WIDTH             =>		C_AXIS_TID_WIDTH		, 
 			C_S_AXIS_TUSER_WIDTH         =>		C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED_div_by_8		, 
 			C_M_AXIS_TUSER_WIDTH         =>		C_M_AXIS_MM2S_TDATA_WIDTH_div_by_8		, 
 			C_AXIS_TDEST_WIDTH           =>		C_AXIS_TDEST_WIDTH		, 
 			--C_AXIS_SIGNAL_SET            =>		C_AXIS_SIGNAL_SET		, 
        		C_FAMILY                     =>		C_FAMILY		   )
     port map( 
      		ACLK                         =>	ACLK                 			, 
      		ARESETN                      =>	ARESETN              			, 
      		ACLKEN                       =>	ACLKEN               			, 
      		S_AXIS_TVALID                =>	S_AXIS_TVALID        			, 
      		S_AXIS_TREADY                =>	S_AXIS_TREADY        			, 
      		S_AXIS_TDATA                 =>	S_AXIS_TDATA(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED-1 downto 0)         			, 
      		S_AXIS_TSTRB                 =>	S_AXIS_TSTRB(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8-1 downto 0)         			, 
      		S_AXIS_TKEEP                 =>	S_AXIS_TKEEP(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8-1 downto 0)         			, 
      		S_AXIS_TLAST                 =>	S_AXIS_TLAST         			, 
      		S_AXIS_TID                   =>	S_AXIS_TID(C_AXIS_TID_WIDTH-1 downto 0)           			, 
      		S_AXIS_TDEST                 =>	S_AXIS_TDEST(C_AXIS_TDEST_WIDTH-1 downto 0)         			, 
      		S_AXIS_TUSER                 =>	S_AXIS_TUSER(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED_div_by_8-1 downto 0)         			, 
      		M_AXIS_TVALID                =>	M_AXIS_TVALID_OUT        			, 
      		M_AXIS_TREADY                =>	M_AXIS_TREADY        			, 
      		M_AXIS_TDATA                 =>	M_AXIS_TDATA(C_M_AXIS_MM2S_TDATA_WIDTH-1 downto 0)         			, 
      		M_AXIS_TSTRB                 =>	M_AXIS_TSTRB(C_M_AXIS_MM2S_TDATA_WIDTH/8-1 downto 0)         			, 
      		M_AXIS_TKEEP                 =>	M_AXIS_TKEEP(C_M_AXIS_MM2S_TDATA_WIDTH/8-1 downto 0)         			, 
      		M_AXIS_TLAST                 =>	M_AXIS_TLAST_OUT         			, 
      		M_AXIS_TID                   =>	M_AXIS_TID(C_AXIS_TID_WIDTH-1 downto 0)           			, 
      		M_AXIS_TDEST                 =>	M_AXIS_TDEST(C_AXIS_TDEST_WIDTH-1 downto 0)         			, 
      		M_AXIS_TUSER                 =>	M_AXIS_TUSER(C_M_AXIS_MM2S_TDATA_WIDTH_div_by_8-1 downto 0)        			
  );


    -- Register to break long timing paths for use in
    -- transfer complete generation
    DWIDTH_REG_STRM_SIGS : process(ACLK)
        begin
            if(ACLK'EVENT and ACLK = '1')then
                if(ARESETN = '0')then
                    M_AXIS_TLAST_D1     <= '0';
                    M_AXIS_TVALID_D1    <= '0';
                    M_AXIS_TREADY_D1    <= '0';
                else
                    M_AXIS_TLAST_D1     <= M_AXIS_TLAST_OUT;
                    M_AXIS_TVALID_D1    <= M_AXIS_TVALID_OUT;
                    M_AXIS_TREADY_D1    <= M_AXIS_TREADY;
                end if;
            end if;
        end process DWIDTH_REG_STRM_SIGS;


--*****************************************************************************
--** Vertical Line Tracking 
--*****************************************************************************
-- Decrement vertical count with each accept tlast
decr_vcount <= '1' when M_AXIS_TLAST_D1 = '1'
                    and M_AXIS_TVALID_D1 = '1'
                    and M_AXIS_TREADY_D1 = '1'
          else '0';


-- Drive ready at fsync out then de-assert once all lines have
-- been accepted.
DWIDTH_VERT_COUNTER : process(ACLK)
    begin
        if(ACLK'EVENT and ACLK = '1')then
            if((ARESETN = '0' and fsync_out = '0') or mm2s_vsize_cntr_clr_flag = '1')then
                vsize_counter       <= (others => '0');
                all_lines_xfred     <= '1';
            elsif(fsync_out = '1')then
                vsize_counter       <= crnt_vsize_d2;
                all_lines_xfred     <= '0';
            elsif(decr_vcount = '1' and vsize_counter = VSIZE_ONE_VALUE)then
                vsize_counter       <= (others => '0');
                all_lines_xfred     <= '1';

            elsif(decr_vcount = '1' and vsize_counter /= VSIZE_ZERO_VALUE)then
                vsize_counter       <= std_logic_vector(unsigned(vsize_counter) - 1);
                all_lines_xfred     <= '0';

            end if;
        end if;
    end process DWIDTH_VERT_COUNTER;

    dwidth_fifo_pipe_empty <= '1' when (all_lines_xfred = '1' and M_AXIS_TVALID_OUT = '0') -- All data for frame transmitted
                            or  dm_halt_reg = '1'                   -- Commanded to Halt
                  else '0';



	end generate GEN_DWIDTH_SOF;


end implementation;


-------------------------------------------------------------------------------
-- axi_vdma_s2mm_axis_dwidth_converter
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_vdma_s2mm_axis_dwidth_converter.vhd
-- Description: This entity is the descriptor fetch command and status inteface
--              for the Scatter Gather Engine AXI DataMover.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v3_00_a.axi_datamover.vhd (FULL)
--                   |- axi_sg_v3_00_a.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;


entity  axi_vdma_s2mm_axis_dwidth_converter is
     generic ( 	C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED         	: integer   			:= 32;
 		C_S_AXIS_S2MM_TDATA_WIDTH         		: integer 		  	:= 32;
 		C_S_AXIS_S2MM_TDATA_WIDTH_div_by_8         	: integer   			:= 4;
 		C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED_div_by_8   : integer   			:= 4;
	        C_S2MM_SOF_ENABLE               		: integer range 0 to 1      	:= 0;
        	ENABLE_FLUSH_ON_FSYNC       			: integer range 0 to 1        	:= 0      ;
 		C_AXIS_TID_WIDTH             			: integer       		:= 1;
 		C_AXIS_TDEST_WIDTH           			: integer       		:= 1;
 		--C_AXIS_SIGNAL_SET            			: integer 		  	:= 255;
        	C_FAMILY                     			: string        	       	:= "virtex7"  );
     port ( 
      		ACLK                         :in  std_logic;
      		ARESETN                      :in  std_logic;
      		ACLKEN                       :in  std_logic;

        	s2mm_fsize_less_err_internal_tvalid_gating                   : in  std_logic                         ;   
        	fsync_out                   : in  std_logic                         ;   
        	crnt_vsize_d2               : in  std_logic_vector(VSIZE_DWIDTH-1 downto 0)                         ;   
      		chnl_ready_dwidth           : out std_logic;
      		strm_not_finished_dwidth    : out std_logic;
      		strm_all_lines_rcvd_dwidth  : out std_logic;
      		all_vount_rcvd_dwidth       : out std_logic;



      		S_AXIS_TVALID                :in  std_logic;
      		S_AXIS_TREADY                :out  std_logic;
      		S_AXIS_TDATA                 :in  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH-1 downto 0);
      		S_AXIS_TSTRB                 :in  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH/8-1 downto 0);
      		S_AXIS_TKEEP                 :in  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH/8-1 downto 0);
      		S_AXIS_TLAST                 :in  std_logic;
      		S_AXIS_TID                   :in  std_logic_vector(C_AXIS_TID_WIDTH-1 downto 0);
      		S_AXIS_TDEST                 :in  std_logic_vector(C_AXIS_TDEST_WIDTH-1 downto 0);
      		S_AXIS_TUSER                 :in  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH_div_by_8-1 downto 0);


      		M_AXIS_TVALID                :out  std_logic;
      		M_AXIS_TREADY                :in   std_logic;
      		M_AXIS_TDATA                 :out  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED-1 downto 0);
      		M_AXIS_TSTRB                 :out  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED/8-1 downto 0);
      		M_AXIS_TKEEP                 :out  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED/8-1 downto 0);
      		M_AXIS_TLAST                 :out  std_logic;
      		M_AXIS_TID                   :out  std_logic_vector(C_AXIS_TID_WIDTH-1 downto 0);
      		M_AXIS_TDEST                 :out  std_logic_vector(C_AXIS_TDEST_WIDTH-1 downto 0);
      		M_AXIS_TUSER                 :out  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED_div_by_8-1 downto 0)
  );


end axi_vdma_s2mm_axis_dwidth_converter;



-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma_s2mm_axis_dwidth_converter is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

constant ZERO_VALUE                 : std_logic_vector(255 downto 0)
                                        := (others => '0');
-- Constants for line tracking logic
constant VSIZE_ONE_VALUE            : std_logic_vector(VSIZE_DWIDTH-1 downto 0)
                                        := std_logic_vector(to_unsigned(1,VSIZE_DWIDTH));

constant VSIZE_ZERO_VALUE           : std_logic_vector(VSIZE_DWIDTH-1 downto 0)
                                        := (others => '0');

-------------------------------------------------------------------------------
-- Verilog module component declarations
-------------------------------------------------------------------------------

  component axi_vdma_v6_3_10_axis_dwidth_converter_v1_0_axis_dwidth_converter is
     generic ( 	C_S_AXIS_TDATA_WIDTH         	: integer   			:= 32;
 		C_M_AXIS_TDATA_WIDTH         	: integer   			:= 32;
 		C_AXIS_TID_WIDTH         	: integer       		:= 1;
 		C_AXIS_TDEST_WIDTH         	: integer       		:= 1;
 		C_S_AXIS_TUSER_WIDTH         	: integer   			:= 4;
 		C_M_AXIS_TUSER_WIDTH         	: integer   			:= 4;
 		--C_AXIS_SIGNAL_SET            	: integer 		  	:= 255;
        	C_FAMILY                     	: string                    	:= "virtex7"  );
     port ( 
      		ACLK                         :in  std_logic;
      		ARESETN                      :in  std_logic;
      		ACLKEN                       :in  std_logic;


      		S_AXIS_TVALID                :in  std_logic;
      		S_AXIS_TREADY                :out std_logic;
      		S_AXIS_TDATA                 :in  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH-1 downto 0);
      		S_AXIS_TSTRB                 :in  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH/8-1 downto 0);
      		S_AXIS_TKEEP                 :in  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH/8-1 downto 0);
      		S_AXIS_TLAST                 :in  std_logic;
      		S_AXIS_TID                   :in  std_logic_vector(C_AXIS_TID_WIDTH-1 downto 0);
      		S_AXIS_TDEST                 :in  std_logic_vector(C_AXIS_TDEST_WIDTH-1 downto 0);
      		S_AXIS_TUSER                 :in  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH_div_by_8-1 downto 0);

      		M_AXIS_TVALID                :out  std_logic;
      		M_AXIS_TREADY                :in   std_logic;
      		M_AXIS_TDATA                 :out  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED-1 downto 0);
      		M_AXIS_TSTRB                 :out  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED/8-1 downto 0);
      		M_AXIS_TKEEP                 :out  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED/8-1 downto 0);
      		M_AXIS_TLAST                 :out  std_logic;
      		M_AXIS_TID                   :out  std_logic_vector(C_AXIS_TID_WIDTH-1 downto 0);
      		M_AXIS_TDEST                 :out  std_logic_vector(C_AXIS_TDEST_WIDTH-1 downto 0);
      		M_AXIS_TUSER                 :out  std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED_div_by_8-1 downto 0)
  );

  end component;
-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal decr_vcount_dwidth                  : std_logic := '0';
signal S_AXIS_TREADY_OUT                   : std_logic := '0';
signal vsize_counter_dwidth                : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0'); 


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin


    GEN_DWIDTH_NO_FLUSH_SOF : if ENABLE_FLUSH_ON_FSYNC = 0 or C_S2MM_SOF_ENABLE = 0 generate
    	begin

      		chnl_ready_dwidth           <= '0' ;
      		strm_not_finished_dwidth    <= '0' ;
      		strm_all_lines_rcvd_dwidth  <= '0' ;
      		all_vount_rcvd_dwidth       <= '0' ;



    S2MM_AXIS_DWIDTH_CONVERTER_I : axi_vdma_v6_3_10_axis_dwidth_converter_v1_0_axis_dwidth_converter
     generic map( 	C_S_AXIS_TDATA_WIDTH         =>		C_S_AXIS_S2MM_TDATA_WIDTH		, 
 			C_M_AXIS_TDATA_WIDTH         =>		C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED		, 
 			C_AXIS_TID_WIDTH             =>		C_AXIS_TID_WIDTH		, 
 			C_S_AXIS_TUSER_WIDTH         =>		C_S_AXIS_S2MM_TDATA_WIDTH_div_by_8		, 
 			C_M_AXIS_TUSER_WIDTH         =>		C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED_div_by_8		, 
 			C_AXIS_TDEST_WIDTH           =>		C_AXIS_TDEST_WIDTH		, 
 			--C_AXIS_SIGNAL_SET            =>		C_AXIS_SIGNAL_SET		, 
        		C_FAMILY                     =>		C_FAMILY		   )
     port map( 
      		ACLK                         =>	ACLK                 			, 
      		ARESETN                      =>	ARESETN              			, 
      		ACLKEN                       =>	ACLKEN               			, 
      		S_AXIS_TVALID                =>	S_AXIS_TVALID        			, 
      		S_AXIS_TREADY                =>	S_AXIS_TREADY        			, 
      		S_AXIS_TDATA                 =>	S_AXIS_TDATA(C_S_AXIS_S2MM_TDATA_WIDTH-1 downto 0)         			, 
      		S_AXIS_TSTRB                 =>	S_AXIS_TSTRB(C_S_AXIS_S2MM_TDATA_WIDTH/8-1 downto 0)         			, 
      		S_AXIS_TKEEP                 =>	S_AXIS_TKEEP(C_S_AXIS_S2MM_TDATA_WIDTH/8-1 downto 0)         			, 
      		S_AXIS_TLAST                 =>	S_AXIS_TLAST         			, 
      		S_AXIS_TID                   =>	S_AXIS_TID(C_AXIS_TID_WIDTH-1 downto 0)           			, 
      		S_AXIS_TDEST                 =>	S_AXIS_TDEST(C_AXIS_TDEST_WIDTH-1 downto 0)         			, 
      		S_AXIS_TUSER                 =>	S_AXIS_TUSER(C_S_AXIS_S2MM_TDATA_WIDTH_div_by_8-1 downto 0)         			, 
      		M_AXIS_TVALID                =>	M_AXIS_TVALID        			, 
      		M_AXIS_TREADY                =>	M_AXIS_TREADY        			, 
      		M_AXIS_TDATA                 =>	M_AXIS_TDATA(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED-1 downto 0)         			, 
      		M_AXIS_TSTRB                 =>	M_AXIS_TSTRB(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED/8-1 downto 0)         			, 
      		M_AXIS_TKEEP                 =>	M_AXIS_TKEEP(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED/8-1 downto 0)         			, 
      		M_AXIS_TLAST                 =>	M_AXIS_TLAST         			, 
      		M_AXIS_TID                   =>	M_AXIS_TID(C_AXIS_TID_WIDTH-1 downto 0)           			, 
      		M_AXIS_TDEST                 =>	M_AXIS_TDEST(C_AXIS_TDEST_WIDTH-1 downto 0)         			, 
      		M_AXIS_TUSER                 =>	M_AXIS_TUSER(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED_div_by_8-1 downto 0)        			
  );



     end generate GEN_DWIDTH_NO_FLUSH_SOF;


    GEN_DWIDTH_FLUSH_SOF : if ENABLE_FLUSH_ON_FSYNC = 1 and C_S2MM_SOF_ENABLE = 1 generate
    	begin



    S2MM_AXIS_DWIDTH_CONVERTER_I : axi_vdma_v6_3_10_axis_dwidth_converter_v1_0_axis_dwidth_converter
     generic map( 	C_S_AXIS_TDATA_WIDTH         =>		C_S_AXIS_S2MM_TDATA_WIDTH		, 
 			C_M_AXIS_TDATA_WIDTH         =>		C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED		, 
 			C_AXIS_TID_WIDTH             =>		C_AXIS_TID_WIDTH		, 
 			C_S_AXIS_TUSER_WIDTH         =>		C_S_AXIS_S2MM_TDATA_WIDTH_div_by_8		, 
 			C_M_AXIS_TUSER_WIDTH         =>		C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED_div_by_8		, 
 			C_AXIS_TDEST_WIDTH           =>		C_AXIS_TDEST_WIDTH		, 
 			--C_AXIS_SIGNAL_SET            =>		C_AXIS_SIGNAL_SET		, 
        		C_FAMILY                     =>		C_FAMILY		   )
     port map( 
      		ACLK                         =>	ACLK                 			, 
      		ARESETN                      =>	ARESETN              			, 
      		ACLKEN                       =>	ACLKEN               			, 

      		S_AXIS_TVALID                =>	S_AXIS_TVALID        			, 
      		S_AXIS_TREADY                =>	S_AXIS_TREADY_OUT        			, 
      		S_AXIS_TDATA                 =>	S_AXIS_TDATA(C_S_AXIS_S2MM_TDATA_WIDTH-1 downto 0)         			, 
      		S_AXIS_TSTRB                 =>	S_AXIS_TSTRB(C_S_AXIS_S2MM_TDATA_WIDTH/8-1 downto 0)         			, 
      		S_AXIS_TKEEP                 =>	S_AXIS_TKEEP(C_S_AXIS_S2MM_TDATA_WIDTH/8-1 downto 0)         			, 
      		S_AXIS_TLAST                 =>	S_AXIS_TLAST         			, 
      		S_AXIS_TID                   =>	S_AXIS_TID(C_AXIS_TID_WIDTH-1 downto 0)           			, 
      		S_AXIS_TDEST                 =>	S_AXIS_TDEST(C_AXIS_TDEST_WIDTH-1 downto 0)         			, 
      		S_AXIS_TUSER                 =>	S_AXIS_TUSER(C_S_AXIS_S2MM_TDATA_WIDTH_div_by_8-1 downto 0)         			, 

      		M_AXIS_TVALID                =>	M_AXIS_TVALID        			, 
      		M_AXIS_TREADY                =>	M_AXIS_TREADY        			, 
      		M_AXIS_TDATA                 =>	M_AXIS_TDATA(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED-1 downto 0)         			, 
      		M_AXIS_TSTRB                 =>	M_AXIS_TSTRB(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED/8-1 downto 0)         			, 
      		M_AXIS_TKEEP                 =>	M_AXIS_TKEEP(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED/8-1 downto 0)         			, 
      		M_AXIS_TLAST                 =>	M_AXIS_TLAST         			, 
      		M_AXIS_TID                   =>	M_AXIS_TID(C_AXIS_TID_WIDTH-1 downto 0)           			, 
      		M_AXIS_TDEST                 =>	M_AXIS_TDEST(C_AXIS_TDEST_WIDTH-1 downto 0)         			, 
      		M_AXIS_TUSER                 =>	M_AXIS_TUSER(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED_div_by_8-1 downto 0)        			
  );




S_AXIS_TREADY <= S_AXIS_TREADY_OUT;

    -- Decrement vertical count with each accept tlast
    decr_vcount_dwidth <= '1' when S_AXIS_TLAST = '1'
                        and S_AXIS_TVALID = '1'
                        and S_AXIS_TREADY_OUT = '1'
              else '0';

    -- Drive ready at fsync out then de-assert once all lines have
    -- been accepted.
    VERT_COUNTER_DWIDTH : process(ACLK)
        begin
            if(ACLK'EVENT and ACLK = '1')then
            if((ARESETN = '0' and fsync_out = '0') or s2mm_fsize_less_err_internal_tvalid_gating = '1')then
                    vsize_counter_dwidth          	<= (others => '0');
                    chnl_ready_dwidth      		<= '0';
                    strm_not_finished_dwidth      	<= '0';
                    strm_all_lines_rcvd_dwidth    	<= '1';
                    all_vount_rcvd_dwidth    		<= '0';

                elsif(fsync_out = '1')then
                    vsize_counter_dwidth          	<= crnt_vsize_d2;
                    chnl_ready_dwidth      		<= '1';
                    strm_not_finished_dwidth      	<= '1';
                    strm_all_lines_rcvd_dwidth    	<= '0';
                    all_vount_rcvd_dwidth    		<= '0';

                elsif(decr_vcount_dwidth = '1' and vsize_counter_dwidth = VSIZE_ONE_VALUE)then
                    vsize_counter_dwidth          	<= (others => '0');
                    chnl_ready_dwidth      		<= '0';
                    strm_not_finished_dwidth      	<= '0';
                    strm_all_lines_rcvd_dwidth    	<= '1';
                    all_vount_rcvd_dwidth    		<= '1';

                elsif(decr_vcount_dwidth = '1' and vsize_counter_dwidth /= VSIZE_ZERO_VALUE)then
                    vsize_counter_dwidth          	<= std_logic_vector(unsigned(vsize_counter_dwidth) - 1);
                    chnl_ready_dwidth      		<= '1';
                    strm_not_finished_dwidth      	<= '1';
                    strm_all_lines_rcvd_dwidth    	<= '0';
                    all_vount_rcvd_dwidth    		<= '0';


            	else
                    all_vount_rcvd_dwidth    		<= '0';



                end if;
            end if;
        end process VERT_COUNTER_DWIDTH;

     
  end generate GEN_DWIDTH_FLUSH_SOF;
end implementation;


-------------------------------------------------------------------------------
-- axi_vdma
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
--  (c) Copyright 2010-2011, 2013 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_vdma.vhd
-- Description: This entity is the top level entity for the AXI VDMA core.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-- Structure:
--                  axi_vdma.vhd
--                   |- axi_vdma_pkg.vhd
--                   |- axi_vdma_intrpt.vhd
--                   |- axi_vdma_rst_module.vhd
--                   |   |- axi_vdma_reset.vhd (mm2s)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |   |- axi_vdma_reset.vhd (s2mm)
--                   |   |   |- axi_vdma_cdc.vhd
--                   |
--                   |- axi_vdma_reg_if.vhd
--                   |   |- axi_vdma_lite_if.vhd
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (mm2s)
--                   |- axi_vdma_vid_cdc.vhd (mm2s)
--                   |- axi_vdma_fsync_gen.vhd (mm2s)
--                   |- axi_vdma_sof_gen.vhd (mm2s)
--                   |- axi_vdma_reg_module.vhd (mm2s)
--                   |   |- axi_vdma_register.vhd (mm2s)
--                   |   |- axi_vdma_regdirect.vhd (mm2s)
--                   |- axi_vdma_mngr.vhd (mm2s)
--                   |   |- axi_vdma_sg_if.vhd (mm2s)
--                   |   |- axi_vdma_sm.vhd (mm2s)
--                   |   |- axi_vdma_cmdsts_if.vhd (mm2s)
--                   |   |- axi_vdma_vidreg_module.vhd (mm2s)
--                   |   |   |- axi_vdma_sgregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vregister.vhd (mm2s)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (mm2s)
--                   |   |   |- axi_vdma_blkmem.vhd (mm2s)
--                   |   |- axi_vdma_genlock_mngr.vhd (mm2s)
--                   |       |- axi_vdma_genlock_mux.vhd (mm2s)
--                   |       |- axi_vdma_greycoder.vhd (mm2s)
--                   |- axi_vdma_mm2s_linebuf.vhd (mm2s)
--                   |   |- axi_vdma_sfifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_afifo_autord.vhd (mm2s)
--                   |   |- axi_vdma_skid_buf.vhd (mm2s)
--                   |   |- axi_vdma_cdc.vhd (mm2s)
--                   |
--                   |- axi_vdma_sg_cdc.vhd (s2mm)
--                   |- axi_vdma_vid_cdc.vhd (s2mm)
--                   |- axi_vdma_fsync_gen.vhd (s2mm)
--                   |- axi_vdma_sof_gen.vhd (s2mm)
--                   |- axi_vdma_reg_module.vhd (s2mm)
--                   |   |- axi_vdma_register.vhd (s2mm)
--                   |   |- axi_vdma_regdirect.vhd (s2mm)
--                   |- axi_vdma_mngr.vhd (s2mm)
--                   |   |- axi_vdma_sg_if.vhd (s2mm)
--                   |   |- axi_vdma_sm.vhd (s2mm)
--                   |   |- axi_vdma_cmdsts_if.vhd (s2mm)
--                   |   |- axi_vdma_vidreg_module.vhd (s2mm)
--                   |   |   |- axi_vdma_sgregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vregister.vhd (s2mm)
--                   |   |   |- axi_vdma_vaddrreg_mux.vhd (s2mm)
--                   |   |   |- axi_vdma_blkmem.vhd (s2mm)
--                   |   |- axi_vdma_genlock_mngr.vhd (s2mm)
--                   |       |- axi_vdma_genlock_mux.vhd (s2mm)
--                   |       |- axi_vdma_greycoder.vhd (s2mm)
--                   |- axi_vdma_s2mm_linebuf.vhd (s2mm)
--                   |   |- axi_vdma_sfifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_afifo_autord.vhd (s2mm)
--                   |   |- axi_vdma_skid_buf.vhd (s2mm)
--                   |   |- axi_vdma_cdc.vhd (s2mm)
--                   |
--                   |- axi_datamover_v5_1_24.axi_datamover.vhd (FULL)
--                   |- axi_vdma_v6_3_10.axi_sg_v4_03.axi_sg.vhd
--
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_vdma_v6_3_10;
use axi_vdma_v6_3_10.axi_vdma_pkg.all;

--library axi_sg_v4_03;
--use axi_sg_v4_03.all;

library axi_datamover_v5_1_24;
use axi_datamover_v5_1_24.all;

library lib_cdc_v1_0_2;
library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.max2;

--use proc_common_v4_0.family_support.all;

-------------------------------------------------------------------------------
entity  axi_vdma is
    generic(
        C_S_AXI_LITE_ADDR_WIDTH         : integer range 9 to 9    	:= 9;
            -- Address width of the AXI Lite Interface

        C_S_AXI_LITE_DATA_WIDTH         : integer range 32 to 32    	:= 32;
            -- Data width of the AXI Lite Interface

        C_DLYTMR_RESOLUTION             : integer range 1 to 100000 	:= 125;
            -- Interrupt Delay Timer resolution in usec

        C_PRMRY_IS_ACLK_ASYNC           : integer range 0 to 1      	:= 1;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - all clocks may be asynchronous.
        -----------------------------------------------------------------------
        -- Video Specific Parameters
        -----------------------------------------------------------------------
        C_ENABLE_VIDPRMTR_READS         : integer range 0 to 1      	:= 1;
            -- Specifies whether video parameters are readable by axi_lite interface
            -- when configure for Register Direct Mode
            -- 0 = Disable Video Parameter Reads (Saves FPGA Resources)
            -- 1 = Enable Video Parameter Reads

        -----------------------------------------------------------------------
        C_DYNAMIC_RESOLUTION           : integer range 0 to 1      	:= 1;
            -- Run time configuration of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 0 = Halt VDMA before writing new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE
            -- 1 = Run time register configuration for new set of HSIZE, STRIDE, FRM_DLY, StartAddress & VSIZE.
        -----------------------------------------------------------------------

        C_NUM_FSTORES                   : integer range 1 to 32     	:= 3;
            -- Number of Frame Stores

        C_USE_FSYNC                     : integer range 0 to 3      	:= 1; 
        -- 2013.1 : Spilt into C_USE_MM2S_FSYNC & C_USE_S2MM_FSYNC. C_USE_FSYNC is no longer used.

        C_USE_MM2S_FSYNC                     : integer range 0 to 1      	:= 0; --2013.1
            -- Specifies MM2S channel operation synchronized to frame sync input
            -- 0 = channel is Free running
            -- 1 = channel uses mm2s_fsync as a frame_sync

        C_USE_S2MM_FSYNC                     : integer range 0 to 2      	:= 2; --2013.1
            -- Specifies MM2S channel operation synchronized to frame sync input
            -- 0 = channel is Free running
            -- 1 = channel uses s2mm_fsync as a frame_sync
            -- 2 = channel uses s2mm_tuser(0) as a frame_sync



        C_FLUSH_ON_FSYNC                : integer range 0 to 3      	:= 1;	--Interally enabled i.e. user values are not passed to the core  and this parameter is redundant (2013.1/14.5)
            -- Specifies VDMA will flush on frame sync
            -- 0 = Disabled -  both channel halts on error detection
            -- 1 = Enabled - both channel does not halt and will flush on next fsync
            -- 2 = Enabled - ONLY MM2S channel does not halt and will flush on next fsync
            -- 3 = Enabled - ONLY S2MM channel does not halt and will flush on next fsync

        C_INCLUDE_INTERNAL_GENLOCK      : integer range 0 to 1      	:= 1; --Interally enabled i.e. user values are not passed to the core  and this parameter is redundant (2013.1/14.5)
            -- Include or exclude the use of internal genlock bus.
            -- 0 = Exclude internal genlock bus
            -- 1 = Include internal genlock bus

        -----------------------------------------------------------------------
        -- Scatter Gather Parameters
        -----------------------------------------------------------------------
        C_INCLUDE_SG                    : integer range 0 to 1      	:= 0;
            -- Include or Exclude Scatter Gather Engine
            -- 0 = Exclude Scatter Gather Engine (Enables Register Direct Mode)
            -- 1 = Include Scatter Gather Engine

        C_M_AXI_SG_ADDR_WIDTH           : integer range 32 to 64    	:= 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_M_AXI_SG_DATA_WIDTH           : integer range 32 to 32    	:= 32;
            -- Master AXI Memory Map Data Width for Scatter Gather R/W Port

        -----------------------------------------------------------------------
        -- Memory Map to Stream (MM2S) Parameters
        -----------------------------------------------------------------------
        C_INCLUDE_MM2S                  : integer range 0 to 1      	:= 1;
            -- Include or exclude MM2S primary data path
            -- 0 = Exclude MM2S primary data path
            -- 1 = Include MM2S primary data path

        C_MM2S_GENLOCK_MODE             : integer range 0 to 3      	:= 3;
            -- Specifies the Gen-Lock mode for the MM2S Channel
            -- 0 = Master Mode
            -- 1 = Slave Mode

        C_MM2S_GENLOCK_NUM_MASTERS      : integer range 1 to 16     	:= 1;
            -- Specifies the number of Gen-Lock masters a Gen-Lock slave
            -- can be synchronized with

        C_MM2S_GENLOCK_REPEAT_EN        : integer range 0 to 1      	:= 0;
            -- In flush on frame sync mode specifies whether frame number
            -- will increment on error'ed frame or repeat error'ed frame
            -- 0 = increment frame
            -- 1 = repeat frame

        C_MM2S_SOF_ENABLE               : integer range 0 to 1      	:= 1;	--Interally enabled i.e. user values are not passed to the core  and this parameter is redundant (2013.1/14.5)
            -- Enable/Disable start of frame generation on tuser(0).
            -- 0 = disable SOF
            -- 1 = enable SOF

        C_INCLUDE_MM2S_DRE              : integer range 0 to 1      	:= 0;
            -- Include or exclude MM2S data realignment engine (DRE)
            -- 0 = Exclude MM2S DRE
            -- 1 = Include MM2S DRE

        C_INCLUDE_MM2S_SF               : integer range 0 to 1      	:= 0;
            -- Include or exclude MM2S Store And Forward Functionality
            -- 0 = Exclude MM2S Store and Forward
            -- 1 = Include MM2S Store and Forward

        C_MM2S_LINEBUFFER_DEPTH         : integer range 0 to 65536  	:= 512;
            -- Depth of line buffer. Width of the line buffer is derived from Streaming width.  

        C_MM2S_LINEBUFFER_THRESH        : integer range 1 to 65536  	:= 4; --Interally enabled i.e. user values are not passed to the core  and this parameter is redundant (2013.1/14.5)
            -- Almost Empty Threshold. Threshold point at which MM2S line buffer
            -- almost empty flag asserts high.  Must be a resolution of
            -- C_M_AXIS_MM2S_TDATA_WIDTH/8
            -- Minimum valid value is C_M_AXIS_MM2S_TDATA_WIDTH/8
            -- Maximum valid value is C_MM2S_LINEBUFFER_DEPTH

        C_MM2S_MAX_BURST_LENGTH         : integer range 2 to 256   	:= 8;
            -- Maximum burst size in databeats per burst request on MM2S Read Port

        C_M_AXI_MM2S_ADDR_WIDTH         : integer range 32 to 64    	:= 32;
            -- Master AXI Memory Map Address Width for MM2S Read Port

        C_M_AXI_MM2S_DATA_WIDTH         : integer range 32 to 1024  	:= 64;
            -- Master AXI Memory Map Data Width for MM2S Read Port

        C_M_AXIS_MM2S_TDATA_WIDTH       : integer range 8 to 1024   	:= 32;
            -- Master AXI Stream Data Width for MM2S Channel

        C_M_AXIS_MM2S_TUSER_BITS        : integer range 1 to 1      	:= 1;
            -- Master AXI Stream User Width for MM2S Channel

        -----------------------------------------------------------------------
        -- Stream to Memory Map (S2MM) Parameters
        -----------------------------------------------------------------------
        C_INCLUDE_S2MM                  : integer range 0 to 1      	:= 1;
            -- Include or exclude S2MM primary data path
            -- 0 = Exclude S2MM primary data path
            -- 1 = Include S2MM primary data path

        C_S2MM_GENLOCK_MODE             : integer range 0 to 3      	:= 2;
            -- Specifies the Gen-Lock mode for the S2MM Channel
            -- 0 = Master Mode
            -- 1 = Slave Mode

        C_S2MM_GENLOCK_NUM_MASTERS      : integer range 1 to 16     	:= 1;
            -- Specifies the number of Gen-Lock masters a Gen-Lock slave
            -- can be synchronized with

        C_S2MM_GENLOCK_REPEAT_EN        : integer range 0 to 1      	:= 1;
            -- In flush on frame sync mode specifies whether frame number
            -- will increment on error'ed frame or repeat error'ed frame
            -- 0 = increment frame
            -- 1 = repeat frame

        C_S2MM_SOF_ENABLE               : integer range 0 to 1      	:= 1; --Interally enabled i.e. user values are not passed to the core  and this parameter is redundant (2013.1/14.5)
            -- Enable/Disable start of frame generation on tuser(0). 
            -- 0 = disable SOF
            -- 1 = enable SOF

        C_INCLUDE_S2MM_DRE              : integer range 0 to 1      	:= 0;
            -- Include or exclude S2MM data realignment engine (DRE)
            -- 0 = Exclude S2MM DRE
            -- 1 = Include S2MM DRE

        C_INCLUDE_S2MM_SF               : integer range 0 to 1      	:= 1;
            -- Include or exclude MM2S Store And Forward Functionality
            -- 0 = Exclude S2MM Store and Forward
            -- 1 = Include S2MM Store and Forward

        C_S2MM_LINEBUFFER_DEPTH         : integer range 0 to 65536  	:= 512;
            -- Depth of line buffer. Width of the line buffer is derived from Streaming width.  

        C_S2MM_LINEBUFFER_THRESH        : integer range 1 to 65536  	:= 4; --Interally enabled i.e. user values are not passed to the core  and this parameter is redundant (2013.1/14.5)
            -- Almost Full Threshold. Threshold point at which S2MM line buffer
            -- almost full flag asserts high.  Must be a resolution of
            -- C_M_AXIS_MM2S_TDATA_WIDTH/8
            -- Minimum valid value is C_S_AXIS_S2MM_TDATA_WIDTH/8
            -- Maximum valid value is C_S2MM_LINEBUFFER_DEPTH

        C_S2MM_MAX_BURST_LENGTH         : integer range 2 to 256   	:= 8;
            -- Maximum burst size in data beats per burst request on S2MM Write Port

        C_M_AXI_S2MM_ADDR_WIDTH         : integer range 32 to 64    	:= 32;
            -- Master AXI Memory Map Address Width for S2MM Write Port

        C_M_AXI_S2MM_DATA_WIDTH         : integer range 32 to 1024  	:= 64;
            -- Master AXI Memory Map Data Width for MM2SS2MMWrite Port

        C_S_AXIS_S2MM_TDATA_WIDTH       : integer range 8 to 1024   	:= 32;
            -- Slave AXI Stream Data Width for S2MM Channel

        C_S_AXIS_S2MM_TUSER_BITS        : integer range 1 to 1      	:= 1;
            -- Slave AXI Stream User Width for S2MM Channel



        --C_ENABLE_DEBUG_INFO             : bit_vector(15 downto 0) 	:= (others => '0');		 
            -- Enable debug information

        C_ENABLE_DEBUG_ALL       : integer range 0 to 1      	:= 0;
            -- Setting this make core backward compatible to 2012.4 version in terms of ports and registers

        C_ENABLE_DEBUG_INFO_0       : integer range 0 to 1      	:= 0;
            -- Enable debug information bit 0
        C_ENABLE_DEBUG_INFO_1       : integer range 0 to 1      	:= 0;
            -- Enable debug information bit 1
        C_ENABLE_DEBUG_INFO_2       : integer range 0 to 1      	:= 0;
            -- Enable debug information bit 2
        C_ENABLE_DEBUG_INFO_3       : integer range 0 to 1      	:= 0;
            -- Enable debug information bit 3
        C_ENABLE_DEBUG_INFO_4       : integer range 0 to 1      	:= 0;
            -- Enable debug information bit 4
        C_ENABLE_DEBUG_INFO_5       : integer range 0 to 1      	:= 0;
            -- Enable debug information bit 5
        C_ENABLE_DEBUG_INFO_6       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 6
        C_ENABLE_DEBUG_INFO_7       : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 7
        C_ENABLE_DEBUG_INFO_8       : integer range 0 to 1      	:= 0;
            -- Enable debug information bit 8
        C_ENABLE_DEBUG_INFO_9       : integer range 0 to 1      	:= 0;
            -- Enable debug information bit 9
        C_ENABLE_DEBUG_INFO_10      : integer range 0 to 1      	:= 0;
            -- Enable debug information bit 10
        C_ENABLE_DEBUG_INFO_11      : integer range 0 to 1      	:= 0;
            -- Enable debug information bit 11
        C_ENABLE_DEBUG_INFO_12      : integer range 0 to 1      	:= 0;
            -- Enable debug information bit 12
        C_ENABLE_DEBUG_INFO_13      : integer range 0 to 1      	:= 0;
            -- Enable debug information bit 13
        C_ENABLE_DEBUG_INFO_14      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 14
        C_ENABLE_DEBUG_INFO_15      : integer range 0 to 1      	:= 1;
            -- Enable debug information bit 15

        C_INSTANCE                      : string   			:= "axi_vdma";
        C_SELECT_XPM                    : integer                       := 1;
        C_ENABLE_VERT_FLIP              : integer range 0 to 1          := 0;            
        C_FAMILY                        : string                    	:= "virtex7"
            -- Target FPGA Device Family
    );
    port (
        -- Control Clocks
        s_axi_lite_aclk             : in  std_logic           		:= '0' ;        --
        m_axi_sg_aclk               : in  std_logic           		:= '0' ;        --

        -- MM2S Clocks
        m_axi_mm2s_aclk             : in  std_logic           		:= '0' ;        --
        m_axis_mm2s_aclk            : in  std_logic           		:= '0' ;        --

        -- S2MM Clocks
        m_axi_s2mm_aclk             : in  std_logic          		:= '0' ;        --
        s_axis_s2mm_aclk            : in  std_logic          		:= '0' ;        --

        axi_resetn                  : in  std_logic          		:= '0' ;        --
                                                                                                --
        -----------------------------------------------------------------------                 --
        -- AXI Lite Control Interface                                                           --
        -----------------------------------------------------------------------                 --
        -- AXI Lite Write Address Channel                                                       --
        s_axi_lite_awvalid          : in  std_logic                    	:= '0' ;        --
        s_axi_lite_awready          : out std_logic                    	       ;        --
        s_axi_lite_awaddr           : in  std_logic_vector                              --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');                   --
                                                                                        --
        -- AXI Lite Write Data Channel                                                  --
        s_axi_lite_wvalid           : in  std_logic                    	:= '0' ;        --
        s_axi_lite_wready           : out std_logic                   	       ;        --
        s_axi_lite_wdata            : in  std_logic_vector                                      --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) 	:= (others => '0');                   --
                                                                                                --
        -- AXI Lite Write Response Channel                                                      --
        s_axi_lite_bresp            : out std_logic_vector(1 downto 0)      ;                   --
        s_axi_lite_bvalid           : out std_logic                         ;                   --
        s_axi_lite_bready           : in  std_logic                       := '0'  ;                   --
                                                                                                --
        -- AXI Lite Read Address Channel                                                        --
        s_axi_lite_arvalid          : in  std_logic                       := '0'  ;                   --
        s_axi_lite_arready          : out std_logic                         ;                   --
        s_axi_lite_araddr           : in  std_logic_vector                                      --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');                   --
        s_axi_lite_rvalid           : out std_logic                         ;                   --
        s_axi_lite_rready           : in  std_logic                       := '0'  ;                   --
        s_axi_lite_rdata            : out std_logic_vector                                      --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);                   --
        s_axi_lite_rresp            : out std_logic_vector(1 downto 0)      ;                   --
                                                                                                --
        -----------------------------------------------------------------------                 --
        -- AXI Video Interface                                                                  --
        -----------------------------------------------------------------------                 --
        mm2s_fsync                  : in  std_logic                        := '0' ;                   --
        mm2s_frame_ptr_in           : in  std_logic_vector                                      --
                                        ((C_MM2S_GENLOCK_NUM_MASTERS*6)-1 downto 0) := (others => '0');            --
        mm2s_frame_ptr_out          : out std_logic_vector(5 downto 0);                         --
        s2mm_fsync                  : in  std_logic                         := '0';                   --
        s2mm_frame_ptr_in           : in  std_logic_vector                                      --
                                        ((C_S2MM_GENLOCK_NUM_MASTERS*6)-1 downto 0) := (others => '0');            --
        s2mm_frame_ptr_out          : out std_logic_vector(5 downto 0);                         --
        mm2s_buffer_empty           : out std_logic                         ;                   --
        mm2s_buffer_almost_empty    : out std_logic                         ;                   --
        s2mm_buffer_full            : out std_logic                         ;                   --
        s2mm_buffer_almost_full     : out std_logic                         ;                   --
                                                                                                --
        mm2s_fsync_out              : out std_logic                         ;                   --
        s2mm_fsync_out              : out std_logic                         ;                   --
        mm2s_prmtr_update           : out std_logic                         ;                   --
        s2mm_prmtr_update           : out std_logic                         ;                   --
                                                                                                --
        -----------------------------------------------------------------------                 --
        -- AXI Scatter Gather Interface                                                         --
        -----------------------------------------------------------------------                 --
        -- Scatter Gather Read Address Channel                                                  --
        m_axi_sg_araddr             : out std_logic_vector                                      --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --
        m_axi_sg_arlen              : out std_logic_vector(7 downto 0)      ;                   --
        m_axi_sg_arsize             : out std_logic_vector(2 downto 0)      ;                   --
        m_axi_sg_arburst            : out std_logic_vector(1 downto 0)      ;                   --
        m_axi_sg_arprot             : out std_logic_vector(2 downto 0)      ;                   --
        m_axi_sg_arcache            : out std_logic_vector(3 downto 0)      ;                   --
        m_axi_sg_arvalid            : out std_logic                         ;                   --
        m_axi_sg_arready            : in  std_logic                         := '0';                   --
                                                                                                --
        -- Memory Map to Stream Scatter Gather Read Data Channel                                --
        m_axi_sg_rdata              : in  std_logic_vector                                      --
                                        (C_M_AXI_SG_DATA_WIDTH-1 downto 0)   := (others => '0');                   --
        m_axi_sg_rresp              : in  std_logic_vector(1 downto 0)       := (others => '0')  ;                   --
        m_axi_sg_rlast              : in  std_logic                          := '0';                   --
        m_axi_sg_rvalid             : in  std_logic                          := '0';                   --
        m_axi_sg_rready             : out std_logic                         ;                   --
                                                                                                --
        -----------------------------------------------------------------------                 --
        -- AXI MM2S Channel                                                                     --
        -----------------------------------------------------------------------                 --
        -- Memory Map To Stream Read Address Channel                                            --
        m_axi_mm2s_araddr           : out std_logic_vector                                      --
                                        (C_M_AXI_MM2S_ADDR_WIDTH-1 downto 0);                   --
        m_axi_mm2s_arlen            : out std_logic_vector(7 downto 0)      ;                   --
        m_axi_mm2s_arsize           : out std_logic_vector(2 downto 0)      ;                   --
        m_axi_mm2s_arburst          : out std_logic_vector(1 downto 0)      ;                   --
        m_axi_mm2s_arprot           : out std_logic_vector(2 downto 0)      ;                   --
        m_axi_mm2s_arcache          : out std_logic_vector(3 downto 0)      ;                   --
        m_axi_mm2s_arvalid          : out std_logic                         ;                   --
        m_axi_mm2s_arready          : in  std_logic                          := '0';                   --
                                                                                                --
        -- Memory Map  to Stream Read Data Channel                                              --
        m_axi_mm2s_rdata            : in  std_logic_vector                                      --
                                        (C_M_AXI_MM2S_DATA_WIDTH-1 downto 0) := (others => '0');                   --
        m_axi_mm2s_rresp            : in  std_logic_vector(1 downto 0)       := (others => '0');                   --
        m_axi_mm2s_rlast            : in  std_logic                          := '0';                   --
        m_axi_mm2s_rvalid           : in  std_logic                          := '0';                   --
        m_axi_mm2s_rready           : out std_logic                         ;                   --
                                                                                                --
        -- Memory Map to Stream Stream Interface                                                --
        mm2s_prmry_reset_out_n      : out std_logic                         ;                   --
        m_axis_mm2s_tdata           : out std_logic_vector                                      --
                                        (C_M_AXIS_MM2S_TDATA_WIDTH-1 downto 0);                 --
        m_axis_mm2s_tkeep           : out std_logic_vector                                      --
                                        ((C_M_AXIS_MM2S_TDATA_WIDTH/8)-1 downto 0);             --
        m_axis_mm2s_tuser           : out std_logic_vector                                      --
                                        (C_M_AXIS_MM2S_TUSER_BITS-1 downto 0);                  --
        m_axis_mm2s_tvalid          : out std_logic                         ;                   --
        m_axis_mm2s_tready          : in  std_logic                          := '0';                   --
        m_axis_mm2s_tlast           : out std_logic                         ;                   --
                                                                                                --
        -----------------------------------------------------------------------                 --
        -- AXI S2MM Channel                                                                     --
        -----------------------------------------------------------------------                 --
        -- Stream to Memory Map Write Address Channel                                           --
        m_axi_s2mm_awaddr           : out std_logic_vector                                      --
                                        (C_M_AXI_S2MM_ADDR_WIDTH-1 downto 0);                   --
        m_axi_s2mm_awlen            : out std_logic_vector(7 downto 0)      ;                   --
        m_axi_s2mm_awsize           : out std_logic_vector(2 downto 0)      ;                   --
        m_axi_s2mm_awburst          : out std_logic_vector(1 downto 0)      ;                   --
        m_axi_s2mm_awprot           : out std_logic_vector(2 downto 0)      ;                   --
        m_axi_s2mm_awcache          : out std_logic_vector(3 downto 0)      ;                   --
        m_axi_s2mm_awvalid          : out std_logic                         ;                   --
        m_axi_s2mm_awready          : in  std_logic                         := '0';                   --
                                                                                                --
        -- Stream to Memory Map Write Data Channel                                              --
        m_axi_s2mm_wdata            : out std_logic_vector                                      --
                                        (C_M_AXI_S2MM_DATA_WIDTH-1 downto 0);                   --
        m_axi_s2mm_wstrb            : out std_logic_vector                                      --
                                        ((C_M_AXI_S2MM_DATA_WIDTH/8)-1 downto 0);               --
        m_axi_s2mm_wlast            : out std_logic                         ;                   --
        m_axi_s2mm_wvalid           : out std_logic                         ;                   --
        m_axi_s2mm_wready           : in  std_logic                         := '0';                   --
                                                                                                --
        -- Stream to Memory Map Write Response Channel                                          --
        m_axi_s2mm_bresp            : in  std_logic_vector(1 downto 0)       := (others => '0');                   --
        m_axi_s2mm_bvalid           : in  std_logic                         := '0';                   --
        m_axi_s2mm_bready           : out std_logic                         ;                   --
                                                                                                --
        -- Stream to Memory Map Steam Interface                                                 --
        s2mm_prmry_reset_out_n      : out std_logic                         ;                   --
        s_axis_s2mm_tdata           : in  std_logic_vector                                      --
                                        (C_S_AXIS_S2MM_TDATA_WIDTH-1 downto 0) := (others => '0');                 --
        s_axis_s2mm_tkeep           : in  std_logic_vector                                      --
                                        ((C_S_AXIS_S2MM_TDATA_WIDTH/8)-1 downto 0) := (others => '0');             --
        s_axis_s2mm_tuser           : in  std_logic_vector                                      --
                                        (C_S_AXIS_S2MM_TUSER_BITS-1 downto 0) := (others => '0');                  --
        s_axis_s2mm_tvalid          : in  std_logic                         := '0';                   --
        s_axis_s2mm_tready          : out std_logic                         ;                   --
        s_axis_s2mm_tlast           : in  std_logic                         := '0';                   --
                                                                                                --
                                                                                                --
        -- MM2S and S2MM Channel Interrupts                                                     --
        mm2s_introut                : out std_logic                         ;                   --
        s2mm_introut                : out std_logic                         ;                   --
        axi_vdma_tstvec             : out std_logic_vector(63 downto 0)                         --
    );

-----------------------------------------------------------------
-- Start of PSFUtil MPD attributes
-----------------------------------------------------------------
attribute IP_GROUP                  : string;
attribute IP_GROUP     of axi_vdma   : entity   is "LOGICORE";

attribute IPTYPE                    : string;
attribute IPTYPE       of axi_vdma   : entity   is "PERIPHERAL";

attribute RUN_NGCBUILD              : string;
attribute RUN_NGCBUILD of axi_vdma   : entity   is "TRUE";

-----------------------------------------------------------------
-- End of PSFUtil MPD attributes
-----------------------------------------------------------------
end axi_vdma;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_vdma is
attribute DowngradeIPIdentifiedWarnings: string;
attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

--constant C_CORE_GENERATION_INFO : string := C_INSTANCE &  ",axi_vdma,{"
--& "C_FAMILY= "    & C_FAMILY
--& ",C_INSTANCE = " & C_INSTANCE   
--& ",C_DLYTMR_RESOLUTION= "    & integer'image(C_DLYTMR_RESOLUTION)
--& ",C_PRMRY_IS_ACLK_ASYNC= "    & integer'image(C_PRMRY_IS_ACLK_ASYNC)
--& ",C_ENABLE_VIDPRMTR_READS= "    & integer'image(C_ENABLE_VIDPRMTR_READS)
--& ",C_DYNAMIC_RESOLUTION= "    & integer'image(C_DYNAMIC_RESOLUTION)
--& ",C_NUM_FSTORES= "    & integer'image(C_NUM_FSTORES)
--& ",C_USE_MM2S_FSYNC= "    & integer'image(C_USE_MM2S_FSYNC)
--& ",C_USE_S2MM_FSYNC= "    & integer'image(C_USE_S2MM_FSYNC)
--& ",C_INCLUDE_SG= "    & integer'image(C_INCLUDE_SG)
--& ",C_INCLUDE_MM2S= "      & integer'image(C_INCLUDE_MM2S)
--& ",C_MM2S_GENLOCK_MODE= "      & integer'image(C_MM2S_GENLOCK_MODE)
--& ",C_MM2S_GENLOCK_NUM_MASTERS= "      & integer'image(C_MM2S_GENLOCK_NUM_MASTERS)
--& ",C_INCLUDE_MM2S_DRE= "      & integer'image(C_INCLUDE_MM2S_DRE)
--& ",C_MM2S_LINEBUFFER_DEPTH= "      & integer'image(C_MM2S_LINEBUFFER_DEPTH)
--& ",C_MM2S_MAX_BURST_LENGTH= "      & integer'image(C_MM2S_MAX_BURST_LENGTH)
--& ",C_M_AXI_MM2S_DATA_WIDTH = "  & integer'image(C_M_AXI_MM2S_DATA_WIDTH)
--& ",C_M_AXIS_MM2S_TDATA_WIDTH = "  & integer'image(C_M_AXIS_MM2S_TDATA_WIDTH)
--& ",C_INCLUDE_S2MM= "      & integer'image(C_INCLUDE_S2MM)
--& ",C_S2MM_GENLOCK_MODE= "      & integer'image(C_S2MM_GENLOCK_MODE)
--& ",C_S2MM_GENLOCK_NUM_MASTERS= "      & integer'image(C_S2MM_GENLOCK_NUM_MASTERS)
--& ",C_INCLUDE_S2MM_DRE= "      & integer'image(C_INCLUDE_S2MM_DRE)
--& ",C_S2MM_LINEBUFFER_DEPTH= "      & integer'image(C_S2MM_LINEBUFFER_DEPTH)
--& ",C_S2MM_MAX_BURST_LENGTH= "      & integer'image(C_S2MM_MAX_BURST_LENGTH)
--& ",C_M_AXI_S2MM_DATA_WIDTH= "      & integer'image(C_M_AXI_S2MM_DATA_WIDTH)
--& ",C_S_AXIS_S2MM_TDATA_WIDTH= "      & integer'image(C_S_AXIS_S2MM_TDATA_WIDTH)
--& "}";
--attribute CORE_GENERATION_INFO : string;
--attribute CORE_GENERATION_INFO of implementation : architecture is C_CORE_GENERATION_INFO;
-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

  function width_calc (value_in : integer)
                     return integer is
  variable addr_value : integer := 32;

  begin
      if (value_in > 32) then
          addr_value := 64;
      else
          addr_value := 32;
      end if;

      return(addr_value);

end function width_calc;


-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- Major Version number 0, 1, 2, 3 etc.
constant VERSION_MAJOR                  : std_logic_vector (3 downto 0) := X"6" ;
-- Minor Version Number 00, 01, 02, etc.
constant VERSION_MINOR                  : std_logic_vector (7 downto 0) := X"20";
-- Version Revision character (EDK) a,b,c,etc
constant VERSION_REVISION               : std_logic_vector (3 downto 0) := X"0" ;
-- Internal build number
constant REVISION_NUMBER                : string := "Build Number: P80";


constant C_M_AXI_MM2S_ADDR_WIDTH_NEW : integer := width_calc (C_M_AXI_MM2S_ADDR_WIDTH);
constant C_M_AXI_S2MM_ADDR_WIDTH_NEW : integer := width_calc (C_M_AXI_S2MM_ADDR_WIDTH);


--*****************************************************************************
--** Scatter Gather Engine Configuration
--*****************************************************************************
constant SG_INCLUDE_DESC_QUEUE          : integer range 0 to 1          := 0;
            -- Include or Exclude Scatter Gather Descriptor Queuing
            -- 0 = Exclude SG Descriptor Queuing
            -- 1 = Include SG Descriptor Queuing
-- Number of Fetch Descriptors to Queue
constant SG_FTCH_DESC2QUEUE             : integer := SG_INCLUDE_DESC_QUEUE * 4;
-- Number of Update Descriptors to Queue
constant SG_UPDT_DESC2QUEUE             : integer := SG_INCLUDE_DESC_QUEUE * 4;
-- Number of fetch words per descriptor for channel 1 (MM2S)
constant SG_CH1_WORDS_TO_FETCH          : integer := 7;
-- Number of fetch words per descriptor for channel 2 (S2MM)
constant SG_CH2_WORDS_TO_FETCH          : integer := 7;
-- Number of update words per descriptor for channel 1 (MM2S)
constant SG_CH1_WORDS_TO_UPDATE         : integer := 1; -- No Descriptor update for video
-- Number of update words per descriptor for channel 2 (S2MM)
constant SG_CH2_WORDS_TO_UPDATE         : integer := 1; -- No Descriptor update for video
-- First word offset (referenced to descriptor beginning) to update for channel 1 (MM2S)
constant SG_CH1_FIRST_UPDATE_WORD       : integer := 0; -- No Descriptor update for video
-- First word offset (referenced to descriptor beginning) to update for channel 2 (MM2S)
constant SG_CH2_FIRST_UPDATE_WORD       : integer := 0; -- No Descriptor update for video
-- Enable stale descriptor check for channel 1
constant SG_CH1_ENBL_STALE_ERR        : integer := 0;
-- Enable stale descriptor check for channel 2
constant SG_CH2_ENBL_STALE_ERR        : integer := 0;
-- Width of descriptor fetch bus
constant M_AXIS_SG_TDATA_WIDTH          : integer := 32;
-- Width of descriptor pointer update bus
constant S_AXIS_UPDPTR_TDATA_WIDTH      : integer := 32;
-- Width of descriptor status update bus
constant S_AXIS_UPDSTS_TDATA_WIDTH      : integer := 33;
-- Include SG Descriptor Updates
constant EXCLUDE_DESC_UPDATE            : integer := 0;  -- No Descriptor update for video
-- Include SG Interrupt Logic
constant EXCLUDE_INTRPT                 : integer := 0; -- Interrupt logic external to sg engine
-- Include SG Delay Interrupt
constant INCLUDE_DLYTMR                 : integer := 1;
constant EXCLUDE_DLYTMR                 : integer := 0;

--*****************************************************************************
--** General/Misc Constants
--*****************************************************************************

--constant C_USE_MM2S_FSYNC     : integer :=find_mm2s_fsync(C_USE_FSYNC,C_INCLUDE_MM2S,C_INCLUDE_S2MM);


--constant C_USE_S2MM_FSYNC     : integer :=find_s2mm_fsync(C_USE_FSYNC,C_INCLUDE_MM2S,C_INCLUDE_S2MM);
constant C_USE_S2MM_FSYNC_01     : integer :=find_s2mm_fsync_01(C_USE_S2MM_FSYNC);

--constant ENABLE_FLUSH_ON_MM2S_FSYNC          : integer :=find_mm2s_flush(C_USE_FSYNC,C_INCLUDE_MM2S,C_INCLUDE_S2MM,C_FLUSH_ON_FSYNC);
--constant ENABLE_FLUSH_ON_S2MM_FSYNC          : integer :=find_s2mm_flush(C_USE_FSYNC,C_INCLUDE_MM2S,C_INCLUDE_S2MM,C_FLUSH_ON_FSYNC);




 
--constant ENABLE_FLUSH_ON_MM2S_FSYNC          : integer :=find_mm2s_flush(C_USE_FSYNC,C_INCLUDE_MM2S,C_INCLUDE_S2MM,C_USE_FSYNC);
--constant ENABLE_FLUSH_ON_S2MM_FSYNC          : integer :=find_s2mm_flush(C_USE_FSYNC,C_INCLUDE_MM2S,C_INCLUDE_S2MM,C_USE_FSYNC);

 
constant ENABLE_FLUSH_ON_MM2S_FSYNC          : integer := C_USE_MM2S_FSYNC;
constant ENABLE_FLUSH_ON_S2MM_FSYNC          : integer := C_USE_S2MM_FSYNC_01;



--*****************************************************************************
--** AXI LITE Interface Constants
--*****************************************************************************
--constant TOTAL_NUM_REGISTER     : integer := NUM_REG_TOTAL_REGDIR;
constant TOTAL_NUM_REGISTER     : integer := get_num_registers(C_INCLUDE_SG,NUM_REG_TOTAL_SG,NUM_REG_TOTAL_REGDIR);








constant C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED     : integer := calculated_mm2s_tdata_width(C_M_AXIS_MM2S_TDATA_WIDTH);
constant C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED     : integer := calculated_s2mm_tdata_width(C_S_AXIS_S2MM_TDATA_WIDTH);



constant C_MM2S_ENABLE_TKEEP     : integer := enable_tkeep_connectivity(C_M_AXIS_MM2S_TDATA_WIDTH,C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED,C_INCLUDE_MM2S_DRE);
constant C_S2MM_ENABLE_TKEEP     : integer := enable_tkeep_connectivity(C_S_AXIS_S2MM_TDATA_WIDTH,C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED,C_INCLUDE_S2MM_DRE);

-- Specifies to register module which channel is which
constant CHANNEL_IS_MM2S        : integer := 1;
constant CHANNEL_IS_S2MM        : integer := 0;

--*****************************************************************************
--** DataMover General Constants
--*****************************************************************************
-- Primary DataMover Configuration
-- DataMover Command / Status FIFO Depth
-- Note :Set maximum to the number of update descriptors to queue, to prevent lock up do to
-- update data fifo full before
constant DM_CMDSTS_FIFO_DEPTH           : integer := 4;

-- DataMover Include Status FIFO
constant DM_INCLUDE_STS_FIFO            : integer := 1;

-- DataMover outstanding address request fifo depth
constant DM_ADDR_PIPE_DEPTH             : integer := 4;

-- Base status vector width
constant BASE_STATUS_WIDTH              : integer := 8;

-- AXI DataMover Full mode value
constant AXI_FULL_MODE                  : integer := 1;

-- Datamover clock always synchronous
constant DM_CLOCK_SYNC                  : integer := 0;

-- Always allow datamover address requests
constant ALWAYS_ALLOW                   : std_logic := '1';

constant ZERO_VALUE                     : std_logic_vector(1023 downto 0) := (others => '0');

--*****************************************************************************
--** S2MM DataMover Specific Constants
--*****************************************************************************
-- AXI DataMover mode for S2MM Channel (0 if channel not included)
constant S2MM_AXI_FULL_MODE             : integer := C_INCLUDE_S2MM * AXI_FULL_MODE;

-- 
-- Enable indeterminate BTT on datamover when S2MM Store And Forward Present
-- In this mode, the DataMovers S2MM store and forward buffer will be used
-- and underflow and overflow will be detected via receive byte compare
-- Enable indeterminate BTT on datamover when S2MM flush on frame sync is
-- enabled allowing S2MM AXIS stream absorption and prevent datamover
-- halt.  Overflow and Underfow error detected external to datamover
-- in axi_vdma_cmdsts.vhd
constant DM_SUPPORT_INDET_BTT           : integer := 1;


-- Indterminate BTT Mode additional status vector width
constant INDETBTT_ADDED_STS_WIDTH       : integer := 24;

-- DataMover status width is based on mode of operation
constant S2MM_DM_STATUS_WIDTH           : integer := BASE_STATUS_WIDTH
                                                  + (DM_SUPPORT_INDET_BTT * INDETBTT_ADDED_STS_WIDTH);
-- Never extend on S2MM
constant S2MM_DM_CMD_EXTENDED           : integer := 0;

-- Minimum value required for length width based on burst size and stream dwidth
-- If hsize is too small based on setting of burst size and
-- dwidth then this will reset the width to a larger mimimum requirement.
constant S2MM_DM_BTT_LENGTH_WIDTH       : integer := required_btt_width(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED,
                                                                   C_S2MM_MAX_BURST_LENGTH,
                                                                   HSIZE_DWIDTH);
constant C_INCLUDE_S2MM_SF_INT           : integer := 1;

-- Enable store and forward on datamover if data widths are mismatched (allows upsizers
-- to be instantiated) or when enabled by user.
constant DM_S2MM_INCLUDE_SF             : integer := enable_snf(C_INCLUDE_S2MM_SF_INT,
                                                                C_M_AXI_S2MM_DATA_WIDTH,
                                                                C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED);

--*****************************************************************************
--** MM2S DataMover Specific Constants
--*****************************************************************************
-- AXI DataMover mode for MM2S Channel (0 if channel not included)
constant MM2S_AXI_FULL_MODE             : integer := C_INCLUDE_MM2S * AXI_FULL_MODE;

-- Never extend on MM2S
constant MM2S_DM_CMD_NOT_EXTENDED       : integer := 0;

-- DataMover status width - fixed to 8 for MM2S
constant MM2S_DM_STATUS_WIDTH           : integer := BASE_STATUS_WIDTH;

-- Minimum value required for length width based on burst size and stream dwidth
-- If hsize is too small based on setting of burst size and
-- dwidth then this will reset the width to a larger mimimum requirement.
constant MM2S_DM_BTT_LENGTH_WIDTH       : integer := required_btt_width(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED,
                                                                  C_MM2S_MAX_BURST_LENGTH,
                                                                  HSIZE_DWIDTH);

-- Enable store and forward on datamover if data widths are mismatched (allows upsizers
-- to be instantiated) or when enabled by user.


----constant DM_MM2S_INCLUDE_SF             : integer := enable_snf(C_INCLUDE_MM2S_SF,
----                                                                C_M_AXI_MM2S_DATA_WIDTH,
----                                                                C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED);
----

constant DM_MM2S_INCLUDE_SF             : integer := enable_snf(0,
                                                                C_M_AXI_MM2S_DATA_WIDTH,
                                                                C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED);





--constant DM_MM2S_INCLUDE_SF             : integer := 0; 


--*****************************************************************************
--** Line Buffer Constants
--*****************************************************************************
-- For LineBuffer, track vertical lines to allow de-assertion of tready
-- when s2mm finished with frame. MM2S does not need to track lines
constant TRACK_NO_LINES                 : integer := 0;
constant TRACK_LINES                    : integer := 1;
-- zero vector of vsize width used to tie off mm2s line tracking ports
constant VSIZE_ZERO                     : std_logic_vector(VSIZE_DWIDTH-1 downto 0)
                                        := (others => '0');

-- Linebuffer default Almost Empty Threshold and Almost Full threshold
constant LINEBUFFER_AE_THRESH           : integer := 1;
constant LINEBUFFER_AF_THRESH           : integer := max2(1,C_MM2S_LINEBUFFER_DEPTH/2);

-- Include and Exclude settings for linebuffer skid buffers
constant INCLUDE_MSTR_SKID_BUFFER       : integer := 1;
constant EXCLUDE_MSTR_SKID_BUFFER       : integer := 0;
constant INCLUDE_SLV_SKID_BUFFER        : integer := 1;
constant EXCLUDE_SLV_SKID_BUFFER        : integer := 0;



-------- Force a depth of 512 minimum if asynchronous clocks enabled and a 128 minimum for synchronous mode
-------- Also converts depth in bytes to depth in data beats
------constant MM2S_LINEBUFFER_DEPTH          : integer := max2(128,(max2((C_MM2S_LINEBUFFER_DEPTH/(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8)),
------                                                          (C_PRMRY_IS_ACLK_ASYNC*512))));
------
-------- Force a depth of 512 minimum if asynchronous clocks enabled and a 128 minimum for synchronous mode
-------- Also converts depth in bytes to depth in data beats
------constant S2MM_LINEBUFFER_DEPTH          : integer := max2(128,(max2((C_S2MM_LINEBUFFER_DEPTH/(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED/8)),
------                                                          (C_PRMRY_IS_ACLK_ASYNC*512))));
------


--2013.1

--constant MM2S_LINEBUFFER_DEPTH          : integer :=  C_MM2S_LINEBUFFER_DEPTH;
--constant S2MM_LINEBUFFER_DEPTH          : integer :=  C_S2MM_LINEBUFFER_DEPTH; 
-- Force a depth of 512 minimum if asynchronous clocks enabled and a 128 minimum for synchronous mode
constant MM2S_LINEBUFFER_DEPTH          : integer := max2(128,(max2(C_MM2S_LINEBUFFER_DEPTH,(C_PRMRY_IS_ACLK_ASYNC*512))));

-- Force a depth of 512 minimum if asynchronous clocks enabled and a 128 minimum for synchronous mode
constant S2MM_LINEBUFFER_DEPTH          : integer := max2(128,(max2(C_S2MM_LINEBUFFER_DEPTH,(C_PRMRY_IS_ACLK_ASYNC*512))));


-- Enable SOF only for external frame sync and when SOF Enable parameter set
----constant MM2S_SOF_ENABLE                : integer := C_USE_MM2S_FSYNC * C_MM2S_SOF_ENABLE;
--constant MM2S_SOF_ENABLE                : integer := C_MM2S_SOF_ENABLE;
constant MM2S_SOF_ENABLE                : integer := 1;
--constant S2MM_SOF_ENABLE                : integer := C_USE_S2MM_FSYNC * C_S2MM_SOF_ENABLE;
--constant S2MM_SOF_ENABLE                : integer := C_USE_S2MM_FSYNC ;
constant S2MM_SOF_ENABLE                : integer := C_USE_S2MM_FSYNC_01 ;


--*****************************************************************************
--** GenLock Constants
--*****************************************************************************
-- GenLock Data Widths for Clock Domain Crossing Module
constant MM2S_GENLOCK_SLVE_PTR_DWIDTH   : integer := (C_MM2S_GENLOCK_NUM_MASTERS*NUM_FRM_STORE_WIDTH);
constant S2MM_GENLOCK_SLVE_PTR_DWIDTH   : integer := (C_S2MM_GENLOCK_NUM_MASTERS*NUM_FRM_STORE_WIDTH);

--constant INTERNAL_GENLOCK_ENABLE        : integer := enable_internal_genloc(C_INCLUDE_MM2S, C_INCLUDE_S2MM, C_INCLUDE_INTERNAL_GENLOCK,
--                                                                            C_MM2S_GENLOCK_MODE,
--                                                                            C_S2MM_GENLOCK_MODE);
--

constant INTERNAL_GENLOCK_ENABLE        : integer := enable_internal_genloc(C_INCLUDE_MM2S, C_INCLUDE_S2MM, 1,
                                                                            C_MM2S_GENLOCK_MODE,
                                                                            C_S2MM_GENLOCK_MODE);


constant C_MM2S_LINEBUFFER_THRESH_INT : integer := calculated_minimum_mm2s_linebuffer_thresh(C_INCLUDE_MM2S, C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED, C_MM2S_LINEBUFFER_DEPTH);
constant C_S2MM_LINEBUFFER_THRESH_INT : integer := calculated_minimum_s2mm_linebuffer_thresh(C_INCLUDE_S2MM, C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED, C_S2MM_LINEBUFFER_DEPTH);

Constant C_ROOT_FAMILY        : string  := C_FAMILY;  -- function from family_support.vhd

constant C_NUM_FSTORES_64 : integer := C_NUM_FSTORES/(C_M_AXI_S2MM_ADDR_WIDTH_NEW/32);

constant CMD_WIDTH : integer := C_M_AXI_MM2S_ADDR_WIDTH_NEW+CMD_BASE_WIDTH; 

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------


--type STARTADDR_ARRAY_TYPE_64        is array(natural range <>)
--                                 of std_logic_vector(C_M_AXI_S2MM_ADDR_WIDTH - 1 downto 0);

signal mm2s_prmry_resetn                : std_logic := '1';     -- AXI  MM2S Primary Reset
signal mm2s_dm_prmry_resetn             : std_logic := '1';     -- AXI  MM2S DataMover Primary Reset (Raw)
signal mm2s_axis_resetn                 : std_logic := '1';     -- AXIS MM2S Primary Reset
signal mm2s_axis_linebuf_reset_out                 : std_logic := '1';     -- AXIS MM2S Primary Reset
signal s2mm_axis_linebuf_reset_out                 : std_logic := '1';     -- AXIS MM2S Primary Reset
signal s2mm_axis_linebuf_reset_out_inv                 : std_logic := '1';     -- AXIS MM2S Primary Reset
signal s2mm_prmry_resetn                : std_logic := '1';     -- AXI  S2MM Primary Reset
signal s2mm_dm_prmry_resetn             : std_logic := '1';     -- AXI  S2MM DataMover Primary Reset (Raw)
signal s2mm_axis_resetn                 : std_logic := '1';     -- AXIS S2MM Primary Reset
signal s_axi_lite_resetn                : std_logic := '1';     -- AXI  Lite Interface Reset (Hard Only)
signal m_axi_sg_resetn                  : std_logic := '1';     -- AXI  Scatter Gather Interface Reset
signal m_axi_dm_sg_resetn               : std_logic := '1';     -- AXI  Scatter Gather Interface Reset (Raw)
signal mm2s_hrd_resetn                  : std_logic := '1';     -- AXI Hard Reset Only for MM2S
signal s2mm_hrd_resetn                  : std_logic := '1';     -- AXI Hard Reset Only for S2MM


-- MM2S Register Module Signals
signal mm2s_stop                        : std_logic := '0';
signal mm2s_stop_reg                        : std_logic := '0';
signal mm2s_halted_clr                  : std_logic := '0';
signal mm2s_halted_set                  : std_logic := '0';
signal mm2s_idle_set                    : std_logic := '0';
signal mm2s_idle_clr                    : std_logic := '0';
signal mm2s_dma_interr_set              : std_logic := '0';
signal mm2s_dma_interr_set_minus_frame_errors              : std_logic := '0';
signal mm2s_dma_slverr_set              : std_logic := '0';
signal mm2s_dma_decerr_set              : std_logic := '0';
signal mm2s_ioc_irq_set                 : std_logic := '0';
signal mm2s_dly_irq_set                 : std_logic := '0';
signal mm2s_irqdelay_status             : std_logic_vector(7 downto 0) := (others => '0');
signal mm2s_irqthresh_status            : std_logic_vector(7 downto 0) := (others => '0');
signal mm2s_new_curdesc_wren            : std_logic := '0';
signal mm2s_new_curdesc                 : std_logic_vector(C_M_AXI_SG_ADDR_WIDTH-1 downto 0)    := (others => '0');
signal mm2s_tailpntr_updated            : std_logic := '0';
signal mm2s_dmacr                       : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal mm2s_dmasr                       : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal mm2s_curdesc                     : std_logic_vector(C_M_AXI_SG_ADDR_WIDTH-1 downto 0)    := (others => '0');
signal mm2s_taildesc                    : std_logic_vector(C_M_AXI_SG_ADDR_WIDTH-1 downto 0)    := (others => '0');
signal mm2s_num_frame_store             : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0)      := (others => '0');
signal mm2s_linebuf_threshold           : std_logic_vector(THRESH_MSB_BIT downto 0)           := (others => '0');
signal mm2s_packet_sof                  : std_logic := '0';
signal mm2s_all_idle                    : std_logic := '0';
signal mm2s_cmdsts_idle                 : std_logic := '0';
signal mm2s_frame_number                : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal mm2s_chnl_current_frame                : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal mm2s_genlock_pair_frame                : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal mm2s_crnt_vsize                  : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');
signal mm2s_crnt_vsize_d2                  : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');
signal mm2s_dlyirq_dsble                : std_logic := '0';
signal mm2s_irqthresh_rstdsbl           : std_logic := '0';
signal mm2s_valid_video_prmtrs          : std_logic := '0';
signal mm2s_all_lines_xfred             : std_logic := '0';
signal mm2s_all_lines_xfred_s           : std_logic := '0';
signal mm2s_all_lines_xfred_s_dwidth    : std_logic := '0';
signal mm2s_fsize_mismatch_err          : std_logic := '0'; -- 
signal mm2s_lsize_mismatch_err          : std_logic := '0'; -- 
signal mm2s_lsize_more_mismatch_err          : std_logic := '0'; -- 
signal mm2s_frame_ptr_out_i             : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0) := (others => '0');
signal mm2s_to_s2mm_fsync               : std_logic := '0';

-- MM2S Register Direct Support
signal mm2s_regdir_idle                 : std_logic := '0';
signal mm2s_prmtr_updt_complete         : std_logic := '0';
signal mm2s_reg_module_vsize            : std_logic_vector(VSIZE_DWIDTH-1 downto 0);
signal mm2s_reg_module_hsize            : std_logic_vector(HSIZE_DWIDTH-1 downto 0);
signal mm2s_reg_module_stride           : std_logic_vector(STRIDE_DWIDTH-1 downto 0);
signal mm2s_reg_module_frmdly           : std_logic_vector(FRMDLY_DWIDTH-1 downto 0);
signal mm2s_reg_module_strt_addr        : STARTADDR_ARRAY_TYPE(0 to C_NUM_FSTORES - 1);
signal mm2s_reg_module_strt_addr_64        : STARTADDR_ARRAY_TYPE_64(0 to C_NUM_FSTORES_64 - 1);

-- MM2S Register Interface Signals
signal mm2s_axi2ip_wrce                 : std_logic_vector(TOTAL_NUM_REGISTER-1 downto 0)       := (others => '0');
signal mm2s_axi2ip_wrdata               : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0')      ;
signal mm2s_axi2ip_rdaddr               : std_logic_vector(C_S_AXI_LITE_ADDR_WIDTH-1 downto 0)  := (others => '0')      ;
--signal mm2s_axi2ip_rden                 : std_logic := '0';
signal mm2s_ip2axi_rddata               : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0')      ;
--signal mm2s_ip2axi_rddata_valid         : std_logic := '0';
signal mm2s_ip2axi_frame_ptr_ref        : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal mm2s_ip2axi_frame_store          : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal mm2s_ip2axi_introut              : std_logic := '0';

-- MM2S Scatter Gather clock domain crossing signals
signal mm2s_cdc2sg_run_stop             : std_logic := '0';
signal mm2s_cdc2sg_stop                 : std_logic := '0';
signal mm2s_cdc2sg_taildesc_wren        : std_logic := '0';
signal mm2s_cdc2sg_taildesc             : std_logic_vector(C_M_AXI_SG_ADDR_WIDTH-1 downto 0) := (others => '0');
signal mm2s_cdc2sg_curdesc              : std_logic_vector(C_M_AXI_SG_ADDR_WIDTH-1 downto 0) := (others => '0');
signal mm2s_sg2cdc_ftch_idle            : std_logic := '0';
signal mm2s_sg2cdc_ftch_interr_set      : std_logic := '0';
signal mm2s_sg2cdc_ftch_slverr_set      : std_logic := '0';
signal mm2s_sg2cdc_ftch_decerr_set      : std_logic := '0';

-- MM2S DMA Controller Signals
signal mm2s_ftch_idle                   : std_logic := '0';
signal mm2s_updt_ioc_irq_set            : std_logic := '0';
signal mm2s_irqthresh_wren              : std_logic := '0';
signal mm2s_irqdelay_wren               : std_logic := '0';
signal mm2s_ftchcmdsts_idle             : std_logic := '0';

-- SG MM2S Descriptor Fetch AXI Stream IN
signal m_axis_mm2s_ftch_tdata           : std_logic_vector(M_AXIS_SG_TDATA_WIDTH-1 downto 0) := (others => '0');
signal m_axis_mm2s_ftch_tvalid          : std_logic := '0';
signal m_axis_mm2s_ftch_tready          : std_logic := '0';
signal m_axis_mm2s_ftch_tlast           : std_logic := '0';

-- DataMover MM2S Command Stream Signals
signal s_axis_mm2s_cmd_tvalid           : std_logic := '0';
signal s_axis_mm2s_cmd_tready           : std_logic := '0';
signal s_axis_mm2s_cmd_tdata            : std_logic_vector
                                            ((C_M_AXI_MM2S_ADDR_WIDTH_NEW+CMD_BASE_WIDTH)-1 downto 0) := (others => '0');
-- DataMover MM2S Status Stream Signals
signal m_axis_mm2s_sts_tvalid           : std_logic := '0';
signal m_axis_mm2s_sts_tready           : std_logic := '0';
signal m_axis_mm2s_sts_tdata            : std_logic_vector(MM2S_DM_STATUS_WIDTH - 1 downto 0) := (others => '0');   -- 
signal m_axis_mm2s_sts_tkeep            : std_logic_vector((MM2S_DM_STATUS_WIDTH/8)-1 downto 0) := (others => '0'); -- 
signal mm2s_err                         : std_logic := '0';
signal mm2s_halt                        : std_logic := '0';
signal mm2s_halt_reg                        : std_logic := '0';
signal mm2s_halt_cmplt                  : std_logic := '0';

-- DataMover To Line Buffer AXI Stream Signals
signal dm2linebuf_mm2s_tdata            : std_logic_vector(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED-1 downto 0);
signal dm2linebuf_mm2s_tkeep            : std_logic_vector((C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8)-1 downto 0);
signal dm2linebuf_mm2s_tlast            : std_logic := '0';
signal dm2linebuf_mm2s_tvalid           : std_logic := '0';
signal linebuf2dm_mm2s_tready           : std_logic := '0';

-- MM2S Error Status Control
signal mm2s_ftch_interr_set             : std_logic := '0';
signal mm2s_ftch_slverr_set             : std_logic := '0';
signal mm2s_ftch_decerr_set             : std_logic := '0';

-- MM2S Soft Reset support
signal mm2s_soft_reset                  : std_logic := '0';
signal mm2s_soft_reset_clr              : std_logic := '0';

-- MM2S SOF generation support
signal m_axis_mm2s_tvalid_i             : std_logic := '0';
signal m_axis_mm2s_tvalid_i_axis_dw_conv             : std_logic := '0';
signal m_axis_mm2s_tlast_i              : std_logic := '0';
signal m_axis_mm2s_tlast_i_axis_dw_conv              : std_logic := '0';

signal              s_axis_s2mm_tdata_i           :   std_logic_vector                                      --
                                        (C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED-1 downto 0) := (others => '0');                 --
signal              s_axis_s2mm_tkeep_i           :   std_logic_vector                                      --
                                        ((C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED/8)-1 downto 0) := (others => '0');             --
signal              s_axis_s2mm_tuser_i           :   std_logic_vector                                      --
                                        (C_S_AXIS_S2MM_TUSER_BITS-1 downto 0) := (others => '0');                  --
signal              s_axis_s2mm_tvalid_i          :   std_logic                         ;                   --
signal              s_axis_s2mm_tvalid_int          :   std_logic                         ;                   --
signal              s_axis_s2mm_tlast_i           :   std_logic ;            


signal         m_axis_mm2s_tdata_i           : std_logic_vector                                      --
                                        (C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED-1 downto 0) := (others => '0');                 --
signal         m_axis_mm2s_tkeep_i           : std_logic_vector                                      --
                                        ((C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8)-1 downto 0) := (others => '0');             --
signal         m_axis_mm2s_tuser_i           : std_logic_vector                                      --
                                        (C_M_AXIS_MM2S_TUSER_BITS-1 downto 0) := (others => '0');                  --
signal         m_axis_mm2s_tready_i          : std_logic                         ;                   --
-- S2MM Register Module Signals
signal s2mm_stop                        : std_logic := '0';
signal s2mm_halted_clr                  : std_logic := '0';
signal s2mm_halted_set                  : std_logic := '0';
signal s2mm_idle_set                    : std_logic := '0';
signal s2mm_idle_clr                    : std_logic := '0';
signal s2mm_dma_interr_set              : std_logic := '0';
signal s2mm_dma_interr_set_minus_frame_errors              : std_logic := '0';
signal s2mm_dma_slverr_set              : std_logic := '0';
signal s2mm_dma_decerr_set              : std_logic := '0';
signal s2mm_ioc_irq_set                 : std_logic := '0';
signal s2mm_dly_irq_set                 : std_logic := '0';
signal s2mm_irqdelay_status             : std_logic_vector(7 downto 0) := (others => '0');
signal s2mm_irqthresh_status            : std_logic_vector(7 downto 0) := (others => '0');
signal s2mm_new_curdesc_wren            : std_logic := '0';
signal s2mm_new_curdesc                 : std_logic_vector(C_M_AXI_SG_ADDR_WIDTH-1 downto 0)    := (others => '0');
signal s2mm_tailpntr_updated            : std_logic := '0';
signal s2mm_dmacr                       : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal s2mm_dmasr                       : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal s2mm_curdesc                     : std_logic_vector(C_M_AXI_SG_ADDR_WIDTH-1 downto 0)    := (others => '0');
signal s2mm_taildesc                    : std_logic_vector(C_M_AXI_SG_ADDR_WIDTH-1 downto 0)    := (others => '0');
signal s2mm_num_frame_store             : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0)      := (others => '0');
signal s2mm_linebuf_threshold           : std_logic_vector(THRESH_MSB_BIT downto 0)           := (others => '0');
signal s2mm_packet_sof                  : std_logic := '0';
signal s2mm_all_idle                    : std_logic := '0';
signal s2mm_cmdsts_idle                 : std_logic := '0';
signal s2mm_frame_number                : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal s2mm_chnl_current_frame                : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal s2mm_genlock_pair_frame                : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal s2mm_dlyirq_dsble                : std_logic := '0';
signal s2mm_irqthresh_rstdsbl           : std_logic := '0';
signal s2mm_valid_video_prmtrs          : std_logic := '0';
signal s2mm_crnt_vsize                  : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');-- 
signal s2mm_update_frmstore             : std_logic := '0'; --
signal s2mm_frmstr_err_addr           : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0'); --
signal s2mm_all_lines_xfred             : std_logic := '0'; -- 
signal all_lasts_rcvd                   : std_logic := '0';
signal s2mm_capture_hsize_at_uf_err_sig : std_logic_vector(15 downto 0) ;
signal s2mm_capture_dm_done_vsize_counter_sig : std_logic_vector(12 downto 0) ;


signal s2mm_fsize_mismatch_err_flag          : std_logic := '0'; -- 
signal s2mm_fsize_mismatch_err          : std_logic := '0'; -- 
signal s2mm_lsize_mismatch_err          : std_logic := '0'; -- 
signal s2mm_lsize_more_mismatch_err          : std_logic := '0'; -- 
signal s2mm_tuser_fsync                 : std_logic := '0';
signal s2mm_frame_ptr_out_i             : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0) := (others => '0');
signal s2mm_to_mm2s_fsync               : std_logic := '0';

-- S2MM Register Direct Support
signal s2mm_regdir_idle                 : std_logic := '0';
signal s2mm_prmtr_updt_complete         : std_logic := '0';
signal s2mm_reg_module_vsize            : std_logic_vector(VSIZE_DWIDTH-1 downto 0);
signal s2mm_reg_module_hsize            : std_logic_vector(HSIZE_DWIDTH-1 downto 0);
signal s2mm_reg_module_stride           : std_logic_vector(STRIDE_DWIDTH-1 downto 0);
signal s2mm_reg_module_frmdly           : std_logic_vector(FRMDLY_DWIDTH-1 downto 0);
signal s2mm_reg_module_strt_addr        : STARTADDR_ARRAY_TYPE(0 to C_NUM_FSTORES - 1);
signal s2mm_reg_module_strt_addr_64        : STARTADDR_ARRAY_TYPE_64(0 to C_NUM_FSTORES_64 - 1);

-- S2MM Register Interface Signals
signal s2mm_axi2ip_wrce                 : std_logic_vector(TOTAL_NUM_REGISTER-1 downto 0)       := (others => '0');
signal s2mm_axi2ip_wrdata               : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal s2mm_axi2ip_rdaddr               : std_logic_vector(C_S_AXI_LITE_ADDR_WIDTH-1 downto 0)  := (others => '0');
--signal s2mm_axi2ip_rden                 : std_logic := '0';
signal s2mm_ip2axi_rddata               : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
--signal s2mm_ip2axi_rddata_valid         : std_logic := '0';
signal s2mm_ip2axi_frame_ptr_ref        : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal s2mm_ip2axi_frame_store          : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal s2mm_ip2axi_introut              : std_logic := '0';

-- S2MM Scatter Gather clock domain crossing signals
signal s2mm_cdc2sg_run_stop             : std_logic := '0';
signal s2mm_cdc2sg_stop                 : std_logic := '0';
signal s2mm_cdc2sg_taildesc_wren        : std_logic := '0';
signal s2mm_cdc2sg_taildesc             : std_logic_vector(C_M_AXI_SG_ADDR_WIDTH-1 downto 0) := (others => '0');
signal s2mm_cdc2sg_curdesc              : std_logic_vector(C_M_AXI_SG_ADDR_WIDTH-1 downto 0) := (others => '0');
signal s2mm_sg2cdc_ftch_idle            : std_logic := '0';
signal s2mm_sg2cdc_ftch_interr_set      : std_logic := '0';
signal s2mm_sg2cdc_ftch_slverr_set      : std_logic := '0';
signal s2mm_sg2cdc_ftch_decerr_set      : std_logic := '0';

-- S2MM DMA Controller Signals
signal s2mm_desc_flush                  : std_logic := '0';
signal s2mm_ftch_idle                   : std_logic := '0';
signal s2mm_irqthresh_wren              : std_logic := '0';
signal s2mm_irqdelay_wren               : std_logic := '0';
signal s2mm_ftchcmdsts_idle             : std_logic := '0';

-- SG S2MM Descriptor Fetch AXI Stream IN
signal m_axis_s2mm_ftch_tdata           : std_logic_vector(M_AXIS_SG_TDATA_WIDTH-1 downto 0) := (others => '0');
signal m_axis_s2mm_ftch_tvalid          : std_logic := '0';
signal m_axis_s2mm_ftch_tready          : std_logic := '0';
signal m_axis_s2mm_ftch_tlast           : std_logic := '0';

-- DataMover S2MM Command Stream Signals
signal s_axis_s2mm_cmd_tvalid           : std_logic := '0';
signal s_axis_s2mm_cmd_tready           : std_logic := '0';
signal s_axis_s2mm_cmd_tdata            : std_logic_vector
                                        ((C_M_AXI_S2MM_ADDR_WIDTH_NEW+CMD_BASE_WIDTH)-1 downto 0) := (others => '0');
-- DataMover S2MM Status Stream Signals
signal m_axis_s2mm_sts_tvalid           : std_logic := '0';
signal m_axis_s2mm_sts_tready           : std_logic := '0';
signal m_axis_s2mm_sts_tdata            : std_logic_vector(S2MM_DM_STATUS_WIDTH - 1 downto 0) := (others => '0');   -- 
signal m_axis_s2mm_sts_tkeep            : std_logic_vector((S2MM_DM_STATUS_WIDTH/8)-1 downto 0) := (others => '0'); -- 
signal s2mm_err                         : std_logic := '0';
signal s2mm_halt                        : std_logic := '0';
signal s2mm_halt_cmplt                  : std_logic := '0';

-- Line Buffer To DataMover AXI Stream Signals
signal linebuf2dm_s2mm_tdata            : std_logic_vector(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED-1 downto 0);
signal linebuf2dm_s2mm_tkeep            : std_logic_vector((C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED/8)-1 downto 0);
signal linebuf2dm_s2mm_tlast            : std_logic := '0';
signal linebuf2dm_s2mm_tvalid           : std_logic := '0';
signal dm2linebuf_s2mm_tready           : std_logic := '0';

-- S2MM Error Status Control
signal s2mm_ftch_interr_set             : std_logic := '0';
signal s2mm_ftch_slverr_set             : std_logic := '0';
signal s2mm_ftch_decerr_set             : std_logic := '0';

-- S2MM Soft Reset support
signal s2mm_soft_reset                  : std_logic := '0';
signal s2mm_soft_reset_clr              : std_logic := '0';

-- S2MM SOF generation support
signal s_axis_s2mm_tready_i             : std_logic := '0';
signal s_axis_s2mm_tready_i_axis_dw_conv             : std_logic := '0';


-- S2MM Vertical Flip support
signal s2mm_vflip                       : std_logic := '1';


-- Video specific
signal s2mm_frame_sync                  : std_logic := '0';
signal mm2s_frame_sync                  : std_logic := '0';
signal mm2s_parameter_update            : std_logic := '0';
signal s2mm_parameter_update            : std_logic := '0';

-- Line Buffer Support
signal mm2s_allbuffer_empty             : std_logic := '0';
signal mm2s_dwidth_fifo_pipe_empty             : std_logic := '0';
signal mm2s_dwidth_fifo_pipe_empty_m             : std_logic := '0';

-- Video CDC support
signal mm2s_cdc2dmac_fsync              : std_logic := '0';
signal mm2s_dmac2cdc_fsync_out          : std_logic := '0';
signal mm2s_dmac2cdc_prmtr_update       : std_logic := '0';
signal mm2s_vid2cdc_packet_sof          : std_logic := '0';

signal s2mm_cdc2dmac_fsync              : std_logic := '0';
signal s2mm_dmac2cdc_fsync_out          : std_logic := '0';
signal s2mm_dmac2cdc_prmtr_update       : std_logic := '0';
signal s2mm_vid2cdc_packet_sof          : std_logic := '0';

-- fsync qualified by valid parameters for frame count
-- decrement
signal mm2s_valid_frame_sync            : std_logic := '0';
signal s2mm_valid_frame_sync            : std_logic := '0';
signal mm2s_valid_frame_sync_cmb        : std_logic := '0';
signal s2mm_valid_frame_sync_cmb        : std_logic := '0';

--signal for test bench and for output
signal s2mm_tstvect_err               : std_logic := '0';
signal mm2s_tstvect_err               : std_logic := '0';
signal s2mm_tstvect_fsync               : std_logic := '0';
signal mm2s_tstvect_fsync               : std_logic := '0';
signal s2mm_tstvect_frame               : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal mm2s_tstvect_frame               : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal s2mm_fsync_out_i                 : std_logic := '0';
signal s2mm_fsync_out_m_i                 : std_logic := '0';
signal mm2s_fsync_out_i                 : std_logic := '0';
signal mm2s_mask_fsync_out              : std_logic := '0';
signal s2mm_mask_fsync_out              : std_logic := '0';

signal mm2s_mstrfrm_tstsync_out         : std_logic := '0';
signal s2mm_mstrfrm_tstsync_out         : std_logic := '0';

-- Genlock pointer signals
signal mm2s_mstrfrm_tstsync             : std_logic := '0';
signal mm2s_s_frame_ptr_in              : std_logic_vector(MM2S_GENLOCK_SLVE_PTR_DWIDTH-1 downto 0) := (others => '0');
signal mm2s_m_frame_ptr_out             : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0) := (others => '0');

signal s2mm_mstrfrm_tstsync             : std_logic := '0';
signal s2mm_s_frame_ptr_in              : std_logic_vector(S2MM_GENLOCK_SLVE_PTR_DWIDTH-1 downto 0) := (others => '0');
signal s2mm_m_frame_ptr_out             : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0) := (others => '0');
signal mm2s_tstvect_frm_ptr_out         : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal s2mm_tstvect_frm_ptr_out         : std_logic_vector(FRAME_NUMBER_WIDTH-1 downto 0) := (others => '0');
signal  sg2cdc_ftch_err_addr          : std_logic_vector(C_M_AXI_SG_ADDR_WIDTH-1 downto 0) := (others => '0');
signal  sg2cdc_ftch_err               : std_logic := '0';
signal  mm2s_ftch_err_addr            : std_logic_vector(C_M_AXI_SG_ADDR_WIDTH-1 downto 0) := (others => '0');
signal  mm2s_ftch_err                 : std_logic := '0';
signal  s2mm_ftch_err_addr            : std_logic_vector(C_M_AXI_SG_ADDR_WIDTH-1 downto 0) := (others => '0');
signal  s2mm_ftch_err                 : std_logic := '0';
-- Internal GenLock bus support
signal s2mm_to_mm2s_frame_ptr_in        : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0) := (others => '0');
signal mm2s_to_s2mm_frame_ptr_in        : std_logic_vector(NUM_FRM_STORE_WIDTH-1 downto 0) := (others => '0');
signal mm2s_reg_index                   : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal s2mm_reg_index                   : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal s2mm_crnt_vsize_d2               : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0');
signal s2mm_fsync_src_select_s          : std_logic_vector(1 downto 0) := (others => '0');
signal hold_dummy_tready_low	        : std_logic := '0';
signal hold_dummy_tready_low2	        : std_logic := '0';
signal drop_fsync_d_pulse_gen_fsize_less_err	                : std_logic := '0';
signal s2mm_tuser_fsync_top	        : std_logic := '0';
signal s2mm_fsync_core	                : std_logic := '0';
signal s2mm_chnl_ready	                : std_logic := '0';
signal s2mm_strm_not_finished           : std_logic := '0';
signal s2mm_strm_all_lines_rcvd         : std_logic := '0';
signal s2mm_all_vount_rcvd              : std_logic := '0';
signal s2mm_fsize_mismatch_err_s        : std_logic := '0'; 
signal s2mm_fsize_less_err_internal_tvalid_gating          	: std_logic := '0'; 
signal s2mm_dummy_tready		: std_logic := '0';
signal s2mm_fsize_more_or_sof_late_s		: std_logic := '0';
signal s2mm_fsize_more_or_sof_late		: std_logic := '0';
signal        s_axis_s2mm_tdata_signal           :   std_logic_vector                                      --
                                        (C_S_AXIS_S2MM_TDATA_WIDTH-1 downto 0) := (others => '0');                 --
signal        s_axis_s2mm_tkeep_signal           :   std_logic_vector                                      --
                                        ((C_S_AXIS_S2MM_TDATA_WIDTH/8)-1 downto 0) := (others => '0');             --
signal        s_axis_s2mm_tuser_signal           :   std_logic_vector                                      --
                                        (C_S_AXIS_S2MM_TUSER_BITS-1 downto 0) := (others => '0');                  --
signal        s_axis_s2mm_tvalid_signal          :   std_logic                         := '0';                   --
signal        s_axis_s2mm_tready_signal          :   std_logic                         := '0';                   --
signal        s_axis_s2mm_tlast_signal           :   std_logic                         := '0';                   --


signal mm2s_fsync_core	                : std_logic := '0';
signal mm2s_fsize_mismatch_err_s        : std_logic := '0';
signal mm2s_fsize_mismatch_err_m        : std_logic := '0';
signal MM2S_DROP_RESIDUAL_OF_FSIZE_ERR_FRAME_S        : std_logic := '0';
signal m_axis_mm2s_tready_i2          	: std_logic                         ;                   --
signal m_axis_mm2s_tvalid_i2          	: std_logic                         ;                   --
signal mm2s_fsync_out_m                 : std_logic := '0';
signal mm2s_fsize_mismatch_err_flag          : std_logic := '0'; -- 
signal mm2s_vsize_cntr_clr_flag          : std_logic := '0'; -- 
signal mm2s_fsync_d1               : std_logic := '0';
signal mm2s_fsync_d2               : std_logic := '0';
signal mm2s_fsync_fe               : std_logic := '0';
signal s2mm_fsync_d1               : std_logic := '0';
signal s2mm_fsync_d2               : std_logic := '0';
signal s2mm_fsync_fe               : std_logic := '0';
signal mm2s_buffer_empty_i         : std_logic := '0';
signal s2mm_buffer_full_i          : std_logic := '0';
signal mm2s_buffer_almost_empty_i  : std_logic := '0';
signal s2mm_buffer_almost_full_i   : std_logic := '0';
signal mm2s_prmtr_update_i         : std_logic := '0';
signal s2mm_prmtr_update_i         : std_logic := '0';
signal mm2s_fsync_out_sig          : std_logic := '0';
signal s2mm_fsync_out_sig          : std_logic := '0';
signal axi_vdma_tstvec_i           : std_logic_vector(63 downto 0) := (others => '0');
signal mm2s_prmry_reset_out_n_i   : std_logic := '1';
signal s2mm_prmry_reset_out_n_i   : std_logic := '1';
signal m_axi_mm2s_araddr_int : std_logic_vector (C_M_AXI_MM2S_ADDR_WIDTH_NEW-1 downto 0)  ;
signal m_axi_s2mm_awaddr_int : std_logic_vector (C_M_AXI_S2MM_ADDR_WIDTH_NEW-1 downto 0)  ;

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin


ENABLE_MM2S_PRMRY_RESET_OUT_N : if (C_INCLUDE_MM2S = 1 and (C_ENABLE_DEBUG_INFO_0 = 1 or C_ENABLE_DEBUG_ALL = 1)) generate
begin 
	mm2s_prmry_reset_out_n <= mm2s_prmry_reset_out_n_i;

end generate ENABLE_MM2S_PRMRY_RESET_OUT_N;
  

DISABLE_MM2S_PRMRY_RESET_OUT_N : if (C_INCLUDE_MM2S = 0 or (C_ENABLE_DEBUG_INFO_0 = 0 and C_ENABLE_DEBUG_ALL = 0)) generate
begin 
	mm2s_prmry_reset_out_n <= '1';

end generate DISABLE_MM2S_PRMRY_RESET_OUT_N;



ENABLE_MM2S_BUFFER_EMPTY : if (C_INCLUDE_MM2S = 1 and (C_ENABLE_DEBUG_INFO_1 = 1 or C_ENABLE_DEBUG_ALL = 1)) generate
begin 
	mm2s_buffer_empty <= mm2s_buffer_empty_i;
	mm2s_buffer_almost_empty <= mm2s_buffer_almost_empty_i;

end generate ENABLE_MM2S_BUFFER_EMPTY;
  

DISABLE_MM2S_BUFFER_EMPTY : if (C_INCLUDE_MM2S = 0 or (C_ENABLE_DEBUG_INFO_1 = 0 and C_ENABLE_DEBUG_ALL = 0)) generate
begin 
	mm2s_buffer_empty <= '0';
	mm2s_buffer_almost_empty <= '0';

end generate DISABLE_MM2S_BUFFER_EMPTY;



ENABLE_MM2S_PRMTR_UPDATE : if (C_INCLUDE_MM2S = 1 and (C_ENABLE_DEBUG_INFO_2 = 1 or C_ENABLE_DEBUG_ALL = 1)) generate
begin 
	mm2s_prmtr_update <= mm2s_prmtr_update_i;

end generate ENABLE_MM2S_PRMTR_UPDATE;
  

DISABLE_MM2S_PRMTR_UPDATE : if (C_INCLUDE_MM2S = 0 or (C_ENABLE_DEBUG_INFO_2 = 0 and C_ENABLE_DEBUG_ALL = 0)) generate
begin 
	mm2s_prmtr_update <= '0';

end generate DISABLE_MM2S_PRMTR_UPDATE;


ENABLE_MM2S_FSYNC_OUT : if (C_INCLUDE_MM2S = 1 and (C_ENABLE_DEBUG_INFO_3 = 1 or C_ENABLE_DEBUG_ALL = 1)) generate
begin 
	mm2s_fsync_out <= mm2s_fsync_out_sig;

end generate ENABLE_MM2S_FSYNC_OUT;
  

DISABLE_MM2S_FSYNC_OUT : if (C_INCLUDE_MM2S = 0 or (C_ENABLE_DEBUG_INFO_3 = 0 and C_ENABLE_DEBUG_ALL = 0)) generate
begin 
	mm2s_fsync_out <= '0';

end generate DISABLE_MM2S_FSYNC_OUT;


ENABLE_AXI_VDMA_TSTVEC : if (C_ENABLE_DEBUG_INFO_4 = 1 or C_ENABLE_DEBUG_ALL = 1) generate
begin 
	axi_vdma_tstvec <= axi_vdma_tstvec_i;

end generate ENABLE_AXI_VDMA_TSTVEC;
  

DISABLE_AXI_VDMA_TSTVEC : if (C_ENABLE_DEBUG_INFO_4 = 0 and C_ENABLE_DEBUG_ALL = 0) generate
begin 
	axi_vdma_tstvec <= (others => '0');

end generate DISABLE_AXI_VDMA_TSTVEC;



ENABLE_S2MM_PRMRY_RESET_OUT_N : if (C_INCLUDE_S2MM = 1 and (C_ENABLE_DEBUG_INFO_8 = 1 or C_ENABLE_DEBUG_ALL = 1)) generate
begin 
	s2mm_prmry_reset_out_n <= s2mm_prmry_reset_out_n_i;

end generate ENABLE_S2MM_PRMRY_RESET_OUT_N;
  

DISABLE_S2MM_PRMRY_RESET_OUT_N : if (C_INCLUDE_S2MM = 0 or (C_ENABLE_DEBUG_INFO_8 = 0 and C_ENABLE_DEBUG_ALL = 0)) generate
begin 
	s2mm_prmry_reset_out_n <= '1';

end generate DISABLE_S2MM_PRMRY_RESET_OUT_N;



ENABLE_S2MM_BUFFER_FULL : if (C_INCLUDE_S2MM = 1 and (C_ENABLE_DEBUG_INFO_9 = 1 or C_ENABLE_DEBUG_ALL = 1)) generate
begin 
	s2mm_buffer_full <= s2mm_buffer_full_i;
	s2mm_buffer_almost_full <= s2mm_buffer_almost_full_i;

end generate ENABLE_S2MM_BUFFER_FULL;
  

DISABLE_S2MM_BUFFER_FULL : if (C_INCLUDE_S2MM = 0 or (C_ENABLE_DEBUG_INFO_9 = 0 and C_ENABLE_DEBUG_ALL = 0)) generate
begin 
	s2mm_buffer_full <= '0';
	s2mm_buffer_almost_full <= '0';

end generate DISABLE_S2MM_BUFFER_FULL;



ENABLE_S2MM_PRMTR_UPDATE : if (C_INCLUDE_S2MM = 1 and (C_ENABLE_DEBUG_INFO_10 = 1 or C_ENABLE_DEBUG_ALL = 1)) generate
begin 
	s2mm_prmtr_update <= s2mm_prmtr_update_i;

end generate ENABLE_S2MM_PRMTR_UPDATE;
  

DISABLE_S2MM_PRMTR_UPDATE : if (C_INCLUDE_S2MM = 0 or (C_ENABLE_DEBUG_INFO_10 = 0 and C_ENABLE_DEBUG_ALL = 0)) generate
begin 
	s2mm_prmtr_update <= '0';

end generate DISABLE_S2MM_PRMTR_UPDATE;



ENABLE_S2MM_FSYNC_OUT : if (C_INCLUDE_S2MM = 1 and (C_ENABLE_DEBUG_INFO_11 = 1 or C_ENABLE_DEBUG_ALL = 1)) generate
begin 
	s2mm_fsync_out <= s2mm_fsync_out_sig;

end generate ENABLE_S2MM_FSYNC_OUT;
  

DISABLE_S2MM_FSYNC_OUT : if (C_INCLUDE_S2MM = 0 or (C_ENABLE_DEBUG_INFO_11 = 0 and C_ENABLE_DEBUG_ALL = 0)) generate
begin 
	s2mm_fsync_out <= '0';

end generate DISABLE_S2MM_FSYNC_OUT;








-- AXI DMA Test Vector (For Xilinx Internal Use Only)
axi_vdma_tstvec_i(63 downto 59)   		<= s2mm_tstvect_frm_ptr_out;		---
axi_vdma_tstvec_i(58 downto 54)   		<= mm2s_tstvect_frm_ptr_out;		---
axi_vdma_tstvec_i(53 downto 49)   		<= s2mm_tstvect_frame;		---
axi_vdma_tstvec_i(48 downto 44)   		<= mm2s_tstvect_frame;		---
axi_vdma_tstvec_i(43 downto 33) 		<= (others => '0');
axi_vdma_tstvec_i(32) 				<= s2mm_strm_all_lines_rcvd;		-- 
axi_vdma_tstvec_i(31) 				<= s2mm_halt;		-- DataMover halt tracking
axi_vdma_tstvec_i(30) 				<= mm2s_halt;		-- DataMover halt tracking
axi_vdma_tstvec_i(29)             		<= s2mm_tstvect_err;
axi_vdma_tstvec_i(28)             		<= mm2s_tstvect_err;
axi_vdma_tstvec_i(27 downto 24)   		<= s2mm_tstvect_frm_ptr_out(3 downto 0);		--
axi_vdma_tstvec_i(23 downto 20)   		<= mm2s_tstvect_frm_ptr_out(3 downto 0);		--
axi_vdma_tstvec_i(19)             		<= s2mm_mstrfrm_tstsync_out;
axi_vdma_tstvec_i(18)             		<= mm2s_mstrfrm_tstsync_out;
axi_vdma_tstvec_i(17)             		<= s2mm_dmasr(DMASR_HALTED_BIT);
axi_vdma_tstvec_i(16)             		<= mm2s_dmasr(DMASR_HALTED_BIT);
axi_vdma_tstvec_i(15 downto 12)   		<= s2mm_tstvect_frame(3 downto 0);			--
axi_vdma_tstvec_i(11 downto 8)    		<= mm2s_tstvect_frame(3 downto 0);			--
axi_vdma_tstvec_i(7)              		<= s2mm_tstvect_fsync
                                    			and not s2mm_mask_fsync_out;
axi_vdma_tstvec_i(6)              		<= mm2s_tstvect_fsync
                                    			and not mm2s_mask_fsync_out;
axi_vdma_tstvec_i(5)              		<= s2mm_tstvect_fsync;
axi_vdma_tstvec_i(4)              		<= mm2s_tstvect_fsync;
axi_vdma_tstvec_i(3)              		<= s2mm_dummy_tready and s_axis_s2mm_tvalid_signal;
axi_vdma_tstvec_i(2)              		<= s2mm_packet_sof;
axi_vdma_tstvec_i(1)              		<= mm2s_all_lines_xfred;
axi_vdma_tstvec_i(0)              		<= mm2s_packet_sof;



GEN_MM2S_ENABLE : if C_INCLUDE_MM2S = 1 generate
begin
GEN_MM2S_D1_REG : process(m_axis_mm2s_aclk)
    begin
        if(m_axis_mm2s_aclk'EVENT and m_axis_mm2s_aclk = '1')then

	  mm2s_fsync_d1      <= mm2s_fsync;
	  mm2s_fsync_d2      <= mm2s_fsync_d1;

        end if;
    end process GEN_MM2S_D1_REG;




mm2s_fsync_fe <= mm2s_fsync_d2 and not mm2s_fsync_d1;
end generate GEN_MM2S_ENABLE;
GEN_NO_MM2S_ENABLE : if C_INCLUDE_MM2S = 0 generate
begin
mm2s_fsync_fe <= '0';
end generate GEN_NO_MM2S_ENABLE;

GEN_S2MM_ENABLE : if C_INCLUDE_S2MM = 1 generate
begin
GEN_S2MM_D1_REG : process(s_axis_s2mm_aclk)
    begin
        if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then

	  s2mm_fsync_d1      <= s2mm_fsync;
	  s2mm_fsync_d2      <= s2mm_fsync_d1;

        end if;
    end process GEN_S2MM_D1_REG;

s2mm_fsync_fe <= s2mm_fsync_d2 and not s2mm_fsync_d1;
end generate GEN_S2MM_ENABLE;

GEN_NO_S2MM_ENABLE : if C_INCLUDE_S2MM = 0 generate
begin
s2mm_fsync_fe <= '0';
end generate GEN_NO_S2MM_ENABLE;

s2mm_fsize_more_or_sof_late_s 		<= s2mm_dummy_tready and s_axis_s2mm_tvalid_signal and not s2mm_fsize_less_err_internal_tvalid_gating;




--s_axis_s2mm_tready              <= s_axis_s2mm_tready_i_axis_dw_conv;
--m_axis_mm2s_tvalid              <= m_axis_mm2s_tvalid_i_axis_dw_conv;


m_axis_mm2s_tvalid              <= m_axis_mm2s_tvalid_i2;
m_axis_mm2s_tlast               <= m_axis_mm2s_tlast_i_axis_dw_conv;


mm2s_frame_ptr_out  <= mm2s_frame_ptr_out_i ;
s2mm_frame_ptr_out  <= s2mm_frame_ptr_out_i ;


--*****************************************************************************
--**                             RESET MODULE                                **
--*****************************************************************************
I_RST_MODULE : entity  axi_vdma_v6_3_10.axi_vdma_rst_module
    generic map(
        C_INCLUDE_MM2S              => C_INCLUDE_MM2S                       ,
        C_INCLUDE_S2MM              => C_INCLUDE_S2MM                       ,
        C_INCLUDE_SG                => C_INCLUDE_SG                         ,
        C_PRMRY_IS_ACLK_ASYNC       => 1 --C_PRMRY_IS_ACLK_ASYNC
    )
    port map(
        -----------------------------------------------------------------------
        -- Clock Sources
        -----------------------------------------------------------------------
        s_axi_lite_aclk             => s_axi_lite_aclk                      ,
        m_axi_sg_aclk               => m_axi_sg_aclk                        ,
        m_axi_mm2s_aclk             => m_axi_mm2s_aclk                      ,
        m_axis_mm2s_aclk            => m_axis_mm2s_aclk                     ,
        m_axi_s2mm_aclk             => m_axi_s2mm_aclk                      ,
        s_axis_s2mm_aclk            => s_axis_s2mm_aclk                     ,

        -----------------------------------------------------------------------
        -- Hard Reset
        -----------------------------------------------------------------------
        axi_resetn                  => axi_resetn                           ,

        -----------------------------------------------------------------------
        -- MM2S Soft Reset Support
        -----------------------------------------------------------------------
        mm2s_soft_reset             => mm2s_soft_reset                      ,
        mm2s_soft_reset_clr         => mm2s_soft_reset_clr                  ,
        mm2s_stop                   => mm2s_stop                            ,
        mm2s_all_idle               => mm2s_ftchcmdsts_idle                 ,
        mm2s_fsize_mismatch_err     => mm2s_fsize_mismatch_err              , -- 
        mm2s_halt                   => mm2s_halt                            ,
        mm2s_halt_cmplt             => mm2s_halt_cmplt                      ,
        mm2s_run_stop               => mm2s_dmacr(DMACR_RS_BIT)             ,

        -----------------------------------------------------------------------
        -- MM2S Soft Reset Support
        -----------------------------------------------------------------------
        s2mm_soft_reset             => s2mm_soft_reset                      ,
        s2mm_soft_reset_clr         => s2mm_soft_reset_clr                  ,
        s2mm_stop                   => s2mm_stop                            ,
        s2mm_all_idle               => s2mm_ftchcmdsts_idle                 ,
        s2mm_fsize_mismatch_err     => s2mm_fsize_mismatch_err              , -- 
        s2mm_halt                   => s2mm_halt                            ,
        s2mm_halt_cmplt             => s2mm_halt_cmplt                      ,
        s2mm_run_stop               => s2mm_dmacr(DMACR_RS_BIT)             ,

        -----------------------------------------------------------------------
        -- SG Status
        -----------------------------------------------------------------------
        ftch_err                  => sg2cdc_ftch_err                    ,

        -----------------------------------------------------------------------
        -- MM2S Distributed Reset Out
        -----------------------------------------------------------------------
        -- AXI Upsizer and Line Buffer
        mm2s_prmry_resetn           => mm2s_prmry_resetn                    ,
        -- AXI DataMover Primary Reset (Raw)
        mm2s_dm_prmry_resetn        => mm2s_dm_prmry_resetn                 ,
        -- AXI Stream Logic Reset
        mm2s_axis_resetn            => mm2s_axis_resetn                     ,
        -- AXI Stream Reset Outputs
        mm2s_axis_reset_out_n       => mm2s_prmry_reset_out_n_i               ,

        -----------------------------------------------------------------------
        -- S2MM Distributed Reset Out
        -----------------------------------------------------------------------
        s2mm_prmry_resetn           => s2mm_prmry_resetn                    ,
        -- AXI DataMover Primary Reset (Raw)
        s2mm_dm_prmry_resetn        => s2mm_dm_prmry_resetn                 ,
        -- AXI Stream Logic Reset
        s2mm_axis_resetn            => s2mm_axis_resetn                     ,
        -- AXI Stream Reset Outputs
        s2mm_axis_reset_out_n       => s2mm_prmry_reset_out_n_i               ,

        -----------------------------------------------------------------------
        -- Scatter Gather Distributed Reset Out
        -----------------------------------------------------------------------
        m_axi_sg_resetn             => m_axi_sg_resetn                      ,
        m_axi_dm_sg_resetn          => m_axi_dm_sg_resetn                   ,

        -----------------------------------------------------------------------
        -- AXI Lite Interface Reset Out (Hard Only)
        -----------------------------------------------------------------------
        s_axi_lite_resetn           => s_axi_lite_resetn                    ,
        mm2s_hrd_resetn             => mm2s_hrd_resetn                      ,
        s2mm_hrd_resetn             => s2mm_hrd_resetn
    );


--*****************************************************************************
--**                      AXI LITE REGISTER INTERFACE                        **
--*****************************************************************************
-------------------------------------------------------------------------------
-- Provides the s_axi_lite inteface and clock domain crossing between
-- axi lite and mm2s/s2mm register modules
-------------------------------------------------------------------------------
AXI_LITE_REG_INTERFACE_I :  entity axi_vdma_v6_3_10.axi_vdma_reg_if
    generic map(
        C_INCLUDE_MM2S              => C_INCLUDE_MM2S                       ,
        C_INCLUDE_S2MM              => C_INCLUDE_S2MM                       ,
        C_INCLUDE_SG                => C_INCLUDE_SG                         ,
        C_ENABLE_VIDPRMTR_READS     => C_ENABLE_VIDPRMTR_READS              ,
        C_ENABLE_DEBUG_ALL      => C_ENABLE_DEBUG_ALL             ,
        C_ENABLE_DEBUG_INFO_0      => C_ENABLE_DEBUG_INFO_0             ,
        C_ENABLE_DEBUG_INFO_1      => C_ENABLE_DEBUG_INFO_1             ,
        C_ENABLE_DEBUG_INFO_2      => C_ENABLE_DEBUG_INFO_2             ,
        C_ENABLE_DEBUG_INFO_3      => C_ENABLE_DEBUG_INFO_3             ,
        C_ENABLE_DEBUG_INFO_4      => C_ENABLE_DEBUG_INFO_4             ,
        C_ENABLE_DEBUG_INFO_5      => C_ENABLE_DEBUG_INFO_5             ,
        C_ENABLE_DEBUG_INFO_6      => C_ENABLE_DEBUG_INFO_6             ,
        C_ENABLE_DEBUG_INFO_7      => C_ENABLE_DEBUG_INFO_7             ,
        C_ENABLE_DEBUG_INFO_8      => C_ENABLE_DEBUG_INFO_8             ,
        C_ENABLE_DEBUG_INFO_9      => C_ENABLE_DEBUG_INFO_9             ,
        C_ENABLE_DEBUG_INFO_10     => C_ENABLE_DEBUG_INFO_10             ,
        C_ENABLE_DEBUG_INFO_11     => C_ENABLE_DEBUG_INFO_11             ,
        C_ENABLE_DEBUG_INFO_12     => C_ENABLE_DEBUG_INFO_12             ,
        C_ENABLE_DEBUG_INFO_13     => C_ENABLE_DEBUG_INFO_13             ,
        C_ENABLE_DEBUG_INFO_14     => C_ENABLE_DEBUG_INFO_14             ,
        C_ENABLE_DEBUG_INFO_15     => C_ENABLE_DEBUG_INFO_15             ,
        C_TOTAL_NUM_REGISTER        => TOTAL_NUM_REGISTER                   ,
        C_PRMRY_IS_ACLK_ASYNC       => 1, --C_PRMRY_IS_ACLK_ASYNC                ,
        C_S_AXI_LITE_ADDR_WIDTH     => C_S_AXI_LITE_ADDR_WIDTH              ,
        C_S_AXI_LITE_DATA_WIDTH     => C_S_AXI_LITE_DATA_WIDTH              ,
        C_VERSION_MAJOR             => VERSION_MAJOR                        ,
        C_VERSION_MINOR             => VERSION_MINOR                        ,
        C_VERSION_REVISION          => VERSION_REVISION                     ,
        C_REVISION_NUMBER           => REVISION_NUMBER
    )
    port map(
        -----------------------------------------------------------------------
        -- AXI Lite Control Interface
        -----------------------------------------------------------------------
        s_axi_lite_aclk             => s_axi_lite_aclk                      ,
        s_axi_lite_reset_n          => s_axi_lite_resetn                    ,
        s_axi_lite_awvalid          => s_axi_lite_awvalid                   ,
        s_axi_lite_awready          => s_axi_lite_awready                   ,
        s_axi_lite_awaddr           => s_axi_lite_awaddr                    ,
        s_axi_lite_wvalid           => s_axi_lite_wvalid                    ,
        s_axi_lite_wready           => s_axi_lite_wready                    ,
        s_axi_lite_wdata            => s_axi_lite_wdata                     ,
        s_axi_lite_bresp            => s_axi_lite_bresp                     ,
        s_axi_lite_bvalid           => s_axi_lite_bvalid                    ,
        s_axi_lite_bready           => s_axi_lite_bready                    ,
        s_axi_lite_arvalid          => s_axi_lite_arvalid                   ,
        s_axi_lite_arready          => s_axi_lite_arready                   ,
        s_axi_lite_araddr           => s_axi_lite_araddr                    ,
        s_axi_lite_rvalid           => s_axi_lite_rvalid                    ,
        s_axi_lite_rready           => s_axi_lite_rready                    ,
        s_axi_lite_rdata            => s_axi_lite_rdata                     ,
        s_axi_lite_rresp            => s_axi_lite_rresp                     ,

        -- MM2S Register Interface
        m_axi_mm2s_aclk             => m_axi_mm2s_aclk                      ,
        mm2s_hrd_resetn             => mm2s_hrd_resetn                      ,
        mm2s_axi2ip_wrce            => mm2s_axi2ip_wrce                     ,
        mm2s_axi2ip_wrdata          => mm2s_axi2ip_wrdata                   ,
        mm2s_axi2ip_rdaddr          => mm2s_axi2ip_rdaddr                   ,
        --mm2s_axi2ip_rden            => mm2s_axi2ip_rden                     ,
        mm2s_ip2axi_rddata          => mm2s_ip2axi_rddata                   ,
        --mm2s_ip2axi_rddata_valid    => mm2s_ip2axi_rddata_valid             ,
        mm2s_ip2axi_frame_ptr_ref   => mm2s_ip2axi_frame_ptr_ref            ,
        mm2s_ip2axi_frame_store     => mm2s_ip2axi_frame_store              ,
        mm2s_chnl_current_frame     => mm2s_chnl_current_frame                ,
        mm2s_genlock_pair_frame     => mm2s_genlock_pair_frame                ,
        mm2s_ip2axi_introut         => mm2s_ip2axi_introut                  ,
        mm2s_introut                => mm2s_introut                         ,

        -- S2MM Register Interface
        m_axi_s2mm_aclk             => m_axi_s2mm_aclk                      ,
        s2mm_hrd_resetn             => s2mm_hrd_resetn                      ,
        s2mm_axi2ip_wrce            => s2mm_axi2ip_wrce                     ,
        s2mm_axi2ip_wrdata          => s2mm_axi2ip_wrdata                   ,
        --s2mm_axi2ip_rden            => s2mm_axi2ip_rden                     ,
        s2mm_axi2ip_rdaddr          => s2mm_axi2ip_rdaddr                   ,
        s2mm_ip2axi_rddata          => s2mm_ip2axi_rddata                   ,
        --s2mm_ip2axi_rddata_valid    => s2mm_ip2axi_rddata_valid             ,
        s2mm_ip2axi_frame_ptr_ref   => s2mm_ip2axi_frame_ptr_ref            ,
        s2mm_ip2axi_frame_store     => s2mm_ip2axi_frame_store              ,
        s2mm_capture_dm_done_vsize_counter     => s2mm_capture_dm_done_vsize_counter_sig                ,
        s2mm_capture_hsize_at_uf_err     => s2mm_capture_hsize_at_uf_err_sig                ,
        s2mm_chnl_current_frame     => s2mm_chnl_current_frame                ,
        s2mm_genlock_pair_frame     => s2mm_genlock_pair_frame                ,
        s2mm_ip2axi_introut         => s2mm_ip2axi_introut                  ,
        s2mm_introut                => s2mm_introut
    );

--*****************************************************************************
--**                       INTERRUPT CONTROLLER                              **
--*****************************************************************************
I_AXI_DMA_INTRPT : entity  axi_vdma_v6_3_10.axi_vdma_intrpt
    generic map(

        C_INCLUDE_CH1              => C_INCLUDE_MM2S                            ,
        C_INCLUDE_CH2              => C_INCLUDE_S2MM                            ,
        --C_ENABLE_DEBUG_INFO        => C_ENABLE_DEBUG_INFO             ,
        C_ENABLE_DEBUG_ALL      => C_ENABLE_DEBUG_ALL             ,
        C_ENABLE_DEBUG_INFO_0      => C_ENABLE_DEBUG_INFO_0             ,
        C_ENABLE_DEBUG_INFO_1      => C_ENABLE_DEBUG_INFO_1             ,
        C_ENABLE_DEBUG_INFO_2      => C_ENABLE_DEBUG_INFO_2             ,
        C_ENABLE_DEBUG_INFO_3      => C_ENABLE_DEBUG_INFO_3             ,
        C_ENABLE_DEBUG_INFO_4      => C_ENABLE_DEBUG_INFO_4             ,
        C_ENABLE_DEBUG_INFO_5      => C_ENABLE_DEBUG_INFO_5             ,
        C_ENABLE_DEBUG_INFO_6      => C_ENABLE_DEBUG_INFO_6             ,
        C_ENABLE_DEBUG_INFO_7      => C_ENABLE_DEBUG_INFO_7             ,
        C_ENABLE_DEBUG_INFO_8      => C_ENABLE_DEBUG_INFO_8             ,
        C_ENABLE_DEBUG_INFO_9      => C_ENABLE_DEBUG_INFO_9             ,
        C_ENABLE_DEBUG_INFO_10     => C_ENABLE_DEBUG_INFO_10             ,
        C_ENABLE_DEBUG_INFO_11     => C_ENABLE_DEBUG_INFO_11             ,
        C_ENABLE_DEBUG_INFO_12     => C_ENABLE_DEBUG_INFO_12             ,
        C_ENABLE_DEBUG_INFO_13     => C_ENABLE_DEBUG_INFO_13             ,
        C_ENABLE_DEBUG_INFO_14     => C_ENABLE_DEBUG_INFO_14             ,
        C_ENABLE_DEBUG_INFO_15     => C_ENABLE_DEBUG_INFO_15             ,
        C_INCLUDE_DLYTMR           => INCLUDE_DLYTMR                            ,
        C_DLYTMR_RESOLUTION        => C_DLYTMR_RESOLUTION
    )
    port map(
        m_axi_ch1_aclk              => m_axi_mm2s_aclk                          ,
        m_axi_ch1_aresetn           => mm2s_prmry_resetn                        ,
        m_axi_ch2_aclk              => m_axi_s2mm_aclk                          ,
        m_axi_ch2_aresetn           => s2mm_prmry_resetn                        ,

        ch1_irqthresh_decr          => mm2s_tstvect_fsync                       ,
        ch1_irqthresh_decr_mask     => mm2s_fsize_mismatch_err_flag                       ,
        ch1_irqthresh_rstdsbl       => mm2s_irqthresh_rstdsbl                   ,
        ch1_dlyirq_dsble            => mm2s_dlyirq_dsble                        ,
        ch1_irqdelay_wren           => mm2s_irqdelay_wren                       ,
        ch1_irqdelay                => mm2s_dmacr(DMACR_IRQDELAY_MSB_BIT
                                           downto DMACR_IRQDELAY_LSB_BIT)       ,
        ch1_irqthresh_wren          => mm2s_irqthresh_wren                      ,
        ch1_irqthresh               => mm2s_dmacr(DMACR_IRQTHRESH_MSB_BIT
                                           downto DMACR_IRQTHRESH_LSB_BIT)      ,
        ch1_packet_sof              => mm2s_packet_sof                          ,
        ch1_packet_eof              => mm2s_tstvect_fsync                       ,
        ch1_packet_eof_mask         => mm2s_fsize_mismatch_err_flag                       ,
        ch1_ioc_irq_set             => mm2s_ioc_irq_set                         ,
        ch1_dly_irq_set             => mm2s_dly_irq_set                         ,
        ch1_irqdelay_status         => mm2s_irqdelay_status                     ,
        ch1_irqthresh_status        => mm2s_irqthresh_status                    ,

        ch2_irqthresh_decr          => s2mm_tstvect_fsync                       ,
        ch2_irqthresh_decr_mask     => s2mm_fsize_mismatch_err_flag                       ,
        ch2_irqthresh_rstdsbl       => s2mm_irqthresh_rstdsbl                   ,
        ch2_dlyirq_dsble            => s2mm_dlyirq_dsble                        ,
        ch2_irqdelay_wren           => s2mm_irqdelay_wren                       ,
        ch2_irqdelay                => s2mm_dmacr(DMACR_IRQDELAY_MSB_BIT
                                           downto DMACR_IRQDELAY_LSB_BIT)       ,
        ch2_irqthresh_wren          => s2mm_irqthresh_wren                      ,
        ch2_irqthresh               => s2mm_dmacr(DMACR_IRQTHRESH_MSB_BIT
                                           downto DMACR_IRQTHRESH_LSB_BIT)      ,
        ch2_packet_sof              => s2mm_packet_sof                          ,
        ch2_packet_eof              => s2mm_tstvect_fsync                       ,
        ch2_packet_eof_mask         => s2mm_fsize_mismatch_err_flag                       ,
        ch2_ioc_irq_set             => s2mm_ioc_irq_set                         ,
        ch2_dly_irq_set             => s2mm_dly_irq_set                         ,
        ch2_irqdelay_status         => s2mm_irqdelay_status                     ,
        ch2_irqthresh_status        => s2mm_irqthresh_status
    );


--*****************************************************************************
--**                       SCATTER GATHER ENGINE                             **
--*****************************************************************************

-- If Scatter Gather Engine is included the instantiate axi_sg
GEN_SG_ENGINE : if C_INCLUDE_SG = 1 generate
    -------------------------------------------------------------------------------
    -- Scatter Gather Engine
    -------------------------------------------------------------------------------
    I_SG_ENGINE : entity  axi_vdma_v6_3_10.axi_sg
        generic map(
            C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH            ,
            C_M_AXI_SG_DATA_WIDTH       => C_M_AXI_SG_DATA_WIDTH            ,
            C_M_AXIS_SG_TDATA_WIDTH     => M_AXIS_SG_TDATA_WIDTH            ,
            C_S_AXIS_UPDPTR_TDATA_WIDTH => S_AXIS_UPDPTR_TDATA_WIDTH        ,
            C_S_AXIS_UPDSTS_TDATA_WIDTH => S_AXIS_UPDSTS_TDATA_WIDTH        ,
            C_SG_FTCH_DESC2QUEUE        => SG_FTCH_DESC2QUEUE               ,
            C_SG_UPDT_DESC2QUEUE        => SG_UPDT_DESC2QUEUE               ,
            C_SG_CH1_WORDS_TO_FETCH     => SG_CH1_WORDS_TO_FETCH            ,
            C_SG_CH1_WORDS_TO_UPDATE    => SG_CH1_WORDS_TO_UPDATE           ,
            C_SG_CH1_FIRST_UPDATE_WORD  => SG_CH1_FIRST_UPDATE_WORD         ,
            C_SG_CH1_ENBL_STALE_ERROR   => SG_CH1_ENBL_STALE_ERR          ,
            C_SG_CH2_WORDS_TO_FETCH     => SG_CH2_WORDS_TO_FETCH            ,
            C_SG_CH2_WORDS_TO_UPDATE    => SG_CH2_WORDS_TO_UPDATE           ,
            C_SG_CH2_FIRST_UPDATE_WORD  => SG_CH2_FIRST_UPDATE_WORD         ,
            C_SG_CH2_ENBL_STALE_ERROR   => SG_CH2_ENBL_STALE_ERR          ,
            C_INCLUDE_CH1               => C_INCLUDE_MM2S                   ,
            C_INCLUDE_CH2               => C_INCLUDE_S2MM                   ,
            C_INCLUDE_DESC_UPDATE       => EXCLUDE_DESC_UPDATE              ,
            C_INCLUDE_INTRPT            => EXCLUDE_INTRPT                   ,
            C_INCLUDE_DLYTMR            => EXCLUDE_DLYTMR                   ,
            C_DLYTMR_RESOLUTION         => C_DLYTMR_RESOLUTION              ,
            C_AXIS_IS_ASYNC             => C_PRMRY_IS_ACLK_ASYNC            ,
            C_FAMILY                    => C_ROOT_FAMILY
        )
        port map(
            -----------------------------------------------------------------------
            -- AXI Scatter Gather Interface
            -----------------------------------------------------------------------
            m_axi_sg_aclk               => m_axi_sg_aclk                    ,
            m_axi_sg_aresetn            => m_axi_sg_resetn                  ,
            dm_resetn                   => m_axi_dm_sg_resetn               ,

            -- Scatter Gather Write Address Channel
            m_axi_sg_awaddr             => open                             ,
            m_axi_sg_awlen              => open                             ,
            m_axi_sg_awsize             => open                             ,
            m_axi_sg_awburst            => open                             ,
            m_axi_sg_awprot             => open                             ,
            m_axi_sg_awcache            => open                             ,
            m_axi_sg_awvalid            => open                             ,
            m_axi_sg_awready            => '0'                              ,

            -- Scatter Gather Write Data Channel
            m_axi_sg_wdata              => open                             ,
            m_axi_sg_wstrb              => open                             ,
            m_axi_sg_wlast              => open                             ,
            m_axi_sg_wvalid             => open                             ,
            m_axi_sg_wready             => '0'                              ,

            -- Scatter Gather Write Response Channel
            m_axi_sg_bresp              => "00"                             ,
            m_axi_sg_bvalid             => '0'                              ,
            m_axi_sg_bready             => open                             ,

            -- Scatter Gather Read Address Channel
            m_axi_sg_araddr             => m_axi_sg_araddr                  ,
            m_axi_sg_arlen              => m_axi_sg_arlen                   ,
            m_axi_sg_arsize             => m_axi_sg_arsize                  ,
            m_axi_sg_arburst            => m_axi_sg_arburst                 ,
            m_axi_sg_arprot             => m_axi_sg_arprot                  ,
            m_axi_sg_arcache            => m_axi_sg_arcache                 ,
            m_axi_sg_arvalid            => m_axi_sg_arvalid                 ,
            m_axi_sg_arready            => m_axi_sg_arready                 ,

            -- Memory Map to Stream Scatter Gather Read Data Channel
            m_axi_sg_rdata              => m_axi_sg_rdata                   ,
            m_axi_sg_rresp              => m_axi_sg_rresp                   ,
            m_axi_sg_rlast              => m_axi_sg_rlast                   ,
            m_axi_sg_rvalid             => m_axi_sg_rvalid                  ,
            m_axi_sg_rready             => m_axi_sg_rready                  ,

            -- Channel 1 Control and Status
            ch1_run_stop                => mm2s_cdc2sg_run_stop             ,
            ch1_desc_flush              => mm2s_cdc2sg_stop                 ,
            ch1_ftch_idle               => mm2s_sg2cdc_ftch_idle            ,
            ch1_ftch_interr_set         => mm2s_sg2cdc_ftch_interr_set      ,
            ch1_ftch_slverr_set         => mm2s_sg2cdc_ftch_slverr_set      ,
            ch1_ftch_decerr_set         => mm2s_sg2cdc_ftch_decerr_set      ,
            ch1_ftch_err_early          => open                             ,
            ch1_ftch_stale_desc         => open                             ,
            ch1_updt_idle               => open                             ,
            ch1_updt_ioc_irq_set        => open                             ,
            ch1_updt_interr_set         => open                             ,
            ch1_updt_slverr_set         => open                             ,
            ch1_updt_decerr_set         => open                             ,
            ch1_dma_interr_set          => open                             ,
            ch1_dma_slverr_set          => open                             ,
            ch1_dma_decerr_set          => open                             ,
            ch1_tailpntr_enabled        => '1'                              ,
            ch1_taildesc_wren           => mm2s_cdc2sg_taildesc_wren        ,
            ch1_taildesc                => mm2s_cdc2sg_taildesc             ,
            ch1_curdesc                 => mm2s_cdc2sg_curdesc              ,

            -- Channel 1 Interrupt Coalescing Signals
            ch1_dlyirq_dsble            => '0'                              ,
            ch1_irqthresh_rstdsbl       => '0'                              ,
            ch1_irqdelay_wren           => '0'                              ,
            ch1_irqdelay                => ZERO_VALUE(7 downto 0)           ,
            ch1_irqthresh_wren          => '0'                              ,
            ch1_irqthresh               => ZERO_VALUE(7 downto 0)           ,
            ch1_packet_sof              => '0'                              ,
            ch1_packet_eof              => '0'                              ,
            ch1_ioc_irq_set             => open                             ,
            ch1_dly_irq_set             => open                             ,
            ch1_irqdelay_status         => open                             ,
            ch1_irqthresh_status        => open                             ,

            -- Channel 1 AXI Fetch Stream Out
            m_axis_ch1_ftch_aclk        => m_axi_mm2s_aclk                  ,
            m_axis_ch1_ftch_tdata       => m_axis_mm2s_ftch_tdata           ,
            m_axis_ch1_ftch_tvalid      => m_axis_mm2s_ftch_tvalid          ,
            m_axis_ch1_ftch_tready      => m_axis_mm2s_ftch_tready          ,
            m_axis_ch1_ftch_tlast       => m_axis_mm2s_ftch_tlast           ,

            -- Channel 1 AXI Update Stream In
            s_axis_ch1_updt_aclk        => '0'                              ,
            s_axis_ch1_updtptr_tdata    => ZERO_VALUE(S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0),
            s_axis_ch1_updtptr_tvalid   => '0'                              ,
            s_axis_ch1_updtptr_tready   => open                             ,
            s_axis_ch1_updtptr_tlast    => '0'                              ,

            s_axis_ch1_updtsts_tdata    => ZERO_VALUE(S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0),
            s_axis_ch1_updtsts_tvalid   => '0'                              ,
            s_axis_ch1_updtsts_tready   => open                             ,
            s_axis_ch1_updtsts_tlast    => '0'                              ,

            -- Channel 2 Control and Status
            ch2_run_stop                => s2mm_cdc2sg_run_stop             ,
            ch2_desc_flush              => s2mm_cdc2sg_stop                 ,
            ch2_ftch_idle               => s2mm_sg2cdc_ftch_idle            ,
            ch2_ftch_interr_set         => s2mm_sg2cdc_ftch_interr_set      ,
            ch2_ftch_slverr_set         => s2mm_sg2cdc_ftch_slverr_set      ,
            ch2_ftch_decerr_set         => s2mm_sg2cdc_ftch_decerr_set      ,
            ch2_ftch_err_early          => open                             ,
            ch2_ftch_stale_desc         => open                             ,
            ch2_updt_idle               => open                             ,
            ch2_updt_ioc_irq_set        => open                             ,
            ch2_updt_interr_set         => open                             ,
            ch2_updt_slverr_set         => open                             ,
            ch2_updt_decerr_set         => open                             ,
            ch2_dma_interr_set          => open                             ,
            ch2_dma_slverr_set          => open                             ,
            ch2_dma_decerr_set          => open                             ,
            ch2_tailpntr_enabled        => '1'                              ,
            ch2_taildesc_wren           => s2mm_cdc2sg_taildesc_wren        ,
            ch2_taildesc                => s2mm_cdc2sg_taildesc             ,
            ch2_curdesc                 => s2mm_cdc2sg_curdesc              ,

            -- Channel 2 Interrupt Coalescing Signals
            ch2_dlyirq_dsble            => '0'                              ,
            ch2_irqthresh_rstdsbl       => '0'                              ,
            ch2_irqdelay_wren           => '0'                              ,
            ch2_irqdelay                => ZERO_VALUE(7 downto 0)           ,
            ch2_irqthresh_wren          => '0'                              ,
            ch2_irqthresh               => ZERO_VALUE(7 downto 0)           ,
            ch2_packet_sof              => '0'                              ,
            ch2_packet_eof              => '0'                              ,
            ch2_ioc_irq_set             => open                             ,
            ch2_dly_irq_set             => open                             ,
            ch2_irqdelay_status         => open                             ,
            ch2_irqthresh_status        => open                             ,

            -- Channel 2 AXI Fetch Stream Out
            m_axis_ch2_ftch_aclk        => m_axi_s2mm_aclk                  ,
            m_axis_ch2_ftch_tdata       => m_axis_s2mm_ftch_tdata           ,
            m_axis_ch2_ftch_tvalid      => m_axis_s2mm_ftch_tvalid          ,
            m_axis_ch2_ftch_tready      => m_axis_s2mm_ftch_tready          ,
            m_axis_ch2_ftch_tlast       => m_axis_s2mm_ftch_tlast           ,

            -- Channel 2 AXI Update Stream In
            s_axis_ch2_updt_aclk        => '0'                  ,
            s_axis_ch2_updtptr_tdata    => ZERO_VALUE(S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0),
            s_axis_ch2_updtptr_tvalid   => '0'                              ,
            s_axis_ch2_updtptr_tready   => open                             ,
            s_axis_ch2_updtptr_tlast    => '0'                              ,

            s_axis_ch2_updtsts_tdata    => ZERO_VALUE(S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0),
            s_axis_ch2_updtsts_tvalid   => '0'                              ,
            s_axis_ch2_updtsts_tready   => open                             ,
            s_axis_ch2_updtsts_tlast    => '0'                              ,

            -- Error addresses
            ftch_error_addr             => sg2cdc_ftch_err_addr           ,
            ftch_error                  => sg2cdc_ftch_err                ,
            updt_error                  => open                             ,
            updt_error_addr             => open
        );

    --*********************************************************************
    --** MM2S Clock Domain To/From Scatter Gather Clock Domain           **
    --*********************************************************************
    MM2S_SG_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_sg_cdc
        generic map(
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC            ,
            C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH
        )
        port map(
            prmry_aclk                  => m_axi_mm2s_aclk                  ,
            prmry_resetn                => mm2s_prmry_resetn                ,

            scndry_aclk                 => m_axi_sg_aclk                    ,
            scndry_resetn               => m_axi_sg_resetn                  ,

            -- From Register Module (Primary Clk Domain)
            reg2cdc_run_stop            => mm2s_dmacr(DMACR_RS_BIT)         ,
            reg2cdc_stop                => mm2s_stop                        ,
            reg2cdc_taildesc_wren       => mm2s_tailpntr_updated            ,
            reg2cdc_taildesc            => mm2s_taildesc                    ,
            reg2cdc_curdesc             => mm2s_curdesc                     ,

            -- To Scatter Gather Engine (Secondary Clk Domain)
            cdc2sg_run_stop             => mm2s_cdc2sg_run_stop             ,
            cdc2sg_stop                 => mm2s_cdc2sg_stop                 ,
            cdc2sg_taildesc_wren        => mm2s_cdc2sg_taildesc_wren        ,
            cdc2sg_taildesc             => mm2s_cdc2sg_taildesc             ,
            cdc2sg_curdesc              => mm2s_cdc2sg_curdesc              ,

            -- From Scatter Gather Engine (Secondary Clk Domain)
            sg2cdc_ftch_idle            => mm2s_sg2cdc_ftch_idle            ,
            sg2cdc_ftch_interr_set      => mm2s_sg2cdc_ftch_interr_set      ,
            sg2cdc_ftch_slverr_set      => mm2s_sg2cdc_ftch_slverr_set      ,
            sg2cdc_ftch_decerr_set      => mm2s_sg2cdc_ftch_decerr_set      ,
            sg2cdc_ftch_err_addr      => sg2cdc_ftch_err_addr           ,
            sg2cdc_ftch_err           => sg2cdc_ftch_err                ,

            -- To DMA Controller
            cdc2dmac_ftch_idle          => mm2s_ftch_idle                   ,

            -- To Register Module
            cdc2reg_ftch_interr_set     => mm2s_ftch_interr_set             ,
            cdc2reg_ftch_slverr_set     => mm2s_ftch_slverr_set             ,
            cdc2reg_ftch_decerr_set     => mm2s_ftch_decerr_set             ,
            cdc2reg_ftch_err_addr     => mm2s_ftch_err_addr             ,
            cdc2reg_ftch_err          => mm2s_ftch_err
        );

    --*********************************************************************
    --** S2MM Clock Domain To/From Scatter Gather Clock Domain           **
    --*********************************************************************
    S2MM_SG_CDC_I : entity  axi_vdma_v6_3_10.axi_vdma_sg_cdc
        generic map(
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC            ,
            C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH
        )
        port map(
            prmry_aclk                  => m_axi_s2mm_aclk                  ,
            prmry_resetn                => s2mm_prmry_resetn                ,

            scndry_aclk                 => m_axi_sg_aclk                    ,
            scndry_resetn               => m_axi_sg_resetn                  ,

            -- From Register Module (Primary Clk Domain)
            reg2cdc_run_stop            => s2mm_dmacr(DMACR_RS_BIT)         ,
            reg2cdc_stop                => s2mm_stop                        ,
            reg2cdc_taildesc_wren       => s2mm_tailpntr_updated            ,
            reg2cdc_taildesc            => s2mm_taildesc                    ,
            reg2cdc_curdesc             => s2mm_curdesc                     ,

            -- To Scatter Gather Engine (Secondary Clk Domain)
            cdc2sg_run_stop             => s2mm_cdc2sg_run_stop             ,
            cdc2sg_stop                 => s2mm_cdc2sg_stop                 ,
            cdc2sg_taildesc_wren        => s2mm_cdc2sg_taildesc_wren        ,
            cdc2sg_taildesc             => s2mm_cdc2sg_taildesc             ,
            cdc2sg_curdesc              => s2mm_cdc2sg_curdesc              ,

            -- From Scatter Gather Engine (Secondary Clk Domain)
            sg2cdc_ftch_idle            => s2mm_sg2cdc_ftch_idle            ,
            sg2cdc_ftch_interr_set      => s2mm_sg2cdc_ftch_interr_set      ,
            sg2cdc_ftch_slverr_set      => s2mm_sg2cdc_ftch_slverr_set      ,
            sg2cdc_ftch_decerr_set      => s2mm_sg2cdc_ftch_decerr_set      ,
            sg2cdc_ftch_err_addr      => sg2cdc_ftch_err_addr           ,
            sg2cdc_ftch_err           => sg2cdc_ftch_err                ,

            -- To DMA Controller
            cdc2dmac_ftch_idle          => s2mm_ftch_idle                   ,

            -- To Register Module
            cdc2reg_ftch_interr_set     => s2mm_ftch_interr_set             ,
            cdc2reg_ftch_slverr_set     => s2mm_ftch_slverr_set             ,
            cdc2reg_ftch_decerr_set     => s2mm_ftch_decerr_set             ,
            cdc2reg_ftch_err_addr     => s2mm_ftch_err_addr             ,
            cdc2reg_ftch_err          => s2mm_ftch_err
        );

end generate GEN_SG_ENGINE;

-- No scatter gather engine therefore tie off unused signals
GEN_NO_SG_ENGINE : if C_INCLUDE_SG = 0 generate
begin
    m_axi_sg_araddr             <= (others => '0');
    m_axi_sg_arlen              <= (others => '0');
    m_axi_sg_arsize             <= (others => '0');
    m_axi_sg_arburst            <= (others => '0');
    m_axi_sg_arcache            <= (others => '0');
    m_axi_sg_arprot             <= (others => '0');
    m_axi_sg_arvalid            <= '0';
    m_axi_sg_rready             <= '0';
    mm2s_ftch_idle              <= '1';
    mm2s_ftch_interr_set        <= '0';
    mm2s_ftch_slverr_set        <= '0';
    mm2s_ftch_decerr_set        <= '0';
    m_axis_mm2s_ftch_tdata      <= (others => '0');
    m_axis_mm2s_ftch_tvalid     <= '0';
    m_axis_mm2s_ftch_tlast      <= '0';
    s2mm_ftch_idle              <= '1';
    s2mm_ftch_interr_set        <= '0';
    s2mm_ftch_slverr_set        <= '0';
    s2mm_ftch_decerr_set        <= '0';
    m_axis_s2mm_ftch_tdata      <= (others => '0');
    m_axis_s2mm_ftch_tvalid     <= '0';
    m_axis_s2mm_ftch_tlast      <= '0';
    mm2s_ftch_err_addr        <= (others => '0');
    mm2s_ftch_err             <= '0';
    s2mm_ftch_err_addr        <= (others => '0');
    s2mm_ftch_err             <= '0';

    sg2cdc_ftch_err             <= '0';
end generate GEN_NO_SG_ENGINE;


--*****************************************************************************
--**                            MM2S CHANNEL                                 **
--*****************************************************************************

-- Generate support logic for MM2S
GEN_SPRT_FOR_MM2S : if C_INCLUDE_MM2S = 1 generate
begin



GEN_FLUSH_SOF_MM2S : if (ENABLE_FLUSH_ON_MM2S_FSYNC = 1  and MM2S_SOF_ENABLE = 1) generate

begin




--m_axis_mm2s_tvalid_i2 <= m_axis_mm2s_tvalid_i_axis_dw_conv when  MM2S_DROP_RESIDUAL_OF_FSIZE_ERR_FRAME_S = '0'
--            else '0';

m_axis_mm2s_tvalid_i2 <= '0' when  MM2S_DROP_RESIDUAL_OF_FSIZE_ERR_FRAME_S = '1' or mm2s_fsync_core = '1'
            else m_axis_mm2s_tvalid_i_axis_dw_conv;
m_axis_mm2s_tready_i2 <= m_axis_mm2s_tready when  MM2S_DROP_RESIDUAL_OF_FSIZE_ERR_FRAME_S = '0'
            else '1';

end generate GEN_FLUSH_SOF_MM2S;


GEN_NO_FLUSH_SOF_MM2S : if (ENABLE_FLUSH_ON_MM2S_FSYNC = 0  or MM2S_SOF_ENABLE = 0) generate

begin


m_axis_mm2s_tvalid_i2 <= m_axis_mm2s_tvalid_i_axis_dw_conv;
m_axis_mm2s_tready_i2 <= m_axis_mm2s_tready;

end generate GEN_NO_FLUSH_SOF_MM2S;







  GEN_AXIS_MM2S_DWIDTH_CONV : if (C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED /=  C_M_AXIS_MM2S_TDATA_WIDTH) generate



		constant C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED_div_by_8     	: integer := C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8;
		constant C_M_AXIS_MM2S_TDATA_WIDTH_div_by_8     		: integer := C_M_AXIS_MM2S_TDATA_WIDTH/8;
		
		signal         m_axis_mm2s_dwidth_tuser_i           : std_logic_vector                                      --
		                                        (C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED_div_by_8-1 downto 0) := (others => '0');                  --
		
		signal         m_axis_mm2s_dwidth_tuser           : std_logic_vector                                      --
		                                        (C_M_AXIS_MM2S_TDATA_WIDTH_div_by_8-1 downto 0) := (others => '0');                  --
		
		




  begin

			                        m_axis_mm2s_dwidth_tuser_i(0)   <= m_axis_mm2s_tuser_i(0);

			MM2S_TUSER_CNCT : for i in 1 to C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED_div_by_8-1 generate
			begin

			                        m_axis_mm2s_dwidth_tuser_i(i)   <= '0';
			
			end generate MM2S_TUSER_CNCT;


		
		m_axis_mm2s_tuser(C_M_AXIS_MM2S_TUSER_BITS-1 downto 0)				 	<= m_axis_mm2s_dwidth_tuser(C_M_AXIS_MM2S_TUSER_BITS-1 downto 0);
		


    AXIS_MM2S_DWIDTH_CONVERTER_I: entity  axi_vdma_v6_3_10.axi_vdma_mm2s_axis_dwidth_converter
        generic map(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED 		=>	C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED		, 
 		C_M_AXIS_MM2S_TDATA_WIDTH         	 		=>	C_M_AXIS_MM2S_TDATA_WIDTH		, 
 		--C_AXIS_SIGNAL_SET            		 		=>	255		, 
 		C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED_div_by_8         	=>	C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED_div_by_8		, 
 		C_M_AXIS_MM2S_TDATA_WIDTH_div_by_8         		=>	C_M_AXIS_MM2S_TDATA_WIDTH_div_by_8		, 
            	C_MM2S_SOF_ENABLE           				=> 	MM2S_SOF_ENABLE                  ,
            	ENABLE_FLUSH_ON_FSYNC      				=> 	ENABLE_FLUSH_ON_MM2S_FSYNC,
 		C_AXIS_TID_WIDTH             		 		=>	1		, 
 		C_AXIS_TDEST_WIDTH           		 		=>	1		, 
        	C_FAMILY                     		 		=>	C_ROOT_FAMILY		   ) 
        port map( 
      		ACLK                         =>	m_axis_mm2s_aclk                 			, 
      		ARESETN                      =>	mm2s_axis_linebuf_reset_out              			, 
      		ACLKEN                       =>	'1'               			, 

            	dm_halt_reg                  => mm2s_halt_reg                        ,
            	stop_reg                     => mm2s_stop_reg                        ,   

             	crnt_vsize_d2                => mm2s_crnt_vsize_d2                  ,   
            	fsync_out                    => mm2s_fsync_out_i    ,
            	mm2s_vsize_cntr_clr_flag     => mm2s_vsize_cntr_clr_flag    ,

		dwidth_fifo_pipe_empty       => mm2s_dwidth_fifo_pipe_empty    ,
                all_lines_xfred_s_dwidth     => mm2s_all_lines_xfred_s_dwidth         ,


      		S_AXIS_TVALID                =>	m_axis_mm2s_tvalid_i        			, 
      		S_AXIS_TREADY                =>	m_axis_mm2s_tready_i        			, 
      		S_AXIS_TDATA                 =>	m_axis_mm2s_tdata_i(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED-1 downto 0)         			, 
      		--S_AXIS_TSTRB                 =>	ZERO_VALUE(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8-1 downto 0)         			, 
      		S_AXIS_TSTRB                 =>	m_axis_mm2s_tkeep_i(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8-1 downto 0)         			, 
      		S_AXIS_TKEEP                 =>	m_axis_mm2s_tkeep_i(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED/8-1 downto 0)         			, 
      		S_AXIS_TLAST                 =>	m_axis_mm2s_tlast_i         			, 
      		S_AXIS_TID                   =>	ZERO_VALUE(0 downto 0)           			, 
      		S_AXIS_TDEST                 =>	ZERO_VALUE(0 downto 0)         			, 
      		S_AXIS_TUSER                 =>	m_axis_mm2s_dwidth_tuser_i(C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED_div_by_8-1 downto 0)         			, 
      		M_AXIS_TVALID                =>	m_axis_mm2s_tvalid_i_axis_dw_conv        			, 
      		M_AXIS_TREADY                =>	m_axis_mm2s_tready_i2        			, 
      		M_AXIS_TDATA                 =>	m_axis_mm2s_tdata(C_M_AXIS_MM2S_TDATA_WIDTH-1 downto 0)         			, 
      		M_AXIS_TSTRB                 =>	open         			, 
      		M_AXIS_TKEEP                 =>	m_axis_mm2s_tkeep(C_M_AXIS_MM2S_TDATA_WIDTH/8-1 downto 0)         			, 
      		M_AXIS_TLAST                 =>	m_axis_mm2s_tlast_i_axis_dw_conv         			, 
      		M_AXIS_TID                   =>	open           			, 
      		M_AXIS_TDEST                 =>	open         			, 
      		M_AXIS_TUSER                 =>	m_axis_mm2s_dwidth_tuser(C_M_AXIS_MM2S_TDATA_WIDTH_div_by_8-1 downto 0)         			
  ) ;


  end generate GEN_AXIS_MM2S_DWIDTH_CONV;


  GEN_NO_AXIS_MM2S_DWIDTH_CONV : if (C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED =  C_M_AXIS_MM2S_TDATA_WIDTH) generate
  begin


		m_axis_mm2s_tvalid_i_axis_dw_conv		<= m_axis_mm2s_tvalid_i;
		m_axis_mm2s_tdata				<= m_axis_mm2s_tdata_i;
		m_axis_mm2s_tkeep				<= m_axis_mm2s_tkeep_i;
		m_axis_mm2s_tlast_i_axis_dw_conv		<= m_axis_mm2s_tlast_i;
		m_axis_mm2s_tuser				<= m_axis_mm2s_tuser_i;
		m_axis_mm2s_tready_i				<= m_axis_mm2s_tready_i2;
		mm2s_dwidth_fifo_pipe_empty				<= '1';
		mm2s_all_lines_xfred_s_dwidth				<= '0';



  end generate GEN_NO_AXIS_MM2S_DWIDTH_CONV;





    --*************************************************************************
    --** MM2S AXI4 Clock Domain - (m_axi_mm2s_aclk)
    --*************************************************************************
    ---------------------------------------------------------------------------
    -- MM2S Register Module
    ---------------------------------------------------------------------------
    MM2S_REGISTER_MODULE_I : entity  axi_vdma_v6_3_10.axi_vdma_reg_module
        generic map(
            C_TOTAL_NUM_REGISTER    => TOTAL_NUM_REGISTER                   ,
            C_INCLUDE_SG            => C_INCLUDE_SG                         ,
            C_CHANNEL_IS_MM2S       => CHANNEL_IS_MM2S                      ,
            C_ENABLE_FLUSH_ON_FSYNC => ENABLE_FLUSH_ON_MM2S_FSYNC                , -- 
            C_ENABLE_VIDPRMTR_READS => C_ENABLE_VIDPRMTR_READS              ,
            C_INTERNAL_GENLOCK_ENABLE   => INTERNAL_GENLOCK_ENABLE          ,
            C_DYNAMIC_RESOLUTION    => C_DYNAMIC_RESOLUTION                ,
            --C_ENABLE_DEBUG_INFO     => C_ENABLE_DEBUG_INFO             ,
        C_ENABLE_DEBUG_ALL      => C_ENABLE_DEBUG_ALL             ,
            C_ENABLE_DEBUG_INFO_0   => C_ENABLE_DEBUG_INFO_0             ,
            C_ENABLE_DEBUG_INFO_1   => C_ENABLE_DEBUG_INFO_1             ,
            C_ENABLE_DEBUG_INFO_2   => C_ENABLE_DEBUG_INFO_2             ,
            C_ENABLE_DEBUG_INFO_3   => C_ENABLE_DEBUG_INFO_3             ,
            C_ENABLE_DEBUG_INFO_4   => C_ENABLE_DEBUG_INFO_4             ,
            C_ENABLE_DEBUG_INFO_5   => C_ENABLE_DEBUG_INFO_5             ,
            C_ENABLE_DEBUG_INFO_6   => C_ENABLE_DEBUG_INFO_6             ,
            C_ENABLE_DEBUG_INFO_7   => C_ENABLE_DEBUG_INFO_7             ,
            C_ENABLE_DEBUG_INFO_8   => C_ENABLE_DEBUG_INFO_8             ,
            C_ENABLE_DEBUG_INFO_9   => C_ENABLE_DEBUG_INFO_9             ,
            C_ENABLE_DEBUG_INFO_10  => C_ENABLE_DEBUG_INFO_10             ,
            C_ENABLE_DEBUG_INFO_11  => C_ENABLE_DEBUG_INFO_11             ,
            C_ENABLE_DEBUG_INFO_12  => C_ENABLE_DEBUG_INFO_12             ,
            C_ENABLE_DEBUG_INFO_13  => C_ENABLE_DEBUG_INFO_13             ,
            C_ENABLE_DEBUG_INFO_14  => C_ENABLE_DEBUG_INFO_14             ,
            C_ENABLE_DEBUG_INFO_15  => C_ENABLE_DEBUG_INFO_15             ,
            C_LINEBUFFER_THRESH     => C_MM2S_LINEBUFFER_THRESH_INT             ,
            C_NUM_FSTORES           => C_NUM_FSTORES                        ,
            C_NUM_FSTORES_64        => C_NUM_FSTORES_64                   ,
            C_GENLOCK_MODE          => C_MM2S_GENLOCK_MODE                  ,
            C_S_AXI_LITE_ADDR_WIDTH => C_S_AXI_LITE_ADDR_WIDTH              ,
            C_S_AXI_LITE_DATA_WIDTH => C_S_AXI_LITE_DATA_WIDTH              ,
            C_M_AXI_SG_ADDR_WIDTH   => C_M_AXI_SG_ADDR_WIDTH                ,
            C_M_AXI_ADDR_WIDTH      => C_M_AXI_SG_ADDR_WIDTH --C_M_AXI_MM2S_ADDR_WIDTH_NEW
        )
        port map(
            prmry_aclk                  => m_axi_mm2s_aclk                  ,
            prmry_resetn                => mm2s_prmry_resetn                ,

            -- Register to AXI Lite Interface
            axi2ip_wrce                 => mm2s_axi2ip_wrce                 ,
            axi2ip_wrdata               => mm2s_axi2ip_wrdata               ,
            axi2ip_rdaddr               => mm2s_axi2ip_rdaddr               ,
            --axi2ip_rden                 => mm2s_axi2ip_rden                 ,
            axi2ip_rden                 => '0'                 ,
            ip2axi_rddata               => mm2s_ip2axi_rddata               ,
            --ip2axi_rddata_valid         => mm2s_ip2axi_rddata_valid         ,
            ip2axi_rddata_valid         => open         ,
            ip2axi_frame_ptr_ref        => mm2s_ip2axi_frame_ptr_ref        ,
            ip2axi_frame_store          => mm2s_ip2axi_frame_store          ,
            ip2axi_introut              => mm2s_ip2axi_introut              ,

            -- Soft Reset
            soft_reset                  => mm2s_soft_reset                  ,
            soft_reset_clr              => mm2s_soft_reset_clr              ,

            -- DMA Control / Status Register Signals
            halted_clr                  => mm2s_halted_clr                  ,
            halted_set                  => mm2s_halted_set                  ,
            idle_set                    => mm2s_idle_set                    ,
            idle_clr                    => mm2s_idle_clr                    ,
            ioc_irq_set                 => mm2s_ioc_irq_set                 ,
            dly_irq_set                 => mm2s_dly_irq_set                 ,
            irqdelay_status             => mm2s_irqdelay_status             ,
            irqthresh_status            => mm2s_irqthresh_status            ,
            frame_sync                  => mm2s_frame_sync                  ,
            fsync_mask                  => mm2s_mask_fsync_out              ,
            new_curdesc_wren            => mm2s_new_curdesc_wren            ,
            new_curdesc                 => mm2s_new_curdesc                 ,
            update_frmstore             => '1'                              , -- Always Update
            new_frmstr                  => mm2s_frame_number                ,
            tstvect_fsync               => mm2s_tstvect_fsync               ,
            valid_frame_sync            => mm2s_valid_frame_sync            ,
            irqthresh_rstdsbl           => mm2s_irqthresh_rstdsbl           ,
            dlyirq_dsble                => mm2s_dlyirq_dsble                ,
            irqthresh_wren              => mm2s_irqthresh_wren              ,
            irqdelay_wren               => mm2s_irqdelay_wren               ,
            tailpntr_updated            => mm2s_tailpntr_updated            ,

            -- Error Detection Control
            stop                        => mm2s_stop                        ,
            dma_interr_set              => mm2s_dma_interr_set              ,
            dma_interr_set_minus_frame_errors              => mm2s_dma_interr_set_minus_frame_errors              ,
            dma_slverr_set              => mm2s_dma_slverr_set              ,
            dma_decerr_set              => mm2s_dma_decerr_set              ,
            ftch_slverr_set             => mm2s_ftch_slverr_set             ,
            ftch_decerr_set             => mm2s_ftch_decerr_set             ,

            fsize_mismatch_err          => mm2s_fsize_mismatch_err          ,   
            lsize_mismatch_err          => mm2s_lsize_mismatch_err          ,   
            lsize_more_mismatch_err          => mm2s_lsize_more_mismatch_err          ,   
            s2mm_fsize_more_or_sof_late => '0'          ,   

            -- VDMA Base Registers
    	reg_index                	=> mm2s_reg_index           ,

            dmacr                       => mm2s_dmacr                       ,
            dmasr                       => mm2s_dmasr                       ,
            curdesc                     => mm2s_curdesc                     ,
            taildesc                    => mm2s_taildesc                    ,
            num_frame_store             => mm2s_num_frame_store             ,
            linebuf_threshold           => mm2s_linebuf_threshold           ,

            -- Register Direct Support
            regdir_idle                 => mm2s_regdir_idle                 ,
            prmtr_updt_complete         => mm2s_prmtr_updt_complete         ,
            reg_module_vsize            => mm2s_reg_module_vsize            ,
            reg_module_hsize            => mm2s_reg_module_hsize            ,
            reg_module_stride           => mm2s_reg_module_stride           ,
            reg_module_frmdly           => mm2s_reg_module_frmdly           ,
            reg_module_strt_addr        => mm2s_reg_module_strt_addr        ,

            -- vertical_flip
            vflip                       => open                             ,
            -- Fetch/Update error addresses
            frmstr_err_addr           => mm2s_frame_number                ,
            ftch_err_addr             => mm2s_ftch_err_addr
        );

ADDR32: if C_M_AXI_MM2S_ADDR_WIDTH_NEW = 32 generate
begin

    ---------------------------------------------------------------------------
    -- MM2S DMA Controller
    ---------------------------------------------------------------------------
    I_MM2S_DMA_MNGR : entity  axi_vdma_v6_3_10.axi_vdma_mngr
        generic map(
            C_PRMY_CMDFIFO_DEPTH        => DM_CMDSTS_FIFO_DEPTH             ,
            C_INCLUDE_SF                => DM_MM2S_INCLUDE_SF               ,
            C_USE_FSYNC                 => C_USE_MM2S_FSYNC                      , -- 
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC            ,
            C_ENABLE_FLUSH_ON_FSYNC     => ENABLE_FLUSH_ON_MM2S_FSYNC            , -- 
            C_NUM_FSTORES               => C_NUM_FSTORES                    ,
            C_GENLOCK_MODE              => C_MM2S_GENLOCK_MODE              ,
            C_DYNAMIC_RESOLUTION        => C_DYNAMIC_RESOLUTION                ,
            C_GENLOCK_NUM_MASTERS       => C_MM2S_GENLOCK_NUM_MASTERS       ,
            --C_GENLOCK_REPEAT_EN         => C_MM2S_GENLOCK_REPEAT_EN         , -- 
            --C_ENABLE_DEBUG_INFO         => C_ENABLE_DEBUG_INFO             ,
            C_ENABLE_VERT_FLIP     => C_ENABLE_VERT_FLIP             ,
        C_ENABLE_DEBUG_ALL      => C_ENABLE_DEBUG_ALL             ,
            C_ENABLE_DEBUG_INFO_0       => C_ENABLE_DEBUG_INFO_0             ,
            C_ENABLE_DEBUG_INFO_1       => C_ENABLE_DEBUG_INFO_1             ,
            C_ENABLE_DEBUG_INFO_2       => C_ENABLE_DEBUG_INFO_2             ,
            C_ENABLE_DEBUG_INFO_3       => C_ENABLE_DEBUG_INFO_3             ,
            C_ENABLE_DEBUG_INFO_4       => C_ENABLE_DEBUG_INFO_4             ,
            C_ENABLE_DEBUG_INFO_5       => C_ENABLE_DEBUG_INFO_5             ,
            C_ENABLE_DEBUG_INFO_6       => C_ENABLE_DEBUG_INFO_6             ,
            C_ENABLE_DEBUG_INFO_7       => C_ENABLE_DEBUG_INFO_7             ,
            C_ENABLE_DEBUG_INFO_8       => C_ENABLE_DEBUG_INFO_8             ,
            C_ENABLE_DEBUG_INFO_9       => C_ENABLE_DEBUG_INFO_9             ,
            C_ENABLE_DEBUG_INFO_10      => C_ENABLE_DEBUG_INFO_10             ,
            C_ENABLE_DEBUG_INFO_11      => C_ENABLE_DEBUG_INFO_11             ,
            C_ENABLE_DEBUG_INFO_12      => C_ENABLE_DEBUG_INFO_12             ,
            C_ENABLE_DEBUG_INFO_13      => C_ENABLE_DEBUG_INFO_13             ,
            C_ENABLE_DEBUG_INFO_14      => C_ENABLE_DEBUG_INFO_14             ,
            C_ENABLE_DEBUG_INFO_15      => C_ENABLE_DEBUG_INFO_15             ,
            C_INTERNAL_GENLOCK_ENABLE   => INTERNAL_GENLOCK_ENABLE          ,
            C_INCLUDE_SG                => C_INCLUDE_SG                     , -- 
            C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH            ,
            C_M_AXIS_SG_TDATA_WIDTH     => M_AXIS_SG_TDATA_WIDTH            ,
            C_M_AXI_ADDR_WIDTH          => C_M_AXI_MM2S_ADDR_WIDTH_NEW          ,
            C_DM_STATUS_WIDTH           => MM2S_DM_STATUS_WIDTH             , -- 
            C_EXTEND_DM_COMMAND         => MM2S_DM_CMD_NOT_EXTENDED         ,
            C_MM2S_SOF_ENABLE           => MM2S_SOF_ENABLE ,
            C_S2MM_SOF_ENABLE           => 0 ,
            C_INCLUDE_MM2S              => C_INCLUDE_MM2S                   ,
            C_INCLUDE_S2MM              => 0                  ,
            C_SELECT_XPM                => C_SELECT_XPM,
            C_FAMILY                    => C_ROOT_FAMILY
        )
        port map(

            -- Secondary Clock and Reset
            prmry_aclk                  => m_axi_mm2s_aclk                  ,
            prmry_resetn                => mm2s_prmry_resetn                ,
            soft_reset                  => mm2s_soft_reset                  ,

            scndry_aclk                 => '0'                 ,
            scndry_resetn               => '1'                 ,


            -- MM2S Control and Status
            run_stop                    => mm2s_dmacr(DMACR_RS_BIT)         ,
            dmacr_repeat_en             => mm2s_dmacr(DMACR_REPEAT_EN_BIT)     ,
            dmasr_halt                  => mm2s_dmasr(DMASR_HALTED_BIT)     ,
            sync_enable                 => mm2s_dmacr(DMACR_SYNCEN_BIT)     ,
            regdir_idle                 => mm2s_regdir_idle                 ,
            ftch_idle                   => mm2s_ftch_idle                   ,
            halt                        => mm2s_halt                        ,
            halt_cmplt                  => mm2s_halt_cmplt                  ,
            halted_clr                  => mm2s_halted_clr                  ,
            halted_set                  => mm2s_halted_set                  ,
            idle_set                    => mm2s_idle_set                    ,
            idle_clr                    => mm2s_idle_clr                    ,
            stop                        => mm2s_stop                        ,
            s2mm_dmasr_lsize_less_err   => '0'     ,
            s2mm_fsize_more_or_sof_late => '0'          ,   
            capture_hsize_at_uf_err     => open          ,   
            all_idle                    => mm2s_all_idle                    ,
            cmdsts_idle                 => mm2s_cmdsts_idle                 ,
            ftchcmdsts_idle             => mm2s_ftchcmdsts_idle             ,
            s2mm_fsync_out_m            => '0'                  ,
            frame_sync                  => mm2s_frame_sync                  ,
            mm2s_fsync_out_m            => mm2s_fsync_out_m                 ,   -- 
            update_frmstore             => open                             ,   -- Not Needed for MM2S channel
            frmstr_err_addr           => open                             ,   -- Not Needed for MM2S channel
            frame_ptr_ref               => mm2s_ip2axi_frame_ptr_ref        ,
            frame_ptr_in                => mm2s_s_frame_ptr_in              ,
            frame_ptr_out               => mm2s_m_frame_ptr_out             ,
            internal_frame_ptr_in       => s2mm_to_mm2s_frame_ptr_in        ,
            valid_frame_sync            => mm2s_valid_frame_sync            ,
            valid_frame_sync_cmb        => mm2s_valid_frame_sync_cmb        ,
            valid_video_prmtrs          => mm2s_valid_video_prmtrs          ,
            parameter_update            => mm2s_parameter_update            ,
            circular_prk_mode           => mm2s_dmacr(DMACR_CRCLPRK_BIT)    ,
            mstr_pntr_ref               => mm2s_dmacr(DMACR_PNTR_NUM_MSB
                                               downto DMACR_PNTR_NUM_LSB)   ,
            genlock_select              => mm2s_dmacr(DMACR_GENLOCK_SEL_BIT),
            line_buffer_empty           => mm2s_allbuffer_empty             ,
            dwidth_fifo_pipe_empty           => mm2s_dwidth_fifo_pipe_empty_m             ,
            crnt_vsize                  => mm2s_crnt_vsize                  ,   -- 
            num_frame_store             => mm2s_num_frame_store             ,
            all_lines_xfred             => mm2s_all_lines_xfred             ,   -- 
            all_lasts_rcvd              => all_lasts_rcvd             ,   -- 
            fsize_mismatch_err_flag     => mm2s_fsize_mismatch_err_flag          ,   -- 
            s2mm_fsize_mismatch_err_s   => open                             ,   -- Not Needed for MM2S channel
drop_fsync_d_pulse_gen_fsize_less_err   => '0'                      ,
      	    s2mm_strm_all_lines_rcvd    => '0'	,	--      : out std_logic;
            s2mm_fsync_core             => '0'                      ,
            mm2s_fsize_mismatch_err_s   => mm2s_fsize_mismatch_err_s          ,   -- 
            mm2s_fsize_mismatch_err_m   => mm2s_fsize_mismatch_err_m          ,   -- 
            fsize_mismatch_err          => mm2s_fsize_mismatch_err          ,   -- 
            lsize_mismatch_err          => mm2s_lsize_mismatch_err          ,   -- 
            lsize_more_mismatch_err          => mm2s_lsize_more_mismatch_err          ,   -- 


            -- Register Direct Support
            prmtr_updt_complete         => mm2s_prmtr_updt_complete         ,
            reg_module_vsize            => mm2s_reg_module_vsize            ,
            reg_module_hsize            => mm2s_reg_module_hsize            ,
            reg_module_stride           => mm2s_reg_module_stride           ,
            reg_module_frmdly           => mm2s_reg_module_frmdly           ,
            reg_module_strt_addr        => mm2s_reg_module_strt_addr        ,

            -- Fsync signals and Genlock for test vector
            tstvect_err               => mm2s_tstvect_err               ,
            tstvect_fsync               => mm2s_tstvect_fsync               ,
            tstvect_frame               => mm2s_tstvect_frame               ,
            tstvect_frm_ptr_out         => mm2s_tstvect_frm_ptr_out         ,
            mstrfrm_tstsync_out         => mm2s_mstrfrm_tstsync             ,

            -- AXI Stream Timing
            packet_sof                  => '1'                              ,  -- NOT Used for MM2S

            -- Primary DMA Errors
            dma_interr_set              => mm2s_dma_interr_set              ,
            dma_interr_set_minus_frame_errors              => mm2s_dma_interr_set_minus_frame_errors              ,
            dma_slverr_set              => mm2s_dma_slverr_set              ,
            dma_decerr_set              => mm2s_dma_decerr_set              ,


            -- SG MM2S Descriptor Fetch AXI Stream In
            m_axis_ftch_tdata           => m_axis_mm2s_ftch_tdata           ,
            m_axis_ftch_tvalid          => m_axis_mm2s_ftch_tvalid          ,
            m_axis_ftch_tready          => m_axis_mm2s_ftch_tready          ,
            m_axis_ftch_tlast           => m_axis_mm2s_ftch_tlast           ,

            -- Currently Being Processed Descriptor/Frame
            frame_number                => mm2s_frame_number                ,
            chnl_current_frame          => mm2s_chnl_current_frame                ,
            genlock_pair_frame          => mm2s_genlock_pair_frame                ,
            new_curdesc                 => mm2s_new_curdesc                 ,
            new_curdesc_wren            => mm2s_new_curdesc_wren            ,
            tailpntr_updated            => mm2s_tailpntr_updated            ,

            -- User Command Interface Ports (AXI Stream)
            s_axis_cmd_tvalid           => s_axis_mm2s_cmd_tvalid           ,
            s_axis_cmd_tready           => s_axis_mm2s_cmd_tready           ,
            s_axis_cmd_tdata            => s_axis_mm2s_cmd_tdata            ,

            -- User Status Interface Ports (AXI Stream)
            m_axis_sts_tvalid           => m_axis_mm2s_sts_tvalid           ,
            m_axis_sts_tready           => m_axis_mm2s_sts_tready           ,
            m_axis_sts_tdata            => m_axis_mm2s_sts_tdata            ,
            m_axis_sts_tkeep            => m_axis_mm2s_sts_tkeep            ,
            err                         => mm2s_err                         ,
            vflip_mngr                  => '0'                       ,
            ftch_err                  => mm2s_ftch_err
        );



end generate ADDR32; 

ADDR64: if C_M_AXI_MM2S_ADDR_WIDTH_NEW > 32 generate
begin

    FSTORES64 : for i in 0 to C_NUM_FSTORES_64-1 generate


         mm2s_reg_module_strt_addr_64 (i) <= mm2s_reg_module_strt_addr (i*2+1) & mm2s_reg_module_strt_addr (i*2);

  end generate FSTORES64;


    ---------------------------------------------------------------------------
    -- MM2S DMA Controller
    ---------------------------------------------------------------------------
    I_MM2S_DMA_MNGR : entity  axi_vdma_v6_3_10.axi_vdma_mngr_64
        generic map(
            C_PRMY_CMDFIFO_DEPTH        => DM_CMDSTS_FIFO_DEPTH             ,
            C_INCLUDE_SF                => DM_MM2S_INCLUDE_SF               ,
            C_USE_FSYNC                 => C_USE_MM2S_FSYNC                      , -- 
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC            ,
            C_ENABLE_FLUSH_ON_FSYNC     => ENABLE_FLUSH_ON_MM2S_FSYNC            , -- 
            C_NUM_FSTORES               => C_NUM_FSTORES_64                    ,
            C_GENLOCK_MODE              => C_MM2S_GENLOCK_MODE              ,
            C_DYNAMIC_RESOLUTION        => C_DYNAMIC_RESOLUTION                ,
            C_GENLOCK_NUM_MASTERS       => C_MM2S_GENLOCK_NUM_MASTERS       ,
            --C_GENLOCK_REPEAT_EN         => C_MM2S_GENLOCK_REPEAT_EN         , -- 
            --C_ENABLE_DEBUG_INFO         => C_ENABLE_DEBUG_INFO             ,
            C_ENABLE_VERT_FLIP     => C_ENABLE_VERT_FLIP             ,
        C_ENABLE_DEBUG_ALL      => C_ENABLE_DEBUG_ALL             ,
            C_ENABLE_DEBUG_INFO_0       => C_ENABLE_DEBUG_INFO_0             ,
            C_ENABLE_DEBUG_INFO_1       => C_ENABLE_DEBUG_INFO_1             ,
            C_ENABLE_DEBUG_INFO_2       => C_ENABLE_DEBUG_INFO_2             ,
            C_ENABLE_DEBUG_INFO_3       => C_ENABLE_DEBUG_INFO_3             ,
            C_ENABLE_DEBUG_INFO_4       => C_ENABLE_DEBUG_INFO_4             ,
            C_ENABLE_DEBUG_INFO_5       => C_ENABLE_DEBUG_INFO_5             ,
            C_ENABLE_DEBUG_INFO_6       => C_ENABLE_DEBUG_INFO_6             ,
            C_ENABLE_DEBUG_INFO_7       => C_ENABLE_DEBUG_INFO_7             ,
            C_ENABLE_DEBUG_INFO_8       => C_ENABLE_DEBUG_INFO_8             ,
            C_ENABLE_DEBUG_INFO_9       => C_ENABLE_DEBUG_INFO_9             ,
            C_ENABLE_DEBUG_INFO_10      => C_ENABLE_DEBUG_INFO_10             ,
            C_ENABLE_DEBUG_INFO_11      => C_ENABLE_DEBUG_INFO_11             ,
            C_ENABLE_DEBUG_INFO_12      => C_ENABLE_DEBUG_INFO_12             ,
            C_ENABLE_DEBUG_INFO_13      => C_ENABLE_DEBUG_INFO_13             ,
            C_ENABLE_DEBUG_INFO_14      => C_ENABLE_DEBUG_INFO_14             ,
            C_ENABLE_DEBUG_INFO_15      => C_ENABLE_DEBUG_INFO_15             ,
            C_INTERNAL_GENLOCK_ENABLE   => INTERNAL_GENLOCK_ENABLE          ,
            C_INCLUDE_SG                => C_INCLUDE_SG                     , -- 
            C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH            ,
            C_M_AXIS_SG_TDATA_WIDTH     => M_AXIS_SG_TDATA_WIDTH            ,
            C_M_AXI_ADDR_WIDTH          => C_M_AXI_MM2S_ADDR_WIDTH_NEW          ,
            C_DM_STATUS_WIDTH           => MM2S_DM_STATUS_WIDTH             , -- 
            C_EXTEND_DM_COMMAND         => MM2S_DM_CMD_NOT_EXTENDED         ,
            C_MM2S_SOF_ENABLE           => MM2S_SOF_ENABLE ,
            C_S2MM_SOF_ENABLE           => 0 ,
            C_INCLUDE_MM2S              => C_INCLUDE_MM2S                   ,
            C_INCLUDE_S2MM              => 0                  ,
            C_SELECT_XPM                => C_SELECT_XPM,
            C_FAMILY                    => C_ROOT_FAMILY
        )
        port map(

            -- Secondary Clock and Reset
            prmry_aclk                  => m_axi_mm2s_aclk                  ,
            prmry_resetn                => mm2s_prmry_resetn                ,
            soft_reset                  => mm2s_soft_reset                  ,

            scndry_aclk                 => '0'                 ,
            scndry_resetn               => '1'                 ,


            -- MM2S Control and Status
            run_stop                    => mm2s_dmacr(DMACR_RS_BIT)         ,
            dmacr_repeat_en             => mm2s_dmacr(DMACR_REPEAT_EN_BIT)     ,
            dmasr_halt                  => mm2s_dmasr(DMASR_HALTED_BIT)     ,
            sync_enable                 => mm2s_dmacr(DMACR_SYNCEN_BIT)     ,
            regdir_idle                 => mm2s_regdir_idle                 ,
            ftch_idle                   => mm2s_ftch_idle                   ,
            halt                        => mm2s_halt                        ,
            halt_cmplt                  => mm2s_halt_cmplt                  ,
            halted_clr                  => mm2s_halted_clr                  ,
            halted_set                  => mm2s_halted_set                  ,
            idle_set                    => mm2s_idle_set                    ,
            idle_clr                    => mm2s_idle_clr                    ,
            stop                        => mm2s_stop                        ,
            s2mm_dmasr_lsize_less_err   => '0'     ,
            s2mm_fsize_more_or_sof_late => '0'          ,   
            capture_hsize_at_uf_err     => open          ,   
            all_idle                    => mm2s_all_idle                    ,
            cmdsts_idle                 => mm2s_cmdsts_idle                 ,
            ftchcmdsts_idle             => mm2s_ftchcmdsts_idle             ,
            s2mm_fsync_out_m            => '0'                  ,
            frame_sync                  => mm2s_frame_sync                  ,
            mm2s_fsync_out_m            => mm2s_fsync_out_m                 ,   -- 
            update_frmstore             => open                             ,   -- Not Needed for MM2S channel
            frmstr_err_addr           => open                             ,   -- Not Needed for MM2S channel
            frame_ptr_ref               => mm2s_ip2axi_frame_ptr_ref        ,
            frame_ptr_in                => mm2s_s_frame_ptr_in              ,
            frame_ptr_out               => mm2s_m_frame_ptr_out             ,
            internal_frame_ptr_in       => s2mm_to_mm2s_frame_ptr_in        ,
            valid_frame_sync            => mm2s_valid_frame_sync            ,
            valid_frame_sync_cmb        => mm2s_valid_frame_sync_cmb        ,
            valid_video_prmtrs          => mm2s_valid_video_prmtrs          ,
            parameter_update            => mm2s_parameter_update            ,
            circular_prk_mode           => mm2s_dmacr(DMACR_CRCLPRK_BIT)    ,
            mstr_pntr_ref               => mm2s_dmacr(DMACR_PNTR_NUM_MSB
                                               downto DMACR_PNTR_NUM_LSB)   ,
            genlock_select              => mm2s_dmacr(DMACR_GENLOCK_SEL_BIT),
            line_buffer_empty           => mm2s_allbuffer_empty             ,
            dwidth_fifo_pipe_empty           => mm2s_dwidth_fifo_pipe_empty_m             ,
            crnt_vsize                  => mm2s_crnt_vsize                  ,   -- 
            num_frame_store             => mm2s_num_frame_store             ,
            all_lines_xfred             => mm2s_all_lines_xfred             ,   -- 
            all_lasts_rcvd              => all_lasts_rcvd             ,   -- 
            fsize_mismatch_err_flag     => mm2s_fsize_mismatch_err_flag          ,   -- 
            s2mm_fsize_mismatch_err_s   => open                             ,   -- Not Needed for MM2S channel
drop_fsync_d_pulse_gen_fsize_less_err   => '0'                      ,
      	    s2mm_strm_all_lines_rcvd    => '0'	,	--      : out std_logic;
            s2mm_fsync_core             => '0'                      ,
            mm2s_fsize_mismatch_err_s   => mm2s_fsize_mismatch_err_s          ,   -- 
            mm2s_fsize_mismatch_err_m   => mm2s_fsize_mismatch_err_m          ,   -- 
            fsize_mismatch_err          => mm2s_fsize_mismatch_err          ,   -- 
            lsize_mismatch_err          => mm2s_lsize_mismatch_err          ,   -- 
            lsize_more_mismatch_err          => mm2s_lsize_more_mismatch_err          ,   -- 


            -- Register Direct Support
            prmtr_updt_complete         => mm2s_prmtr_updt_complete         ,
            reg_module_vsize            => mm2s_reg_module_vsize            ,
            reg_module_hsize            => mm2s_reg_module_hsize            ,
            reg_module_stride           => mm2s_reg_module_stride           ,
            reg_module_frmdly           => mm2s_reg_module_frmdly           ,
            reg_module_strt_addr        => mm2s_reg_module_strt_addr_64        ,

            -- Fsync signals and Genlock for test vector
            tstvect_err               => mm2s_tstvect_err               ,
            tstvect_fsync               => mm2s_tstvect_fsync               ,
            tstvect_frame               => mm2s_tstvect_frame               ,
            tstvect_frm_ptr_out         => mm2s_tstvect_frm_ptr_out         ,
            mstrfrm_tstsync_out         => mm2s_mstrfrm_tstsync             ,

            -- AXI Stream Timing
            packet_sof                  => '1'                              ,  -- NOT Used for MM2S

            -- Primary DMA Errors
            dma_interr_set              => mm2s_dma_interr_set              ,
            dma_interr_set_minus_frame_errors              => mm2s_dma_interr_set_minus_frame_errors              ,
            dma_slverr_set              => mm2s_dma_slverr_set              ,
            dma_decerr_set              => mm2s_dma_decerr_set              ,


            -- SG MM2S Descriptor Fetch AXI Stream In
            m_axis_ftch_tdata           => m_axis_mm2s_ftch_tdata           ,
            m_axis_ftch_tvalid          => m_axis_mm2s_ftch_tvalid          ,
            m_axis_ftch_tready          => m_axis_mm2s_ftch_tready          ,
            m_axis_ftch_tlast           => m_axis_mm2s_ftch_tlast           ,

            -- Currently Being Processed Descriptor/Frame
            frame_number                => mm2s_frame_number                ,
            chnl_current_frame          => mm2s_chnl_current_frame                ,
            genlock_pair_frame          => mm2s_genlock_pair_frame                ,
            new_curdesc                 => mm2s_new_curdesc                 ,
            new_curdesc_wren            => mm2s_new_curdesc_wren            ,
            tailpntr_updated            => mm2s_tailpntr_updated            ,

            -- User Command Interface Ports (AXI Stream)
            s_axis_cmd_tvalid           => s_axis_mm2s_cmd_tvalid           ,
            s_axis_cmd_tready           => s_axis_mm2s_cmd_tready           ,
            s_axis_cmd_tdata            => s_axis_mm2s_cmd_tdata            ,

            -- User Status Interface Ports (AXI Stream)
            m_axis_sts_tvalid           => m_axis_mm2s_sts_tvalid           ,
            m_axis_sts_tready           => m_axis_mm2s_sts_tready           ,
            m_axis_sts_tdata            => m_axis_mm2s_sts_tdata            ,
            m_axis_sts_tkeep            => m_axis_mm2s_sts_tkeep            ,
            err                         => mm2s_err                         ,
            vflip_mngr                  => '0'                      ,
            ftch_err                  => mm2s_ftch_err
        );

end generate ADDR64; 



    ---------------------------------------------------------------------------
    -- MM2S Frame sync generator
    ---------------------------------------------------------------------------
    MM2S_FSYNC_I : entity  axi_vdma_v6_3_10.axi_vdma_fsync_gen
        generic map(
            C_USE_FSYNC                 => C_USE_MM2S_FSYNC                      ,
            ENABLE_FLUSH_ON_S2MM_FSYNC  => 0                      ,
            ENABLE_FLUSH_ON_MM2S_FSYNC  => ENABLE_FLUSH_ON_MM2S_FSYNC                      ,
            C_INCLUDE_S2MM              => 0                   ,
            C_INCLUDE_MM2S              => 1                       ,
            C_SOF_ENABLE                => MM2S_SOF_ENABLE                                    -- Always disabled
        )
        port map(
            prmry_aclk                  => m_axi_mm2s_aclk                  ,
            prmry_resetn                => mm2s_prmry_resetn                ,

            -- Frame Count Enable Support
            valid_frame_sync_cmb        => mm2s_valid_frame_sync_cmb        ,
            valid_video_prmtrs          => mm2s_valid_video_prmtrs          ,
            frmcnt_ioc                  => mm2s_ioc_irq_set                 ,
            dmacr_frmcnt_enbl           => mm2s_dmacr(DMACR_FRMCNTEN_BIT)   ,
            dmasr_frmcnt_status         => mm2s_irqthresh_status            ,
            mask_fsync_out              => mm2s_mask_fsync_out              ,

            -- VDMA process status
            run_stop                    => mm2s_dmacr(DMACR_RS_BIT)         ,
            all_idle                    => mm2s_all_idle                    ,
            parameter_update            => mm2s_parameter_update            ,

            -- VDMA Frame Sync Sources
            fsync                       => mm2s_cdc2dmac_fsync              ,
            tuser_fsync                 => '0'                              ,   -- Not used by MM2S
            othrchnl_fsync              => s2mm_to_mm2s_fsync               ,

            fsync_src_select            => mm2s_dmacr(DMACR_FSYNCSEL_MSB
                                            downto DMACR_FSYNCSEL_LSB)      ,

            -- VDMA frame sync output to core
            frame_sync                  => mm2s_frame_sync                  ,

            -- VDMA frame sync output to ports
            frame_sync_out              => mm2s_dmac2cdc_fsync_out          ,
            prmtr_update                => mm2s_dmac2cdc_prmtr_update
        );

    -- Clock Domain Crossing between m_axi_mm2s_aclk and m_axis_mm2s_aclk
    MM2S_VID_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_vid_cdc
        generic map(
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC            ,
            C_GENLOCK_MSTR_PTR_DWIDTH   => NUM_FRM_STORE_WIDTH          ,
            C_GENLOCK_SLVE_PTR_DWIDTH   => MM2S_GENLOCK_SLVE_PTR_DWIDTH     ,
            C_INTERNAL_GENLOCK_ENABLE   => INTERNAL_GENLOCK_ENABLE
        )
        port map(
            prmry_aclk                  => m_axi_mm2s_aclk                  ,
            prmry_resetn                => mm2s_prmry_resetn                ,

            scndry_aclk                 => m_axis_mm2s_aclk                 ,
            scndry_resetn               => mm2s_axis_resetn                 ,

            -- Genlock internal bus cdc
            othrchnl_aclk               => m_axi_s2mm_aclk                  ,
            othrchnl_resetn             => s2mm_prmry_resetn                ,
            othrchnl2cdc_frame_ptr_out  => s2mm_frame_ptr_out_i             ,
            cdc2othrchnl_frame_ptr_in   => s2mm_to_mm2s_frame_ptr_in        ,

            cdc2othrchnl_fsync          => mm2s_to_s2mm_fsync               ,

            -- GenLock Clock Domain Crossing
            dmac2cdc_frame_ptr_out      => mm2s_m_frame_ptr_out             ,
            cdc2top_frame_ptr_out       => mm2s_frame_ptr_out_i             ,
            top2cdc_frame_ptr_in        => mm2s_frame_ptr_in                ,
            cdc2dmac_frame_ptr_in       => mm2s_s_frame_ptr_in              ,
            dmac2cdc_mstrfrm_tstsync    => mm2s_mstrfrm_tstsync             ,
            cdc2dmac_mstrfrm_tstsync    => mm2s_mstrfrm_tstsync_out         ,

            -- SOF Detection Domain Crossing
            vid2cdc_packet_sof          => mm2s_vid2cdc_packet_sof          ,
            cdc2dmac_packet_sof         => mm2s_packet_sof                  ,

            -- Frame Sync Generation Domain Crossing
            vid2cdc_fsync               => mm2s_fsync_core                       ,
            cdc2dmac_fsync              => mm2s_cdc2dmac_fsync              ,

            dmac2cdc_fsync_out          => mm2s_dmac2cdc_fsync_out          ,
            dmac2cdc_prmtr_update       => mm2s_dmac2cdc_prmtr_update       ,

            cdc2vid_fsync_out           => mm2s_fsync_out_i                 ,
            cdc2vid_prmtr_update        => mm2s_prmtr_update_i
        );

    mm2s_fsync_out_sig  <= mm2s_fsync_out_i;

    -- Start of Frame Detection - used for interrupt coalescing
    MM2S_SOF_I : entity  axi_vdma_v6_3_10.axi_vdma_sof_gen
        port map(
            scndry_aclk                 => m_axis_mm2s_aclk                 ,
            scndry_resetn               => mm2s_axis_resetn                 ,

            axis_tready                 => m_axis_mm2s_tready_i2               ,
            ---axis_tvalid                 => m_axis_mm2s_tvalid_i             ,
            axis_tvalid                 => m_axis_mm2s_tvalid_i2             ,

            fsync                       => mm2s_fsync_out_i                 , -- 

            packet_sof                  => mm2s_vid2cdc_packet_sof
        );

    ---------------------------------------------------------------------------
    -- Primary MM2S Line Buffer
    ---------------------------------------------------------------------------
    MM2S_LINEBUFFER_I : entity  axi_vdma_v6_3_10.axi_vdma_mm2s_linebuf
        generic map(
            C_DATA_WIDTH                => C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED        ,
            C_M_AXIS_MM2S_TDATA_WIDTH   => C_M_AXIS_MM2S_TDATA_WIDTH        ,
            --C_INCLUDE_MM2S_SF           => C_INCLUDE_MM2S_SF                ,
            C_INCLUDE_MM2S_SF           => 0                ,
            C_INCLUDE_MM2S_DRE          => C_MM2S_ENABLE_TKEEP                   ,
            C_MM2S_SOF_ENABLE           => MM2S_SOF_ENABLE                  ,
            C_M_AXIS_MM2S_TUSER_BITS    => C_M_AXIS_MM2S_TUSER_BITS         ,
            C_TOPLVL_LINEBUFFER_DEPTH   => C_MM2S_LINEBUFFER_DEPTH          , -- 
            ENABLE_FLUSH_ON_FSYNC       => ENABLE_FLUSH_ON_MM2S_FSYNC,
            --C_ENABLE_DEBUG_INFO         => C_ENABLE_DEBUG_INFO             ,
        C_ENABLE_DEBUG_ALL      => C_ENABLE_DEBUG_ALL             ,
            C_ENABLE_DEBUG_INFO_0       => C_ENABLE_DEBUG_INFO_0             ,
            C_ENABLE_DEBUG_INFO_1       => C_ENABLE_DEBUG_INFO_1             ,
            C_ENABLE_DEBUG_INFO_2       => C_ENABLE_DEBUG_INFO_2             ,
            C_ENABLE_DEBUG_INFO_3       => C_ENABLE_DEBUG_INFO_3             ,
            C_ENABLE_DEBUG_INFO_4       => C_ENABLE_DEBUG_INFO_4             ,
            C_ENABLE_DEBUG_INFO_5       => C_ENABLE_DEBUG_INFO_5             ,
            C_ENABLE_DEBUG_INFO_6       => C_ENABLE_DEBUG_INFO_6             ,
            C_ENABLE_DEBUG_INFO_7       => C_ENABLE_DEBUG_INFO_7             ,
            C_ENABLE_DEBUG_INFO_8       => C_ENABLE_DEBUG_INFO_8             ,
            C_ENABLE_DEBUG_INFO_9       => C_ENABLE_DEBUG_INFO_9             ,
            C_ENABLE_DEBUG_INFO_10      => C_ENABLE_DEBUG_INFO_10             ,
            C_ENABLE_DEBUG_INFO_11      => C_ENABLE_DEBUG_INFO_11             ,
            C_ENABLE_DEBUG_INFO_12      => C_ENABLE_DEBUG_INFO_12             ,
            C_ENABLE_DEBUG_INFO_13      => C_ENABLE_DEBUG_INFO_13             ,
            C_ENABLE_DEBUG_INFO_14      => C_ENABLE_DEBUG_INFO_14             ,
            C_ENABLE_DEBUG_INFO_15      => C_ENABLE_DEBUG_INFO_15             ,
            C_LINEBUFFER_DEPTH          => MM2S_LINEBUFFER_DEPTH            ,
            C_LINEBUFFER_AE_THRESH      => C_MM2S_LINEBUFFER_THRESH_INT         ,
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC            ,
            C_FAMILY                    => C_ROOT_FAMILY
        )
        port map(
            -------------------------------------------------------------------
            -- AXI Scatter Gather Interface
            -------------------------------------------------------------------
            -- MM2S AXIS Datamover side
            s_axis_aclk                 => m_axi_mm2s_aclk                  ,
            s_axis_resetn               => mm2s_prmry_resetn                ,

            -- MM2S AXIS Out side
            m_axis_aclk                 => m_axis_mm2s_aclk                 ,
            m_axis_resetn               => mm2s_axis_resetn                 ,
            mm2s_axis_linebuf_reset_out => mm2s_axis_linebuf_reset_out                 ,
            run_stop                    => mm2s_dmacr(DMACR_RS_BIT)         ,


            s2mm_axis_resetn            => s2mm_axis_resetn                     ,
            s_axis_s2mm_aclk            => s_axis_s2mm_aclk                     ,
            mm2s_fsync                  => mm2s_fsync_fe                      ,
            s2mm_fsync                  => s2mm_fsync_fe                      ,
            mm2s_fsync_core             => mm2s_fsync_core                      ,
            mm2s_vsize_cntr_clr_flag    => mm2s_vsize_cntr_clr_flag                            , 
            mm2s_fsize_mismatch_err_flag => mm2s_fsize_mismatch_err_flag                            , 
            MM2S_DROP_RESIDUAL_OF_FSIZE_ERR_FRAME_S   => MM2S_DROP_RESIDUAL_OF_FSIZE_ERR_FRAME_S                      ,
            mm2s_fsize_mismatch_err_m   => mm2s_fsize_mismatch_err_m                      ,
            mm2s_fsize_mismatch_err_s   => mm2s_fsize_mismatch_err_s                      ,
            fsync_src_select            => mm2s_dmacr(DMACR_FSYNCSEL_MSB
                                            downto DMACR_FSYNCSEL_LSB)      ,

            -- Graceful shut down control
            cmdsts_idle                 => mm2s_cmdsts_idle                 ,
            dm_halt                     => mm2s_halt                        ,
            dm_halt_reg_out             => mm2s_halt_reg                        ,
            stop                        => mm2s_stop                        ,   -- 
            stop_reg_out                => mm2s_stop_reg                        ,   -- 

            -- Vertical Line Count control
            crnt_vsize                  => mm2s_crnt_vsize                  ,   -- 
            crnt_vsize_d2_out           => mm2s_crnt_vsize_d2                  ,   -- 
            fsync_out                   => mm2s_fsync_out_i                 ,   -- 
            fsync_out_m                 => mm2s_fsync_out_m                 ,   -- 
            frame_sync                  => mm2s_frame_sync                  ,   -- 

            -- Threshold
            linebuf_threshold           => mm2s_linebuf_threshold           ,


            -- Stream In (Datamover to Linebuffer)
            s_axis_tdata                => dm2linebuf_mm2s_tdata            ,
            s_axis_tkeep                => dm2linebuf_mm2s_tkeep            ,
            s_axis_tlast                => dm2linebuf_mm2s_tlast            ,
            s_axis_tvalid               => dm2linebuf_mm2s_tvalid           ,
            s_axis_tready               => linebuf2dm_mm2s_tready           ,

            -- Stream Out (Linebuffer to AXIS Out)
            m_axis_tdata                => m_axis_mm2s_tdata_i                ,
            m_axis_tkeep                => m_axis_mm2s_tkeep_i                ,
            m_axis_tlast                => m_axis_mm2s_tlast_i              ,
            m_axis_tvalid               => m_axis_mm2s_tvalid_i             ,
            m_axis_tready               => m_axis_mm2s_tready_i               ,
            m_axis_tuser                => m_axis_mm2s_tuser_i                ,

            -- Fifo Status Flags
            dwidth_fifo_pipe_empty      => mm2s_dwidth_fifo_pipe_empty             ,
            dwidth_fifo_pipe_empty_m      => mm2s_dwidth_fifo_pipe_empty_m             ,
            mm2s_fifo_pipe_empty        => mm2s_allbuffer_empty             ,
            mm2s_fifo_empty             => mm2s_buffer_empty_i                ,
            mm2s_fifo_almost_empty      => mm2s_buffer_almost_empty_i         ,
            mm2s_all_lines_xfred_s_dwidth => mm2s_all_lines_xfred_s_dwidth         ,
            mm2s_all_lines_xfred_s      => mm2s_all_lines_xfred_s         ,
            mm2s_all_lines_xfred        => mm2s_all_lines_xfred                 -- 
        );


end generate GEN_SPRT_FOR_MM2S;


-- Do not generate support logic for MM2S
GEN_NO_SPRT_FOR_MM2S : if C_INCLUDE_MM2S = 0 generate
begin
    -- Register Module Tie-Offs
    mm2s_ip2axi_rddata              <= (others => '0');
    --mm2s_ip2axi_rddata_valid        <= '0';
    mm2s_ip2axi_frame_ptr_ref       <= (others => '0');
    mm2s_ip2axi_frame_store         <= (others => '0');
    mm2s_ip2axi_introut             <= '0';
    mm2s_soft_reset                 <= '0';
    mm2s_irqthresh_rstdsbl          <= '0';
    mm2s_dlyirq_dsble               <= '0';
    mm2s_irqthresh_wren             <= '0';
    mm2s_irqdelay_wren              <= '0';
    mm2s_tailpntr_updated           <= '0';
    mm2s_dmacr                      <= (others => '0');
    mm2s_dmasr                      <= (others => '0');
    mm2s_curdesc                    <= (others => '0');
    mm2s_taildesc                   <= (others => '0');

    --internal to mm2s generate (dont really need to tie off)
    mm2s_num_frame_store            <= (others => '0');
    mm2s_linebuf_threshold          <= (others => '0');
    mm2s_regdir_idle                <= '0';
    mm2s_prmtr_updt_complete        <= '0';
    mm2s_reg_module_vsize           <= (others => '0');
    mm2s_reg_module_hsize           <= (others => '0');
    mm2s_reg_module_stride          <= (others => '0');
    mm2s_reg_module_frmdly          <= (others => '0');

    -- Must zero each element of an array of vectors to zero
    -- all vectors.
    GEN_MM2S_ZERO_STRT : for i in 0 to C_NUM_FSTORES-1 generate
        begin
            mm2s_reg_module_strt_addr(i)   <= (others => '0');
    end generate GEN_MM2S_ZERO_STRT;

    -- Line Buffer Tie-Offs
    linebuf2dm_mm2s_tready          <= '0';
    m_axis_mm2s_tdata               <= (others => '0');
    m_axis_mm2s_tdata_i               <= (others => '0');
    m_axis_mm2s_tkeep               <= (others => '0');
    m_axis_mm2s_tkeep_i               <= (others => '0');
    m_axis_mm2s_tlast_i             <= '0';
    m_axis_mm2s_tlast_i_axis_dw_conv             <= '0';
    m_axis_mm2s_tuser               <= (others => '0');
    m_axis_mm2s_tuser_i               <= (others => '0');
    m_axis_mm2s_tvalid_i            <= '0';
    m_axis_mm2s_tvalid_i2            <= '0';
    m_axis_mm2s_tvalid_i_axis_dw_conv            <= '0';
    mm2s_allbuffer_empty            <= '0';
    mm2s_dwidth_fifo_pipe_empty            <= '0';
    mm2s_buffer_empty_i               <= '0';
    mm2s_buffer_almost_empty_i        <= '0';
    mm2s_all_lines_xfred            <= '0';

    -- SOF generator
    mm2s_packet_sof                 <= '0';

    -- DMA Controller
    mm2s_halted_clr                 <= '0';
    mm2s_halted_set                 <= '0';
    mm2s_idle_set                   <= '0';
    mm2s_idle_clr                   <= '0';
    mm2s_frame_number               <= (others => '0');
    mm2s_chnl_current_frame               <= (others => '0');
    mm2s_genlock_pair_frame               <= (others => '0');
    mm2s_new_curdesc                <= (others => '0');
    mm2s_new_curdesc_wren           <= '0';
    mm2s_stop                       <= '0';
    mm2s_stop_reg                       <= '0';
    mm2s_all_idle                   <= '1';
    mm2s_cmdsts_idle                <= '1';
    mm2s_ftchcmdsts_idle            <= '1';
    m_axis_mm2s_ftch_tready         <= '0';
    s_axis_mm2s_cmd_tvalid          <= '0';
    s_axis_mm2s_cmd_tdata           <= (others => '0');
    m_axis_mm2s_sts_tready          <= '0';
    mm2s_m_frame_ptr_out            <= (others => '0');
    mm2s_frame_ptr_out_i            <= (others => '0');
    s2mm_to_mm2s_frame_ptr_in       <= (others => '0');
    mm2s_valid_frame_sync           <= '0';
    mm2s_valid_frame_sync_cmb       <= '0';
    mm2s_valid_video_prmtrs         <= '0';
    mm2s_parameter_update           <= '0';
    mm2s_tstvect_err              <= '0';
    mm2s_tstvect_fsync              <= '0';
    mm2s_tstvect_frame              <= (others => '0');
    mm2s_dma_interr_set             <= '0';
    mm2s_dma_interr_set_minus_frame_errors             <= '0';
    mm2s_dma_slverr_set             <= '0';
    mm2s_dma_decerr_set             <= '0';
    mm2s_crnt_vsize                 <= (others => '0');
    mm2s_crnt_vsize_d2                 <= (others => '0');
    mm2s_fsize_mismatch_err         <= '0';
    mm2s_lsize_mismatch_err         <= '0';
    mm2s_lsize_more_mismatch_err         <= '0';

    -- Frame Sync generator
    mm2s_frame_sync                 <= '0';
    mm2s_fsync_out_sig                  <= '0';
    mm2s_prmtr_update_i               <= '0';
    mm2s_mask_fsync_out             <= '0';
    mm2s_mstrfrm_tstsync            <= '0';
    mm2s_mstrfrm_tstsync_out        <= '0';
    mm2s_tstvect_frm_ptr_out        <= (others => '0');
    mm2s_to_s2mm_fsync              <= '0';


end generate GEN_NO_SPRT_FOR_MM2S;

--*****************************************************************************
--**                            S2MM CHANNEL                                 **
--*****************************************************************************

-- Generate support logic for S2MM
GEN_SPRT_FOR_S2MM : if C_INCLUDE_S2MM = 1 generate

		signal no_fsync_before_vsize_sel_00_01             	: std_logic := '0';
begin
------------------------------------------------------------------------------------------------------------------------------------------------------


s2mm_axis_linebuf_reset_out_inv <= not s2mm_axis_linebuf_reset_out;

GEN_S2MM_DRE_ON_SKID : if C_S2MM_ENABLE_TKEEP = 1 generate
begin


    --*********************************************************--
    --**               S2MM SLAVE SKID BUFFER                **--
    --*********************************************************--
    I_S2MM_SKID_FLUSH_SOF : entity axi_vdma_v6_3_10.axi_vdma_skid_buf
        generic map(
            C_WDATA_WIDTH           => C_S_AXIS_S2MM_TDATA_WIDTH             ,
            C_TUSER_WIDTH           => C_S_AXIS_S2MM_TUSER_BITS
        )
        port map(
            -- System Ports
            ACLK                   => s_axis_s2mm_aclk              ,
            ARST                   => s2mm_axis_linebuf_reset_out_inv          ,

            -- Shutdown control (assert for 1 clk pulse)
            skid_stop              => '0'                      ,

            -- Slave Side (Stream Data Input)
            S_VALID                => s_axis_s2mm_tvalid   ,
            S_READY                => s_axis_s2mm_tready        ,
            S_Data                 => s_axis_s2mm_tdata             ,
            S_STRB                 => s_axis_s2mm_tkeep             ,
            S_Last                 => s_axis_s2mm_tlast             ,
            S_User                 => s_axis_s2mm_tuser             ,

            -- Master Side (Stream Data Output)
            M_VALID                => s_axis_s2mm_tvalid_signal            ,
            M_READY                => s_axis_s2mm_tready_signal            ,
            M_Data                 => s_axis_s2mm_tdata_signal             ,
            M_STRB                 => s_axis_s2mm_tkeep_signal             ,
            M_Last                 => s_axis_s2mm_tlast_signal            ,
            M_User                 => s_axis_s2mm_tuser_signal 
        );

end generate GEN_S2MM_DRE_ON_SKID;


GEN_S2MM_DRE_OFF_SKID : if C_S2MM_ENABLE_TKEEP = 0 generate
begin



    --*********************************************************--
    --**               S2MM SLAVE SKID BUFFER                **--
    --*********************************************************--
    I_S2MM_SKID_FLUSH_SOF : entity axi_vdma_v6_3_10.axi_vdma_skid_buf
        generic map(
            C_WDATA_WIDTH           => C_S_AXIS_S2MM_TDATA_WIDTH             ,
            C_TUSER_WIDTH           => C_S_AXIS_S2MM_TUSER_BITS
        )
        port map(
            -- System Ports
            ACLK                   => s_axis_s2mm_aclk              ,
            ARST                   => s2mm_axis_linebuf_reset_out_inv          ,

            -- Shutdown control (assert for 1 clk pulse)
            skid_stop              => '0'                      ,

            -- Slave Side (Stream Data Input)
            S_VALID                => s_axis_s2mm_tvalid   ,
            S_READY                => s_axis_s2mm_tready        ,
            S_Data                 => s_axis_s2mm_tdata             ,
            --S_STRB                 => s_axis_s2mm_tkeep             ,
            S_STRB                 => (others => '1')             ,
            S_Last                 => s_axis_s2mm_tlast             ,
            S_User                 => s_axis_s2mm_tuser             ,

            -- Master Side (Stream Data Output)
            M_VALID                => s_axis_s2mm_tvalid_signal            ,
            M_READY                => s_axis_s2mm_tready_signal            ,
            M_Data                 => s_axis_s2mm_tdata_signal             ,
            M_STRB                 => s_axis_s2mm_tkeep_signal             ,
            M_Last                 => s_axis_s2mm_tlast_signal            ,
            M_User                 => s_axis_s2mm_tuser_signal 
        );


end generate GEN_S2MM_DRE_OFF_SKID;







	GEN_FLUSH_SOF_TREADY : if ENABLE_FLUSH_ON_S2MM_FSYNC = 1 and  S2MM_SOF_ENABLE = 1 generate


		signal s2mm_fsize_less_err_flag_10          			: std_logic := '0'; 
		signal s2mm_fsize_less_err_flag_00_01          			: std_logic := '0'; 
		signal s_axis_s2mm_tuser_d1                 			: std_logic := '0';
		signal s2mm_tuser_to_fsync_out                 			: std_logic := '0';
		signal d_tready_sof_late                 			: std_logic := '0';
		signal d_tready_sof_late_cmb                 			: std_logic := '0';
		signal s2mm_sof_late_err                 			: std_logic := '0';

		signal s2mm_prmtr_or_tail_ptr_updt_complete             	: std_logic := '0';
		signal s2mm_prmtr_updt_complete_s             			: std_logic := '0';
		signal s2mm_dmasr_halted_s             				: std_logic := '0';
		signal d_tready_before_fsync_clr_flag1             		: std_logic := '0';
		signal d_tready_before_fsync             			: std_logic := '0';
		signal d_tready_before_fsync_cmb             			: std_logic := '0';

		signal d_tready_after_prmtr_updt             			: std_logic := '0';
		signal d_tready_after_prmtr_updt_clrd_till_reset           	: std_logic := '0';
		signal d_tready_after_prmtr_updt_clrd             		: std_logic := '0';
		signal d_tready_sof_late_prmtr_updt             		: std_logic := '0';
		signal d_tready_after_prmtr_updt_clrd_cmb             		: std_logic := '0';
		signal s2mm_sof_late_err_prmtr_updt             		: std_logic := '0';

		signal s2mm_fsync_src_select_s_d1                  		: std_logic_vector(1 downto 0) := (others => '0');


		signal s2mm_dummy_tready_fsync_src_sel_00_or_01       		: std_logic := '0';
		signal s2mm_dummy_tready_fsync_src_sel_10       		: std_logic := '0';


		signal d_tready_before_fsync_clr_flag1_sel_00_01             	: std_logic := '0';
		signal d_tready_before_fsync_clrd_sel_00_01            	 	: std_logic := '0';
		signal d_tready_before_fsync_clr_sel_00_01            	 	: std_logic := '0';
		signal d_tready_before_fsync_sel_00_01             		: std_logic := '0';
		signal d_tready_before_fsync_cmb_sel_00_01           		: std_logic := '0';
		signal d_tready_after_vcount_sel_00_01           		: std_logic := '0';
		signal after_vcount_flag_sel_00_01	           		: std_logic := '0';
		signal d_tready_after_fsize_less_err_flag_00_01       		: std_logic := '0';
		signal d_tready_after_fsize_less_err_00_01       		: std_logic := '0';
		signal s2mm_fsize_less_err_internal_tvalid_gating_10       	: std_logic := '0';
		signal s2mm_fsize_less_err_internal_tvalid_gating_00_01       	: std_logic := '0';

        	    begin


no_fsync_before_vsize_sel_00_01 <= d_tready_before_fsync_clr_flag1_sel_00_01;










	
 		s_axis_s2mm_tvalid_int			<= 	s_axis_s2mm_tvalid_signal and s2mm_chnl_ready ;
		s_axis_s2mm_tready_signal		<= 	(s_axis_s2mm_tready_i_axis_dw_conv  and s2mm_chnl_ready) or s2mm_dummy_tready;




GEN_C_USE_S2MM_FSYNC_0 : if C_USE_S2MM_FSYNC = 0 generate
begin
                        s2mm_fsize_less_err_internal_tvalid_gating <= '0';

end generate GEN_C_USE_S2MM_FSYNC_0;

GEN_C_USE_S2MM_FSYNC_1 : if C_USE_S2MM_FSYNC = 1 generate
begin
                        s2mm_dummy_tready <= s2mm_dummy_tready_fsync_src_sel_00_or_01;
                        s2mm_fsize_less_err_internal_tvalid_gating <= s2mm_fsize_less_err_internal_tvalid_gating_00_01;

end generate GEN_C_USE_S2MM_FSYNC_1;


GEN_C_USE_S2MM_FSYNC_2 : if C_USE_S2MM_FSYNC = 2 generate
begin
                        s2mm_dummy_tready <= s2mm_dummy_tready_fsync_src_sel_10;
                        s2mm_fsize_less_err_internal_tvalid_gating <= s2mm_fsize_less_err_internal_tvalid_gating_10;

end generate GEN_C_USE_S2MM_FSYNC_2;






----        FSYNC_SEL_TREADY_S2MM_S : process(s2mm_fsync_src_select_s_d1,
----                                 s2mm_dummy_tready,
----                                 s2mm_dummy_tready_fsync_src_sel_00_or_01,
----                                 s2mm_fsize_less_err_internal_tvalid_gating_10,
----                                 s2mm_fsize_less_err_internal_tvalid_gating_00_01,
----                                 s2mm_fsize_less_err_internal_tvalid_gating,
----                                 s2mm_dummy_tready_fsync_src_sel_10)
----            begin
----                case s2mm_fsync_src_select_s_d1 is
----
----                    when "00" =>   -- primary fsync (default)
----                        s2mm_dummy_tready <= s2mm_dummy_tready_fsync_src_sel_00_or_01;
----                        s2mm_fsize_less_err_internal_tvalid_gating <= s2mm_fsize_less_err_internal_tvalid_gating_00_01;
----                    when "01" =>   -- other channel fsync
----                        s2mm_dummy_tready <= s2mm_dummy_tready_fsync_src_sel_00_or_01;
----                        s2mm_fsize_less_err_internal_tvalid_gating <= s2mm_fsize_less_err_internal_tvalid_gating_00_01;
----                    when "10" =>   -- s2mm_tuser_fsync_top_d1 fsync  
----                        s2mm_dummy_tready <= s2mm_dummy_tready_fsync_src_sel_10;
----                        s2mm_fsize_less_err_internal_tvalid_gating <= s2mm_fsize_less_err_internal_tvalid_gating_10;
----                    when others =>
----                        s2mm_dummy_tready <= '0';
----                        s2mm_fsize_less_err_internal_tvalid_gating <= '0';
----                end case;
----            end process FSYNC_SEL_TREADY_S2MM_S;
----
----
----
----				D1_S2MM_FSYNC_SRC_SEL_STRM : process(s_axis_s2mm_aclk)
----				    begin
----				        if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
----				            if(s2mm_axis_resetn = '0')then
----				                s2mm_fsync_src_select_s_d1  <= (others => '0');
----				            else
----				                s2mm_fsync_src_select_s_d1  <= s2mm_fsync_src_select_s;
----				            end if;
----				        end if;
----				    end process D1_S2MM_FSYNC_SRC_SEL_STRM;
----


--------------------------------------------------TUSER Start-------------------------------------------------------------------------------------------------------------------------

		s2mm_dummy_tready_fsync_src_sel_10	<= 	d_tready_sof_late_cmb  or d_tready_before_fsync_cmb ;


		d_tready_sof_late_cmb 			<= 	d_tready_sof_late  when  s2mm_tuser_fsync_top = '0' and s2mm_tuser_to_fsync_out = '0' and s2mm_chnl_ready = '0'             											    else '0';

        	TUSER_TO_FSYNC_OUT_FLAG : process(s_axis_s2mm_aclk)
        	    begin
        	        if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
        	            if(s2mm_axis_resetn = '0' or s2mm_fsync_out_i = '1'  )then
        	                s2mm_tuser_to_fsync_out <= '0';
        	            elsif(s2mm_tuser_fsync_top = '1' and d_tready_before_fsync_clr_flag1 = '0')then
        	                s2mm_tuser_to_fsync_out <= '1';
        	            end if;
        	        end if;
        	    end process TUSER_TO_FSYNC_OUT_FLAG;

		s2mm_fsize_less_err_internal_tvalid_gating_10 <= '1'  when  s2mm_fsize_less_err_flag_10 = '1' and  s2mm_tuser_fsync_top = '0'
		            else '0';
		
		
		FSIZE_LESS_ERR_FLAG_10 : process(s_axis_s2mm_aclk)
		    begin
		        if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
		            if(s2mm_axis_resetn = '0' or s2mm_tuser_fsync_top = '1')then
		                s2mm_fsize_less_err_flag_10  <= '0';
		            elsif(s2mm_fsize_mismatch_err_s = '1')then
		                s2mm_fsize_less_err_flag_10  <= '1';
		            end if;
		        end if;
		    end process FSIZE_LESS_ERR_FLAG_10;
		

    		    TOP_TUSER_RE_PROCESS : process(s_axis_s2mm_aclk)
    		        begin
    		            if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
    		                if(s2mm_axis_resetn = '0')then
    		                    s_axis_s2mm_tuser_d1 <= '0';
    		                else
    		                    s_axis_s2mm_tuser_d1 <= s_axis_s2mm_tuser_signal(0) and s_axis_s2mm_tvalid_signal;
    		                end if;
    		            end if;
    		        end process TOP_TUSER_RE_PROCESS;

    		    s2mm_tuser_fsync_top <= s_axis_s2mm_tuser_signal(0) and s_axis_s2mm_tvalid_signal and (not s_axis_s2mm_tuser_d1);


        	SOF_LATE_ERR_PULSE_PROCESS : process(s_axis_s2mm_aclk)
        	    begin
        	        if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
        	            if(s2mm_axis_resetn = '0' or s2mm_sof_late_err = '1' or s2mm_chnl_ready = '1' or d_tready_before_fsync_clr_flag1 = '1')then
        	                s2mm_sof_late_err <= '0';
        	                d_tready_sof_late <= '0';
        	            elsif((s2mm_chnl_ready = '0' or s2mm_fsize_less_err_internal_tvalid_gating_10 = '1') and s_axis_s2mm_tvalid_signal = '1' and s_axis_s2mm_tuser_signal(0) = '0' ) then
        	                s2mm_sof_late_err <= '1';
        	                d_tready_sof_late <= '1';
        	            end if;
        	        end if;
        	    end process SOF_LATE_ERR_PULSE_PROCESS;




--------------------------------------------------------------------------------------------------------



d_tready_before_fsync_cmb <= d_tready_before_fsync and d_tready_before_fsync_clr_flag1;





GEN_D_TREADY_BEFORE_FSYNC : process(s_axis_s2mm_aclk)
    begin
        if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
            if(d_tready_before_fsync_clr_flag1 = '0')then
                d_tready_before_fsync  <= '0';
            elsif(s2mm_axis_resetn = '1' or s2mm_dmasr_halted_s = '1')then
                d_tready_before_fsync  <= '1';
            end if;
        end if;
    end process GEN_D_TREADY_BEFORE_FSYNC;






VALID_PRM_UPDT_FLAG_10 : process(s_axis_s2mm_aclk)
    begin
        if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
            if(s2mm_axis_resetn = '0' or s2mm_dmasr_halted_s = '1')then
                d_tready_before_fsync_clr_flag1  <= '1';
            elsif(s2mm_prmtr_updt_complete_s = '1')then
                d_tready_before_fsync_clr_flag1  <= '0';
            end if;
        end if;
    end process VALID_PRM_UPDT_FLAG_10;



--------------------------------------------------TUSER End-------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------External Fsync Start-----------------------------------------------------------------------------------------------------------------------


s2mm_dummy_tready_fsync_src_sel_00_or_01	<= 	d_tready_after_fsize_less_err_00_01 or d_tready_after_vcount_sel_00_01 or d_tready_before_fsync_cmb_sel_00_01;


--------------------------------------------------------------------------------------------------------------

d_tready_after_fsize_less_err_00_01 <= '1'  when  d_tready_after_fsize_less_err_flag_00_01 = '1' and  s2mm_fsync_core = '0' and hold_dummy_tready_low2 = '0'
            else '0';



TREADY_AFTER_FSIZE_LESS_ERR_FLAG_00_01 : process(s_axis_s2mm_aclk)
    begin
        if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
            if(s2mm_axis_resetn = '0' or s2mm_fsync_core = '1'  or hold_dummy_tready_low2 = '1')then
                d_tready_after_fsize_less_err_flag_00_01  <= '0';
            elsif(s2mm_fsize_mismatch_err_s = '1')then
                d_tready_after_fsize_less_err_flag_00_01  <= '1';
            end if;
        end if;
    end process TREADY_AFTER_FSIZE_LESS_ERR_FLAG_00_01;


--------------------------------------------------------------------------------------------------------------


d_tready_after_vcount_sel_00_01 <= '1'  when  s2mm_fsync_core = '0' and after_vcount_flag_sel_00_01 = '1' and hold_dummy_tready_low = '0'
            else '0';

REG_S2MM_FSYNC_TO_FSYNC_OUT_FLAG_00_01 : process(s_axis_s2mm_aclk)
    begin
        if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
            if(s2mm_axis_resetn = '0' or s2mm_fsync_core = '1' or hold_dummy_tready_low = '1')then
                after_vcount_flag_sel_00_01  <= '0';
            elsif(s2mm_all_vount_rcvd = '1')then
                after_vcount_flag_sel_00_01  <= '1';
            end if;
        end if;
    end process REG_S2MM_FSYNC_TO_FSYNC_OUT_FLAG_00_01;



--------------------------------------------------------------------------------------------------------------


d_tready_before_fsync_cmb_sel_00_01 <= d_tready_before_fsync_sel_00_01 and d_tready_before_fsync_clr_sel_00_01;





GEN_D_TREADY_BEFORE_FSYNC_00_01 : process(s_axis_s2mm_aclk)
    begin
        if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
            if(s2mm_fsync_core = '1'and d_tready_before_fsync_clr_flag1_sel_00_01 = '1')then
                d_tready_before_fsync_sel_00_01  <= '0';
            elsif(s2mm_axis_resetn = '1')then
                d_tready_before_fsync_sel_00_01  <= '1';
            end if;
        end if;
    end process GEN_D_TREADY_BEFORE_FSYNC_00_01;




d_tready_before_fsync_clr_sel_00_01 <= '0'  when  d_tready_before_fsync_clr_flag1_sel_00_01 = '1' and  s2mm_fsync_core = '1'
            else d_tready_before_fsync_clrd_sel_00_01;



REG_INITIAL_FRM_FLAG_00_01 : process(s_axis_s2mm_aclk)
    begin
        if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
            if(s2mm_axis_resetn = '0' or s2mm_dmasr_halted_s = '1')then
                d_tready_before_fsync_clrd_sel_00_01  <= '1';
            elsif(s2mm_fsync_core = '1'and d_tready_before_fsync_clr_flag1_sel_00_01 = '1')then
                d_tready_before_fsync_clrd_sel_00_01  <= '0';
            end if;
        end if;
    end process REG_INITIAL_FRM_FLAG_00_01;


VALID_PRM_UPDT_FLAG_00_01 : process(s_axis_s2mm_aclk)
    begin
        if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
            if(s2mm_axis_resetn = '0' or s2mm_dmasr_halted_s = '1')then
                d_tready_before_fsync_clr_flag1_sel_00_01  <= '0';
            elsif(s2mm_prmtr_updt_complete_s = '1')then
                d_tready_before_fsync_clr_flag1_sel_00_01  <= '1';
            end if;
        end if;
    end process VALID_PRM_UPDT_FLAG_00_01;


-----------------------------------------------------------------------------------

		s2mm_fsize_less_err_internal_tvalid_gating_00_01 <= '1'  when  s2mm_fsize_less_err_flag_00_01 = '1' and  s2mm_fsync_core = '0'
		            else '0';
			
		FSIZE_LESS_ERR_FLAG_00_01 : process(s_axis_s2mm_aclk)
		    begin
		        if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
		            if(s2mm_axis_resetn = '0' or s2mm_fsync_core = '1')then
		                s2mm_fsize_less_err_flag_00_01  <= '0';
		            elsif(s2mm_fsize_mismatch_err_s = '1')then
		                s2mm_fsize_less_err_flag_00_01  <= '1';
		            end if;
		        end if;
		    end process FSIZE_LESS_ERR_FLAG_00_01;
		


--------------------------------------------------External Fsync End-------------------------------------------------------------------------------------------------------------------------
SG_INCLUDED : if C_INCLUDE_SG = 1 generate

s2mm_prmtr_or_tail_ptr_updt_complete <= s2mm_tailpntr_updated;

end generate SG_INCLUDED;

SG_NOT_INCLUDED : if C_INCLUDE_SG = 0 generate

s2mm_prmtr_or_tail_ptr_updt_complete <= s2mm_prmtr_updt_complete;

end generate SG_NOT_INCLUDED;



GEN_FOR_ASYNC_FLUSH_SOF : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin


----    S2MM_PRM_UPDT_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_PULSE_P_S_OPEN_ENDED                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axi_s2mm_aclk                               ,
----            prmry_resetn            => s2mm_prmry_resetn                             ,
----            scndry_aclk             => s_axis_s2mm_aclk                              ,
----            scndry_resetn           => s2mm_axis_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => s2mm_prmtr_or_tail_ptr_updt_complete                         ,
----            scndry_out              => s2mm_prmtr_updt_complete_s                          ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----


S2MM_PRM_UPDT_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axi_s2mm_aclk,
        prmry_resetn               => s2mm_prmry_resetn, 
        prmry_in                   => s2mm_prmtr_or_tail_ptr_updt_complete, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_s2mm_aclk, 
        scndry_resetn              => s2mm_axis_resetn,
        scndry_out                 => s2mm_prmtr_updt_complete_s,
        scndry_vect_out            => open
    );







----    S2MM_HALTED_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_P_S                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axi_s2mm_aclk                               ,
----            prmry_resetn            => s2mm_prmry_resetn                             ,
----            scndry_aclk             => s_axis_s2mm_aclk                              ,
----            scndry_resetn           => s2mm_axis_resetn                            ,
----            scndry_in               => '0'                                      ,   -- Not Used
----            prmry_out               => open                                     ,   -- Not Used
----            prmry_in                => s2mm_dmasr(DMASR_HALTED_BIT)                         ,
----            scndry_out              => s2mm_dmasr_halted_s                          ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----



S2MM_HALTED_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axi_s2mm_aclk,
        prmry_resetn               => s2mm_prmry_resetn, 
        prmry_in                   => s2mm_dmasr(DMASR_HALTED_BIT), 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => s_axis_s2mm_aclk, 
        scndry_resetn              => s2mm_axis_resetn,
        scndry_out                 => s2mm_dmasr_halted_s,
        scndry_vect_out            => open
    );








----    SOF_LATE_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_cdc
----        generic map(
----            C_CDC_TYPE              => CDC_TYPE_LEVEL_S_P                           ,
----            C_VECTOR_WIDTH          => 1
----        )
----        port map (
----            prmry_aclk              => m_axi_s2mm_aclk                               ,
----            prmry_resetn            => s2mm_prmry_resetn                             ,
----            scndry_aclk             => s_axis_s2mm_aclk                              ,
----            scndry_resetn           => s2mm_axis_resetn                            ,
----            scndry_in               => s2mm_fsize_more_or_sof_late_s                                      ,   -- Not Used
----            prmry_out               => s2mm_fsize_more_or_sof_late                                     ,   -- Not Used
----            prmry_in                => '0'                         ,
----            scndry_out              => open                          ,
----            scndry_vect_s_h         => '0'                                      ,   -- Not Used
----            scndry_vect_in          => ZERO_VALUE(0 downto 0)              ,   -- Not Used
----            prmry_vect_out          => open                                     ,   -- Not Used
----            prmry_vect_s_h          => '0'                                      ,   -- Not Used
----            prmry_vect_in           => ZERO_VALUE(0 downto 0)              ,   -- Not Used
----            scndry_vect_out         => open                                         -- Not Used
----        );
----


SOF_LATE_CDC_I : entity lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_FLOP_INPUT               => 1,	--valid only for level CDC
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axis_s2mm_aclk,
        prmry_resetn               => s2mm_axis_resetn, 
        prmry_in                   => s2mm_fsize_more_or_sof_late_s, 
        prmry_vect_in              => (others => '0'),
        prmry_ack                  => open,
                                    
        scndry_aclk                => m_axi_s2mm_aclk, 
        scndry_resetn              => s2mm_prmry_resetn,
        scndry_out                 => s2mm_fsize_more_or_sof_late,
        scndry_vect_out            => open
    );



end generate GEN_FOR_ASYNC_FLUSH_SOF;



GEN_FOR_SYNC_FLUSH_SOF : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin
    s2mm_dmasr_halted_s           <= s2mm_dmasr(DMASR_HALTED_BIT);
    s2mm_prmtr_updt_complete_s    <= s2mm_prmtr_or_tail_ptr_updt_complete;
    s2mm_fsize_more_or_sof_late    <= s2mm_fsize_more_or_sof_late_s;

end generate GEN_FOR_SYNC_FLUSH_SOF;













---------------------------------------------------------------------------	
	
	end generate GEN_FLUSH_SOF_TREADY;
----------------------------------------------------------------------------------------------------------------------------------------------------------	
	
	GEN_FLUSH_NO_SOF_TREADY : if ENABLE_FLUSH_ON_S2MM_FSYNC = 1 and  S2MM_SOF_ENABLE = 0 generate
        	    begin
	
						--s_axis_s2mm_tdata_signal  <= s_axis_s2mm_tdata;
				                --s_axis_s2mm_tkeep_signal  <= s_axis_s2mm_tkeep;
				                --s_axis_s2mm_tuser_signal  <= s_axis_s2mm_tuser;
				                --s_axis_s2mm_tlast_signal  <= s_axis_s2mm_tlast;
				                --s_axis_s2mm_tvalid_signal <= s_axis_s2mm_tvalid;
				                --s_axis_s2mm_tready 	  <= s_axis_s2mm_tready_signal;



	 		s_axis_s2mm_tvalid_int			<= 	s_axis_s2mm_tvalid_signal;
			s_axis_s2mm_tready_signal              	<= 	s_axis_s2mm_tready_i_axis_dw_conv;
			s2mm_dummy_tready			<=	'0';
			s2mm_fsize_less_err_internal_tvalid_gating   <= '0';
	end generate GEN_FLUSH_NO_SOF_TREADY;
	
	
	GEN_NO_FLUSH_TREADY : if ENABLE_FLUSH_ON_S2MM_FSYNC = 0 generate
        	    begin
	

						--s_axis_s2mm_tdata_signal  <= s_axis_s2mm_tdata;
				                --s_axis_s2mm_tkeep_signal  <= s_axis_s2mm_tkeep;
				                --s_axis_s2mm_tuser_signal  <= s_axis_s2mm_tuser;
				                --s_axis_s2mm_tlast_signal  <= s_axis_s2mm_tlast;
				                --s_axis_s2mm_tvalid_signal <= s_axis_s2mm_tvalid;
				                --s_axis_s2mm_tready 	  <= s_axis_s2mm_tready_signal;

			s2mm_fsize_less_err_internal_tvalid_gating   <= '0';

	 		s_axis_s2mm_tvalid_int			<= 	s_axis_s2mm_tvalid_signal;
			s_axis_s2mm_tready_signal              	<= 	s_axis_s2mm_tready_i_axis_dw_conv;
			s2mm_dummy_tready			<=	'0';
	
	
	end generate GEN_NO_FLUSH_TREADY;
	





  GEN_AXIS_S2MM_DWIDTH_CONV : if C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED /=  C_S_AXIS_S2MM_TDATA_WIDTH generate
 
		constant C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED_div_by_8     	: integer := C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED/8;
		constant C_S_AXIS_S2MM_TDATA_WIDTH_div_by_8     		: integer := C_S_AXIS_S2MM_TDATA_WIDTH/8;
		
		signal   s_axis_s2mm_dwidth_tuser_i           			:   std_logic_vector                                      --
		                                        				(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED_div_by_8-1 downto 0) := (others => '0');                  --
		
		signal   s_axis_s2mm_dwidth_tuser           			:   std_logic_vector                                      --
		                                        				(C_S_AXIS_S2MM_TDATA_WIDTH_div_by_8-1 downto 0) := (others => '0');                  --


  begin


			S2MM_TUSER_CNCT : for i in 0 to C_S_AXIS_S2MM_TDATA_WIDTH_div_by_8-1 generate
			begin

			                        s_axis_s2mm_dwidth_tuser(i)   <= s_axis_s2mm_tuser_signal(0);
			
			end generate S2MM_TUSER_CNCT;




		
		s_axis_s2mm_tuser_i(C_S_AXIS_S2MM_TUSER_BITS-1 downto 0)		<= s_axis_s2mm_dwidth_tuser_i(C_S_AXIS_S2MM_TUSER_BITS-1 downto 0);

    AXIS_S2MM_DWIDTH_CONVERTER_I: entity  axi_vdma_v6_3_10.axi_vdma_s2mm_axis_dwidth_converter
        generic map(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED 	=>	C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED		, 
 		C_S_AXIS_S2MM_TDATA_WIDTH         	 	=>	C_S_AXIS_S2MM_TDATA_WIDTH		, 
 		--C_AXIS_SIGNAL_SET            		 	=>	255		, 
 		C_S_AXIS_S2MM_TDATA_WIDTH_div_by_8         	=>	C_S_AXIS_S2MM_TDATA_WIDTH_div_by_8		, 
 		C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED_div_by_8   =>	C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED_div_by_8		, 
            	C_S2MM_SOF_ENABLE           			=> 	S2MM_SOF_ENABLE                  ,
            	ENABLE_FLUSH_ON_FSYNC      			=> 	ENABLE_FLUSH_ON_S2MM_FSYNC,
 		C_AXIS_TID_WIDTH             		 	=>	1		, 
 		C_AXIS_TDEST_WIDTH           		 	=>	1		, 
        	C_FAMILY                     		 	=>	C_ROOT_FAMILY		   ) 
        port map( 
      		ACLK                         =>	s_axis_s2mm_aclk                 			, 
      		ARESETN                      =>	s2mm_axis_linebuf_reset_out              			, 
      		--ARESETN                      =>	s2mm_axis_resetn              			, 
      		ACLKEN                       =>	'1'               			, 


        	s2mm_fsize_less_err_internal_tvalid_gating                   =>	s2mm_fsize_less_err_internal_tvalid_gating		,	--	: in  std_logic                         ;   
        	fsync_out                   =>	s2mm_fsync_out_i		,	--	: in  std_logic                         ;   
        	crnt_vsize_d2               =>	s2mm_crnt_vsize_d2		,	--	: in  std_logic_vector(VSIZE_DWIDTH-1 downto 0)                         ;   
      		chnl_ready_dwidth           =>	s2mm_chnl_ready			,	--	: out std_logic;
      		strm_not_finished_dwidth    =>	s2mm_strm_not_finished		,	--      : out std_logic;
      		strm_all_lines_rcvd_dwidth  =>	s2mm_strm_all_lines_rcvd	,	--      : out std_logic;
      		all_vount_rcvd_dwidth	    =>	s2mm_all_vount_rcvd	,	--      : out std_logic;



      		S_AXIS_TVALID                =>	s_axis_s2mm_tvalid_int        			, 
      		S_AXIS_TREADY                =>	s_axis_s2mm_tready_i_axis_dw_conv        			, 
      		S_AXIS_TDATA                 =>	s_axis_s2mm_tdata_signal(C_S_AXIS_S2MM_TDATA_WIDTH-1 downto 0)         			, 
      		--S_AXIS_TSTRB                 =>	ZERO_VALUE(C_S_AXIS_S2MM_TDATA_WIDTH/8-1 downto 0)         			, 
      		S_AXIS_TSTRB                 =>	s_axis_s2mm_tkeep_signal(C_S_AXIS_S2MM_TDATA_WIDTH/8-1 downto 0)         			, 
      		S_AXIS_TKEEP                 =>	s_axis_s2mm_tkeep_signal(C_S_AXIS_S2MM_TDATA_WIDTH/8-1 downto 0)         			, 
      		S_AXIS_TLAST                 =>	s_axis_s2mm_tlast_signal         			, 
      		S_AXIS_TID                   =>	ZERO_VALUE(0 downto 0)           			, 
      		S_AXIS_TDEST                 =>	ZERO_VALUE(0 downto 0)         			, 
      		S_AXIS_TUSER                 =>	s_axis_s2mm_dwidth_tuser(C_S_AXIS_S2MM_TDATA_WIDTH_div_by_8-1 downto 0)         			, 



      		M_AXIS_TVALID                =>	s_axis_s2mm_tvalid_i        			, 
      		M_AXIS_TREADY                =>	s_axis_s2mm_tready_i        			, 
      		M_AXIS_TDATA                 =>	s_axis_s2mm_tdata_i(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED-1 downto 0)         			, 
      		M_AXIS_TSTRB                 =>	open         			, 
      		M_AXIS_TKEEP                 =>	s_axis_s2mm_tkeep_i(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED/8-1 downto 0)         			, 
      		M_AXIS_TLAST                 =>	s_axis_s2mm_tlast_i         			, 
      		M_AXIS_TID                   =>	open           			, 
      		M_AXIS_TDEST                 =>	open         			, 
      		M_AXIS_TUSER                 =>	s_axis_s2mm_dwidth_tuser_i(C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED_div_by_8-1 downto 0)         			
  ) ;


  end generate GEN_AXIS_S2MM_DWIDTH_CONV;


  GEN_NO_AXIS_S2MM_DWIDTH_CONV_NO_FLUSH_SOF : if ((C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED =  C_S_AXIS_S2MM_TDATA_WIDTH) and  (ENABLE_FLUSH_ON_S2MM_FSYNC = 0 or  S2MM_SOF_ENABLE = 0) )generate
  begin


 		s_axis_s2mm_tvalid_i			<= 	s_axis_s2mm_tvalid_int;
 		s_axis_s2mm_tdata_i			<= 	s_axis_s2mm_tdata_signal;
 		s_axis_s2mm_tkeep_i			<= 	s_axis_s2mm_tkeep_signal;
 		s_axis_s2mm_tlast_i			<= 	s_axis_s2mm_tlast_signal;
 		s_axis_s2mm_tuser_i			<= 	s_axis_s2mm_tuser_signal;
 		s_axis_s2mm_tready_i_axis_dw_conv	<= 	s_axis_s2mm_tready_i;


s2mm_chnl_ready			<= '0' ;
s2mm_strm_not_finished		<= '0' ;	
s2mm_strm_all_lines_rcvd	<= '0' ;
s2mm_all_vount_rcvd		<= '0' ;



  end generate GEN_NO_AXIS_S2MM_DWIDTH_CONV_NO_FLUSH_SOF;





  GEN_NO_AXIS_S2MM_DWIDTH_CONV : if ((C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED =  C_S_AXIS_S2MM_TDATA_WIDTH) and  (ENABLE_FLUSH_ON_S2MM_FSYNC = 1 and  S2MM_SOF_ENABLE = 1) ) generate

	constant ZERO_VALUE                 		: std_logic_vector(255 downto 0)
	                                        						:= (others => '0');

	constant VSIZE_ONE_VALUE            		: std_logic_vector(VSIZE_DWIDTH-1 downto 0)
	                                        						:= std_logic_vector(to_unsigned(1,VSIZE_DWIDTH));

	constant VSIZE_ZERO_VALUE           		: std_logic_vector(VSIZE_DWIDTH-1 downto 0)
	                                        						:= (others => '0');
	
	
	signal chnl_ready_no_dwidth                  : std_logic := '0';
	signal strm_not_finished_no_dwidth           : std_logic := '0';
	signal strm_all_lines_rcvd_no_dwidth         : std_logic := '0';
	signal decr_vcount_no_dwidth                 : std_logic := '0';
	signal vsize_counter_no_dwidth               : std_logic_vector(VSIZE_DWIDTH-1 downto 0) := (others => '0'); 

 	signal all_vount_rcvd_no_dwidth              : std_logic := '0';



  begin


 		s_axis_s2mm_tvalid_i			<= 	s_axis_s2mm_tvalid_int;
 		s_axis_s2mm_tdata_i			<= 	s_axis_s2mm_tdata_signal;
 		s_axis_s2mm_tkeep_i			<= 	s_axis_s2mm_tkeep_signal;
 		s_axis_s2mm_tlast_i			<= 	s_axis_s2mm_tlast_signal;
 		s_axis_s2mm_tuser_i			<= 	s_axis_s2mm_tuser_signal;
 		s_axis_s2mm_tready_i_axis_dw_conv	<= 	s_axis_s2mm_tready_i;


    -- Decrement vertical count with each accept tlast
    decr_vcount_no_dwidth <= '1' when s_axis_s2mm_tlast_signal = '1'
                        and s_axis_s2mm_tvalid_int = '1'
                        and s_axis_s2mm_tready_i_axis_dw_conv = '1'
              else '0';

    -- Drive ready at fsync out then de-assert once all lines have
    -- been accepted.
    NO_DWIDTH_VERT_COUNTER : process(s_axis_s2mm_aclk)
        begin
            if(s_axis_s2mm_aclk'EVENT and s_axis_s2mm_aclk = '1')then
            --if(s2mm_axis_linebuf_reset_out = '0' and s2mm_fsync_out_i = '0')then
            --if((s2mm_axis_linebuf_reset_out = '0' and s2mm_fsync_out_i = '0') or s2mm_fsize_less_err_flag = '1')then
            if((s2mm_axis_linebuf_reset_out = '0' and s2mm_fsync_out_i = '0') or s2mm_fsize_less_err_internal_tvalid_gating = '1')then
                    vsize_counter_no_dwidth          	<= (others => '0');
                    chnl_ready_no_dwidth      		<= '0';
                    strm_not_finished_no_dwidth      	<= '0';
                    strm_all_lines_rcvd_no_dwidth    	<= '1';
                    all_vount_rcvd_no_dwidth    	<= '0';

                elsif(s2mm_fsync_out_i = '1')then
                    vsize_counter_no_dwidth          	<= s2mm_crnt_vsize_d2;
                    chnl_ready_no_dwidth     		<= '1';
                    strm_not_finished_no_dwidth     	<= '1';
                    strm_all_lines_rcvd_no_dwidth    	<= '0';
                    all_vount_rcvd_no_dwidth    	<= '0';

                elsif(decr_vcount_no_dwidth = '1' and vsize_counter_no_dwidth = VSIZE_ONE_VALUE)then
                    vsize_counter_no_dwidth          	<= (others => '0');
                    chnl_ready_no_dwidth      		<= '0';
                    strm_not_finished_no_dwidth      	<= '0';
                    strm_all_lines_rcvd_no_dwidth    	<= '1';
                    all_vount_rcvd_no_dwidth    	<= '1';

                elsif(decr_vcount_no_dwidth = '1' and vsize_counter_no_dwidth /= VSIZE_ZERO_VALUE)then
                    vsize_counter_no_dwidth          	<= std_logic_vector(unsigned(vsize_counter_no_dwidth) - 1);
                    chnl_ready_no_dwidth      		<= '1';
                    strm_not_finished_no_dwidth      	<= '1';
                    strm_all_lines_rcvd_no_dwidth    	<= '0';
                    all_vount_rcvd_no_dwidth    	<= '0';

            	else
                    all_vount_rcvd_no_dwidth    	<= '0';


                end if;
            end if;
        end process NO_DWIDTH_VERT_COUNTER;



s2mm_chnl_ready			<= chnl_ready_no_dwidth;
s2mm_strm_not_finished		<= strm_not_finished_no_dwidth;	
s2mm_strm_all_lines_rcvd	<= strm_all_lines_rcvd_no_dwidth;

s2mm_all_vount_rcvd		<= all_vount_rcvd_no_dwidth;


  end generate GEN_NO_AXIS_S2MM_DWIDTH_CONV;





    ---------------------------------------------------------------------------
    -- S2MM Register Module
    ---------------------------------------------------------------------------
    S2MM_REGISTER_MODULE_I : entity  axi_vdma_v6_3_10.axi_vdma_reg_module
        generic map(
            C_TOTAL_NUM_REGISTER    => TOTAL_NUM_REGISTER                   ,
            C_INCLUDE_SG            => C_INCLUDE_SG                         ,
            C_CHANNEL_IS_MM2S       => CHANNEL_IS_S2MM                      ,
            C_ENABLE_FLUSH_ON_FSYNC => ENABLE_FLUSH_ON_S2MM_FSYNC                , -- 
            C_ENABLE_VIDPRMTR_READS => C_ENABLE_VIDPRMTR_READS              ,
            C_INTERNAL_GENLOCK_ENABLE   => INTERNAL_GENLOCK_ENABLE          ,
            C_DYNAMIC_RESOLUTION    => C_DYNAMIC_RESOLUTION                ,
            C_NUM_FSTORES           => C_NUM_FSTORES                        ,
            C_NUM_FSTORES_64        => C_NUM_FSTORES_64                   ,
            --C_ENABLE_DEBUG_INFO     => C_ENABLE_DEBUG_INFO             ,
            C_ENABLE_VERT_FLIP     => C_ENABLE_VERT_FLIP             ,
        C_ENABLE_DEBUG_ALL      => C_ENABLE_DEBUG_ALL             ,
            C_ENABLE_DEBUG_INFO_0   => C_ENABLE_DEBUG_INFO_0             ,
            C_ENABLE_DEBUG_INFO_1   => C_ENABLE_DEBUG_INFO_1             ,
            C_ENABLE_DEBUG_INFO_2   => C_ENABLE_DEBUG_INFO_2             ,
            C_ENABLE_DEBUG_INFO_3   => C_ENABLE_DEBUG_INFO_3             ,
            C_ENABLE_DEBUG_INFO_4   => C_ENABLE_DEBUG_INFO_4             ,
            C_ENABLE_DEBUG_INFO_5   => C_ENABLE_DEBUG_INFO_5             ,
            C_ENABLE_DEBUG_INFO_6   => C_ENABLE_DEBUG_INFO_6             ,
            C_ENABLE_DEBUG_INFO_7   => C_ENABLE_DEBUG_INFO_7             ,
            C_ENABLE_DEBUG_INFO_8   => C_ENABLE_DEBUG_INFO_8             ,
            C_ENABLE_DEBUG_INFO_9   => C_ENABLE_DEBUG_INFO_9             ,
            C_ENABLE_DEBUG_INFO_10  => C_ENABLE_DEBUG_INFO_10             ,
            C_ENABLE_DEBUG_INFO_11  => C_ENABLE_DEBUG_INFO_11             ,
            C_ENABLE_DEBUG_INFO_12  => C_ENABLE_DEBUG_INFO_12             ,
            C_ENABLE_DEBUG_INFO_13  => C_ENABLE_DEBUG_INFO_13             ,
            C_ENABLE_DEBUG_INFO_14  => C_ENABLE_DEBUG_INFO_14             ,
            C_ENABLE_DEBUG_INFO_15  => C_ENABLE_DEBUG_INFO_15             ,
            C_LINEBUFFER_THRESH     => C_S2MM_LINEBUFFER_THRESH_INT             ,
            C_GENLOCK_MODE          => C_S2MM_GENLOCK_MODE                  ,
            C_S_AXI_LITE_ADDR_WIDTH => C_S_AXI_LITE_ADDR_WIDTH              ,
            C_S_AXI_LITE_DATA_WIDTH => C_S_AXI_LITE_DATA_WIDTH              ,
            C_M_AXI_SG_ADDR_WIDTH   => C_M_AXI_SG_ADDR_WIDTH                ,
            C_M_AXI_ADDR_WIDTH      => C_M_AXI_SG_ADDR_WIDTH --C_M_AXI_S2MM_ADDR_WIDTH_NEW
        )
        port map(
            prmry_aclk                  => m_axi_s2mm_aclk                  ,
            prmry_resetn                => s2mm_prmry_resetn                ,

            -- Register to AXI Lite Interface
            axi2ip_wrce                 => s2mm_axi2ip_wrce                 ,
            axi2ip_wrdata               => s2mm_axi2ip_wrdata               ,
            axi2ip_rdaddr               => s2mm_axi2ip_rdaddr               ,
            --axi2ip_rden                 => s2mm_axi2ip_rden                 ,
            axi2ip_rden                 => '0'                 ,
            ip2axi_rddata               => s2mm_ip2axi_rddata               ,
            --ip2axi_rddata_valid         => s2mm_ip2axi_rddata_valid         ,
            ip2axi_rddata_valid         => open         ,
            ip2axi_frame_ptr_ref        => s2mm_ip2axi_frame_ptr_ref        ,
            ip2axi_frame_store          => s2mm_ip2axi_frame_store          ,
            ip2axi_introut              => s2mm_ip2axi_introut              ,

            -- Soft Reset
            soft_reset                  => s2mm_soft_reset                  ,
            soft_reset_clr              => s2mm_soft_reset_clr              ,

            -- DMA Control / Status Register Signals
            halted_clr                  => s2mm_halted_clr                  ,
            halted_set                  => s2mm_halted_set                  ,
            idle_set                    => s2mm_idle_set                    ,
            idle_clr                    => s2mm_idle_clr                    ,
            ioc_irq_set                 => s2mm_ioc_irq_set                 ,
            dly_irq_set                 => s2mm_dly_irq_set                 ,
            irqdelay_status             => s2mm_irqdelay_status             ,
            irqthresh_status            => s2mm_irqthresh_status            ,
            frame_sync                  => s2mm_frame_sync                  ,
            fsync_mask                  => s2mm_mask_fsync_out              ,
            new_curdesc_wren            => s2mm_new_curdesc_wren            ,
            new_curdesc                 => s2mm_new_curdesc                 ,
            update_frmstore             => s2mm_update_frmstore             ,
            new_frmstr                  => s2mm_frame_number                ,
            tstvect_fsync               => s2mm_tstvect_fsync               ,
            valid_frame_sync            => s2mm_valid_frame_sync            ,
            irqthresh_rstdsbl           => s2mm_irqthresh_rstdsbl           ,
            dlyirq_dsble                => s2mm_dlyirq_dsble                ,
            irqthresh_wren              => s2mm_irqthresh_wren              ,
            irqdelay_wren               => s2mm_irqdelay_wren               ,
            tailpntr_updated            => s2mm_tailpntr_updated            ,

            -- Error Detection Control
            stop                        => s2mm_stop                        ,
            dma_interr_set              => s2mm_dma_interr_set              ,
            dma_interr_set_minus_frame_errors              => s2mm_dma_interr_set_minus_frame_errors              ,
            dma_slverr_set              => s2mm_dma_slverr_set              ,
            dma_decerr_set              => s2mm_dma_decerr_set              ,
            ftch_slverr_set             => s2mm_ftch_slverr_set             ,
            ftch_decerr_set             => s2mm_ftch_decerr_set             ,

            fsize_mismatch_err          => s2mm_fsize_mismatch_err          ,   
            lsize_mismatch_err          => s2mm_lsize_mismatch_err          ,   
            lsize_more_mismatch_err          => s2mm_lsize_more_mismatch_err          ,   
            s2mm_fsize_more_or_sof_late => s2mm_fsize_more_or_sof_late          ,   

            -- VDMA Base Registers
    	reg_index                	=> s2mm_reg_index           ,
            dmacr                       => s2mm_dmacr                       ,
            dmasr                       => s2mm_dmasr                       ,
            curdesc                     => s2mm_curdesc                     ,
            taildesc                    => s2mm_taildesc                    ,
            num_frame_store             => s2mm_num_frame_store             ,
            linebuf_threshold           => s2mm_linebuf_threshold           ,

            -- Register Direct Support
            regdir_idle                 => s2mm_regdir_idle                 ,
            prmtr_updt_complete         => s2mm_prmtr_updt_complete         ,
            reg_module_vsize            => s2mm_reg_module_vsize            ,
            reg_module_hsize            => s2mm_reg_module_hsize            ,
            reg_module_stride           => s2mm_reg_module_stride           ,
            reg_module_frmdly           => s2mm_reg_module_frmdly           ,
            reg_module_strt_addr        => s2mm_reg_module_strt_addr        ,
            
            -- vertical_flip
            vflip                       => s2mm_vflip                       ,

            -- Fetch/Update error addresses
            frmstr_err_addr           => s2mm_frmstr_err_addr           ,
            ftch_err_addr             => s2mm_ftch_err_addr
        );

S2MMADDR32: if C_M_AXI_S2MM_ADDR_WIDTH_NEW = 32 generate
begin

    ---------------------------------------------------------------------------
    -- S2MM DMA Controller
    ---------------------------------------------------------------------------
    I_S2MM_DMA_MNGR : entity  axi_vdma_v6_3_10.axi_vdma_mngr
        generic map(
            C_PRMY_CMDFIFO_DEPTH        => DM_CMDSTS_FIFO_DEPTH             ,
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC            ,
            C_INCLUDE_SF                => DM_S2MM_INCLUDE_SF               ,
            C_USE_FSYNC                 => C_USE_S2MM_FSYNC_01                      ,   -- 
            C_ENABLE_FLUSH_ON_FSYNC     => ENABLE_FLUSH_ON_S2MM_FSYNC            ,   -- 
            C_NUM_FSTORES               => C_NUM_FSTORES                    ,
            C_GENLOCK_MODE              => C_S2MM_GENLOCK_MODE              ,
            C_GENLOCK_NUM_MASTERS       => C_S2MM_GENLOCK_NUM_MASTERS       ,
            C_DYNAMIC_RESOLUTION        => C_DYNAMIC_RESOLUTION                ,
            --C_GENLOCK_REPEAT_EN         => C_S2MM_GENLOCK_REPEAT_EN         ,   -- 
            --C_ENABLE_DEBUG_INFO         => C_ENABLE_DEBUG_INFO             ,
            C_ENABLE_VERT_FLIP     => C_ENABLE_VERT_FLIP             ,
        C_ENABLE_DEBUG_ALL      => C_ENABLE_DEBUG_ALL             ,
            C_ENABLE_DEBUG_INFO_0       => C_ENABLE_DEBUG_INFO_0             ,
            C_ENABLE_DEBUG_INFO_1       => C_ENABLE_DEBUG_INFO_1             ,
            C_ENABLE_DEBUG_INFO_2       => C_ENABLE_DEBUG_INFO_2             ,
            C_ENABLE_DEBUG_INFO_3       => C_ENABLE_DEBUG_INFO_3             ,
            C_ENABLE_DEBUG_INFO_4       => C_ENABLE_DEBUG_INFO_4             ,
            C_ENABLE_DEBUG_INFO_5       => C_ENABLE_DEBUG_INFO_5             ,
            C_ENABLE_DEBUG_INFO_6       => C_ENABLE_DEBUG_INFO_6             ,
            C_ENABLE_DEBUG_INFO_7       => C_ENABLE_DEBUG_INFO_7             ,
            C_ENABLE_DEBUG_INFO_8       => C_ENABLE_DEBUG_INFO_8             ,
            C_ENABLE_DEBUG_INFO_9       => C_ENABLE_DEBUG_INFO_9             ,
            C_ENABLE_DEBUG_INFO_10      => C_ENABLE_DEBUG_INFO_10             ,
            C_ENABLE_DEBUG_INFO_11      => C_ENABLE_DEBUG_INFO_11             ,
            C_ENABLE_DEBUG_INFO_12      => C_ENABLE_DEBUG_INFO_12             ,
            C_ENABLE_DEBUG_INFO_13      => C_ENABLE_DEBUG_INFO_13             ,
            C_ENABLE_DEBUG_INFO_14      => C_ENABLE_DEBUG_INFO_14             ,
            C_ENABLE_DEBUG_INFO_15      => C_ENABLE_DEBUG_INFO_15             ,
            C_INTERNAL_GENLOCK_ENABLE   => INTERNAL_GENLOCK_ENABLE          ,
            C_INCLUDE_SG                => C_INCLUDE_SG                     ,   -- 
            C_SELECT_XPM                => C_SELECT_XPM,
            C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH            ,
            C_M_AXIS_SG_TDATA_WIDTH     => M_AXIS_SG_TDATA_WIDTH            ,
            C_M_AXI_ADDR_WIDTH          => C_M_AXI_S2MM_ADDR_WIDTH_NEW          ,
            C_DM_STATUS_WIDTH           => S2MM_DM_STATUS_WIDTH             ,   -- 
            C_EXTEND_DM_COMMAND         => S2MM_DM_CMD_EXTENDED             ,
            C_S2MM_SOF_ENABLE           => S2MM_SOF_ENABLE,
            C_MM2S_SOF_ENABLE           => 0                   ,
            C_INCLUDE_MM2S              => 0                   ,
            C_INCLUDE_S2MM              => C_INCLUDE_S2MM                   ,
            C_FAMILY                    => C_ROOT_FAMILY
        )
        port map(
            -- Secondary Clock and Reset
            prmry_aclk                  => m_axi_s2mm_aclk                  ,
            prmry_resetn                => s2mm_prmry_resetn                ,
            soft_reset                  => s2mm_soft_reset                  ,

            scndry_aclk                 => s_axis_s2mm_aclk                 ,
            scndry_resetn               => s2mm_axis_resetn                 ,

            -- MM2S Control and Status
            run_stop                    => s2mm_dmacr(DMACR_RS_BIT)         ,
            dmacr_repeat_en             => s2mm_dmacr(DMACR_REPEAT_EN_BIT)     ,
            dmasr_halt                  => s2mm_dmasr(DMASR_HALTED_BIT)     ,
            sync_enable                 => s2mm_dmacr(DMACR_SYNCEN_BIT)     ,
            regdir_idle                 => s2mm_regdir_idle                 ,
            ftch_idle                   => s2mm_ftch_idle                   ,
            halt                        => s2mm_halt                        ,
            halt_cmplt                  => s2mm_halt_cmplt                  ,
            halted_clr                  => s2mm_halted_clr                  ,
            halted_set                  => s2mm_halted_set                  ,
            idle_set                    => s2mm_idle_set                    ,
            idle_clr                    => s2mm_idle_clr                    ,
            stop                        => s2mm_stop                        ,
            s2mm_fsize_more_or_sof_late => s2mm_fsize_more_or_sof_late          ,   
            s2mm_dmasr_lsize_less_err   => s2mm_dmasr(DMASR_LSIZEERR_BIT)     ,
            all_idle                    => s2mm_all_idle                    ,
            cmdsts_idle                 => s2mm_cmdsts_idle                 ,
            ftchcmdsts_idle             => s2mm_ftchcmdsts_idle             ,
            s2mm_fsync_out_m            => s2mm_fsync_out_m_i                  ,
            mm2s_fsync_out_m            => '0'                 ,   -- 
            frame_sync                  => s2mm_frame_sync                  ,
            update_frmstore             => s2mm_update_frmstore             ,   -- 
            frmstr_err_addr           => s2mm_frmstr_err_addr           ,   -- 
            frame_ptr_ref               => s2mm_ip2axi_frame_ptr_ref        ,
            frame_ptr_in                => s2mm_s_frame_ptr_in              ,
            frame_ptr_out               => s2mm_m_frame_ptr_out             ,
            internal_frame_ptr_in       => mm2s_to_s2mm_frame_ptr_in        ,
            valid_frame_sync            => s2mm_valid_frame_sync            ,
            valid_frame_sync_cmb        => s2mm_valid_frame_sync_cmb        ,
            valid_video_prmtrs          => s2mm_valid_video_prmtrs          ,
            parameter_update            => s2mm_parameter_update            ,
            circular_prk_mode           => s2mm_dmacr(DMACR_CRCLPRK_BIT)    ,
            mstr_pntr_ref               => s2mm_dmacr(DMACR_PNTR_NUM_MSB
                                               downto DMACR_PNTR_NUM_LSB)   ,
            genlock_select              => s2mm_dmacr(DMACR_GENLOCK_SEL_BIT),
            line_buffer_empty           => '1'                              ,   -- NOT Used by S2MM therefore tie off
            dwidth_fifo_pipe_empty           => '1'                              ,   -- NOT Used by S2MM therefore tie off
            crnt_vsize                  => s2mm_crnt_vsize                  ,   -- 
            num_frame_store             => s2mm_num_frame_store             ,
            all_lines_xfred             => s2mm_all_lines_xfred             ,   -- 
            all_lasts_rcvd              => all_lasts_rcvd             ,   
            mm2s_fsize_mismatch_err_m   => '0'                             ,   -- Not Needed for MM2S channel
            mm2s_fsize_mismatch_err_s   => '0'                             ,   -- Not Needed for MM2S channel
            s2mm_fsize_mismatch_err_s   => s2mm_fsize_mismatch_err_s                             ,   -- Not Needed for MM2S channel
drop_fsync_d_pulse_gen_fsize_less_err   => drop_fsync_d_pulse_gen_fsize_less_err                      ,
      	    s2mm_strm_all_lines_rcvd    => s2mm_strm_all_lines_rcvd	,	--      : out std_logic;
            s2mm_fsync_core             => s2mm_fsync_core                      ,
            fsize_mismatch_err_flag          => s2mm_fsize_mismatch_err_flag          ,   -- 
            fsize_mismatch_err          => s2mm_fsize_mismatch_err          ,   -- 
            lsize_mismatch_err          => s2mm_lsize_mismatch_err          ,   -- 
            lsize_more_mismatch_err     => s2mm_lsize_more_mismatch_err          ,   -- 
            capture_hsize_at_uf_err     => s2mm_capture_hsize_at_uf_err_sig          ,   

            -- Register Direct Support
            prmtr_updt_complete         => s2mm_prmtr_updt_complete         ,
            reg_module_vsize            => s2mm_reg_module_vsize            ,
            reg_module_hsize            => s2mm_reg_module_hsize            ,
            reg_module_stride           => s2mm_reg_module_stride           ,
            reg_module_frmdly           => s2mm_reg_module_frmdly           ,
            reg_module_strt_addr        => s2mm_reg_module_strt_addr        ,

            -- Test vector signals
            tstvect_err               => s2mm_tstvect_err               ,
            tstvect_fsync               => s2mm_tstvect_fsync               ,
            tstvect_frame               => s2mm_tstvect_frame               ,
            tstvect_frm_ptr_out         => s2mm_tstvect_frm_ptr_out         ,
            mstrfrm_tstsync_out         => s2mm_mstrfrm_tstsync             ,

            -- AXI Stream Timing
            packet_sof                  => s2mm_packet_sof                  ,


            -- Primary DMA Errors
            dma_interr_set              => s2mm_dma_interr_set              ,
            dma_interr_set_minus_frame_errors              => s2mm_dma_interr_set_minus_frame_errors              ,
            dma_slverr_set              => s2mm_dma_slverr_set              ,
            dma_decerr_set              => s2mm_dma_decerr_set              ,

            -- SG MM2S Descriptor Fetch AXI Stream In
            m_axis_ftch_tdata           => m_axis_s2mm_ftch_tdata           ,
            m_axis_ftch_tvalid          => m_axis_s2mm_ftch_tvalid          ,
            m_axis_ftch_tready          => m_axis_s2mm_ftch_tready          ,
            m_axis_ftch_tlast           => m_axis_s2mm_ftch_tlast           ,

            -- Currently Being Processed Descriptor/Frame
            frame_number                => s2mm_frame_number                ,
            chnl_current_frame          => s2mm_chnl_current_frame                ,
            genlock_pair_frame          => s2mm_genlock_pair_frame                ,
            new_curdesc                 => s2mm_new_curdesc                 ,
            new_curdesc_wren            => s2mm_new_curdesc_wren            ,
            tailpntr_updated            => s2mm_tailpntr_updated            ,

            -- User Command Interface Ports (AXI Stream)
            s_axis_cmd_tvalid           => s_axis_s2mm_cmd_tvalid           ,
            s_axis_cmd_tready           => s_axis_s2mm_cmd_tready           ,
            s_axis_cmd_tdata            => s_axis_s2mm_cmd_tdata            ,

            
            -- vertical_flip
            vflip_mngr                  => s2mm_vflip                       ,


            -- User Status Interface Ports (AXI Stream)
            m_axis_sts_tvalid           => m_axis_s2mm_sts_tvalid           ,
            m_axis_sts_tready           => m_axis_s2mm_sts_tready           ,
            m_axis_sts_tdata            => m_axis_s2mm_sts_tdata            ,
            m_axis_sts_tkeep            => m_axis_s2mm_sts_tkeep       ,
            err                         => s2mm_err                         ,
            ftch_err                  => s2mm_ftch_err
        );



end generate S2MMADDR32;


S2MMADDR64: if C_M_AXI_S2MM_ADDR_WIDTH_NEW > 32 generate
begin

    S2MM_FSTORES64 : for i in 0 to C_NUM_FSTORES_64-1 generate


         s2mm_reg_module_strt_addr_64 (i) <= s2mm_reg_module_strt_addr (i*2+1) & s2mm_reg_module_strt_addr (i*2);

  end generate S2MM_FSTORES64;

    ---------------------------------------------------------------------------
    -- S2MM DMA Controller
    ---------------------------------------------------------------------------
    I_S2MM_DMA_MNGR : entity  axi_vdma_v6_3_10.axi_vdma_mngr_64
        generic map(
            C_PRMY_CMDFIFO_DEPTH        => DM_CMDSTS_FIFO_DEPTH             ,
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC            ,
            C_INCLUDE_SF                => DM_S2MM_INCLUDE_SF               ,
            C_USE_FSYNC                 => C_USE_S2MM_FSYNC_01                      ,   -- 
            C_ENABLE_FLUSH_ON_FSYNC     => ENABLE_FLUSH_ON_S2MM_FSYNC            ,   -- 
            C_NUM_FSTORES               => C_NUM_FSTORES_64                    ,
            C_GENLOCK_MODE              => C_S2MM_GENLOCK_MODE              ,
            C_GENLOCK_NUM_MASTERS       => C_S2MM_GENLOCK_NUM_MASTERS       ,
            C_DYNAMIC_RESOLUTION        => C_DYNAMIC_RESOLUTION                ,
            --C_GENLOCK_REPEAT_EN         => C_S2MM_GENLOCK_REPEAT_EN         ,   -- 
            --C_ENABLE_DEBUG_INFO         => C_ENABLE_DEBUG_INFO             ,
            C_ENABLE_VERT_FLIP     => C_ENABLE_VERT_FLIP             ,
        C_ENABLE_DEBUG_ALL      => C_ENABLE_DEBUG_ALL             ,
            C_ENABLE_DEBUG_INFO_0       => C_ENABLE_DEBUG_INFO_0             ,
            C_ENABLE_DEBUG_INFO_1       => C_ENABLE_DEBUG_INFO_1             ,
            C_ENABLE_DEBUG_INFO_2       => C_ENABLE_DEBUG_INFO_2             ,
            C_ENABLE_DEBUG_INFO_3       => C_ENABLE_DEBUG_INFO_3             ,
            C_ENABLE_DEBUG_INFO_4       => C_ENABLE_DEBUG_INFO_4             ,
            C_ENABLE_DEBUG_INFO_5       => C_ENABLE_DEBUG_INFO_5             ,
            C_ENABLE_DEBUG_INFO_6       => C_ENABLE_DEBUG_INFO_6             ,
            C_ENABLE_DEBUG_INFO_7       => C_ENABLE_DEBUG_INFO_7             ,
            C_ENABLE_DEBUG_INFO_8       => C_ENABLE_DEBUG_INFO_8             ,
            C_ENABLE_DEBUG_INFO_9       => C_ENABLE_DEBUG_INFO_9             ,
            C_ENABLE_DEBUG_INFO_10      => C_ENABLE_DEBUG_INFO_10             ,
            C_ENABLE_DEBUG_INFO_11      => C_ENABLE_DEBUG_INFO_11             ,
            C_ENABLE_DEBUG_INFO_12      => C_ENABLE_DEBUG_INFO_12             ,
            C_ENABLE_DEBUG_INFO_13      => C_ENABLE_DEBUG_INFO_13             ,
            C_ENABLE_DEBUG_INFO_14      => C_ENABLE_DEBUG_INFO_14             ,
            C_ENABLE_DEBUG_INFO_15      => C_ENABLE_DEBUG_INFO_15             ,
            C_INTERNAL_GENLOCK_ENABLE   => INTERNAL_GENLOCK_ENABLE          ,
            C_INCLUDE_SG                => C_INCLUDE_SG                     ,   -- 
            C_SELECT_XPM                => C_SELECT_XPM,
            C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH            ,
            C_M_AXIS_SG_TDATA_WIDTH     => M_AXIS_SG_TDATA_WIDTH            ,
            C_M_AXI_ADDR_WIDTH          => C_M_AXI_S2MM_ADDR_WIDTH_NEW          ,
            C_DM_STATUS_WIDTH           => S2MM_DM_STATUS_WIDTH             ,   -- 
            C_EXTEND_DM_COMMAND         => S2MM_DM_CMD_EXTENDED             ,
            C_S2MM_SOF_ENABLE           => S2MM_SOF_ENABLE,
            C_MM2S_SOF_ENABLE           => 0                   ,
            C_INCLUDE_MM2S              => 0                   ,
            C_INCLUDE_S2MM              => C_INCLUDE_S2MM                   ,
            C_FAMILY                    => C_ROOT_FAMILY
        )
        port map(
            -- Secondary Clock and Reset
            prmry_aclk                  => m_axi_s2mm_aclk                  ,
            prmry_resetn                => s2mm_prmry_resetn                ,
            soft_reset                  => s2mm_soft_reset                  ,

            scndry_aclk                 => s_axis_s2mm_aclk                 ,
            scndry_resetn               => s2mm_axis_resetn                 ,

            -- MM2S Control and Status
            run_stop                    => s2mm_dmacr(DMACR_RS_BIT)         ,
            dmacr_repeat_en             => s2mm_dmacr(DMACR_REPEAT_EN_BIT)     ,
            dmasr_halt                  => s2mm_dmasr(DMASR_HALTED_BIT)     ,
            sync_enable                 => s2mm_dmacr(DMACR_SYNCEN_BIT)     ,
            regdir_idle                 => s2mm_regdir_idle                 ,
            ftch_idle                   => s2mm_ftch_idle                   ,
            halt                        => s2mm_halt                        ,
            halt_cmplt                  => s2mm_halt_cmplt                  ,
            halted_clr                  => s2mm_halted_clr                  ,
            halted_set                  => s2mm_halted_set                  ,
            idle_set                    => s2mm_idle_set                    ,
            idle_clr                    => s2mm_idle_clr                    ,
            stop                        => s2mm_stop                        ,
            s2mm_fsize_more_or_sof_late => s2mm_fsize_more_or_sof_late          ,   
            s2mm_dmasr_lsize_less_err   => s2mm_dmasr(DMASR_LSIZEERR_BIT)     ,
            all_idle                    => s2mm_all_idle                    ,
            cmdsts_idle                 => s2mm_cmdsts_idle                 ,
            ftchcmdsts_idle             => s2mm_ftchcmdsts_idle             ,
            s2mm_fsync_out_m            => s2mm_fsync_out_m_i                  ,
            mm2s_fsync_out_m            => '0'                 ,   -- 
            frame_sync                  => s2mm_frame_sync                  ,
            update_frmstore             => s2mm_update_frmstore             ,   -- 
            frmstr_err_addr           => s2mm_frmstr_err_addr           ,   -- 
            frame_ptr_ref               => s2mm_ip2axi_frame_ptr_ref        ,
            frame_ptr_in                => s2mm_s_frame_ptr_in              ,
            frame_ptr_out               => s2mm_m_frame_ptr_out             ,
            internal_frame_ptr_in       => mm2s_to_s2mm_frame_ptr_in        ,
            valid_frame_sync            => s2mm_valid_frame_sync            ,
            valid_frame_sync_cmb        => s2mm_valid_frame_sync_cmb        ,
            valid_video_prmtrs          => s2mm_valid_video_prmtrs          ,
            parameter_update            => s2mm_parameter_update            ,
            circular_prk_mode           => s2mm_dmacr(DMACR_CRCLPRK_BIT)    ,
            mstr_pntr_ref               => s2mm_dmacr(DMACR_PNTR_NUM_MSB
                                               downto DMACR_PNTR_NUM_LSB)   ,
            genlock_select              => s2mm_dmacr(DMACR_GENLOCK_SEL_BIT),
            line_buffer_empty           => '1'                              ,   -- NOT Used by S2MM therefore tie off
            dwidth_fifo_pipe_empty           => '1'                              ,   -- NOT Used by S2MM therefore tie off
            crnt_vsize                  => s2mm_crnt_vsize                  ,   -- 
            num_frame_store             => s2mm_num_frame_store             ,
            all_lines_xfred             => s2mm_all_lines_xfred             ,   -- 
            all_lasts_rcvd              => all_lasts_rcvd             ,   
            mm2s_fsize_mismatch_err_m   => '0'                             ,   -- Not Needed for MM2S channel
            mm2s_fsize_mismatch_err_s   => '0'                             ,   -- Not Needed for MM2S channel
            s2mm_fsize_mismatch_err_s   => s2mm_fsize_mismatch_err_s                             ,   -- Not Needed for MM2S channel
drop_fsync_d_pulse_gen_fsize_less_err   => drop_fsync_d_pulse_gen_fsize_less_err                      ,
      	    s2mm_strm_all_lines_rcvd    => s2mm_strm_all_lines_rcvd	,	--      : out std_logic;
            s2mm_fsync_core             => s2mm_fsync_core                      ,
            fsize_mismatch_err_flag          => s2mm_fsize_mismatch_err_flag          ,   -- 
            fsize_mismatch_err          => s2mm_fsize_mismatch_err          ,   -- 
            lsize_mismatch_err          => s2mm_lsize_mismatch_err          ,   -- 
            lsize_more_mismatch_err     => s2mm_lsize_more_mismatch_err          ,   -- 
            capture_hsize_at_uf_err     => s2mm_capture_hsize_at_uf_err_sig          ,   

            -- Register Direct Support
            prmtr_updt_complete         => s2mm_prmtr_updt_complete         ,
            reg_module_vsize            => s2mm_reg_module_vsize            ,
            reg_module_hsize            => s2mm_reg_module_hsize            ,
            reg_module_stride           => s2mm_reg_module_stride           ,
            reg_module_frmdly           => s2mm_reg_module_frmdly           ,
            reg_module_strt_addr        => s2mm_reg_module_strt_addr_64        ,

            -- Test vector signals
            tstvect_err               => s2mm_tstvect_err               ,
            tstvect_fsync               => s2mm_tstvect_fsync               ,
            tstvect_frame               => s2mm_tstvect_frame               ,
            tstvect_frm_ptr_out         => s2mm_tstvect_frm_ptr_out         ,
            mstrfrm_tstsync_out         => s2mm_mstrfrm_tstsync             ,

            -- AXI Stream Timing
            packet_sof                  => s2mm_packet_sof                  ,


            -- Primary DMA Errors
            dma_interr_set              => s2mm_dma_interr_set              ,
            dma_interr_set_minus_frame_errors              => s2mm_dma_interr_set_minus_frame_errors              ,
            dma_slverr_set              => s2mm_dma_slverr_set              ,
            dma_decerr_set              => s2mm_dma_decerr_set              ,

            -- SG MM2S Descriptor Fetch AXI Stream In
            m_axis_ftch_tdata           => m_axis_s2mm_ftch_tdata           ,
            m_axis_ftch_tvalid          => m_axis_s2mm_ftch_tvalid          ,
            m_axis_ftch_tready          => m_axis_s2mm_ftch_tready          ,
            m_axis_ftch_tlast           => m_axis_s2mm_ftch_tlast           ,

            -- Currently Being Processed Descriptor/Frame
            frame_number                => s2mm_frame_number                ,
            chnl_current_frame          => s2mm_chnl_current_frame                ,
            genlock_pair_frame          => s2mm_genlock_pair_frame                ,
            new_curdesc                 => s2mm_new_curdesc                 ,
            new_curdesc_wren            => s2mm_new_curdesc_wren            ,
            tailpntr_updated            => s2mm_tailpntr_updated            ,

            -- User Command Interface Ports (AXI Stream)
            s_axis_cmd_tvalid           => s_axis_s2mm_cmd_tvalid           ,
            s_axis_cmd_tready           => s_axis_s2mm_cmd_tready           ,
            s_axis_cmd_tdata            => s_axis_s2mm_cmd_tdata            ,

          -- vertical_flip
            vflip_mngr                  => s2mm_vflip                       ,

            -- User Status Interface Ports (AXI Stream)
            m_axis_sts_tvalid           => m_axis_s2mm_sts_tvalid           ,
            m_axis_sts_tready           => m_axis_s2mm_sts_tready           ,
            m_axis_sts_tdata            => m_axis_s2mm_sts_tdata            ,
            m_axis_sts_tkeep            => m_axis_s2mm_sts_tkeep       ,
            err                         => s2mm_err                         ,
            ftch_err                  => s2mm_ftch_err
        );


end generate S2MMADDR64;



    ---------------------------------------------------------------------------
    -- MM2S Frame sync generator
    ---------------------------------------------------------------------------
    S2MM_FSYNC_I : entity  axi_vdma_v6_3_10.axi_vdma_fsync_gen
        generic map(
            C_USE_FSYNC                 => C_USE_S2MM_FSYNC_01                      ,
            ENABLE_FLUSH_ON_S2MM_FSYNC  => ENABLE_FLUSH_ON_S2MM_FSYNC                      ,
            ENABLE_FLUSH_ON_MM2S_FSYNC  => 0                      ,
            C_INCLUDE_S2MM              => 1                   ,
            C_INCLUDE_MM2S              => 0                       ,
            C_SOF_ENABLE                => S2MM_SOF_ENABLE
        )
        port map(
            prmry_aclk                  => m_axi_s2mm_aclk                  ,
            prmry_resetn                => s2mm_prmry_resetn                ,

            -- Frame Count Enable Support
            valid_frame_sync_cmb        => s2mm_valid_frame_sync_cmb        ,
            valid_video_prmtrs          => s2mm_valid_video_prmtrs          ,
            frmcnt_ioc                  => s2mm_ioc_irq_set                 ,
            dmacr_frmcnt_enbl           => s2mm_dmacr(DMACR_FRMCNTEN_BIT)   ,
            dmasr_frmcnt_status         => s2mm_irqthresh_status            ,
            mask_fsync_out              => s2mm_mask_fsync_out              ,

            -- VDMA process status
            run_stop                    => s2mm_dmacr(DMACR_RS_BIT)         ,
            all_idle                    => s2mm_all_idle                    ,
            parameter_update            => s2mm_parameter_update            ,

            -- VDMA Frame Sync sources
            fsync                       => s2mm_cdc2dmac_fsync              ,
            tuser_fsync                 => s2mm_tuser_fsync                 ,
            othrchnl_fsync              => mm2s_to_s2mm_fsync               ,

            fsync_src_select            => s2mm_dmacr(DMACR_FSYNCSEL_MSB
                                            downto DMACR_FSYNCSEL_LSB)      ,

            -- VDMA frame sync output to core
            frame_sync                  => s2mm_frame_sync                  ,

            -- VDMA Frame Sync Output to ports
            frame_sync_out              => s2mm_dmac2cdc_fsync_out          ,
            prmtr_update                => s2mm_dmac2cdc_prmtr_update
        );

    -- Clock Domain Crossing between m_axi_s2mm_aclk and s_axis_s2mm_aclk
    S2MM_VID_CDC_I : entity axi_vdma_v6_3_10.axi_vdma_vid_cdc
        generic map(
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC            ,
            C_GENLOCK_MSTR_PTR_DWIDTH   => NUM_FRM_STORE_WIDTH          ,
            C_GENLOCK_SLVE_PTR_DWIDTH   => S2MM_GENLOCK_SLVE_PTR_DWIDTH     ,
            C_INTERNAL_GENLOCK_ENABLE   => INTERNAL_GENLOCK_ENABLE
        )
        port map(
            prmry_aclk                  => m_axi_s2mm_aclk                  ,
            prmry_resetn                => s2mm_prmry_resetn                ,

            scndry_aclk                 => s_axis_s2mm_aclk                 ,
            scndry_resetn               => s2mm_axis_resetn                 ,

            -- Genlock internal bus cdc
            othrchnl_aclk               => m_axi_mm2s_aclk                  ,
            othrchnl_resetn             => mm2s_prmry_resetn                ,
            othrchnl2cdc_frame_ptr_out  => mm2s_frame_ptr_out_i             ,
            cdc2othrchnl_frame_ptr_in   => mm2s_to_s2mm_frame_ptr_in        ,
            cdc2othrchnl_fsync          => s2mm_to_mm2s_fsync               ,

            -- GenLock Clock Domain Crossing
            dmac2cdc_frame_ptr_out      => s2mm_m_frame_ptr_out             ,
            cdc2top_frame_ptr_out       => s2mm_frame_ptr_out_i             ,
            top2cdc_frame_ptr_in        => s2mm_frame_ptr_in                ,
            cdc2dmac_frame_ptr_in       => s2mm_s_frame_ptr_in              ,
            dmac2cdc_mstrfrm_tstsync    => s2mm_mstrfrm_tstsync             ,
            cdc2dmac_mstrfrm_tstsync    => s2mm_mstrfrm_tstsync_out         ,

            -- SOF Detection Domain Crossing
            vid2cdc_packet_sof          => s2mm_vid2cdc_packet_sof          ,
            cdc2dmac_packet_sof         => s2mm_packet_sof                  ,

            -- Frame Sync Generation Domain Crossing
            vid2cdc_fsync               => s2mm_fsync_core                       ,
            cdc2dmac_fsync              => s2mm_cdc2dmac_fsync              ,

            dmac2cdc_fsync_out          => s2mm_dmac2cdc_fsync_out          ,
            dmac2cdc_prmtr_update       => s2mm_dmac2cdc_prmtr_update       ,

            cdc2vid_fsync_out           => s2mm_fsync_out_i                 ,
            cdc2vid_prmtr_update        => s2mm_prmtr_update_i
        );

    s2mm_fsync_out_sig  <= s2mm_fsync_out_i;

    -- Start of Frame Detection - used for interrupt coalescing
    S2MM_SOF_I : entity  axi_vdma_v6_3_10.axi_vdma_sof_gen
        port map(
            scndry_aclk                 => s_axis_s2mm_aclk                 ,
            scndry_resetn               => s2mm_axis_resetn                 ,

            axis_tready                 => s_axis_s2mm_tready_i             ,
            axis_tvalid                 => s_axis_s2mm_tvalid_i               ,

            fsync                       => s2mm_fsync_out_i                 , -- 

            packet_sof                  => s2mm_vid2cdc_packet_sof
        );

    -------------------------------------------------------------------------------
    -- Primary S2MM Line Buffer
    -------------------------------------------------------------------------------
    S2MM_LINEBUFFER_I : entity  axi_vdma_v6_3_10.axi_vdma_s2mm_linebuf
        generic map(
            C_DATA_WIDTH                => C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED            ,
            C_S2MM_SOF_ENABLE           => S2MM_SOF_ENABLE                      ,
            C_USE_FSYNC                 => C_USE_S2MM_FSYNC_01                      ,   
            C_USE_S2MM_FSYNC            => C_USE_S2MM_FSYNC                      ,   
            C_S_AXIS_S2MM_TUSER_BITS    => C_S_AXIS_S2MM_TUSER_BITS             ,
            C_INCLUDE_S2MM_DRE          => C_S2MM_ENABLE_TKEEP                   ,
            C_TOPLVL_LINEBUFFER_DEPTH   => C_S2MM_LINEBUFFER_DEPTH              , -- 
            --C_ENABLE_DEBUG_INFO         => C_ENABLE_DEBUG_INFO             ,
        C_ENABLE_DEBUG_ALL      => C_ENABLE_DEBUG_ALL             ,
            C_ENABLE_DEBUG_INFO_0       => C_ENABLE_DEBUG_INFO_0             ,
            C_ENABLE_DEBUG_INFO_1       => C_ENABLE_DEBUG_INFO_1             ,
            C_ENABLE_DEBUG_INFO_2       => C_ENABLE_DEBUG_INFO_2             ,
            C_ENABLE_DEBUG_INFO_3       => C_ENABLE_DEBUG_INFO_3             ,
            C_ENABLE_DEBUG_INFO_4       => C_ENABLE_DEBUG_INFO_4             ,
            C_ENABLE_DEBUG_INFO_5       => C_ENABLE_DEBUG_INFO_5             ,
            C_ENABLE_DEBUG_INFO_6       => C_ENABLE_DEBUG_INFO_6             ,
            C_ENABLE_DEBUG_INFO_7       => C_ENABLE_DEBUG_INFO_7             ,
            C_ENABLE_DEBUG_INFO_8       => C_ENABLE_DEBUG_INFO_8             ,
            C_ENABLE_DEBUG_INFO_9       => C_ENABLE_DEBUG_INFO_9             ,
            C_ENABLE_DEBUG_INFO_10      => C_ENABLE_DEBUG_INFO_10             ,
            C_ENABLE_DEBUG_INFO_11      => C_ENABLE_DEBUG_INFO_11             ,
            C_ENABLE_DEBUG_INFO_12      => C_ENABLE_DEBUG_INFO_12             ,
            C_ENABLE_DEBUG_INFO_13      => C_ENABLE_DEBUG_INFO_13             ,
            C_ENABLE_DEBUG_INFO_14      => C_ENABLE_DEBUG_INFO_14             ,
            C_ENABLE_DEBUG_INFO_15      => C_ENABLE_DEBUG_INFO_15             ,
            C_LINEBUFFER_DEPTH          => S2MM_LINEBUFFER_DEPTH                ,
            C_LINEBUFFER_AF_THRESH      => C_S2MM_LINEBUFFER_THRESH_INT             ,
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC                ,
            ENABLE_FLUSH_ON_FSYNC       => ENABLE_FLUSH_ON_S2MM_FSYNC,
            C_INCLUDE_MM2S              => C_INCLUDE_MM2S                       ,
            C_FAMILY                    => C_ROOT_FAMILY
        )
        port map(
            -----------------------------------------------------------------------
            -- AXI Scatter Gather Interface
            -----------------------------------------------------------------------
            s_axis_aclk                 => s_axis_s2mm_aclk                     ,
            s_axis_resetn               => s2mm_axis_resetn                     ,
            m_axis_aclk                 => m_axi_s2mm_aclk                      ,
            m_axis_resetn               => s2mm_prmry_resetn                    ,
            s2mm_axis_linebuf_reset_out               => s2mm_axis_linebuf_reset_out                    ,

            -- Graceful shut down control
            run_stop                    => s2mm_dmacr(DMACR_RS_BIT)             ,
            dm_halt                     => s2mm_halt                            , -- 
            dm_halt_cmplt               => s2mm_halt_cmplt                            , -- 

            capture_dm_done_vsize_counter => s2mm_capture_dm_done_vsize_counter_sig                            , 
            s2mm_fsize_mismatch_err_flag => s2mm_fsize_mismatch_err_flag                            , 
            s2mm_fsize_mismatch_err_s   => s2mm_fsize_mismatch_err_s                            , 
            s2mm_fsize_mismatch_err   => s2mm_fsize_mismatch_err                            , 

drop_fsync_d_pulse_gen_fsize_less_err   => drop_fsync_d_pulse_gen_fsize_less_err                      ,
no_fsync_before_vsize_sel_00_01         => no_fsync_before_vsize_sel_00_01                      ,

            hold_dummy_tready_low       => hold_dummy_tready_low                      ,
            hold_dummy_tready_low2      => hold_dummy_tready_low2                      ,
            mm2s_fsync                  => mm2s_fsync_fe                      ,
            m_axis_mm2s_aclk            => m_axis_mm2s_aclk                      ,
            mm2s_axis_resetn            => mm2s_axis_resetn                      ,

            s2mm_fsync_core             => s2mm_fsync_core                      ,
            s2mm_fsync                  => s2mm_fsync_fe                      ,
            s2mm_tuser_fsync_top        => s2mm_tuser_fsync_top                      ,
            s2mm_dmasr_fsize_less_err   => s2mm_dmasr(DMASR_FSIZEERR_BIT)     ,

            fsync_src_select            => s2mm_dmacr(DMACR_FSYNCSEL_MSB
                                            downto DMACR_FSYNCSEL_LSB)      ,
            fsync_src_select_s          => s2mm_fsync_src_select_s                      ,

            chnl_ready_external         => s2mm_chnl_ready                      ,
            strm_not_finished           => s2mm_strm_not_finished                      ,
            crnt_vsize_d2_s               => s2mm_crnt_vsize_d2                      ,

            -- Line Tracking Control
            crnt_vsize                  => s2mm_crnt_vsize                      ,
            fsync_out_m                   => s2mm_fsync_out_m_i                     ,
            fsync_out                   => s2mm_fsync_out_i                     ,
            frame_sync                  => s2mm_frame_sync                      ,

            -- Threshold
            linebuf_threshold           => s2mm_linebuf_threshold               ,

            -- Stream In
            s_axis_tdata                => s_axis_s2mm_tdata_i                    ,
            s_axis_tkeep                => s_axis_s2mm_tkeep_i                    ,
            s_axis_tlast                => s_axis_s2mm_tlast_i                    ,
            s_axis_tvalid               => s_axis_s2mm_tvalid_i                   ,
            s_axis_tready               => s_axis_s2mm_tready_i                 ,
            s_axis_tuser                => s_axis_s2mm_tuser_i                    ,

            -- Stream Out
            m_axis_tdata                => linebuf2dm_s2mm_tdata                ,
            m_axis_tkeep                => linebuf2dm_s2mm_tkeep                ,
            m_axis_tlast                => linebuf2dm_s2mm_tlast                ,
            m_axis_tvalid               => linebuf2dm_s2mm_tvalid               ,
            m_axis_tready               => dm2linebuf_s2mm_tready               ,

            -- Fifo Status Flags
            s2mm_fifo_full              => s2mm_buffer_full_i                     ,
            s2mm_fifo_almost_full       => s2mm_buffer_almost_full_i              ,
            s2mm_all_lines_xfred        => s2mm_all_lines_xfred                 ,   -- 
            all_lasts_rcvd              => all_lasts_rcvd                       ,
            s2mm_tuser_fsync            => s2mm_tuser_fsync
        );

end generate GEN_SPRT_FOR_S2MM;

-- Do not generate support logic for S2MM
GEN_NO_SPRT_FOR_S2MM : if C_INCLUDE_S2MM = 0 generate
begin

    -- Register Module Tie-Offs
    s2mm_ip2axi_rddata               <= (others => '0');
    --s2mm_ip2axi_rddata_valid         <= '0';
    s2mm_ip2axi_frame_ptr_ref        <= (others => '0');
    s2mm_ip2axi_frame_store          <= (others => '0');
    s2mm_ip2axi_introut              <= '0';
    s2mm_soft_reset                  <= '0';
    s2mm_irqthresh_rstdsbl           <= '0';
    s2mm_dlyirq_dsble                <= '0';
    s2mm_irqthresh_wren              <= '0';
    s2mm_irqdelay_wren               <= '0';
    s2mm_tailpntr_updated            <= '0';
    s2mm_dmacr                       <= (others => '0');
    s2mm_dmasr                       <= (others => '0');
    s2mm_curdesc                     <= (others => '0');
    s2mm_taildesc                    <= (others => '0');
    s2mm_num_frame_store             <= (others => '0');
    s2mm_linebuf_threshold           <= (others => '0');
    s2mm_regdir_idle                 <= '0';
    s2mm_prmtr_updt_complete         <= '0';
    s2mm_reg_module_vsize            <= (others => '0');
    s2mm_reg_module_hsize            <= (others => '0');
    s2mm_reg_module_stride           <= (others => '0');
    s2mm_reg_module_frmdly           <= (others => '0');

    s2mm_dummy_tready		     <=	'0';
      s2mm_fsize_less_err_internal_tvalid_gating <= '0';

    -- Must zero each element of an array of vectors to zero
    -- all vectors.
    GEN_S2MM_ZERO_STRT : for i in 0 to C_NUM_FSTORES-1 generate
        begin
            s2mm_reg_module_strt_addr(i)   <= (others => '0');
    end generate GEN_S2MM_ZERO_STRT;

    -- Line buffer Tie-Offs
    s_axis_s2mm_tready_i_axis_dw_conv            <= '0';
    s_axis_s2mm_tready_i            <= '0';
    s_axis_s2mm_tready            <= '0';
    s2mm_capture_dm_done_vsize_counter_sig           <= (others => '0');
    s2mm_capture_hsize_at_uf_err_sig           <= (others => '0');
    linebuf2dm_s2mm_tdata           <= (others => '0');
    linebuf2dm_s2mm_tkeep           <= (others => '0');
    linebuf2dm_s2mm_tlast           <= '0';
    linebuf2dm_s2mm_tvalid          <= '0';
    s2mm_buffer_full_i              <= '0';
    s2mm_buffer_almost_full_i       <= '0';
    s2mm_all_lines_xfred            <= '0'; -- 
    s2mm_tuser_fsync                <= '0';

    -- Frame sync generator
    s2mm_frame_sync                 <= '0';
    -- SOF/EOF generator
    s2mm_packet_sof                 <= '0';
    -- DMA Controller
    s2mm_halted_clr                 <= '0';
    s2mm_halted_set                 <= '1';
    s2mm_idle_set                   <= '0';
    s2mm_idle_clr                   <= '0';
    s2mm_frame_number               <= (others => '0');
    s2mm_chnl_current_frame         <= (others => '0');
    s2mm_genlock_pair_frame         <= (others => '0');
    s2mm_new_curdesc_wren           <= '0';
    s2mm_new_curdesc                <= (others => '0');
    s2mm_stop                       <= '0';
    s2mm_all_idle                   <= '1';
    s2mm_cmdsts_idle                <= '1';
    s2mm_ftchcmdsts_idle            <= '1';
    m_axis_s2mm_ftch_tready         <= '0';
    s_axis_s2mm_cmd_tvalid          <= '0';
    s_axis_s2mm_cmd_tdata           <= (others => '0');
    m_axis_s2mm_sts_tready          <= '0';
    s2mm_frame_ptr_out_i            <= (others => '0');
    s2mm_m_frame_ptr_out            <= (others => '0');
    mm2s_to_s2mm_frame_ptr_in       <= (others => '0');
    s2mm_valid_frame_sync           <= '0';
    s2mm_valid_frame_sync_cmb       <= '0';
    s2mm_valid_video_prmtrs         <= '0';
    s2mm_parameter_update           <= '0';
    s2mm_tstvect_err              <= '0';
    s2mm_tstvect_fsync              <= '0';
    s2mm_tstvect_frame              <= (others => '0');
    s2mm_dma_interr_set             <= '0';
    s2mm_dma_interr_set_minus_frame_errors             <= '0';
    s2mm_dma_slverr_set             <= '0';
    s2mm_dma_decerr_set             <= '0';
    s2mm_fsize_mismatch_err         <= '0';
    s2mm_lsize_mismatch_err         <= '0';
    s2mm_lsize_more_mismatch_err         <= '0';

    -- Frame Sync generator
    s2mm_fsync_out_sig                  <= '0';
    s2mm_prmtr_update_i               <= '0';
    s2mm_crnt_vsize                 <= (others => '0'); -- 
    s2mm_mask_fsync_out             <= '0';
    s2mm_mstrfrm_tstsync            <= '0';
    s2mm_mstrfrm_tstsync_out        <= '0';
    s2mm_tstvect_frm_ptr_out        <= (others => '0');
    s2mm_frmstr_err_addr          <= (others => '0');
    s2mm_to_mm2s_fsync              <= '0';

end generate GEN_NO_SPRT_FOR_S2MM;


-------------------------------------------------------------------------------
-- Primary MM2S and S2MM DataMover
-------------------------------------------------------------------------------
I_PRMRY_DATAMOVER : entity axi_datamover_v5_1_24.axi_datamover
    generic map(
        C_INCLUDE_MM2S              => MM2S_AXI_FULL_MODE                   ,
        C_M_AXI_MM2S_ADDR_WIDTH     => C_M_AXI_MM2S_ADDR_WIDTH_NEW              ,
        C_M_AXI_MM2S_DATA_WIDTH     => C_M_AXI_MM2S_DATA_WIDTH              ,
        C_M_AXIS_MM2S_TDATA_WIDTH   => C_M_AXIS_MM2S_TDATA_WIDTH_CALCULATED            ,
        C_INCLUDE_MM2S_STSFIFO      => DM_INCLUDE_STS_FIFO                  ,
        C_MM2S_STSCMD_FIFO_DEPTH    => DM_CMDSTS_FIFO_DEPTH                 ,
        C_MM2S_STSCMD_IS_ASYNC      => DM_CLOCK_SYNC                        ,
        C_INCLUDE_MM2S_DRE          => C_INCLUDE_MM2S_DRE                   ,
        C_ENABLE_MM2S_TKEEP         => C_MM2S_ENABLE_TKEEP                   ,
        C_MM2S_BURST_SIZE           => C_MM2S_MAX_BURST_LENGTH              ,
        C_MM2S_BTT_USED             => MM2S_DM_BTT_LENGTH_WIDTH             ,
        C_MM2S_ADDR_PIPE_DEPTH      => DM_ADDR_PIPE_DEPTH                   ,
        C_MM2S_INCLUDE_SF           => DM_MM2S_INCLUDE_SF                   ,

	C_ENABLE_SKID_BUF	    => "11100"				    ,		

        C_INCLUDE_S2MM              => S2MM_AXI_FULL_MODE                   ,
        C_M_AXI_S2MM_ADDR_WIDTH     => C_M_AXI_S2MM_ADDR_WIDTH_NEW              ,
        C_M_AXI_S2MM_DATA_WIDTH     => C_M_AXI_S2MM_DATA_WIDTH              ,
        C_S_AXIS_S2MM_TDATA_WIDTH   => C_S_AXIS_S2MM_TDATA_WIDTH_CALCULATED            ,
        C_INCLUDE_S2MM_STSFIFO      => DM_INCLUDE_STS_FIFO                  ,
        C_S2MM_STSCMD_FIFO_DEPTH    => DM_CMDSTS_FIFO_DEPTH                 ,
        C_S2MM_STSCMD_IS_ASYNC      => DM_CLOCK_SYNC                        ,
        C_INCLUDE_S2MM_DRE          => C_INCLUDE_S2MM_DRE                   ,
        C_ENABLE_S2MM_TKEEP         => C_S2MM_ENABLE_TKEEP                   ,
        C_S2MM_BURST_SIZE           => C_S2MM_MAX_BURST_LENGTH              ,
        C_S2MM_BTT_USED             => S2MM_DM_BTT_LENGTH_WIDTH             ,
        C_S2MM_SUPPORT_INDET_BTT    => DM_SUPPORT_INDET_BTT                 ,
        C_S2MM_ADDR_PIPE_DEPTH      => DM_ADDR_PIPE_DEPTH                   ,
        C_S2MM_INCLUDE_SF           => DM_S2MM_INCLUDE_SF                   ,
        C_CMD_WIDTH                 => CMD_WIDTH                            ,
        C_FAMILY                    => C_ROOT_FAMILY
    )
    port map(
        -- MM2S Primary Clock / Reset input
        m_axi_mm2s_aclk             => m_axi_mm2s_aclk                      ,
        m_axi_mm2s_aresetn          => mm2s_dm_prmry_resetn                 ,
        mm2s_halt                   => mm2s_halt                            ,
        mm2s_halt_cmplt             => mm2s_halt_cmplt                      ,
        mm2s_err                    => mm2s_err                             ,
        mm2s_allow_addr_req         => ALWAYS_ALLOW                         ,
        mm2s_addr_req_posted        => open                                 ,
        mm2s_rd_xfer_cmplt          => open                                 ,

        -- Memory Map to Stream Command FIFO and Status FIFO I/O --------------
        m_axis_mm2s_cmdsts_aclk     => m_axi_mm2s_aclk                      ,
        m_axis_mm2s_cmdsts_aresetn  => mm2s_dm_prmry_resetn                 ,

        -- User Command Interface Ports (AXI Stream)
        s_axis_mm2s_cmd_tvalid      => s_axis_mm2s_cmd_tvalid               ,
        s_axis_mm2s_cmd_tready      => s_axis_mm2s_cmd_tready               ,
        s_axis_mm2s_cmd_tdata       => s_axis_mm2s_cmd_tdata                ,

        -- User Status Interface Ports (AXI Stream)
        m_axis_mm2s_sts_tvalid      => m_axis_mm2s_sts_tvalid               ,
        m_axis_mm2s_sts_tready      => m_axis_mm2s_sts_tready               ,
        m_axis_mm2s_sts_tdata       => m_axis_mm2s_sts_tdata                ,
        m_axis_mm2s_sts_tkeep       => m_axis_mm2s_sts_tkeep                ,
        m_axis_mm2s_sts_tlast       => open                                 ,

        -- MM2S AXI Address Channel I/O  --------------------------------------
        m_axi_mm2s_arid             => open                                 ,
        m_axi_mm2s_araddr           => m_axi_mm2s_araddr_int                    ,
        m_axi_mm2s_arlen            => m_axi_mm2s_arlen                     ,
        m_axi_mm2s_arsize           => m_axi_mm2s_arsize                    ,
        m_axi_mm2s_arburst          => m_axi_mm2s_arburst                   ,
        m_axi_mm2s_arprot           => m_axi_mm2s_arprot                    ,
        m_axi_mm2s_arcache          => m_axi_mm2s_arcache                   ,
        m_axi_mm2s_arvalid          => m_axi_mm2s_arvalid                   ,
        m_axi_mm2s_arready          => m_axi_mm2s_arready                   ,

        -- MM2S AXI MMap Read Data Channel I/O  -------------------------------
        m_axi_mm2s_rdata            => m_axi_mm2s_rdata                     ,
        m_axi_mm2s_rresp            => m_axi_mm2s_rresp                     ,
        m_axi_mm2s_rlast            => m_axi_mm2s_rlast                     ,
        m_axi_mm2s_rvalid           => m_axi_mm2s_rvalid                    ,
        m_axi_mm2s_rready           => m_axi_mm2s_rready                    ,

        -- MM2S AXI Master Stream Channel I/O  --------------------------------
        m_axis_mm2s_tdata           => dm2linebuf_mm2s_tdata                ,
        m_axis_mm2s_tkeep           => dm2linebuf_mm2s_tkeep                ,
        m_axis_mm2s_tlast           => dm2linebuf_mm2s_tlast                ,
        m_axis_mm2s_tvalid          => dm2linebuf_mm2s_tvalid               ,
        m_axis_mm2s_tready          => linebuf2dm_mm2s_tready               ,

        -- Testing Support I/O
        mm2s_dbg_sel                => (others => '0')                      ,
        mm2s_dbg_data               => open                                 ,
        -- Datamover v4_02_a addional signals not needed for VDMA 
        --sg_ctl                      => (others => '0')                      ,
        m_axi_mm2s_aruser           => open                                 ,
        m_axi_s2mm_awuser           => open                                 ,

        -- S2MM Primary Clock/Reset input
        m_axi_s2mm_aclk             => m_axi_s2mm_aclk                      ,
        m_axi_s2mm_aresetn          => s2mm_dm_prmry_resetn                 ,
        s2mm_halt                   => s2mm_halt                            ,
        s2mm_halt_cmplt             => s2mm_halt_cmplt                      ,
        s2mm_err                    => s2mm_err                             ,
        s2mm_allow_addr_req         => ALWAYS_ALLOW                         ,
        s2mm_addr_req_posted        => open                                 ,
        s2mm_wr_xfer_cmplt          => open                                 ,
        s2mm_ld_nxt_len             => open                                 ,
        s2mm_wr_len                 => open                                 ,

        -- Stream to Memory Map Command FIFO and Status FIFO I/O --------------
        m_axis_s2mm_cmdsts_awclk    => m_axi_s2mm_aclk                      ,
        m_axis_s2mm_cmdsts_aresetn  => s2mm_dm_prmry_resetn                 ,

        -- User Command Interface Ports (AXI Stream)
        s_axis_s2mm_cmd_tvalid      => s_axis_s2mm_cmd_tvalid               ,
        s_axis_s2mm_cmd_tready      => s_axis_s2mm_cmd_tready               ,
        s_axis_s2mm_cmd_tdata       => s_axis_s2mm_cmd_tdata                ,

        -- User Status Interface Ports (AXI Stream)
        m_axis_s2mm_sts_tvalid      => m_axis_s2mm_sts_tvalid               ,
        m_axis_s2mm_sts_tready      => m_axis_s2mm_sts_tready               ,
        m_axis_s2mm_sts_tdata       => m_axis_s2mm_sts_tdata                ,
        m_axis_s2mm_sts_tkeep       => m_axis_s2mm_sts_tkeep                ,
        m_axis_s2mm_sts_tlast       => open                                 ,


        -- S2MM AXI Address Channel I/O  --------------------------------------
        m_axi_s2mm_awid             => open                                 ,
        m_axi_s2mm_awaddr           => m_axi_s2mm_awaddr_int                    ,
        m_axi_s2mm_awlen            => m_axi_s2mm_awlen                     ,
        m_axi_s2mm_awsize           => m_axi_s2mm_awsize                    ,
        m_axi_s2mm_awburst          => m_axi_s2mm_awburst                   ,
        m_axi_s2mm_awprot           => m_axi_s2mm_awprot                    ,
        m_axi_s2mm_awcache          => m_axi_s2mm_awcache                   ,
        m_axi_s2mm_awvalid          => m_axi_s2mm_awvalid                   ,
        m_axi_s2mm_awready          => m_axi_s2mm_awready                   ,

        -- S2MM AXI MMap Write Data Channel I/O  ------------------------------
        m_axi_s2mm_wdata            => m_axi_s2mm_wdata                     ,
        m_axi_s2mm_wstrb            => m_axi_s2mm_wstrb                     ,
        m_axi_s2mm_wlast            => m_axi_s2mm_wlast                     ,
        m_axi_s2mm_wvalid           => m_axi_s2mm_wvalid                    ,
        m_axi_s2mm_wready           => m_axi_s2mm_wready                    ,

        -- S2MM AXI MMap Write response Channel I/O  --------------------------
        m_axi_s2mm_bresp            => m_axi_s2mm_bresp                     ,
        m_axi_s2mm_bvalid           => m_axi_s2mm_bvalid                    ,
        m_axi_s2mm_bready           => m_axi_s2mm_bready                    ,


        -- S2MM AXI Slave Stream Channel I/O  ---------------------------------
        s_axis_s2mm_tdata           => linebuf2dm_s2mm_tdata                ,
        s_axis_s2mm_tkeep           => linebuf2dm_s2mm_tkeep                ,
        s_axis_s2mm_tlast           => linebuf2dm_s2mm_tlast                ,
        s_axis_s2mm_tvalid          => linebuf2dm_s2mm_tvalid               ,
        s_axis_s2mm_tready          => dm2linebuf_s2mm_tready               ,

        -- Testing Support I/O
        s2mm_dbg_sel                => (others => '0')                      ,
        s2mm_dbg_data               => open
    );






m_axi_mm2s_araddr <= m_axi_mm2s_araddr_int (C_M_AXI_MM2S_ADDR_WIDTH-1 downto 0);
m_axi_s2mm_awaddr <= m_axi_s2mm_awaddr_int (C_M_AXI_S2MM_ADDR_WIDTH-1 downto 0);


end implementation;


